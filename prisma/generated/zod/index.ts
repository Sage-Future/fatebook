import { z } from 'zod';
import { Prisma } from '@prisma/client';
import Decimal from 'decimal.js';

/////////////////////////////////////////
// HELPER FUNCTIONS
/////////////////////////////////////////

// DECIMAL
//------------------------------------------------------

export const DecimalJsLikeSchema: z.ZodType<Prisma.DecimalJsLike> = z.object({
  d: z.array(z.number()),
  e: z.number(),
  s: z.number(),
  toFixed: z.function(z.tuple([]), z.string()),
})

export const DECIMAL_STRING_REGEX = /^(?:-?Infinity|NaN|-?(?:0[bB][01]+(?:\.[01]+)?(?:[pP][-+]?\d+)?|0[oO][0-7]+(?:\.[0-7]+)?(?:[pP][-+]?\d+)?|0[xX][\da-fA-F]+(?:\.[\da-fA-F]+)?(?:[pP][-+]?\d+)?|(?:\d+|\d*\.\d+)(?:[eE][-+]?\d+)?))$/;

export const isValidDecimalInput =
  (v?: null | string | number | Prisma.DecimalJsLike): v is string | number | Prisma.DecimalJsLike => {
    if (v === undefined || v === null) return false;
    return (
      (typeof v === 'object' && 'd' in v && 'e' in v && 's' in v && 'toFixed' in v) ||
      (typeof v === 'string' && DECIMAL_STRING_REGEX.test(v)) ||
      typeof v === 'number'
    )
  };

/////////////////////////////////////////
// ENUMS
/////////////////////////////////////////

export const TransactionIsolationLevelSchema = z.enum(['ReadUncommitted','ReadCommitted','RepeatableRead','Serializable']);

export const WorkspaceScalarFieldEnumSchema = z.enum(['teamId','teamName','token','createdAt']);

export const ForecastScalarFieldEnumSchema = z.enum(['id','createdAt','comment','forecast','profileId','questionId','optionId','userId']);

export const QuestionScoreScalarFieldEnumSchema = z.enum(['id','createdAt','relativeScore','questionId','userQuestionComboId','absoluteScore','rank','userId','questionOptionId']);

export const QuestionOptionScalarFieldEnumSchema = z.enum(['id','questionId','text','resolution','createdAt','userId','resolvedAt']);

export const QuestionScalarFieldEnumSchema = z.enum(['id','createdAt','comment','profileId','title','type','resolveBy','resolved','pingedForResolution','resolution','resolvedAt','notes','hideForecastsUntil','hideForecastsUntilPrediction','userId','sharedPublicly','unlisted','exclusiveAnswers']);

export const TagScalarFieldEnumSchema = z.enum(['id','createdAt','name','userId']);

export const ResolutionSlackMessageScalarFieldEnumSchema = z.enum(['id','questionId','detailsId','profileId']);

export const PingSlackMessageScalarFieldEnumSchema = z.enum(['id','questionId','detailsId']);

export const QuestionSlackMessageScalarFieldEnumSchema = z.enum(['id','questionId','detailsId','updatedAt']);

export const SlackMessageScalarFieldEnumSchema = z.enum(['id','ts','channel','teamId']);

export const UserScalarFieldEnumSchema = z.enum(['id','name','createdAt','email','image','staleReminder','unsubscribedFromEmailsAt','apiKey','discordUserId','emailVerified']);

export const ProfileScalarFieldEnumSchema = z.enum(['id','createdAt','slackId','slackTeamId','userId']);

export const GroupScalarFieldEnumSchema = z.enum(['id','type','createdAt','name','slackTeamId']);

export const TargetScalarFieldEnumSchema = z.enum(['id','userId','profileId','type','goal','lastFailedAt','notifyOn','lastNotified']);

export const AccountScalarFieldEnumSchema = z.enum(['id','userId','type','provider','providerAccountId','refresh_token','access_token','expires_at','token_type','scope','id_token','session_state']);

export const CommentScalarFieldEnumSchema = z.enum(['id','createdAt','comment','questionId','userId']);

export const UserListScalarFieldEnumSchema = z.enum(['id','createdAt','inviteId','name','emailDomains','syncToSlackTeamId','syncToSlackChannelId','authorId']);

export const TournamentScalarFieldEnumSchema = z.enum(['id','createdAt','name','description','authorId','sharedPublicly','unlisted','userListId','anyoneInListCanEdit','showLeaderboard','predictYourYear','syncToSlackTeamId','syncToSlackChannelId']);

export const NotificationScalarFieldEnumSchema = z.enum(['id','createdAt','emailSentAt','title','content','url','tags','read','userId','questionId']);

export const FeedbackScalarFieldEnumSchema = z.enum(['id','createdAt','type','message','email','userId']);

export const SortOrderSchema = z.enum(['asc','desc']);

export const QueryModeSchema = z.enum(['default','insensitive']);

export const WorkspaceOrderByRelevanceFieldEnumSchema = z.enum(['teamId','teamName','token']);

export const NullsOrderSchema = z.enum(['first','last']);

export const ForecastOrderByRelevanceFieldEnumSchema = z.enum(['comment','questionId','optionId','userId']);

export const QuestionScoreOrderByRelevanceFieldEnumSchema = z.enum(['questionId','userQuestionComboId','userId','questionOptionId']);

export const QuestionOptionOrderByRelevanceFieldEnumSchema = z.enum(['id','questionId','text','userId']);

export const QuestionOrderByRelevanceFieldEnumSchema = z.enum(['id','comment','title','notes','userId']);

export const TagOrderByRelevanceFieldEnumSchema = z.enum(['id','name','userId']);

export const ResolutionSlackMessageOrderByRelevanceFieldEnumSchema = z.enum(['questionId']);

export const PingSlackMessageOrderByRelevanceFieldEnumSchema = z.enum(['questionId']);

export const QuestionSlackMessageOrderByRelevanceFieldEnumSchema = z.enum(['questionId']);

export const SlackMessageOrderByRelevanceFieldEnumSchema = z.enum(['ts','channel','teamId']);

export const UserOrderByRelevanceFieldEnumSchema = z.enum(['id','name','email','image','apiKey','discordUserId']);

export const ProfileOrderByRelevanceFieldEnumSchema = z.enum(['slackId','slackTeamId','userId']);

export const GroupOrderByRelevanceFieldEnumSchema = z.enum(['name','slackTeamId']);

export const TargetOrderByRelevanceFieldEnumSchema = z.enum(['userId']);

export const AccountOrderByRelevanceFieldEnumSchema = z.enum(['id','userId','type','provider','providerAccountId','refresh_token','access_token','token_type','scope','id_token','session_state']);

export const CommentOrderByRelevanceFieldEnumSchema = z.enum(['comment','questionId','userId']);

export const UserListOrderByRelevanceFieldEnumSchema = z.enum(['id','inviteId','name','emailDomains','syncToSlackTeamId','syncToSlackChannelId','authorId']);

export const TournamentOrderByRelevanceFieldEnumSchema = z.enum(['id','name','description','authorId','userListId','syncToSlackTeamId','syncToSlackChannelId']);

export const NotificationOrderByRelevanceFieldEnumSchema = z.enum(['id','title','content','url','tags','userId','questionId']);

export const FeedbackOrderByRelevanceFieldEnumSchema = z.enum(['id','type','message','email','userId']);

export const QuestionTypeSchema = z.enum(['BINARY','MULTIPLE_CHOICE','QUANTITY']);

export type QuestionTypeType = `${z.infer<typeof QuestionTypeSchema>}`

export const DayOfTheWeekSchema = z.enum(['MONDAY','TUESDAY','WEDNESDAY','THURSDAY','FRIDAY','SATURDAY','SUNDAY']);

export type DayOfTheWeekType = `${z.infer<typeof DayOfTheWeekSchema>}`

export const TargetTypeSchema = z.enum(['FORECAST','QUESTION']);

export type TargetTypeType = `${z.infer<typeof TargetTypeSchema>}`

export const GroupTypeSchema = z.enum(['WEB','SLACK']);

export type GroupTypeType = `${z.infer<typeof GroupTypeSchema>}`

export const ResolutionSchema = z.enum(['YES','NO','AMBIGUOUS']);

export type ResolutionType = `${z.infer<typeof ResolutionSchema>}`

/////////////////////////////////////////
// MODELS
/////////////////////////////////////////

/////////////////////////////////////////
// WORKSPACE SCHEMA
/////////////////////////////////////////

export const WorkspaceSchema = z.object({
  teamId: z.string(),
  teamName: z.string(),
  token: z.string(),
  createdAt: z.coerce.date(),
})

export type Workspace = z.infer<typeof WorkspaceSchema>

/////////////////////////////////////////
// FORECAST SCHEMA
/////////////////////////////////////////

export const ForecastSchema = z.object({
  id: z.number().int(),
  createdAt: z.coerce.date(),
  comment: z.string().nullable(),
  forecast: z.instanceof(Prisma.Decimal, { message: "Field 'forecast' must be a Decimal. Location: ['Models', 'Forecast']"}),
  profileId: z.number().int().nullable(),
  questionId: z.string(),
  optionId: z.string().nullable(),
  userId: z.string(),
})

export type Forecast = z.infer<typeof ForecastSchema>

/////////////////////////////////////////
// QUESTION SCORE SCHEMA
/////////////////////////////////////////

export const QuestionScoreSchema = z.object({
  id: z.number().int(),
  createdAt: z.coerce.date(),
  relativeScore: z.instanceof(Prisma.Decimal, { message: "Field 'relativeScore' must be a Decimal. Location: ['Models', 'QuestionScore']"}).nullable(),
  questionId: z.string(),
  userQuestionComboId: z.string(),
  absoluteScore: z.instanceof(Prisma.Decimal, { message: "Field 'absoluteScore' must be a Decimal. Location: ['Models', 'QuestionScore']"}),
  rank: z.number().int(),
  userId: z.string(),
  questionOptionId: z.string().nullable(),
})

export type QuestionScore = z.infer<typeof QuestionScoreSchema>

/////////////////////////////////////////
// QUESTION OPTION SCHEMA
/////////////////////////////////////////

export const QuestionOptionSchema = z.object({
  resolution: ResolutionSchema.nullable(),
  id: z.string().cuid(),
  questionId: z.string(),
  text: z.string(),
  createdAt: z.coerce.date(),
  userId: z.string(),
  resolvedAt: z.coerce.date().nullable(),
})

export type QuestionOption = z.infer<typeof QuestionOptionSchema>

/////////////////////////////////////////
// QUESTION SCHEMA
/////////////////////////////////////////

export const QuestionSchema = z.object({
  type: QuestionTypeSchema,
  resolution: ResolutionSchema.nullable(),
  id: z.string().cuid(),
  createdAt: z.coerce.date(),
  comment: z.string().nullable(),
  profileId: z.number().int().nullable(),
  title: z.string(),
  resolveBy: z.coerce.date(),
  resolved: z.boolean(),
  pingedForResolution: z.boolean(),
  resolvedAt: z.coerce.date().nullable(),
  notes: z.string().nullable(),
  hideForecastsUntil: z.coerce.date().nullable(),
  hideForecastsUntilPrediction: z.boolean().nullable(),
  userId: z.string(),
  sharedPublicly: z.boolean(),
  unlisted: z.boolean(),
  exclusiveAnswers: z.boolean().nullable(),
})

export type Question = z.infer<typeof QuestionSchema>

/////////////////////////////////////////
// TAG SCHEMA
/////////////////////////////////////////

export const TagSchema = z.object({
  id: z.string().cuid(),
  createdAt: z.coerce.date(),
  name: z.string(),
  userId: z.string(),
})

export type Tag = z.infer<typeof TagSchema>

/////////////////////////////////////////
// RESOLUTION SLACK MESSAGE SCHEMA
/////////////////////////////////////////

export const ResolutionSlackMessageSchema = z.object({
  id: z.number().int(),
  questionId: z.string(),
  detailsId: z.number().int(),
  profileId: z.number().int().nullable(),
})

export type ResolutionSlackMessage = z.infer<typeof ResolutionSlackMessageSchema>

/////////////////////////////////////////
// PING SLACK MESSAGE SCHEMA
/////////////////////////////////////////

export const PingSlackMessageSchema = z.object({
  id: z.number().int(),
  questionId: z.string(),
  detailsId: z.number().int(),
})

export type PingSlackMessage = z.infer<typeof PingSlackMessageSchema>

/////////////////////////////////////////
// QUESTION SLACK MESSAGE SCHEMA
/////////////////////////////////////////

export const QuestionSlackMessageSchema = z.object({
  id: z.number().int(),
  questionId: z.string(),
  detailsId: z.number().int(),
  updatedAt: z.coerce.date(),
})

export type QuestionSlackMessage = z.infer<typeof QuestionSlackMessageSchema>

/////////////////////////////////////////
// SLACK MESSAGE SCHEMA
/////////////////////////////////////////

export const SlackMessageSchema = z.object({
  id: z.number().int(),
  ts: z.string(),
  channel: z.string(),
  teamId: z.string(),
})

export type SlackMessage = z.infer<typeof SlackMessageSchema>

/////////////////////////////////////////
// USER SCHEMA
/////////////////////////////////////////

export const UserSchema = z.object({
  id: z.string().cuid(),
  name: z.string().nullable(),
  createdAt: z.coerce.date(),
  email: z.string(),
  image: z.string().nullable(),
  staleReminder: z.boolean(),
  unsubscribedFromEmailsAt: z.coerce.date().nullable(),
  apiKey: z.string().nullable(),
  discordUserId: z.string().nullable(),
  emailVerified: z.coerce.date().nullable(),
})

export type User = z.infer<typeof UserSchema>

/////////////////////////////////////////
// PROFILE SCHEMA
/////////////////////////////////////////

export const ProfileSchema = z.object({
  id: z.number().int(),
  createdAt: z.coerce.date(),
  slackId: z.string().nullable(),
  slackTeamId: z.string().nullable(),
  userId: z.string(),
})

export type Profile = z.infer<typeof ProfileSchema>

/////////////////////////////////////////
// GROUP SCHEMA
/////////////////////////////////////////

export const GroupSchema = z.object({
  type: GroupTypeSchema,
  id: z.number().int(),
  createdAt: z.coerce.date(),
  name: z.string(),
  slackTeamId: z.string().nullable(),
})

export type Group = z.infer<typeof GroupSchema>

/////////////////////////////////////////
// TARGET SCHEMA
/////////////////////////////////////////

export const TargetSchema = z.object({
  type: TargetTypeSchema,
  notifyOn: DayOfTheWeekSchema,
  id: z.number().int(),
  userId: z.string(),
  profileId: z.number().int().nullable(),
  goal: z.number().int(),
  lastFailedAt: z.coerce.date(),
  lastNotified: z.coerce.date(),
})

export type Target = z.infer<typeof TargetSchema>

/////////////////////////////////////////
// ACCOUNT SCHEMA
/////////////////////////////////////////

export const AccountSchema = z.object({
  id: z.string().cuid(),
  userId: z.string(),
  type: z.string(),
  provider: z.string(),
  providerAccountId: z.string(),
  refresh_token: z.string().nullable(),
  access_token: z.string().nullable(),
  expires_at: z.number().int().nullable(),
  token_type: z.string().nullable(),
  scope: z.string().nullable(),
  id_token: z.string().nullable(),
  session_state: z.string().nullable(),
})

export type Account = z.infer<typeof AccountSchema>

/////////////////////////////////////////
// COMMENT SCHEMA
/////////////////////////////////////////

export const CommentSchema = z.object({
  id: z.number().int(),
  createdAt: z.coerce.date(),
  comment: z.string(),
  questionId: z.string(),
  userId: z.string(),
})

export type Comment = z.infer<typeof CommentSchema>

/////////////////////////////////////////
// USER LIST SCHEMA
/////////////////////////////////////////

export const UserListSchema = z.object({
  id: z.string().cuid(),
  createdAt: z.coerce.date(),
  inviteId: z.string().cuid().nullable(),
  name: z.string(),
  emailDomains: z.string().array(),
  syncToSlackTeamId: z.string().nullable(),
  syncToSlackChannelId: z.string().nullable(),
  authorId: z.string(),
})

export type UserList = z.infer<typeof UserListSchema>

/////////////////////////////////////////
// TOURNAMENT SCHEMA
/////////////////////////////////////////

export const TournamentSchema = z.object({
  id: z.string().cuid(),
  createdAt: z.coerce.date(),
  name: z.string(),
  description: z.string().nullable(),
  authorId: z.string(),
  sharedPublicly: z.boolean(),
  unlisted: z.boolean(),
  userListId: z.string().nullable(),
  anyoneInListCanEdit: z.boolean(),
  showLeaderboard: z.boolean(),
  predictYourYear: z.number().int().nullable(),
  syncToSlackTeamId: z.string().nullable(),
  syncToSlackChannelId: z.string().nullable(),
})

export type Tournament = z.infer<typeof TournamentSchema>

/////////////////////////////////////////
// NOTIFICATION SCHEMA
/////////////////////////////////////////

export const NotificationSchema = z.object({
  id: z.string().cuid(),
  createdAt: z.coerce.date(),
  emailSentAt: z.coerce.date().nullable(),
  title: z.string(),
  content: z.string(),
  url: z.string().nullable(),
  tags: z.string().array(),
  read: z.boolean(),
  userId: z.string(),
  questionId: z.string().nullable(),
})

export type Notification = z.infer<typeof NotificationSchema>

/////////////////////////////////////////
// FEEDBACK SCHEMA
/////////////////////////////////////////

export const FeedbackSchema = z.object({
  id: z.string().cuid(),
  createdAt: z.coerce.date(),
  type: z.string(),
  message: z.string(),
  email: z.string().nullable(),
  userId: z.string().nullable(),
})

export type Feedback = z.infer<typeof FeedbackSchema>

/////////////////////////////////////////
// SELECT & INCLUDE
/////////////////////////////////////////

// WORKSPACE
//------------------------------------------------------

export const WorkspaceSelectSchema: z.ZodType<Prisma.WorkspaceSelect> = z.object({
  teamId: z.boolean().optional(),
  teamName: z.boolean().optional(),
  token: z.boolean().optional(),
  createdAt: z.boolean().optional(),
}).strict()

// FORECAST
//------------------------------------------------------

export const ForecastIncludeSchema: z.ZodType<Prisma.ForecastInclude> = z.object({
  option: z.union([z.boolean(),z.lazy(() => QuestionOptionArgsSchema)]).optional(),
  profile: z.union([z.boolean(),z.lazy(() => ProfileArgsSchema)]).optional(),
  question: z.union([z.boolean(),z.lazy(() => QuestionArgsSchema)]).optional(),
  user: z.union([z.boolean(),z.lazy(() => UserArgsSchema)]).optional(),
}).strict()

export const ForecastArgsSchema: z.ZodType<Prisma.ForecastDefaultArgs> = z.object({
  select: z.lazy(() => ForecastSelectSchema).optional(),
  include: z.lazy(() => ForecastIncludeSchema).optional(),
}).strict();

export const ForecastSelectSchema: z.ZodType<Prisma.ForecastSelect> = z.object({
  id: z.boolean().optional(),
  createdAt: z.boolean().optional(),
  comment: z.boolean().optional(),
  forecast: z.boolean().optional(),
  profileId: z.boolean().optional(),
  questionId: z.boolean().optional(),
  optionId: z.boolean().optional(),
  userId: z.boolean().optional(),
  option: z.union([z.boolean(),z.lazy(() => QuestionOptionArgsSchema)]).optional(),
  profile: z.union([z.boolean(),z.lazy(() => ProfileArgsSchema)]).optional(),
  question: z.union([z.boolean(),z.lazy(() => QuestionArgsSchema)]).optional(),
  user: z.union([z.boolean(),z.lazy(() => UserArgsSchema)]).optional(),
}).strict()

// QUESTION SCORE
//------------------------------------------------------

export const QuestionScoreIncludeSchema: z.ZodType<Prisma.QuestionScoreInclude> = z.object({
  question: z.union([z.boolean(),z.lazy(() => QuestionArgsSchema)]).optional(),
  user: z.union([z.boolean(),z.lazy(() => UserArgsSchema)]).optional(),
  QuestionOption: z.union([z.boolean(),z.lazy(() => QuestionOptionArgsSchema)]).optional(),
}).strict()

export const QuestionScoreArgsSchema: z.ZodType<Prisma.QuestionScoreDefaultArgs> = z.object({
  select: z.lazy(() => QuestionScoreSelectSchema).optional(),
  include: z.lazy(() => QuestionScoreIncludeSchema).optional(),
}).strict();

export const QuestionScoreSelectSchema: z.ZodType<Prisma.QuestionScoreSelect> = z.object({
  id: z.boolean().optional(),
  createdAt: z.boolean().optional(),
  relativeScore: z.boolean().optional(),
  questionId: z.boolean().optional(),
  userQuestionComboId: z.boolean().optional(),
  absoluteScore: z.boolean().optional(),
  rank: z.boolean().optional(),
  userId: z.boolean().optional(),
  questionOptionId: z.boolean().optional(),
  question: z.union([z.boolean(),z.lazy(() => QuestionArgsSchema)]).optional(),
  user: z.union([z.boolean(),z.lazy(() => UserArgsSchema)]).optional(),
  QuestionOption: z.union([z.boolean(),z.lazy(() => QuestionOptionArgsSchema)]).optional(),
}).strict()

// QUESTION OPTION
//------------------------------------------------------

export const QuestionOptionIncludeSchema: z.ZodType<Prisma.QuestionOptionInclude> = z.object({
  question: z.union([z.boolean(),z.lazy(() => QuestionArgsSchema)]).optional(),
  forecasts: z.union([z.boolean(),z.lazy(() => ForecastFindManyArgsSchema)]).optional(),
  user: z.union([z.boolean(),z.lazy(() => UserArgsSchema)]).optional(),
  questionScores: z.union([z.boolean(),z.lazy(() => QuestionScoreFindManyArgsSchema)]).optional(),
  _count: z.union([z.boolean(),z.lazy(() => QuestionOptionCountOutputTypeArgsSchema)]).optional(),
}).strict()

export const QuestionOptionArgsSchema: z.ZodType<Prisma.QuestionOptionDefaultArgs> = z.object({
  select: z.lazy(() => QuestionOptionSelectSchema).optional(),
  include: z.lazy(() => QuestionOptionIncludeSchema).optional(),
}).strict();

export const QuestionOptionCountOutputTypeArgsSchema: z.ZodType<Prisma.QuestionOptionCountOutputTypeDefaultArgs> = z.object({
  select: z.lazy(() => QuestionOptionCountOutputTypeSelectSchema).nullish(),
}).strict();

export const QuestionOptionCountOutputTypeSelectSchema: z.ZodType<Prisma.QuestionOptionCountOutputTypeSelect> = z.object({
  forecasts: z.boolean().optional(),
  questionScores: z.boolean().optional(),
}).strict();

export const QuestionOptionSelectSchema: z.ZodType<Prisma.QuestionOptionSelect> = z.object({
  id: z.boolean().optional(),
  questionId: z.boolean().optional(),
  text: z.boolean().optional(),
  resolution: z.boolean().optional(),
  createdAt: z.boolean().optional(),
  userId: z.boolean().optional(),
  resolvedAt: z.boolean().optional(),
  question: z.union([z.boolean(),z.lazy(() => QuestionArgsSchema)]).optional(),
  forecasts: z.union([z.boolean(),z.lazy(() => ForecastFindManyArgsSchema)]).optional(),
  user: z.union([z.boolean(),z.lazy(() => UserArgsSchema)]).optional(),
  questionScores: z.union([z.boolean(),z.lazy(() => QuestionScoreFindManyArgsSchema)]).optional(),
  _count: z.union([z.boolean(),z.lazy(() => QuestionOptionCountOutputTypeArgsSchema)]).optional(),
}).strict()

// QUESTION
//------------------------------------------------------

export const QuestionIncludeSchema: z.ZodType<Prisma.QuestionInclude> = z.object({
  options: z.union([z.boolean(),z.lazy(() => QuestionOptionFindManyArgsSchema)]).optional(),
  forecasts: z.union([z.boolean(),z.lazy(() => ForecastFindManyArgsSchema)]).optional(),
  pingResolveMessages: z.union([z.boolean(),z.lazy(() => PingSlackMessageFindManyArgsSchema)]).optional(),
  profile: z.union([z.boolean(),z.lazy(() => ProfileArgsSchema)]).optional(),
  user: z.union([z.boolean(),z.lazy(() => UserArgsSchema)]).optional(),
  sharedWith: z.union([z.boolean(),z.lazy(() => UserFindManyArgsSchema)]).optional(),
  sharedWithLists: z.union([z.boolean(),z.lazy(() => UserListFindManyArgsSchema)]).optional(),
  questionScores: z.union([z.boolean(),z.lazy(() => QuestionScoreFindManyArgsSchema)]).optional(),
  questionMessages: z.union([z.boolean(),z.lazy(() => QuestionSlackMessageFindManyArgsSchema)]).optional(),
  resolutionMessages: z.union([z.boolean(),z.lazy(() => ResolutionSlackMessageFindManyArgsSchema)]).optional(),
  comments: z.union([z.boolean(),z.lazy(() => CommentFindManyArgsSchema)]).optional(),
  tags: z.union([z.boolean(),z.lazy(() => TagFindManyArgsSchema)]).optional(),
  tournaments: z.union([z.boolean(),z.lazy(() => TournamentFindManyArgsSchema)]).optional(),
  notifications: z.union([z.boolean(),z.lazy(() => NotificationFindManyArgsSchema)]).optional(),
  _count: z.union([z.boolean(),z.lazy(() => QuestionCountOutputTypeArgsSchema)]).optional(),
}).strict()

export const QuestionArgsSchema: z.ZodType<Prisma.QuestionDefaultArgs> = z.object({
  select: z.lazy(() => QuestionSelectSchema).optional(),
  include: z.lazy(() => QuestionIncludeSchema).optional(),
}).strict();

export const QuestionCountOutputTypeArgsSchema: z.ZodType<Prisma.QuestionCountOutputTypeDefaultArgs> = z.object({
  select: z.lazy(() => QuestionCountOutputTypeSelectSchema).nullish(),
}).strict();

export const QuestionCountOutputTypeSelectSchema: z.ZodType<Prisma.QuestionCountOutputTypeSelect> = z.object({
  options: z.boolean().optional(),
  forecasts: z.boolean().optional(),
  pingResolveMessages: z.boolean().optional(),
  sharedWith: z.boolean().optional(),
  sharedWithLists: z.boolean().optional(),
  questionScores: z.boolean().optional(),
  questionMessages: z.boolean().optional(),
  resolutionMessages: z.boolean().optional(),
  comments: z.boolean().optional(),
  tags: z.boolean().optional(),
  tournaments: z.boolean().optional(),
  notifications: z.boolean().optional(),
}).strict();

export const QuestionSelectSchema: z.ZodType<Prisma.QuestionSelect> = z.object({
  id: z.boolean().optional(),
  createdAt: z.boolean().optional(),
  comment: z.boolean().optional(),
  profileId: z.boolean().optional(),
  title: z.boolean().optional(),
  type: z.boolean().optional(),
  resolveBy: z.boolean().optional(),
  resolved: z.boolean().optional(),
  pingedForResolution: z.boolean().optional(),
  resolution: z.boolean().optional(),
  resolvedAt: z.boolean().optional(),
  notes: z.boolean().optional(),
  hideForecastsUntil: z.boolean().optional(),
  hideForecastsUntilPrediction: z.boolean().optional(),
  userId: z.boolean().optional(),
  sharedPublicly: z.boolean().optional(),
  unlisted: z.boolean().optional(),
  exclusiveAnswers: z.boolean().optional(),
  options: z.union([z.boolean(),z.lazy(() => QuestionOptionFindManyArgsSchema)]).optional(),
  forecasts: z.union([z.boolean(),z.lazy(() => ForecastFindManyArgsSchema)]).optional(),
  pingResolveMessages: z.union([z.boolean(),z.lazy(() => PingSlackMessageFindManyArgsSchema)]).optional(),
  profile: z.union([z.boolean(),z.lazy(() => ProfileArgsSchema)]).optional(),
  user: z.union([z.boolean(),z.lazy(() => UserArgsSchema)]).optional(),
  sharedWith: z.union([z.boolean(),z.lazy(() => UserFindManyArgsSchema)]).optional(),
  sharedWithLists: z.union([z.boolean(),z.lazy(() => UserListFindManyArgsSchema)]).optional(),
  questionScores: z.union([z.boolean(),z.lazy(() => QuestionScoreFindManyArgsSchema)]).optional(),
  questionMessages: z.union([z.boolean(),z.lazy(() => QuestionSlackMessageFindManyArgsSchema)]).optional(),
  resolutionMessages: z.union([z.boolean(),z.lazy(() => ResolutionSlackMessageFindManyArgsSchema)]).optional(),
  comments: z.union([z.boolean(),z.lazy(() => CommentFindManyArgsSchema)]).optional(),
  tags: z.union([z.boolean(),z.lazy(() => TagFindManyArgsSchema)]).optional(),
  tournaments: z.union([z.boolean(),z.lazy(() => TournamentFindManyArgsSchema)]).optional(),
  notifications: z.union([z.boolean(),z.lazy(() => NotificationFindManyArgsSchema)]).optional(),
  _count: z.union([z.boolean(),z.lazy(() => QuestionCountOutputTypeArgsSchema)]).optional(),
}).strict()

// TAG
//------------------------------------------------------

export const TagIncludeSchema: z.ZodType<Prisma.TagInclude> = z.object({
  user: z.union([z.boolean(),z.lazy(() => UserArgsSchema)]).optional(),
  questions: z.union([z.boolean(),z.lazy(() => QuestionFindManyArgsSchema)]).optional(),
  _count: z.union([z.boolean(),z.lazy(() => TagCountOutputTypeArgsSchema)]).optional(),
}).strict()

export const TagArgsSchema: z.ZodType<Prisma.TagDefaultArgs> = z.object({
  select: z.lazy(() => TagSelectSchema).optional(),
  include: z.lazy(() => TagIncludeSchema).optional(),
}).strict();

export const TagCountOutputTypeArgsSchema: z.ZodType<Prisma.TagCountOutputTypeDefaultArgs> = z.object({
  select: z.lazy(() => TagCountOutputTypeSelectSchema).nullish(),
}).strict();

export const TagCountOutputTypeSelectSchema: z.ZodType<Prisma.TagCountOutputTypeSelect> = z.object({
  questions: z.boolean().optional(),
}).strict();

export const TagSelectSchema: z.ZodType<Prisma.TagSelect> = z.object({
  id: z.boolean().optional(),
  createdAt: z.boolean().optional(),
  name: z.boolean().optional(),
  userId: z.boolean().optional(),
  user: z.union([z.boolean(),z.lazy(() => UserArgsSchema)]).optional(),
  questions: z.union([z.boolean(),z.lazy(() => QuestionFindManyArgsSchema)]).optional(),
  _count: z.union([z.boolean(),z.lazy(() => TagCountOutputTypeArgsSchema)]).optional(),
}).strict()

// RESOLUTION SLACK MESSAGE
//------------------------------------------------------

export const ResolutionSlackMessageIncludeSchema: z.ZodType<Prisma.ResolutionSlackMessageInclude> = z.object({
  message: z.union([z.boolean(),z.lazy(() => SlackMessageArgsSchema)]).optional(),
  profile: z.union([z.boolean(),z.lazy(() => ProfileArgsSchema)]).optional(),
  question: z.union([z.boolean(),z.lazy(() => QuestionArgsSchema)]).optional(),
}).strict()

export const ResolutionSlackMessageArgsSchema: z.ZodType<Prisma.ResolutionSlackMessageDefaultArgs> = z.object({
  select: z.lazy(() => ResolutionSlackMessageSelectSchema).optional(),
  include: z.lazy(() => ResolutionSlackMessageIncludeSchema).optional(),
}).strict();

export const ResolutionSlackMessageSelectSchema: z.ZodType<Prisma.ResolutionSlackMessageSelect> = z.object({
  id: z.boolean().optional(),
  questionId: z.boolean().optional(),
  detailsId: z.boolean().optional(),
  profileId: z.boolean().optional(),
  message: z.union([z.boolean(),z.lazy(() => SlackMessageArgsSchema)]).optional(),
  profile: z.union([z.boolean(),z.lazy(() => ProfileArgsSchema)]).optional(),
  question: z.union([z.boolean(),z.lazy(() => QuestionArgsSchema)]).optional(),
}).strict()

// PING SLACK MESSAGE
//------------------------------------------------------

export const PingSlackMessageIncludeSchema: z.ZodType<Prisma.PingSlackMessageInclude> = z.object({
  message: z.union([z.boolean(),z.lazy(() => SlackMessageArgsSchema)]).optional(),
  question: z.union([z.boolean(),z.lazy(() => QuestionArgsSchema)]).optional(),
}).strict()

export const PingSlackMessageArgsSchema: z.ZodType<Prisma.PingSlackMessageDefaultArgs> = z.object({
  select: z.lazy(() => PingSlackMessageSelectSchema).optional(),
  include: z.lazy(() => PingSlackMessageIncludeSchema).optional(),
}).strict();

export const PingSlackMessageSelectSchema: z.ZodType<Prisma.PingSlackMessageSelect> = z.object({
  id: z.boolean().optional(),
  questionId: z.boolean().optional(),
  detailsId: z.boolean().optional(),
  message: z.union([z.boolean(),z.lazy(() => SlackMessageArgsSchema)]).optional(),
  question: z.union([z.boolean(),z.lazy(() => QuestionArgsSchema)]).optional(),
}).strict()

// QUESTION SLACK MESSAGE
//------------------------------------------------------

export const QuestionSlackMessageIncludeSchema: z.ZodType<Prisma.QuestionSlackMessageInclude> = z.object({
  message: z.union([z.boolean(),z.lazy(() => SlackMessageArgsSchema)]).optional(),
  question: z.union([z.boolean(),z.lazy(() => QuestionArgsSchema)]).optional(),
}).strict()

export const QuestionSlackMessageArgsSchema: z.ZodType<Prisma.QuestionSlackMessageDefaultArgs> = z.object({
  select: z.lazy(() => QuestionSlackMessageSelectSchema).optional(),
  include: z.lazy(() => QuestionSlackMessageIncludeSchema).optional(),
}).strict();

export const QuestionSlackMessageSelectSchema: z.ZodType<Prisma.QuestionSlackMessageSelect> = z.object({
  id: z.boolean().optional(),
  questionId: z.boolean().optional(),
  detailsId: z.boolean().optional(),
  updatedAt: z.boolean().optional(),
  message: z.union([z.boolean(),z.lazy(() => SlackMessageArgsSchema)]).optional(),
  question: z.union([z.boolean(),z.lazy(() => QuestionArgsSchema)]).optional(),
}).strict()

// SLACK MESSAGE
//------------------------------------------------------

export const SlackMessageIncludeSchema: z.ZodType<Prisma.SlackMessageInclude> = z.object({
  pingSlackMessage: z.union([z.boolean(),z.lazy(() => PingSlackMessageArgsSchema)]).optional(),
  questionSlackMessage: z.union([z.boolean(),z.lazy(() => QuestionSlackMessageArgsSchema)]).optional(),
  resolutionSlackMessage: z.union([z.boolean(),z.lazy(() => ResolutionSlackMessageArgsSchema)]).optional(),
}).strict()

export const SlackMessageArgsSchema: z.ZodType<Prisma.SlackMessageDefaultArgs> = z.object({
  select: z.lazy(() => SlackMessageSelectSchema).optional(),
  include: z.lazy(() => SlackMessageIncludeSchema).optional(),
}).strict();

export const SlackMessageSelectSchema: z.ZodType<Prisma.SlackMessageSelect> = z.object({
  id: z.boolean().optional(),
  ts: z.boolean().optional(),
  channel: z.boolean().optional(),
  teamId: z.boolean().optional(),
  pingSlackMessage: z.union([z.boolean(),z.lazy(() => PingSlackMessageArgsSchema)]).optional(),
  questionSlackMessage: z.union([z.boolean(),z.lazy(() => QuestionSlackMessageArgsSchema)]).optional(),
  resolutionSlackMessage: z.union([z.boolean(),z.lazy(() => ResolutionSlackMessageArgsSchema)]).optional(),
}).strict()

// USER
//------------------------------------------------------

export const UserIncludeSchema: z.ZodType<Prisma.UserInclude> = z.object({
  forecasts: z.union([z.boolean(),z.lazy(() => ForecastFindManyArgsSchema)]).optional(),
  profiles: z.union([z.boolean(),z.lazy(() => ProfileFindManyArgsSchema)]).optional(),
  questions: z.union([z.boolean(),z.lazy(() => QuestionFindManyArgsSchema)]).optional(),
  questionScores: z.union([z.boolean(),z.lazy(() => QuestionScoreFindManyArgsSchema)]).optional(),
  questionsSharedWith: z.union([z.boolean(),z.lazy(() => QuestionFindManyArgsSchema)]).optional(),
  comments: z.union([z.boolean(),z.lazy(() => CommentFindManyArgsSchema)]).optional(),
  target: z.union([z.boolean(),z.lazy(() => TargetArgsSchema)]).optional(),
  authorOfLists: z.union([z.boolean(),z.lazy(() => UserListFindManyArgsSchema)]).optional(),
  memberOfLists: z.union([z.boolean(),z.lazy(() => UserListFindManyArgsSchema)]).optional(),
  tags: z.union([z.boolean(),z.lazy(() => TagFindManyArgsSchema)]).optional(),
  tournaments: z.union([z.boolean(),z.lazy(() => TournamentFindManyArgsSchema)]).optional(),
  notifications: z.union([z.boolean(),z.lazy(() => NotificationFindManyArgsSchema)]).optional(),
  questionOptions: z.union([z.boolean(),z.lazy(() => QuestionOptionFindManyArgsSchema)]).optional(),
  accounts: z.union([z.boolean(),z.lazy(() => AccountFindManyArgsSchema)]).optional(),
  _count: z.union([z.boolean(),z.lazy(() => UserCountOutputTypeArgsSchema)]).optional(),
}).strict()

export const UserArgsSchema: z.ZodType<Prisma.UserDefaultArgs> = z.object({
  select: z.lazy(() => UserSelectSchema).optional(),
  include: z.lazy(() => UserIncludeSchema).optional(),
}).strict();

export const UserCountOutputTypeArgsSchema: z.ZodType<Prisma.UserCountOutputTypeDefaultArgs> = z.object({
  select: z.lazy(() => UserCountOutputTypeSelectSchema).nullish(),
}).strict();

export const UserCountOutputTypeSelectSchema: z.ZodType<Prisma.UserCountOutputTypeSelect> = z.object({
  forecasts: z.boolean().optional(),
  profiles: z.boolean().optional(),
  questions: z.boolean().optional(),
  questionScores: z.boolean().optional(),
  questionsSharedWith: z.boolean().optional(),
  comments: z.boolean().optional(),
  authorOfLists: z.boolean().optional(),
  memberOfLists: z.boolean().optional(),
  tags: z.boolean().optional(),
  tournaments: z.boolean().optional(),
  notifications: z.boolean().optional(),
  questionOptions: z.boolean().optional(),
  accounts: z.boolean().optional(),
}).strict();

export const UserSelectSchema: z.ZodType<Prisma.UserSelect> = z.object({
  id: z.boolean().optional(),
  name: z.boolean().optional(),
  createdAt: z.boolean().optional(),
  email: z.boolean().optional(),
  image: z.boolean().optional(),
  staleReminder: z.boolean().optional(),
  unsubscribedFromEmailsAt: z.boolean().optional(),
  apiKey: z.boolean().optional(),
  discordUserId: z.boolean().optional(),
  emailVerified: z.boolean().optional(),
  forecasts: z.union([z.boolean(),z.lazy(() => ForecastFindManyArgsSchema)]).optional(),
  profiles: z.union([z.boolean(),z.lazy(() => ProfileFindManyArgsSchema)]).optional(),
  questions: z.union([z.boolean(),z.lazy(() => QuestionFindManyArgsSchema)]).optional(),
  questionScores: z.union([z.boolean(),z.lazy(() => QuestionScoreFindManyArgsSchema)]).optional(),
  questionsSharedWith: z.union([z.boolean(),z.lazy(() => QuestionFindManyArgsSchema)]).optional(),
  comments: z.union([z.boolean(),z.lazy(() => CommentFindManyArgsSchema)]).optional(),
  target: z.union([z.boolean(),z.lazy(() => TargetArgsSchema)]).optional(),
  authorOfLists: z.union([z.boolean(),z.lazy(() => UserListFindManyArgsSchema)]).optional(),
  memberOfLists: z.union([z.boolean(),z.lazy(() => UserListFindManyArgsSchema)]).optional(),
  tags: z.union([z.boolean(),z.lazy(() => TagFindManyArgsSchema)]).optional(),
  tournaments: z.union([z.boolean(),z.lazy(() => TournamentFindManyArgsSchema)]).optional(),
  notifications: z.union([z.boolean(),z.lazy(() => NotificationFindManyArgsSchema)]).optional(),
  questionOptions: z.union([z.boolean(),z.lazy(() => QuestionOptionFindManyArgsSchema)]).optional(),
  accounts: z.union([z.boolean(),z.lazy(() => AccountFindManyArgsSchema)]).optional(),
  _count: z.union([z.boolean(),z.lazy(() => UserCountOutputTypeArgsSchema)]).optional(),
}).strict()

// PROFILE
//------------------------------------------------------

export const ProfileIncludeSchema: z.ZodType<Prisma.ProfileInclude> = z.object({
  forecasts: z.union([z.boolean(),z.lazy(() => ForecastFindManyArgsSchema)]).optional(),
  user: z.union([z.boolean(),z.lazy(() => UserArgsSchema)]).optional(),
  questions: z.union([z.boolean(),z.lazy(() => QuestionFindManyArgsSchema)]).optional(),
  resolutionMessages: z.union([z.boolean(),z.lazy(() => ResolutionSlackMessageFindManyArgsSchema)]).optional(),
  target: z.union([z.boolean(),z.lazy(() => TargetArgsSchema)]).optional(),
  _count: z.union([z.boolean(),z.lazy(() => ProfileCountOutputTypeArgsSchema)]).optional(),
}).strict()

export const ProfileArgsSchema: z.ZodType<Prisma.ProfileDefaultArgs> = z.object({
  select: z.lazy(() => ProfileSelectSchema).optional(),
  include: z.lazy(() => ProfileIncludeSchema).optional(),
}).strict();

export const ProfileCountOutputTypeArgsSchema: z.ZodType<Prisma.ProfileCountOutputTypeDefaultArgs> = z.object({
  select: z.lazy(() => ProfileCountOutputTypeSelectSchema).nullish(),
}).strict();

export const ProfileCountOutputTypeSelectSchema: z.ZodType<Prisma.ProfileCountOutputTypeSelect> = z.object({
  forecasts: z.boolean().optional(),
  questions: z.boolean().optional(),
  resolutionMessages: z.boolean().optional(),
}).strict();

export const ProfileSelectSchema: z.ZodType<Prisma.ProfileSelect> = z.object({
  id: z.boolean().optional(),
  createdAt: z.boolean().optional(),
  slackId: z.boolean().optional(),
  slackTeamId: z.boolean().optional(),
  userId: z.boolean().optional(),
  forecasts: z.union([z.boolean(),z.lazy(() => ForecastFindManyArgsSchema)]).optional(),
  user: z.union([z.boolean(),z.lazy(() => UserArgsSchema)]).optional(),
  questions: z.union([z.boolean(),z.lazy(() => QuestionFindManyArgsSchema)]).optional(),
  resolutionMessages: z.union([z.boolean(),z.lazy(() => ResolutionSlackMessageFindManyArgsSchema)]).optional(),
  target: z.union([z.boolean(),z.lazy(() => TargetArgsSchema)]).optional(),
  _count: z.union([z.boolean(),z.lazy(() => ProfileCountOutputTypeArgsSchema)]).optional(),
}).strict()

// GROUP
//------------------------------------------------------

export const GroupSelectSchema: z.ZodType<Prisma.GroupSelect> = z.object({
  id: z.boolean().optional(),
  type: z.boolean().optional(),
  createdAt: z.boolean().optional(),
  name: z.boolean().optional(),
  slackTeamId: z.boolean().optional(),
}).strict()

// TARGET
//------------------------------------------------------

export const TargetIncludeSchema: z.ZodType<Prisma.TargetInclude> = z.object({
  user: z.union([z.boolean(),z.lazy(() => UserArgsSchema)]).optional(),
  profile: z.union([z.boolean(),z.lazy(() => ProfileArgsSchema)]).optional(),
}).strict()

export const TargetArgsSchema: z.ZodType<Prisma.TargetDefaultArgs> = z.object({
  select: z.lazy(() => TargetSelectSchema).optional(),
  include: z.lazy(() => TargetIncludeSchema).optional(),
}).strict();

export const TargetSelectSchema: z.ZodType<Prisma.TargetSelect> = z.object({
  id: z.boolean().optional(),
  userId: z.boolean().optional(),
  profileId: z.boolean().optional(),
  type: z.boolean().optional(),
  goal: z.boolean().optional(),
  lastFailedAt: z.boolean().optional(),
  notifyOn: z.boolean().optional(),
  lastNotified: z.boolean().optional(),
  user: z.union([z.boolean(),z.lazy(() => UserArgsSchema)]).optional(),
  profile: z.union([z.boolean(),z.lazy(() => ProfileArgsSchema)]).optional(),
}).strict()

// ACCOUNT
//------------------------------------------------------

export const AccountIncludeSchema: z.ZodType<Prisma.AccountInclude> = z.object({
  user: z.union([z.boolean(),z.lazy(() => UserArgsSchema)]).optional(),
}).strict()

export const AccountArgsSchema: z.ZodType<Prisma.AccountDefaultArgs> = z.object({
  select: z.lazy(() => AccountSelectSchema).optional(),
  include: z.lazy(() => AccountIncludeSchema).optional(),
}).strict();

export const AccountSelectSchema: z.ZodType<Prisma.AccountSelect> = z.object({
  id: z.boolean().optional(),
  userId: z.boolean().optional(),
  type: z.boolean().optional(),
  provider: z.boolean().optional(),
  providerAccountId: z.boolean().optional(),
  refresh_token: z.boolean().optional(),
  access_token: z.boolean().optional(),
  expires_at: z.boolean().optional(),
  token_type: z.boolean().optional(),
  scope: z.boolean().optional(),
  id_token: z.boolean().optional(),
  session_state: z.boolean().optional(),
  user: z.union([z.boolean(),z.lazy(() => UserArgsSchema)]).optional(),
}).strict()

// COMMENT
//------------------------------------------------------

export const CommentIncludeSchema: z.ZodType<Prisma.CommentInclude> = z.object({
  question: z.union([z.boolean(),z.lazy(() => QuestionArgsSchema)]).optional(),
  user: z.union([z.boolean(),z.lazy(() => UserArgsSchema)]).optional(),
}).strict()

export const CommentArgsSchema: z.ZodType<Prisma.CommentDefaultArgs> = z.object({
  select: z.lazy(() => CommentSelectSchema).optional(),
  include: z.lazy(() => CommentIncludeSchema).optional(),
}).strict();

export const CommentSelectSchema: z.ZodType<Prisma.CommentSelect> = z.object({
  id: z.boolean().optional(),
  createdAt: z.boolean().optional(),
  comment: z.boolean().optional(),
  questionId: z.boolean().optional(),
  userId: z.boolean().optional(),
  question: z.union([z.boolean(),z.lazy(() => QuestionArgsSchema)]).optional(),
  user: z.union([z.boolean(),z.lazy(() => UserArgsSchema)]).optional(),
}).strict()

// USER LIST
//------------------------------------------------------

export const UserListIncludeSchema: z.ZodType<Prisma.UserListInclude> = z.object({
  author: z.union([z.boolean(),z.lazy(() => UserArgsSchema)]).optional(),
  users: z.union([z.boolean(),z.lazy(() => UserFindManyArgsSchema)]).optional(),
  questions: z.union([z.boolean(),z.lazy(() => QuestionFindManyArgsSchema)]).optional(),
  tournaments: z.union([z.boolean(),z.lazy(() => TournamentFindManyArgsSchema)]).optional(),
  _count: z.union([z.boolean(),z.lazy(() => UserListCountOutputTypeArgsSchema)]).optional(),
}).strict()

export const UserListArgsSchema: z.ZodType<Prisma.UserListDefaultArgs> = z.object({
  select: z.lazy(() => UserListSelectSchema).optional(),
  include: z.lazy(() => UserListIncludeSchema).optional(),
}).strict();

export const UserListCountOutputTypeArgsSchema: z.ZodType<Prisma.UserListCountOutputTypeDefaultArgs> = z.object({
  select: z.lazy(() => UserListCountOutputTypeSelectSchema).nullish(),
}).strict();

export const UserListCountOutputTypeSelectSchema: z.ZodType<Prisma.UserListCountOutputTypeSelect> = z.object({
  users: z.boolean().optional(),
  questions: z.boolean().optional(),
  tournaments: z.boolean().optional(),
}).strict();

export const UserListSelectSchema: z.ZodType<Prisma.UserListSelect> = z.object({
  id: z.boolean().optional(),
  createdAt: z.boolean().optional(),
  inviteId: z.boolean().optional(),
  name: z.boolean().optional(),
  emailDomains: z.boolean().optional(),
  syncToSlackTeamId: z.boolean().optional(),
  syncToSlackChannelId: z.boolean().optional(),
  authorId: z.boolean().optional(),
  author: z.union([z.boolean(),z.lazy(() => UserArgsSchema)]).optional(),
  users: z.union([z.boolean(),z.lazy(() => UserFindManyArgsSchema)]).optional(),
  questions: z.union([z.boolean(),z.lazy(() => QuestionFindManyArgsSchema)]).optional(),
  tournaments: z.union([z.boolean(),z.lazy(() => TournamentFindManyArgsSchema)]).optional(),
  _count: z.union([z.boolean(),z.lazy(() => UserListCountOutputTypeArgsSchema)]).optional(),
}).strict()

// TOURNAMENT
//------------------------------------------------------

export const TournamentIncludeSchema: z.ZodType<Prisma.TournamentInclude> = z.object({
  questions: z.union([z.boolean(),z.lazy(() => QuestionFindManyArgsSchema)]).optional(),
  author: z.union([z.boolean(),z.lazy(() => UserArgsSchema)]).optional(),
  userList: z.union([z.boolean(),z.lazy(() => UserListArgsSchema)]).optional(),
  _count: z.union([z.boolean(),z.lazy(() => TournamentCountOutputTypeArgsSchema)]).optional(),
}).strict()

export const TournamentArgsSchema: z.ZodType<Prisma.TournamentDefaultArgs> = z.object({
  select: z.lazy(() => TournamentSelectSchema).optional(),
  include: z.lazy(() => TournamentIncludeSchema).optional(),
}).strict();

export const TournamentCountOutputTypeArgsSchema: z.ZodType<Prisma.TournamentCountOutputTypeDefaultArgs> = z.object({
  select: z.lazy(() => TournamentCountOutputTypeSelectSchema).nullish(),
}).strict();

export const TournamentCountOutputTypeSelectSchema: z.ZodType<Prisma.TournamentCountOutputTypeSelect> = z.object({
  questions: z.boolean().optional(),
}).strict();

export const TournamentSelectSchema: z.ZodType<Prisma.TournamentSelect> = z.object({
  id: z.boolean().optional(),
  createdAt: z.boolean().optional(),
  name: z.boolean().optional(),
  description: z.boolean().optional(),
  authorId: z.boolean().optional(),
  sharedPublicly: z.boolean().optional(),
  unlisted: z.boolean().optional(),
  userListId: z.boolean().optional(),
  anyoneInListCanEdit: z.boolean().optional(),
  showLeaderboard: z.boolean().optional(),
  predictYourYear: z.boolean().optional(),
  syncToSlackTeamId: z.boolean().optional(),
  syncToSlackChannelId: z.boolean().optional(),
  questions: z.union([z.boolean(),z.lazy(() => QuestionFindManyArgsSchema)]).optional(),
  author: z.union([z.boolean(),z.lazy(() => UserArgsSchema)]).optional(),
  userList: z.union([z.boolean(),z.lazy(() => UserListArgsSchema)]).optional(),
  _count: z.union([z.boolean(),z.lazy(() => TournamentCountOutputTypeArgsSchema)]).optional(),
}).strict()

// NOTIFICATION
//------------------------------------------------------

export const NotificationIncludeSchema: z.ZodType<Prisma.NotificationInclude> = z.object({
  user: z.union([z.boolean(),z.lazy(() => UserArgsSchema)]).optional(),
  question: z.union([z.boolean(),z.lazy(() => QuestionArgsSchema)]).optional(),
}).strict()

export const NotificationArgsSchema: z.ZodType<Prisma.NotificationDefaultArgs> = z.object({
  select: z.lazy(() => NotificationSelectSchema).optional(),
  include: z.lazy(() => NotificationIncludeSchema).optional(),
}).strict();

export const NotificationSelectSchema: z.ZodType<Prisma.NotificationSelect> = z.object({
  id: z.boolean().optional(),
  createdAt: z.boolean().optional(),
  emailSentAt: z.boolean().optional(),
  title: z.boolean().optional(),
  content: z.boolean().optional(),
  url: z.boolean().optional(),
  tags: z.boolean().optional(),
  read: z.boolean().optional(),
  userId: z.boolean().optional(),
  questionId: z.boolean().optional(),
  user: z.union([z.boolean(),z.lazy(() => UserArgsSchema)]).optional(),
  question: z.union([z.boolean(),z.lazy(() => QuestionArgsSchema)]).optional(),
}).strict()

// FEEDBACK
//------------------------------------------------------

export const FeedbackSelectSchema: z.ZodType<Prisma.FeedbackSelect> = z.object({
  id: z.boolean().optional(),
  createdAt: z.boolean().optional(),
  type: z.boolean().optional(),
  message: z.boolean().optional(),
  email: z.boolean().optional(),
  userId: z.boolean().optional(),
}).strict()


/////////////////////////////////////////
// INPUT TYPES
/////////////////////////////////////////

export const WorkspaceWhereInputSchema: z.ZodType<Prisma.WorkspaceWhereInput> = z.object({
  AND: z.union([ z.lazy(() => WorkspaceWhereInputSchema),z.lazy(() => WorkspaceWhereInputSchema).array() ]).optional(),
  OR: z.lazy(() => WorkspaceWhereInputSchema).array().optional(),
  NOT: z.union([ z.lazy(() => WorkspaceWhereInputSchema),z.lazy(() => WorkspaceWhereInputSchema).array() ]).optional(),
  teamId: z.union([ z.lazy(() => StringFilterSchema),z.string() ]).optional(),
  teamName: z.union([ z.lazy(() => StringFilterSchema),z.string() ]).optional(),
  token: z.union([ z.lazy(() => StringFilterSchema),z.string() ]).optional(),
  createdAt: z.union([ z.lazy(() => DateTimeFilterSchema),z.coerce.date() ]).optional(),
}).strict();

export const WorkspaceOrderByWithRelationInputSchema: z.ZodType<Prisma.WorkspaceOrderByWithRelationInput> = z.object({
  teamId: z.lazy(() => SortOrderSchema).optional(),
  teamName: z.lazy(() => SortOrderSchema).optional(),
  token: z.lazy(() => SortOrderSchema).optional(),
  createdAt: z.lazy(() => SortOrderSchema).optional(),
  _relevance: z.lazy(() => WorkspaceOrderByRelevanceInputSchema).optional()
}).strict();

export const WorkspaceWhereUniqueInputSchema: z.ZodType<Prisma.WorkspaceWhereUniqueInput> = z.object({
  teamId: z.string()
})
.and(z.object({
  teamId: z.string().optional(),
  AND: z.union([ z.lazy(() => WorkspaceWhereInputSchema),z.lazy(() => WorkspaceWhereInputSchema).array() ]).optional(),
  OR: z.lazy(() => WorkspaceWhereInputSchema).array().optional(),
  NOT: z.union([ z.lazy(() => WorkspaceWhereInputSchema),z.lazy(() => WorkspaceWhereInputSchema).array() ]).optional(),
  teamName: z.union([ z.lazy(() => StringFilterSchema),z.string() ]).optional(),
  token: z.union([ z.lazy(() => StringFilterSchema),z.string() ]).optional(),
  createdAt: z.union([ z.lazy(() => DateTimeFilterSchema),z.coerce.date() ]).optional(),
}).strict());

export const WorkspaceOrderByWithAggregationInputSchema: z.ZodType<Prisma.WorkspaceOrderByWithAggregationInput> = z.object({
  teamId: z.lazy(() => SortOrderSchema).optional(),
  teamName: z.lazy(() => SortOrderSchema).optional(),
  token: z.lazy(() => SortOrderSchema).optional(),
  createdAt: z.lazy(() => SortOrderSchema).optional(),
  _count: z.lazy(() => WorkspaceCountOrderByAggregateInputSchema).optional(),
  _max: z.lazy(() => WorkspaceMaxOrderByAggregateInputSchema).optional(),
  _min: z.lazy(() => WorkspaceMinOrderByAggregateInputSchema).optional()
}).strict();

export const WorkspaceScalarWhereWithAggregatesInputSchema: z.ZodType<Prisma.WorkspaceScalarWhereWithAggregatesInput> = z.object({
  AND: z.union([ z.lazy(() => WorkspaceScalarWhereWithAggregatesInputSchema),z.lazy(() => WorkspaceScalarWhereWithAggregatesInputSchema).array() ]).optional(),
  OR: z.lazy(() => WorkspaceScalarWhereWithAggregatesInputSchema).array().optional(),
  NOT: z.union([ z.lazy(() => WorkspaceScalarWhereWithAggregatesInputSchema),z.lazy(() => WorkspaceScalarWhereWithAggregatesInputSchema).array() ]).optional(),
  teamId: z.union([ z.lazy(() => StringWithAggregatesFilterSchema),z.string() ]).optional(),
  teamName: z.union([ z.lazy(() => StringWithAggregatesFilterSchema),z.string() ]).optional(),
  token: z.union([ z.lazy(() => StringWithAggregatesFilterSchema),z.string() ]).optional(),
  createdAt: z.union([ z.lazy(() => DateTimeWithAggregatesFilterSchema),z.coerce.date() ]).optional(),
}).strict();

export const ForecastWhereInputSchema: z.ZodType<Prisma.ForecastWhereInput> = z.object({
  AND: z.union([ z.lazy(() => ForecastWhereInputSchema),z.lazy(() => ForecastWhereInputSchema).array() ]).optional(),
  OR: z.lazy(() => ForecastWhereInputSchema).array().optional(),
  NOT: z.union([ z.lazy(() => ForecastWhereInputSchema),z.lazy(() => ForecastWhereInputSchema).array() ]).optional(),
  id: z.union([ z.lazy(() => IntFilterSchema),z.number() ]).optional(),
  createdAt: z.union([ z.lazy(() => DateTimeFilterSchema),z.coerce.date() ]).optional(),
  comment: z.union([ z.lazy(() => StringNullableFilterSchema),z.string() ]).optional().nullable(),
  forecast: z.union([ z.lazy(() => DecimalFilterSchema),z.union([z.number(),z.string(),z.instanceof(Decimal),z.instanceof(Prisma.Decimal),DecimalJsLikeSchema,]).refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' }) ]).optional(),
  profileId: z.union([ z.lazy(() => IntNullableFilterSchema),z.number() ]).optional().nullable(),
  questionId: z.union([ z.lazy(() => StringFilterSchema),z.string() ]).optional(),
  optionId: z.union([ z.lazy(() => StringNullableFilterSchema),z.string() ]).optional().nullable(),
  userId: z.union([ z.lazy(() => StringFilterSchema),z.string() ]).optional(),
  option: z.union([ z.lazy(() => QuestionOptionNullableRelationFilterSchema),z.lazy(() => QuestionOptionWhereInputSchema) ]).optional().nullable(),
  profile: z.union([ z.lazy(() => ProfileNullableRelationFilterSchema),z.lazy(() => ProfileWhereInputSchema) ]).optional().nullable(),
  question: z.union([ z.lazy(() => QuestionRelationFilterSchema),z.lazy(() => QuestionWhereInputSchema) ]).optional(),
  user: z.union([ z.lazy(() => UserRelationFilterSchema),z.lazy(() => UserWhereInputSchema) ]).optional(),
}).strict();

export const ForecastOrderByWithRelationInputSchema: z.ZodType<Prisma.ForecastOrderByWithRelationInput> = z.object({
  id: z.lazy(() => SortOrderSchema).optional(),
  createdAt: z.lazy(() => SortOrderSchema).optional(),
  comment: z.union([ z.lazy(() => SortOrderSchema),z.lazy(() => SortOrderInputSchema) ]).optional(),
  forecast: z.lazy(() => SortOrderSchema).optional(),
  profileId: z.union([ z.lazy(() => SortOrderSchema),z.lazy(() => SortOrderInputSchema) ]).optional(),
  questionId: z.lazy(() => SortOrderSchema).optional(),
  optionId: z.union([ z.lazy(() => SortOrderSchema),z.lazy(() => SortOrderInputSchema) ]).optional(),
  userId: z.lazy(() => SortOrderSchema).optional(),
  option: z.lazy(() => QuestionOptionOrderByWithRelationInputSchema).optional(),
  profile: z.lazy(() => ProfileOrderByWithRelationInputSchema).optional(),
  question: z.lazy(() => QuestionOrderByWithRelationInputSchema).optional(),
  user: z.lazy(() => UserOrderByWithRelationInputSchema).optional(),
  _relevance: z.lazy(() => ForecastOrderByRelevanceInputSchema).optional()
}).strict();

export const ForecastWhereUniqueInputSchema: z.ZodType<Prisma.ForecastWhereUniqueInput> = z.object({
  id: z.number().int()
})
.and(z.object({
  id: z.number().int().optional(),
  AND: z.union([ z.lazy(() => ForecastWhereInputSchema),z.lazy(() => ForecastWhereInputSchema).array() ]).optional(),
  OR: z.lazy(() => ForecastWhereInputSchema).array().optional(),
  NOT: z.union([ z.lazy(() => ForecastWhereInputSchema),z.lazy(() => ForecastWhereInputSchema).array() ]).optional(),
  createdAt: z.union([ z.lazy(() => DateTimeFilterSchema),z.coerce.date() ]).optional(),
  comment: z.union([ z.lazy(() => StringNullableFilterSchema),z.string() ]).optional().nullable(),
  forecast: z.union([ z.lazy(() => DecimalFilterSchema),z.union([z.number(),z.string(),z.instanceof(Decimal),z.instanceof(Prisma.Decimal),DecimalJsLikeSchema,]).refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' }) ]).optional(),
  profileId: z.union([ z.lazy(() => IntNullableFilterSchema),z.number().int() ]).optional().nullable(),
  questionId: z.union([ z.lazy(() => StringFilterSchema),z.string() ]).optional(),
  optionId: z.union([ z.lazy(() => StringNullableFilterSchema),z.string() ]).optional().nullable(),
  userId: z.union([ z.lazy(() => StringFilterSchema),z.string() ]).optional(),
  option: z.union([ z.lazy(() => QuestionOptionNullableRelationFilterSchema),z.lazy(() => QuestionOptionWhereInputSchema) ]).optional().nullable(),
  profile: z.union([ z.lazy(() => ProfileNullableRelationFilterSchema),z.lazy(() => ProfileWhereInputSchema) ]).optional().nullable(),
  question: z.union([ z.lazy(() => QuestionRelationFilterSchema),z.lazy(() => QuestionWhereInputSchema) ]).optional(),
  user: z.union([ z.lazy(() => UserRelationFilterSchema),z.lazy(() => UserWhereInputSchema) ]).optional(),
}).strict());

export const ForecastOrderByWithAggregationInputSchema: z.ZodType<Prisma.ForecastOrderByWithAggregationInput> = z.object({
  id: z.lazy(() => SortOrderSchema).optional(),
  createdAt: z.lazy(() => SortOrderSchema).optional(),
  comment: z.union([ z.lazy(() => SortOrderSchema),z.lazy(() => SortOrderInputSchema) ]).optional(),
  forecast: z.lazy(() => SortOrderSchema).optional(),
  profileId: z.union([ z.lazy(() => SortOrderSchema),z.lazy(() => SortOrderInputSchema) ]).optional(),
  questionId: z.lazy(() => SortOrderSchema).optional(),
  optionId: z.union([ z.lazy(() => SortOrderSchema),z.lazy(() => SortOrderInputSchema) ]).optional(),
  userId: z.lazy(() => SortOrderSchema).optional(),
  _count: z.lazy(() => ForecastCountOrderByAggregateInputSchema).optional(),
  _avg: z.lazy(() => ForecastAvgOrderByAggregateInputSchema).optional(),
  _max: z.lazy(() => ForecastMaxOrderByAggregateInputSchema).optional(),
  _min: z.lazy(() => ForecastMinOrderByAggregateInputSchema).optional(),
  _sum: z.lazy(() => ForecastSumOrderByAggregateInputSchema).optional()
}).strict();

export const ForecastScalarWhereWithAggregatesInputSchema: z.ZodType<Prisma.ForecastScalarWhereWithAggregatesInput> = z.object({
  AND: z.union([ z.lazy(() => ForecastScalarWhereWithAggregatesInputSchema),z.lazy(() => ForecastScalarWhereWithAggregatesInputSchema).array() ]).optional(),
  OR: z.lazy(() => ForecastScalarWhereWithAggregatesInputSchema).array().optional(),
  NOT: z.union([ z.lazy(() => ForecastScalarWhereWithAggregatesInputSchema),z.lazy(() => ForecastScalarWhereWithAggregatesInputSchema).array() ]).optional(),
  id: z.union([ z.lazy(() => IntWithAggregatesFilterSchema),z.number() ]).optional(),
  createdAt: z.union([ z.lazy(() => DateTimeWithAggregatesFilterSchema),z.coerce.date() ]).optional(),
  comment: z.union([ z.lazy(() => StringNullableWithAggregatesFilterSchema),z.string() ]).optional().nullable(),
  forecast: z.union([ z.lazy(() => DecimalWithAggregatesFilterSchema),z.union([z.number(),z.string(),z.instanceof(Decimal),z.instanceof(Prisma.Decimal),DecimalJsLikeSchema,]).refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' }) ]).optional(),
  profileId: z.union([ z.lazy(() => IntNullableWithAggregatesFilterSchema),z.number() ]).optional().nullable(),
  questionId: z.union([ z.lazy(() => StringWithAggregatesFilterSchema),z.string() ]).optional(),
  optionId: z.union([ z.lazy(() => StringNullableWithAggregatesFilterSchema),z.string() ]).optional().nullable(),
  userId: z.union([ z.lazy(() => StringWithAggregatesFilterSchema),z.string() ]).optional(),
}).strict();

export const QuestionScoreWhereInputSchema: z.ZodType<Prisma.QuestionScoreWhereInput> = z.object({
  AND: z.union([ z.lazy(() => QuestionScoreWhereInputSchema),z.lazy(() => QuestionScoreWhereInputSchema).array() ]).optional(),
  OR: z.lazy(() => QuestionScoreWhereInputSchema).array().optional(),
  NOT: z.union([ z.lazy(() => QuestionScoreWhereInputSchema),z.lazy(() => QuestionScoreWhereInputSchema).array() ]).optional(),
  id: z.union([ z.lazy(() => IntFilterSchema),z.number() ]).optional(),
  createdAt: z.union([ z.lazy(() => DateTimeFilterSchema),z.coerce.date() ]).optional(),
  relativeScore: z.union([ z.lazy(() => DecimalNullableFilterSchema),z.union([z.number(),z.string(),z.instanceof(Decimal),z.instanceof(Prisma.Decimal),DecimalJsLikeSchema,]).refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' }) ]).optional().nullable(),
  questionId: z.union([ z.lazy(() => StringFilterSchema),z.string() ]).optional(),
  userQuestionComboId: z.union([ z.lazy(() => StringFilterSchema),z.string() ]).optional(),
  absoluteScore: z.union([ z.lazy(() => DecimalFilterSchema),z.union([z.number(),z.string(),z.instanceof(Decimal),z.instanceof(Prisma.Decimal),DecimalJsLikeSchema,]).refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' }) ]).optional(),
  rank: z.union([ z.lazy(() => IntFilterSchema),z.number() ]).optional(),
  userId: z.union([ z.lazy(() => StringFilterSchema),z.string() ]).optional(),
  questionOptionId: z.union([ z.lazy(() => StringNullableFilterSchema),z.string() ]).optional().nullable(),
  question: z.union([ z.lazy(() => QuestionRelationFilterSchema),z.lazy(() => QuestionWhereInputSchema) ]).optional(),
  user: z.union([ z.lazy(() => UserRelationFilterSchema),z.lazy(() => UserWhereInputSchema) ]).optional(),
  QuestionOption: z.union([ z.lazy(() => QuestionOptionNullableRelationFilterSchema),z.lazy(() => QuestionOptionWhereInputSchema) ]).optional().nullable(),
}).strict();

export const QuestionScoreOrderByWithRelationInputSchema: z.ZodType<Prisma.QuestionScoreOrderByWithRelationInput> = z.object({
  id: z.lazy(() => SortOrderSchema).optional(),
  createdAt: z.lazy(() => SortOrderSchema).optional(),
  relativeScore: z.union([ z.lazy(() => SortOrderSchema),z.lazy(() => SortOrderInputSchema) ]).optional(),
  questionId: z.lazy(() => SortOrderSchema).optional(),
  userQuestionComboId: z.lazy(() => SortOrderSchema).optional(),
  absoluteScore: z.lazy(() => SortOrderSchema).optional(),
  rank: z.lazy(() => SortOrderSchema).optional(),
  userId: z.lazy(() => SortOrderSchema).optional(),
  questionOptionId: z.union([ z.lazy(() => SortOrderSchema),z.lazy(() => SortOrderInputSchema) ]).optional(),
  question: z.lazy(() => QuestionOrderByWithRelationInputSchema).optional(),
  user: z.lazy(() => UserOrderByWithRelationInputSchema).optional(),
  QuestionOption: z.lazy(() => QuestionOptionOrderByWithRelationInputSchema).optional(),
  _relevance: z.lazy(() => QuestionScoreOrderByRelevanceInputSchema).optional()
}).strict();

export const QuestionScoreWhereUniqueInputSchema: z.ZodType<Prisma.QuestionScoreWhereUniqueInput> = z.union([
  z.object({
    id: z.number().int(),
    userQuestionComboId: z.string()
  }),
  z.object({
    id: z.number().int(),
  }),
  z.object({
    userQuestionComboId: z.string(),
  }),
])
.and(z.object({
  id: z.number().int().optional(),
  userQuestionComboId: z.string().optional(),
  AND: z.union([ z.lazy(() => QuestionScoreWhereInputSchema),z.lazy(() => QuestionScoreWhereInputSchema).array() ]).optional(),
  OR: z.lazy(() => QuestionScoreWhereInputSchema).array().optional(),
  NOT: z.union([ z.lazy(() => QuestionScoreWhereInputSchema),z.lazy(() => QuestionScoreWhereInputSchema).array() ]).optional(),
  createdAt: z.union([ z.lazy(() => DateTimeFilterSchema),z.coerce.date() ]).optional(),
  relativeScore: z.union([ z.lazy(() => DecimalNullableFilterSchema),z.union([z.number(),z.string(),z.instanceof(Decimal),z.instanceof(Prisma.Decimal),DecimalJsLikeSchema,]).refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' }) ]).optional().nullable(),
  questionId: z.union([ z.lazy(() => StringFilterSchema),z.string() ]).optional(),
  absoluteScore: z.union([ z.lazy(() => DecimalFilterSchema),z.union([z.number(),z.string(),z.instanceof(Decimal),z.instanceof(Prisma.Decimal),DecimalJsLikeSchema,]).refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' }) ]).optional(),
  rank: z.union([ z.lazy(() => IntFilterSchema),z.number().int() ]).optional(),
  userId: z.union([ z.lazy(() => StringFilterSchema),z.string() ]).optional(),
  questionOptionId: z.union([ z.lazy(() => StringNullableFilterSchema),z.string() ]).optional().nullable(),
  question: z.union([ z.lazy(() => QuestionRelationFilterSchema),z.lazy(() => QuestionWhereInputSchema) ]).optional(),
  user: z.union([ z.lazy(() => UserRelationFilterSchema),z.lazy(() => UserWhereInputSchema) ]).optional(),
  QuestionOption: z.union([ z.lazy(() => QuestionOptionNullableRelationFilterSchema),z.lazy(() => QuestionOptionWhereInputSchema) ]).optional().nullable(),
}).strict());

export const QuestionScoreOrderByWithAggregationInputSchema: z.ZodType<Prisma.QuestionScoreOrderByWithAggregationInput> = z.object({
  id: z.lazy(() => SortOrderSchema).optional(),
  createdAt: z.lazy(() => SortOrderSchema).optional(),
  relativeScore: z.union([ z.lazy(() => SortOrderSchema),z.lazy(() => SortOrderInputSchema) ]).optional(),
  questionId: z.lazy(() => SortOrderSchema).optional(),
  userQuestionComboId: z.lazy(() => SortOrderSchema).optional(),
  absoluteScore: z.lazy(() => SortOrderSchema).optional(),
  rank: z.lazy(() => SortOrderSchema).optional(),
  userId: z.lazy(() => SortOrderSchema).optional(),
  questionOptionId: z.union([ z.lazy(() => SortOrderSchema),z.lazy(() => SortOrderInputSchema) ]).optional(),
  _count: z.lazy(() => QuestionScoreCountOrderByAggregateInputSchema).optional(),
  _avg: z.lazy(() => QuestionScoreAvgOrderByAggregateInputSchema).optional(),
  _max: z.lazy(() => QuestionScoreMaxOrderByAggregateInputSchema).optional(),
  _min: z.lazy(() => QuestionScoreMinOrderByAggregateInputSchema).optional(),
  _sum: z.lazy(() => QuestionScoreSumOrderByAggregateInputSchema).optional()
}).strict();

export const QuestionScoreScalarWhereWithAggregatesInputSchema: z.ZodType<Prisma.QuestionScoreScalarWhereWithAggregatesInput> = z.object({
  AND: z.union([ z.lazy(() => QuestionScoreScalarWhereWithAggregatesInputSchema),z.lazy(() => QuestionScoreScalarWhereWithAggregatesInputSchema).array() ]).optional(),
  OR: z.lazy(() => QuestionScoreScalarWhereWithAggregatesInputSchema).array().optional(),
  NOT: z.union([ z.lazy(() => QuestionScoreScalarWhereWithAggregatesInputSchema),z.lazy(() => QuestionScoreScalarWhereWithAggregatesInputSchema).array() ]).optional(),
  id: z.union([ z.lazy(() => IntWithAggregatesFilterSchema),z.number() ]).optional(),
  createdAt: z.union([ z.lazy(() => DateTimeWithAggregatesFilterSchema),z.coerce.date() ]).optional(),
  relativeScore: z.union([ z.lazy(() => DecimalNullableWithAggregatesFilterSchema),z.union([z.number(),z.string(),z.instanceof(Decimal),z.instanceof(Prisma.Decimal),DecimalJsLikeSchema,]).refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' }) ]).optional().nullable(),
  questionId: z.union([ z.lazy(() => StringWithAggregatesFilterSchema),z.string() ]).optional(),
  userQuestionComboId: z.union([ z.lazy(() => StringWithAggregatesFilterSchema),z.string() ]).optional(),
  absoluteScore: z.union([ z.lazy(() => DecimalWithAggregatesFilterSchema),z.union([z.number(),z.string(),z.instanceof(Decimal),z.instanceof(Prisma.Decimal),DecimalJsLikeSchema,]).refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' }) ]).optional(),
  rank: z.union([ z.lazy(() => IntWithAggregatesFilterSchema),z.number() ]).optional(),
  userId: z.union([ z.lazy(() => StringWithAggregatesFilterSchema),z.string() ]).optional(),
  questionOptionId: z.union([ z.lazy(() => StringNullableWithAggregatesFilterSchema),z.string() ]).optional().nullable(),
}).strict();

export const QuestionOptionWhereInputSchema: z.ZodType<Prisma.QuestionOptionWhereInput> = z.object({
  AND: z.union([ z.lazy(() => QuestionOptionWhereInputSchema),z.lazy(() => QuestionOptionWhereInputSchema).array() ]).optional(),
  OR: z.lazy(() => QuestionOptionWhereInputSchema).array().optional(),
  NOT: z.union([ z.lazy(() => QuestionOptionWhereInputSchema),z.lazy(() => QuestionOptionWhereInputSchema).array() ]).optional(),
  id: z.union([ z.lazy(() => StringFilterSchema),z.string() ]).optional(),
  questionId: z.union([ z.lazy(() => StringFilterSchema),z.string() ]).optional(),
  text: z.union([ z.lazy(() => StringFilterSchema),z.string() ]).optional(),
  resolution: z.union([ z.lazy(() => EnumResolutionNullableFilterSchema),z.lazy(() => ResolutionSchema) ]).optional().nullable(),
  createdAt: z.union([ z.lazy(() => DateTimeFilterSchema),z.coerce.date() ]).optional(),
  userId: z.union([ z.lazy(() => StringFilterSchema),z.string() ]).optional(),
  resolvedAt: z.union([ z.lazy(() => DateTimeNullableFilterSchema),z.coerce.date() ]).optional().nullable(),
  question: z.union([ z.lazy(() => QuestionRelationFilterSchema),z.lazy(() => QuestionWhereInputSchema) ]).optional(),
  forecasts: z.lazy(() => ForecastListRelationFilterSchema).optional(),
  user: z.union([ z.lazy(() => UserRelationFilterSchema),z.lazy(() => UserWhereInputSchema) ]).optional(),
  questionScores: z.lazy(() => QuestionScoreListRelationFilterSchema).optional()
}).strict();

export const QuestionOptionOrderByWithRelationInputSchema: z.ZodType<Prisma.QuestionOptionOrderByWithRelationInput> = z.object({
  id: z.lazy(() => SortOrderSchema).optional(),
  questionId: z.lazy(() => SortOrderSchema).optional(),
  text: z.lazy(() => SortOrderSchema).optional(),
  resolution: z.union([ z.lazy(() => SortOrderSchema),z.lazy(() => SortOrderInputSchema) ]).optional(),
  createdAt: z.lazy(() => SortOrderSchema).optional(),
  userId: z.lazy(() => SortOrderSchema).optional(),
  resolvedAt: z.union([ z.lazy(() => SortOrderSchema),z.lazy(() => SortOrderInputSchema) ]).optional(),
  question: z.lazy(() => QuestionOrderByWithRelationInputSchema).optional(),
  forecasts: z.lazy(() => ForecastOrderByRelationAggregateInputSchema).optional(),
  user: z.lazy(() => UserOrderByWithRelationInputSchema).optional(),
  questionScores: z.lazy(() => QuestionScoreOrderByRelationAggregateInputSchema).optional(),
  _relevance: z.lazy(() => QuestionOptionOrderByRelevanceInputSchema).optional()
}).strict();

export const QuestionOptionWhereUniqueInputSchema: z.ZodType<Prisma.QuestionOptionWhereUniqueInput> = z.object({
  id: z.string().cuid()
})
.and(z.object({
  id: z.string().cuid().optional(),
  AND: z.union([ z.lazy(() => QuestionOptionWhereInputSchema),z.lazy(() => QuestionOptionWhereInputSchema).array() ]).optional(),
  OR: z.lazy(() => QuestionOptionWhereInputSchema).array().optional(),
  NOT: z.union([ z.lazy(() => QuestionOptionWhereInputSchema),z.lazy(() => QuestionOptionWhereInputSchema).array() ]).optional(),
  questionId: z.union([ z.lazy(() => StringFilterSchema),z.string() ]).optional(),
  text: z.union([ z.lazy(() => StringFilterSchema),z.string() ]).optional(),
  resolution: z.union([ z.lazy(() => EnumResolutionNullableFilterSchema),z.lazy(() => ResolutionSchema) ]).optional().nullable(),
  createdAt: z.union([ z.lazy(() => DateTimeFilterSchema),z.coerce.date() ]).optional(),
  userId: z.union([ z.lazy(() => StringFilterSchema),z.string() ]).optional(),
  resolvedAt: z.union([ z.lazy(() => DateTimeNullableFilterSchema),z.coerce.date() ]).optional().nullable(),
  question: z.union([ z.lazy(() => QuestionRelationFilterSchema),z.lazy(() => QuestionWhereInputSchema) ]).optional(),
  forecasts: z.lazy(() => ForecastListRelationFilterSchema).optional(),
  user: z.union([ z.lazy(() => UserRelationFilterSchema),z.lazy(() => UserWhereInputSchema) ]).optional(),
  questionScores: z.lazy(() => QuestionScoreListRelationFilterSchema).optional()
}).strict());

export const QuestionOptionOrderByWithAggregationInputSchema: z.ZodType<Prisma.QuestionOptionOrderByWithAggregationInput> = z.object({
  id: z.lazy(() => SortOrderSchema).optional(),
  questionId: z.lazy(() => SortOrderSchema).optional(),
  text: z.lazy(() => SortOrderSchema).optional(),
  resolution: z.union([ z.lazy(() => SortOrderSchema),z.lazy(() => SortOrderInputSchema) ]).optional(),
  createdAt: z.lazy(() => SortOrderSchema).optional(),
  userId: z.lazy(() => SortOrderSchema).optional(),
  resolvedAt: z.union([ z.lazy(() => SortOrderSchema),z.lazy(() => SortOrderInputSchema) ]).optional(),
  _count: z.lazy(() => QuestionOptionCountOrderByAggregateInputSchema).optional(),
  _max: z.lazy(() => QuestionOptionMaxOrderByAggregateInputSchema).optional(),
  _min: z.lazy(() => QuestionOptionMinOrderByAggregateInputSchema).optional()
}).strict();

export const QuestionOptionScalarWhereWithAggregatesInputSchema: z.ZodType<Prisma.QuestionOptionScalarWhereWithAggregatesInput> = z.object({
  AND: z.union([ z.lazy(() => QuestionOptionScalarWhereWithAggregatesInputSchema),z.lazy(() => QuestionOptionScalarWhereWithAggregatesInputSchema).array() ]).optional(),
  OR: z.lazy(() => QuestionOptionScalarWhereWithAggregatesInputSchema).array().optional(),
  NOT: z.union([ z.lazy(() => QuestionOptionScalarWhereWithAggregatesInputSchema),z.lazy(() => QuestionOptionScalarWhereWithAggregatesInputSchema).array() ]).optional(),
  id: z.union([ z.lazy(() => StringWithAggregatesFilterSchema),z.string() ]).optional(),
  questionId: z.union([ z.lazy(() => StringWithAggregatesFilterSchema),z.string() ]).optional(),
  text: z.union([ z.lazy(() => StringWithAggregatesFilterSchema),z.string() ]).optional(),
  resolution: z.union([ z.lazy(() => EnumResolutionNullableWithAggregatesFilterSchema),z.lazy(() => ResolutionSchema) ]).optional().nullable(),
  createdAt: z.union([ z.lazy(() => DateTimeWithAggregatesFilterSchema),z.coerce.date() ]).optional(),
  userId: z.union([ z.lazy(() => StringWithAggregatesFilterSchema),z.string() ]).optional(),
  resolvedAt: z.union([ z.lazy(() => DateTimeNullableWithAggregatesFilterSchema),z.coerce.date() ]).optional().nullable(),
}).strict();

export const QuestionWhereInputSchema: z.ZodType<Prisma.QuestionWhereInput> = z.object({
  AND: z.union([ z.lazy(() => QuestionWhereInputSchema),z.lazy(() => QuestionWhereInputSchema).array() ]).optional(),
  OR: z.lazy(() => QuestionWhereInputSchema).array().optional(),
  NOT: z.union([ z.lazy(() => QuestionWhereInputSchema),z.lazy(() => QuestionWhereInputSchema).array() ]).optional(),
  id: z.union([ z.lazy(() => StringFilterSchema),z.string() ]).optional(),
  createdAt: z.union([ z.lazy(() => DateTimeFilterSchema),z.coerce.date() ]).optional(),
  comment: z.union([ z.lazy(() => StringNullableFilterSchema),z.string() ]).optional().nullable(),
  profileId: z.union([ z.lazy(() => IntNullableFilterSchema),z.number() ]).optional().nullable(),
  title: z.union([ z.lazy(() => StringFilterSchema),z.string() ]).optional(),
  type: z.union([ z.lazy(() => EnumQuestionTypeFilterSchema),z.lazy(() => QuestionTypeSchema) ]).optional(),
  resolveBy: z.union([ z.lazy(() => DateTimeFilterSchema),z.coerce.date() ]).optional(),
  resolved: z.union([ z.lazy(() => BoolFilterSchema),z.boolean() ]).optional(),
  pingedForResolution: z.union([ z.lazy(() => BoolFilterSchema),z.boolean() ]).optional(),
  resolution: z.union([ z.lazy(() => EnumResolutionNullableFilterSchema),z.lazy(() => ResolutionSchema) ]).optional().nullable(),
  resolvedAt: z.union([ z.lazy(() => DateTimeNullableFilterSchema),z.coerce.date() ]).optional().nullable(),
  notes: z.union([ z.lazy(() => StringNullableFilterSchema),z.string() ]).optional().nullable(),
  hideForecastsUntil: z.union([ z.lazy(() => DateTimeNullableFilterSchema),z.coerce.date() ]).optional().nullable(),
  hideForecastsUntilPrediction: z.union([ z.lazy(() => BoolNullableFilterSchema),z.boolean() ]).optional().nullable(),
  userId: z.union([ z.lazy(() => StringFilterSchema),z.string() ]).optional(),
  sharedPublicly: z.union([ z.lazy(() => BoolFilterSchema),z.boolean() ]).optional(),
  unlisted: z.union([ z.lazy(() => BoolFilterSchema),z.boolean() ]).optional(),
  exclusiveAnswers: z.union([ z.lazy(() => BoolNullableFilterSchema),z.boolean() ]).optional().nullable(),
  options: z.lazy(() => QuestionOptionListRelationFilterSchema).optional(),
  forecasts: z.lazy(() => ForecastListRelationFilterSchema).optional(),
  pingResolveMessages: z.lazy(() => PingSlackMessageListRelationFilterSchema).optional(),
  profile: z.union([ z.lazy(() => ProfileNullableRelationFilterSchema),z.lazy(() => ProfileWhereInputSchema) ]).optional().nullable(),
  user: z.union([ z.lazy(() => UserRelationFilterSchema),z.lazy(() => UserWhereInputSchema) ]).optional(),
  sharedWith: z.lazy(() => UserListRelationFilterSchema).optional(),
  sharedWithLists: z.lazy(() => UserListListRelationFilterSchema).optional(),
  questionScores: z.lazy(() => QuestionScoreListRelationFilterSchema).optional(),
  questionMessages: z.lazy(() => QuestionSlackMessageListRelationFilterSchema).optional(),
  resolutionMessages: z.lazy(() => ResolutionSlackMessageListRelationFilterSchema).optional(),
  comments: z.lazy(() => CommentListRelationFilterSchema).optional(),
  tags: z.lazy(() => TagListRelationFilterSchema).optional(),
  tournaments: z.lazy(() => TournamentListRelationFilterSchema).optional(),
  notifications: z.lazy(() => NotificationListRelationFilterSchema).optional()
}).strict();

export const QuestionOrderByWithRelationInputSchema: z.ZodType<Prisma.QuestionOrderByWithRelationInput> = z.object({
  id: z.lazy(() => SortOrderSchema).optional(),
  createdAt: z.lazy(() => SortOrderSchema).optional(),
  comment: z.union([ z.lazy(() => SortOrderSchema),z.lazy(() => SortOrderInputSchema) ]).optional(),
  profileId: z.union([ z.lazy(() => SortOrderSchema),z.lazy(() => SortOrderInputSchema) ]).optional(),
  title: z.lazy(() => SortOrderSchema).optional(),
  type: z.lazy(() => SortOrderSchema).optional(),
  resolveBy: z.lazy(() => SortOrderSchema).optional(),
  resolved: z.lazy(() => SortOrderSchema).optional(),
  pingedForResolution: z.lazy(() => SortOrderSchema).optional(),
  resolution: z.union([ z.lazy(() => SortOrderSchema),z.lazy(() => SortOrderInputSchema) ]).optional(),
  resolvedAt: z.union([ z.lazy(() => SortOrderSchema),z.lazy(() => SortOrderInputSchema) ]).optional(),
  notes: z.union([ z.lazy(() => SortOrderSchema),z.lazy(() => SortOrderInputSchema) ]).optional(),
  hideForecastsUntil: z.union([ z.lazy(() => SortOrderSchema),z.lazy(() => SortOrderInputSchema) ]).optional(),
  hideForecastsUntilPrediction: z.union([ z.lazy(() => SortOrderSchema),z.lazy(() => SortOrderInputSchema) ]).optional(),
  userId: z.lazy(() => SortOrderSchema).optional(),
  sharedPublicly: z.lazy(() => SortOrderSchema).optional(),
  unlisted: z.lazy(() => SortOrderSchema).optional(),
  exclusiveAnswers: z.union([ z.lazy(() => SortOrderSchema),z.lazy(() => SortOrderInputSchema) ]).optional(),
  options: z.lazy(() => QuestionOptionOrderByRelationAggregateInputSchema).optional(),
  forecasts: z.lazy(() => ForecastOrderByRelationAggregateInputSchema).optional(),
  pingResolveMessages: z.lazy(() => PingSlackMessageOrderByRelationAggregateInputSchema).optional(),
  profile: z.lazy(() => ProfileOrderByWithRelationInputSchema).optional(),
  user: z.lazy(() => UserOrderByWithRelationInputSchema).optional(),
  sharedWith: z.lazy(() => UserOrderByRelationAggregateInputSchema).optional(),
  sharedWithLists: z.lazy(() => UserListOrderByRelationAggregateInputSchema).optional(),
  questionScores: z.lazy(() => QuestionScoreOrderByRelationAggregateInputSchema).optional(),
  questionMessages: z.lazy(() => QuestionSlackMessageOrderByRelationAggregateInputSchema).optional(),
  resolutionMessages: z.lazy(() => ResolutionSlackMessageOrderByRelationAggregateInputSchema).optional(),
  comments: z.lazy(() => CommentOrderByRelationAggregateInputSchema).optional(),
  tags: z.lazy(() => TagOrderByRelationAggregateInputSchema).optional(),
  tournaments: z.lazy(() => TournamentOrderByRelationAggregateInputSchema).optional(),
  notifications: z.lazy(() => NotificationOrderByRelationAggregateInputSchema).optional(),
  _relevance: z.lazy(() => QuestionOrderByRelevanceInputSchema).optional()
}).strict();

export const QuestionWhereUniqueInputSchema: z.ZodType<Prisma.QuestionWhereUniqueInput> = z.object({
  id: z.string().cuid()
})
.and(z.object({
  id: z.string().cuid().optional(),
  AND: z.union([ z.lazy(() => QuestionWhereInputSchema),z.lazy(() => QuestionWhereInputSchema).array() ]).optional(),
  OR: z.lazy(() => QuestionWhereInputSchema).array().optional(),
  NOT: z.union([ z.lazy(() => QuestionWhereInputSchema),z.lazy(() => QuestionWhereInputSchema).array() ]).optional(),
  createdAt: z.union([ z.lazy(() => DateTimeFilterSchema),z.coerce.date() ]).optional(),
  comment: z.union([ z.lazy(() => StringNullableFilterSchema),z.string() ]).optional().nullable(),
  profileId: z.union([ z.lazy(() => IntNullableFilterSchema),z.number().int() ]).optional().nullable(),
  title: z.union([ z.lazy(() => StringFilterSchema),z.string() ]).optional(),
  type: z.union([ z.lazy(() => EnumQuestionTypeFilterSchema),z.lazy(() => QuestionTypeSchema) ]).optional(),
  resolveBy: z.union([ z.lazy(() => DateTimeFilterSchema),z.coerce.date() ]).optional(),
  resolved: z.union([ z.lazy(() => BoolFilterSchema),z.boolean() ]).optional(),
  pingedForResolution: z.union([ z.lazy(() => BoolFilterSchema),z.boolean() ]).optional(),
  resolution: z.union([ z.lazy(() => EnumResolutionNullableFilterSchema),z.lazy(() => ResolutionSchema) ]).optional().nullable(),
  resolvedAt: z.union([ z.lazy(() => DateTimeNullableFilterSchema),z.coerce.date() ]).optional().nullable(),
  notes: z.union([ z.lazy(() => StringNullableFilterSchema),z.string() ]).optional().nullable(),
  hideForecastsUntil: z.union([ z.lazy(() => DateTimeNullableFilterSchema),z.coerce.date() ]).optional().nullable(),
  hideForecastsUntilPrediction: z.union([ z.lazy(() => BoolNullableFilterSchema),z.boolean() ]).optional().nullable(),
  userId: z.union([ z.lazy(() => StringFilterSchema),z.string() ]).optional(),
  sharedPublicly: z.union([ z.lazy(() => BoolFilterSchema),z.boolean() ]).optional(),
  unlisted: z.union([ z.lazy(() => BoolFilterSchema),z.boolean() ]).optional(),
  exclusiveAnswers: z.union([ z.lazy(() => BoolNullableFilterSchema),z.boolean() ]).optional().nullable(),
  options: z.lazy(() => QuestionOptionListRelationFilterSchema).optional(),
  forecasts: z.lazy(() => ForecastListRelationFilterSchema).optional(),
  pingResolveMessages: z.lazy(() => PingSlackMessageListRelationFilterSchema).optional(),
  profile: z.union([ z.lazy(() => ProfileNullableRelationFilterSchema),z.lazy(() => ProfileWhereInputSchema) ]).optional().nullable(),
  user: z.union([ z.lazy(() => UserRelationFilterSchema),z.lazy(() => UserWhereInputSchema) ]).optional(),
  sharedWith: z.lazy(() => UserListRelationFilterSchema).optional(),
  sharedWithLists: z.lazy(() => UserListListRelationFilterSchema).optional(),
  questionScores: z.lazy(() => QuestionScoreListRelationFilterSchema).optional(),
  questionMessages: z.lazy(() => QuestionSlackMessageListRelationFilterSchema).optional(),
  resolutionMessages: z.lazy(() => ResolutionSlackMessageListRelationFilterSchema).optional(),
  comments: z.lazy(() => CommentListRelationFilterSchema).optional(),
  tags: z.lazy(() => TagListRelationFilterSchema).optional(),
  tournaments: z.lazy(() => TournamentListRelationFilterSchema).optional(),
  notifications: z.lazy(() => NotificationListRelationFilterSchema).optional()
}).strict());

export const QuestionOrderByWithAggregationInputSchema: z.ZodType<Prisma.QuestionOrderByWithAggregationInput> = z.object({
  id: z.lazy(() => SortOrderSchema).optional(),
  createdAt: z.lazy(() => SortOrderSchema).optional(),
  comment: z.union([ z.lazy(() => SortOrderSchema),z.lazy(() => SortOrderInputSchema) ]).optional(),
  profileId: z.union([ z.lazy(() => SortOrderSchema),z.lazy(() => SortOrderInputSchema) ]).optional(),
  title: z.lazy(() => SortOrderSchema).optional(),
  type: z.lazy(() => SortOrderSchema).optional(),
  resolveBy: z.lazy(() => SortOrderSchema).optional(),
  resolved: z.lazy(() => SortOrderSchema).optional(),
  pingedForResolution: z.lazy(() => SortOrderSchema).optional(),
  resolution: z.union([ z.lazy(() => SortOrderSchema),z.lazy(() => SortOrderInputSchema) ]).optional(),
  resolvedAt: z.union([ z.lazy(() => SortOrderSchema),z.lazy(() => SortOrderInputSchema) ]).optional(),
  notes: z.union([ z.lazy(() => SortOrderSchema),z.lazy(() => SortOrderInputSchema) ]).optional(),
  hideForecastsUntil: z.union([ z.lazy(() => SortOrderSchema),z.lazy(() => SortOrderInputSchema) ]).optional(),
  hideForecastsUntilPrediction: z.union([ z.lazy(() => SortOrderSchema),z.lazy(() => SortOrderInputSchema) ]).optional(),
  userId: z.lazy(() => SortOrderSchema).optional(),
  sharedPublicly: z.lazy(() => SortOrderSchema).optional(),
  unlisted: z.lazy(() => SortOrderSchema).optional(),
  exclusiveAnswers: z.union([ z.lazy(() => SortOrderSchema),z.lazy(() => SortOrderInputSchema) ]).optional(),
  _count: z.lazy(() => QuestionCountOrderByAggregateInputSchema).optional(),
  _avg: z.lazy(() => QuestionAvgOrderByAggregateInputSchema).optional(),
  _max: z.lazy(() => QuestionMaxOrderByAggregateInputSchema).optional(),
  _min: z.lazy(() => QuestionMinOrderByAggregateInputSchema).optional(),
  _sum: z.lazy(() => QuestionSumOrderByAggregateInputSchema).optional()
}).strict();

export const QuestionScalarWhereWithAggregatesInputSchema: z.ZodType<Prisma.QuestionScalarWhereWithAggregatesInput> = z.object({
  AND: z.union([ z.lazy(() => QuestionScalarWhereWithAggregatesInputSchema),z.lazy(() => QuestionScalarWhereWithAggregatesInputSchema).array() ]).optional(),
  OR: z.lazy(() => QuestionScalarWhereWithAggregatesInputSchema).array().optional(),
  NOT: z.union([ z.lazy(() => QuestionScalarWhereWithAggregatesInputSchema),z.lazy(() => QuestionScalarWhereWithAggregatesInputSchema).array() ]).optional(),
  id: z.union([ z.lazy(() => StringWithAggregatesFilterSchema),z.string() ]).optional(),
  createdAt: z.union([ z.lazy(() => DateTimeWithAggregatesFilterSchema),z.coerce.date() ]).optional(),
  comment: z.union([ z.lazy(() => StringNullableWithAggregatesFilterSchema),z.string() ]).optional().nullable(),
  profileId: z.union([ z.lazy(() => IntNullableWithAggregatesFilterSchema),z.number() ]).optional().nullable(),
  title: z.union([ z.lazy(() => StringWithAggregatesFilterSchema),z.string() ]).optional(),
  type: z.union([ z.lazy(() => EnumQuestionTypeWithAggregatesFilterSchema),z.lazy(() => QuestionTypeSchema) ]).optional(),
  resolveBy: z.union([ z.lazy(() => DateTimeWithAggregatesFilterSchema),z.coerce.date() ]).optional(),
  resolved: z.union([ z.lazy(() => BoolWithAggregatesFilterSchema),z.boolean() ]).optional(),
  pingedForResolution: z.union([ z.lazy(() => BoolWithAggregatesFilterSchema),z.boolean() ]).optional(),
  resolution: z.union([ z.lazy(() => EnumResolutionNullableWithAggregatesFilterSchema),z.lazy(() => ResolutionSchema) ]).optional().nullable(),
  resolvedAt: z.union([ z.lazy(() => DateTimeNullableWithAggregatesFilterSchema),z.coerce.date() ]).optional().nullable(),
  notes: z.union([ z.lazy(() => StringNullableWithAggregatesFilterSchema),z.string() ]).optional().nullable(),
  hideForecastsUntil: z.union([ z.lazy(() => DateTimeNullableWithAggregatesFilterSchema),z.coerce.date() ]).optional().nullable(),
  hideForecastsUntilPrediction: z.union([ z.lazy(() => BoolNullableWithAggregatesFilterSchema),z.boolean() ]).optional().nullable(),
  userId: z.union([ z.lazy(() => StringWithAggregatesFilterSchema),z.string() ]).optional(),
  sharedPublicly: z.union([ z.lazy(() => BoolWithAggregatesFilterSchema),z.boolean() ]).optional(),
  unlisted: z.union([ z.lazy(() => BoolWithAggregatesFilterSchema),z.boolean() ]).optional(),
  exclusiveAnswers: z.union([ z.lazy(() => BoolNullableWithAggregatesFilterSchema),z.boolean() ]).optional().nullable(),
}).strict();

export const TagWhereInputSchema: z.ZodType<Prisma.TagWhereInput> = z.object({
  AND: z.union([ z.lazy(() => TagWhereInputSchema),z.lazy(() => TagWhereInputSchema).array() ]).optional(),
  OR: z.lazy(() => TagWhereInputSchema).array().optional(),
  NOT: z.union([ z.lazy(() => TagWhereInputSchema),z.lazy(() => TagWhereInputSchema).array() ]).optional(),
  id: z.union([ z.lazy(() => StringFilterSchema),z.string() ]).optional(),
  createdAt: z.union([ z.lazy(() => DateTimeFilterSchema),z.coerce.date() ]).optional(),
  name: z.union([ z.lazy(() => StringFilterSchema),z.string() ]).optional(),
  userId: z.union([ z.lazy(() => StringFilterSchema),z.string() ]).optional(),
  user: z.union([ z.lazy(() => UserRelationFilterSchema),z.lazy(() => UserWhereInputSchema) ]).optional(),
  questions: z.lazy(() => QuestionListRelationFilterSchema).optional()
}).strict();

export const TagOrderByWithRelationInputSchema: z.ZodType<Prisma.TagOrderByWithRelationInput> = z.object({
  id: z.lazy(() => SortOrderSchema).optional(),
  createdAt: z.lazy(() => SortOrderSchema).optional(),
  name: z.lazy(() => SortOrderSchema).optional(),
  userId: z.lazy(() => SortOrderSchema).optional(),
  user: z.lazy(() => UserOrderByWithRelationInputSchema).optional(),
  questions: z.lazy(() => QuestionOrderByRelationAggregateInputSchema).optional(),
  _relevance: z.lazy(() => TagOrderByRelevanceInputSchema).optional()
}).strict();

export const TagWhereUniqueInputSchema: z.ZodType<Prisma.TagWhereUniqueInput> = z.union([
  z.object({
    id: z.string().cuid(),
    name_userId: z.lazy(() => TagNameUserIdCompoundUniqueInputSchema)
  }),
  z.object({
    id: z.string().cuid(),
  }),
  z.object({
    name_userId: z.lazy(() => TagNameUserIdCompoundUniqueInputSchema),
  }),
])
.and(z.object({
  id: z.string().cuid().optional(),
  name_userId: z.lazy(() => TagNameUserIdCompoundUniqueInputSchema).optional(),
  AND: z.union([ z.lazy(() => TagWhereInputSchema),z.lazy(() => TagWhereInputSchema).array() ]).optional(),
  OR: z.lazy(() => TagWhereInputSchema).array().optional(),
  NOT: z.union([ z.lazy(() => TagWhereInputSchema),z.lazy(() => TagWhereInputSchema).array() ]).optional(),
  createdAt: z.union([ z.lazy(() => DateTimeFilterSchema),z.coerce.date() ]).optional(),
  name: z.union([ z.lazy(() => StringFilterSchema),z.string() ]).optional(),
  userId: z.union([ z.lazy(() => StringFilterSchema),z.string() ]).optional(),
  user: z.union([ z.lazy(() => UserRelationFilterSchema),z.lazy(() => UserWhereInputSchema) ]).optional(),
  questions: z.lazy(() => QuestionListRelationFilterSchema).optional()
}).strict());

export const TagOrderByWithAggregationInputSchema: z.ZodType<Prisma.TagOrderByWithAggregationInput> = z.object({
  id: z.lazy(() => SortOrderSchema).optional(),
  createdAt: z.lazy(() => SortOrderSchema).optional(),
  name: z.lazy(() => SortOrderSchema).optional(),
  userId: z.lazy(() => SortOrderSchema).optional(),
  _count: z.lazy(() => TagCountOrderByAggregateInputSchema).optional(),
  _max: z.lazy(() => TagMaxOrderByAggregateInputSchema).optional(),
  _min: z.lazy(() => TagMinOrderByAggregateInputSchema).optional()
}).strict();

export const TagScalarWhereWithAggregatesInputSchema: z.ZodType<Prisma.TagScalarWhereWithAggregatesInput> = z.object({
  AND: z.union([ z.lazy(() => TagScalarWhereWithAggregatesInputSchema),z.lazy(() => TagScalarWhereWithAggregatesInputSchema).array() ]).optional(),
  OR: z.lazy(() => TagScalarWhereWithAggregatesInputSchema).array().optional(),
  NOT: z.union([ z.lazy(() => TagScalarWhereWithAggregatesInputSchema),z.lazy(() => TagScalarWhereWithAggregatesInputSchema).array() ]).optional(),
  id: z.union([ z.lazy(() => StringWithAggregatesFilterSchema),z.string() ]).optional(),
  createdAt: z.union([ z.lazy(() => DateTimeWithAggregatesFilterSchema),z.coerce.date() ]).optional(),
  name: z.union([ z.lazy(() => StringWithAggregatesFilterSchema),z.string() ]).optional(),
  userId: z.union([ z.lazy(() => StringWithAggregatesFilterSchema),z.string() ]).optional(),
}).strict();

export const ResolutionSlackMessageWhereInputSchema: z.ZodType<Prisma.ResolutionSlackMessageWhereInput> = z.object({
  AND: z.union([ z.lazy(() => ResolutionSlackMessageWhereInputSchema),z.lazy(() => ResolutionSlackMessageWhereInputSchema).array() ]).optional(),
  OR: z.lazy(() => ResolutionSlackMessageWhereInputSchema).array().optional(),
  NOT: z.union([ z.lazy(() => ResolutionSlackMessageWhereInputSchema),z.lazy(() => ResolutionSlackMessageWhereInputSchema).array() ]).optional(),
  id: z.union([ z.lazy(() => IntFilterSchema),z.number() ]).optional(),
  questionId: z.union([ z.lazy(() => StringFilterSchema),z.string() ]).optional(),
  detailsId: z.union([ z.lazy(() => IntFilterSchema),z.number() ]).optional(),
  profileId: z.union([ z.lazy(() => IntNullableFilterSchema),z.number() ]).optional().nullable(),
  message: z.union([ z.lazy(() => SlackMessageRelationFilterSchema),z.lazy(() => SlackMessageWhereInputSchema) ]).optional(),
  profile: z.union([ z.lazy(() => ProfileNullableRelationFilterSchema),z.lazy(() => ProfileWhereInputSchema) ]).optional().nullable(),
  question: z.union([ z.lazy(() => QuestionRelationFilterSchema),z.lazy(() => QuestionWhereInputSchema) ]).optional(),
}).strict();

export const ResolutionSlackMessageOrderByWithRelationInputSchema: z.ZodType<Prisma.ResolutionSlackMessageOrderByWithRelationInput> = z.object({
  id: z.lazy(() => SortOrderSchema).optional(),
  questionId: z.lazy(() => SortOrderSchema).optional(),
  detailsId: z.lazy(() => SortOrderSchema).optional(),
  profileId: z.union([ z.lazy(() => SortOrderSchema),z.lazy(() => SortOrderInputSchema) ]).optional(),
  message: z.lazy(() => SlackMessageOrderByWithRelationInputSchema).optional(),
  profile: z.lazy(() => ProfileOrderByWithRelationInputSchema).optional(),
  question: z.lazy(() => QuestionOrderByWithRelationInputSchema).optional(),
  _relevance: z.lazy(() => ResolutionSlackMessageOrderByRelevanceInputSchema).optional()
}).strict();

export const ResolutionSlackMessageWhereUniqueInputSchema: z.ZodType<Prisma.ResolutionSlackMessageWhereUniqueInput> = z.union([
  z.object({
    id: z.number().int(),
    detailsId: z.number().int()
  }),
  z.object({
    id: z.number().int(),
  }),
  z.object({
    detailsId: z.number().int(),
  }),
])
.and(z.object({
  id: z.number().int().optional(),
  detailsId: z.number().int().optional(),
  AND: z.union([ z.lazy(() => ResolutionSlackMessageWhereInputSchema),z.lazy(() => ResolutionSlackMessageWhereInputSchema).array() ]).optional(),
  OR: z.lazy(() => ResolutionSlackMessageWhereInputSchema).array().optional(),
  NOT: z.union([ z.lazy(() => ResolutionSlackMessageWhereInputSchema),z.lazy(() => ResolutionSlackMessageWhereInputSchema).array() ]).optional(),
  questionId: z.union([ z.lazy(() => StringFilterSchema),z.string() ]).optional(),
  profileId: z.union([ z.lazy(() => IntNullableFilterSchema),z.number().int() ]).optional().nullable(),
  message: z.union([ z.lazy(() => SlackMessageRelationFilterSchema),z.lazy(() => SlackMessageWhereInputSchema) ]).optional(),
  profile: z.union([ z.lazy(() => ProfileNullableRelationFilterSchema),z.lazy(() => ProfileWhereInputSchema) ]).optional().nullable(),
  question: z.union([ z.lazy(() => QuestionRelationFilterSchema),z.lazy(() => QuestionWhereInputSchema) ]).optional(),
}).strict());

export const ResolutionSlackMessageOrderByWithAggregationInputSchema: z.ZodType<Prisma.ResolutionSlackMessageOrderByWithAggregationInput> = z.object({
  id: z.lazy(() => SortOrderSchema).optional(),
  questionId: z.lazy(() => SortOrderSchema).optional(),
  detailsId: z.lazy(() => SortOrderSchema).optional(),
  profileId: z.union([ z.lazy(() => SortOrderSchema),z.lazy(() => SortOrderInputSchema) ]).optional(),
  _count: z.lazy(() => ResolutionSlackMessageCountOrderByAggregateInputSchema).optional(),
  _avg: z.lazy(() => ResolutionSlackMessageAvgOrderByAggregateInputSchema).optional(),
  _max: z.lazy(() => ResolutionSlackMessageMaxOrderByAggregateInputSchema).optional(),
  _min: z.lazy(() => ResolutionSlackMessageMinOrderByAggregateInputSchema).optional(),
  _sum: z.lazy(() => ResolutionSlackMessageSumOrderByAggregateInputSchema).optional()
}).strict();

export const ResolutionSlackMessageScalarWhereWithAggregatesInputSchema: z.ZodType<Prisma.ResolutionSlackMessageScalarWhereWithAggregatesInput> = z.object({
  AND: z.union([ z.lazy(() => ResolutionSlackMessageScalarWhereWithAggregatesInputSchema),z.lazy(() => ResolutionSlackMessageScalarWhereWithAggregatesInputSchema).array() ]).optional(),
  OR: z.lazy(() => ResolutionSlackMessageScalarWhereWithAggregatesInputSchema).array().optional(),
  NOT: z.union([ z.lazy(() => ResolutionSlackMessageScalarWhereWithAggregatesInputSchema),z.lazy(() => ResolutionSlackMessageScalarWhereWithAggregatesInputSchema).array() ]).optional(),
  id: z.union([ z.lazy(() => IntWithAggregatesFilterSchema),z.number() ]).optional(),
  questionId: z.union([ z.lazy(() => StringWithAggregatesFilterSchema),z.string() ]).optional(),
  detailsId: z.union([ z.lazy(() => IntWithAggregatesFilterSchema),z.number() ]).optional(),
  profileId: z.union([ z.lazy(() => IntNullableWithAggregatesFilterSchema),z.number() ]).optional().nullable(),
}).strict();

export const PingSlackMessageWhereInputSchema: z.ZodType<Prisma.PingSlackMessageWhereInput> = z.object({
  AND: z.union([ z.lazy(() => PingSlackMessageWhereInputSchema),z.lazy(() => PingSlackMessageWhereInputSchema).array() ]).optional(),
  OR: z.lazy(() => PingSlackMessageWhereInputSchema).array().optional(),
  NOT: z.union([ z.lazy(() => PingSlackMessageWhereInputSchema),z.lazy(() => PingSlackMessageWhereInputSchema).array() ]).optional(),
  id: z.union([ z.lazy(() => IntFilterSchema),z.number() ]).optional(),
  questionId: z.union([ z.lazy(() => StringFilterSchema),z.string() ]).optional(),
  detailsId: z.union([ z.lazy(() => IntFilterSchema),z.number() ]).optional(),
  message: z.union([ z.lazy(() => SlackMessageRelationFilterSchema),z.lazy(() => SlackMessageWhereInputSchema) ]).optional(),
  question: z.union([ z.lazy(() => QuestionRelationFilterSchema),z.lazy(() => QuestionWhereInputSchema) ]).optional(),
}).strict();

export const PingSlackMessageOrderByWithRelationInputSchema: z.ZodType<Prisma.PingSlackMessageOrderByWithRelationInput> = z.object({
  id: z.lazy(() => SortOrderSchema).optional(),
  questionId: z.lazy(() => SortOrderSchema).optional(),
  detailsId: z.lazy(() => SortOrderSchema).optional(),
  message: z.lazy(() => SlackMessageOrderByWithRelationInputSchema).optional(),
  question: z.lazy(() => QuestionOrderByWithRelationInputSchema).optional(),
  _relevance: z.lazy(() => PingSlackMessageOrderByRelevanceInputSchema).optional()
}).strict();

export const PingSlackMessageWhereUniqueInputSchema: z.ZodType<Prisma.PingSlackMessageWhereUniqueInput> = z.union([
  z.object({
    id: z.number().int(),
    detailsId: z.number().int()
  }),
  z.object({
    id: z.number().int(),
  }),
  z.object({
    detailsId: z.number().int(),
  }),
])
.and(z.object({
  id: z.number().int().optional(),
  detailsId: z.number().int().optional(),
  AND: z.union([ z.lazy(() => PingSlackMessageWhereInputSchema),z.lazy(() => PingSlackMessageWhereInputSchema).array() ]).optional(),
  OR: z.lazy(() => PingSlackMessageWhereInputSchema).array().optional(),
  NOT: z.union([ z.lazy(() => PingSlackMessageWhereInputSchema),z.lazy(() => PingSlackMessageWhereInputSchema).array() ]).optional(),
  questionId: z.union([ z.lazy(() => StringFilterSchema),z.string() ]).optional(),
  message: z.union([ z.lazy(() => SlackMessageRelationFilterSchema),z.lazy(() => SlackMessageWhereInputSchema) ]).optional(),
  question: z.union([ z.lazy(() => QuestionRelationFilterSchema),z.lazy(() => QuestionWhereInputSchema) ]).optional(),
}).strict());

export const PingSlackMessageOrderByWithAggregationInputSchema: z.ZodType<Prisma.PingSlackMessageOrderByWithAggregationInput> = z.object({
  id: z.lazy(() => SortOrderSchema).optional(),
  questionId: z.lazy(() => SortOrderSchema).optional(),
  detailsId: z.lazy(() => SortOrderSchema).optional(),
  _count: z.lazy(() => PingSlackMessageCountOrderByAggregateInputSchema).optional(),
  _avg: z.lazy(() => PingSlackMessageAvgOrderByAggregateInputSchema).optional(),
  _max: z.lazy(() => PingSlackMessageMaxOrderByAggregateInputSchema).optional(),
  _min: z.lazy(() => PingSlackMessageMinOrderByAggregateInputSchema).optional(),
  _sum: z.lazy(() => PingSlackMessageSumOrderByAggregateInputSchema).optional()
}).strict();

export const PingSlackMessageScalarWhereWithAggregatesInputSchema: z.ZodType<Prisma.PingSlackMessageScalarWhereWithAggregatesInput> = z.object({
  AND: z.union([ z.lazy(() => PingSlackMessageScalarWhereWithAggregatesInputSchema),z.lazy(() => PingSlackMessageScalarWhereWithAggregatesInputSchema).array() ]).optional(),
  OR: z.lazy(() => PingSlackMessageScalarWhereWithAggregatesInputSchema).array().optional(),
  NOT: z.union([ z.lazy(() => PingSlackMessageScalarWhereWithAggregatesInputSchema),z.lazy(() => PingSlackMessageScalarWhereWithAggregatesInputSchema).array() ]).optional(),
  id: z.union([ z.lazy(() => IntWithAggregatesFilterSchema),z.number() ]).optional(),
  questionId: z.union([ z.lazy(() => StringWithAggregatesFilterSchema),z.string() ]).optional(),
  detailsId: z.union([ z.lazy(() => IntWithAggregatesFilterSchema),z.number() ]).optional(),
}).strict();

export const QuestionSlackMessageWhereInputSchema: z.ZodType<Prisma.QuestionSlackMessageWhereInput> = z.object({
  AND: z.union([ z.lazy(() => QuestionSlackMessageWhereInputSchema),z.lazy(() => QuestionSlackMessageWhereInputSchema).array() ]).optional(),
  OR: z.lazy(() => QuestionSlackMessageWhereInputSchema).array().optional(),
  NOT: z.union([ z.lazy(() => QuestionSlackMessageWhereInputSchema),z.lazy(() => QuestionSlackMessageWhereInputSchema).array() ]).optional(),
  id: z.union([ z.lazy(() => IntFilterSchema),z.number() ]).optional(),
  questionId: z.union([ z.lazy(() => StringFilterSchema),z.string() ]).optional(),
  detailsId: z.union([ z.lazy(() => IntFilterSchema),z.number() ]).optional(),
  updatedAt: z.union([ z.lazy(() => DateTimeFilterSchema),z.coerce.date() ]).optional(),
  message: z.union([ z.lazy(() => SlackMessageRelationFilterSchema),z.lazy(() => SlackMessageWhereInputSchema) ]).optional(),
  question: z.union([ z.lazy(() => QuestionRelationFilterSchema),z.lazy(() => QuestionWhereInputSchema) ]).optional(),
}).strict();

export const QuestionSlackMessageOrderByWithRelationInputSchema: z.ZodType<Prisma.QuestionSlackMessageOrderByWithRelationInput> = z.object({
  id: z.lazy(() => SortOrderSchema).optional(),
  questionId: z.lazy(() => SortOrderSchema).optional(),
  detailsId: z.lazy(() => SortOrderSchema).optional(),
  updatedAt: z.lazy(() => SortOrderSchema).optional(),
  message: z.lazy(() => SlackMessageOrderByWithRelationInputSchema).optional(),
  question: z.lazy(() => QuestionOrderByWithRelationInputSchema).optional(),
  _relevance: z.lazy(() => QuestionSlackMessageOrderByRelevanceInputSchema).optional()
}).strict();

export const QuestionSlackMessageWhereUniqueInputSchema: z.ZodType<Prisma.QuestionSlackMessageWhereUniqueInput> = z.union([
  z.object({
    id: z.number().int(),
    detailsId: z.number().int()
  }),
  z.object({
    id: z.number().int(),
  }),
  z.object({
    detailsId: z.number().int(),
  }),
])
.and(z.object({
  id: z.number().int().optional(),
  detailsId: z.number().int().optional(),
  AND: z.union([ z.lazy(() => QuestionSlackMessageWhereInputSchema),z.lazy(() => QuestionSlackMessageWhereInputSchema).array() ]).optional(),
  OR: z.lazy(() => QuestionSlackMessageWhereInputSchema).array().optional(),
  NOT: z.union([ z.lazy(() => QuestionSlackMessageWhereInputSchema),z.lazy(() => QuestionSlackMessageWhereInputSchema).array() ]).optional(),
  questionId: z.union([ z.lazy(() => StringFilterSchema),z.string() ]).optional(),
  updatedAt: z.union([ z.lazy(() => DateTimeFilterSchema),z.coerce.date() ]).optional(),
  message: z.union([ z.lazy(() => SlackMessageRelationFilterSchema),z.lazy(() => SlackMessageWhereInputSchema) ]).optional(),
  question: z.union([ z.lazy(() => QuestionRelationFilterSchema),z.lazy(() => QuestionWhereInputSchema) ]).optional(),
}).strict());

export const QuestionSlackMessageOrderByWithAggregationInputSchema: z.ZodType<Prisma.QuestionSlackMessageOrderByWithAggregationInput> = z.object({
  id: z.lazy(() => SortOrderSchema).optional(),
  questionId: z.lazy(() => SortOrderSchema).optional(),
  detailsId: z.lazy(() => SortOrderSchema).optional(),
  updatedAt: z.lazy(() => SortOrderSchema).optional(),
  _count: z.lazy(() => QuestionSlackMessageCountOrderByAggregateInputSchema).optional(),
  _avg: z.lazy(() => QuestionSlackMessageAvgOrderByAggregateInputSchema).optional(),
  _max: z.lazy(() => QuestionSlackMessageMaxOrderByAggregateInputSchema).optional(),
  _min: z.lazy(() => QuestionSlackMessageMinOrderByAggregateInputSchema).optional(),
  _sum: z.lazy(() => QuestionSlackMessageSumOrderByAggregateInputSchema).optional()
}).strict();

export const QuestionSlackMessageScalarWhereWithAggregatesInputSchema: z.ZodType<Prisma.QuestionSlackMessageScalarWhereWithAggregatesInput> = z.object({
  AND: z.union([ z.lazy(() => QuestionSlackMessageScalarWhereWithAggregatesInputSchema),z.lazy(() => QuestionSlackMessageScalarWhereWithAggregatesInputSchema).array() ]).optional(),
  OR: z.lazy(() => QuestionSlackMessageScalarWhereWithAggregatesInputSchema).array().optional(),
  NOT: z.union([ z.lazy(() => QuestionSlackMessageScalarWhereWithAggregatesInputSchema),z.lazy(() => QuestionSlackMessageScalarWhereWithAggregatesInputSchema).array() ]).optional(),
  id: z.union([ z.lazy(() => IntWithAggregatesFilterSchema),z.number() ]).optional(),
  questionId: z.union([ z.lazy(() => StringWithAggregatesFilterSchema),z.string() ]).optional(),
  detailsId: z.union([ z.lazy(() => IntWithAggregatesFilterSchema),z.number() ]).optional(),
  updatedAt: z.union([ z.lazy(() => DateTimeWithAggregatesFilterSchema),z.coerce.date() ]).optional(),
}).strict();

export const SlackMessageWhereInputSchema: z.ZodType<Prisma.SlackMessageWhereInput> = z.object({
  AND: z.union([ z.lazy(() => SlackMessageWhereInputSchema),z.lazy(() => SlackMessageWhereInputSchema).array() ]).optional(),
  OR: z.lazy(() => SlackMessageWhereInputSchema).array().optional(),
  NOT: z.union([ z.lazy(() => SlackMessageWhereInputSchema),z.lazy(() => SlackMessageWhereInputSchema).array() ]).optional(),
  id: z.union([ z.lazy(() => IntFilterSchema),z.number() ]).optional(),
  ts: z.union([ z.lazy(() => StringFilterSchema),z.string() ]).optional(),
  channel: z.union([ z.lazy(() => StringFilterSchema),z.string() ]).optional(),
  teamId: z.union([ z.lazy(() => StringFilterSchema),z.string() ]).optional(),
  pingSlackMessage: z.union([ z.lazy(() => PingSlackMessageNullableRelationFilterSchema),z.lazy(() => PingSlackMessageWhereInputSchema) ]).optional().nullable(),
  questionSlackMessage: z.union([ z.lazy(() => QuestionSlackMessageNullableRelationFilterSchema),z.lazy(() => QuestionSlackMessageWhereInputSchema) ]).optional().nullable(),
  resolutionSlackMessage: z.union([ z.lazy(() => ResolutionSlackMessageNullableRelationFilterSchema),z.lazy(() => ResolutionSlackMessageWhereInputSchema) ]).optional().nullable(),
}).strict();

export const SlackMessageOrderByWithRelationInputSchema: z.ZodType<Prisma.SlackMessageOrderByWithRelationInput> = z.object({
  id: z.lazy(() => SortOrderSchema).optional(),
  ts: z.lazy(() => SortOrderSchema).optional(),
  channel: z.lazy(() => SortOrderSchema).optional(),
  teamId: z.lazy(() => SortOrderSchema).optional(),
  pingSlackMessage: z.lazy(() => PingSlackMessageOrderByWithRelationInputSchema).optional(),
  questionSlackMessage: z.lazy(() => QuestionSlackMessageOrderByWithRelationInputSchema).optional(),
  resolutionSlackMessage: z.lazy(() => ResolutionSlackMessageOrderByWithRelationInputSchema).optional(),
  _relevance: z.lazy(() => SlackMessageOrderByRelevanceInputSchema).optional()
}).strict();

export const SlackMessageWhereUniqueInputSchema: z.ZodType<Prisma.SlackMessageWhereUniqueInput> = z.object({
  id: z.number().int()
})
.and(z.object({
  id: z.number().int().optional(),
  AND: z.union([ z.lazy(() => SlackMessageWhereInputSchema),z.lazy(() => SlackMessageWhereInputSchema).array() ]).optional(),
  OR: z.lazy(() => SlackMessageWhereInputSchema).array().optional(),
  NOT: z.union([ z.lazy(() => SlackMessageWhereInputSchema),z.lazy(() => SlackMessageWhereInputSchema).array() ]).optional(),
  ts: z.union([ z.lazy(() => StringFilterSchema),z.string() ]).optional(),
  channel: z.union([ z.lazy(() => StringFilterSchema),z.string() ]).optional(),
  teamId: z.union([ z.lazy(() => StringFilterSchema),z.string() ]).optional(),
  pingSlackMessage: z.union([ z.lazy(() => PingSlackMessageNullableRelationFilterSchema),z.lazy(() => PingSlackMessageWhereInputSchema) ]).optional().nullable(),
  questionSlackMessage: z.union([ z.lazy(() => QuestionSlackMessageNullableRelationFilterSchema),z.lazy(() => QuestionSlackMessageWhereInputSchema) ]).optional().nullable(),
  resolutionSlackMessage: z.union([ z.lazy(() => ResolutionSlackMessageNullableRelationFilterSchema),z.lazy(() => ResolutionSlackMessageWhereInputSchema) ]).optional().nullable(),
}).strict());

export const SlackMessageOrderByWithAggregationInputSchema: z.ZodType<Prisma.SlackMessageOrderByWithAggregationInput> = z.object({
  id: z.lazy(() => SortOrderSchema).optional(),
  ts: z.lazy(() => SortOrderSchema).optional(),
  channel: z.lazy(() => SortOrderSchema).optional(),
  teamId: z.lazy(() => SortOrderSchema).optional(),
  _count: z.lazy(() => SlackMessageCountOrderByAggregateInputSchema).optional(),
  _avg: z.lazy(() => SlackMessageAvgOrderByAggregateInputSchema).optional(),
  _max: z.lazy(() => SlackMessageMaxOrderByAggregateInputSchema).optional(),
  _min: z.lazy(() => SlackMessageMinOrderByAggregateInputSchema).optional(),
  _sum: z.lazy(() => SlackMessageSumOrderByAggregateInputSchema).optional()
}).strict();

export const SlackMessageScalarWhereWithAggregatesInputSchema: z.ZodType<Prisma.SlackMessageScalarWhereWithAggregatesInput> = z.object({
  AND: z.union([ z.lazy(() => SlackMessageScalarWhereWithAggregatesInputSchema),z.lazy(() => SlackMessageScalarWhereWithAggregatesInputSchema).array() ]).optional(),
  OR: z.lazy(() => SlackMessageScalarWhereWithAggregatesInputSchema).array().optional(),
  NOT: z.union([ z.lazy(() => SlackMessageScalarWhereWithAggregatesInputSchema),z.lazy(() => SlackMessageScalarWhereWithAggregatesInputSchema).array() ]).optional(),
  id: z.union([ z.lazy(() => IntWithAggregatesFilterSchema),z.number() ]).optional(),
  ts: z.union([ z.lazy(() => StringWithAggregatesFilterSchema),z.string() ]).optional(),
  channel: z.union([ z.lazy(() => StringWithAggregatesFilterSchema),z.string() ]).optional(),
  teamId: z.union([ z.lazy(() => StringWithAggregatesFilterSchema),z.string() ]).optional(),
}).strict();

export const UserWhereInputSchema: z.ZodType<Prisma.UserWhereInput> = z.object({
  AND: z.union([ z.lazy(() => UserWhereInputSchema),z.lazy(() => UserWhereInputSchema).array() ]).optional(),
  OR: z.lazy(() => UserWhereInputSchema).array().optional(),
  NOT: z.union([ z.lazy(() => UserWhereInputSchema),z.lazy(() => UserWhereInputSchema).array() ]).optional(),
  id: z.union([ z.lazy(() => StringFilterSchema),z.string() ]).optional(),
  name: z.union([ z.lazy(() => StringNullableFilterSchema),z.string() ]).optional().nullable(),
  createdAt: z.union([ z.lazy(() => DateTimeFilterSchema),z.coerce.date() ]).optional(),
  email: z.union([ z.lazy(() => StringFilterSchema),z.string() ]).optional(),
  image: z.union([ z.lazy(() => StringNullableFilterSchema),z.string() ]).optional().nullable(),
  staleReminder: z.union([ z.lazy(() => BoolFilterSchema),z.boolean() ]).optional(),
  unsubscribedFromEmailsAt: z.union([ z.lazy(() => DateTimeNullableFilterSchema),z.coerce.date() ]).optional().nullable(),
  apiKey: z.union([ z.lazy(() => StringNullableFilterSchema),z.string() ]).optional().nullable(),
  discordUserId: z.union([ z.lazy(() => StringNullableFilterSchema),z.string() ]).optional().nullable(),
  emailVerified: z.union([ z.lazy(() => DateTimeNullableFilterSchema),z.coerce.date() ]).optional().nullable(),
  forecasts: z.lazy(() => ForecastListRelationFilterSchema).optional(),
  profiles: z.lazy(() => ProfileListRelationFilterSchema).optional(),
  questions: z.lazy(() => QuestionListRelationFilterSchema).optional(),
  questionScores: z.lazy(() => QuestionScoreListRelationFilterSchema).optional(),
  questionsSharedWith: z.lazy(() => QuestionListRelationFilterSchema).optional(),
  comments: z.lazy(() => CommentListRelationFilterSchema).optional(),
  target: z.union([ z.lazy(() => TargetNullableRelationFilterSchema),z.lazy(() => TargetWhereInputSchema) ]).optional().nullable(),
  authorOfLists: z.lazy(() => UserListListRelationFilterSchema).optional(),
  memberOfLists: z.lazy(() => UserListListRelationFilterSchema).optional(),
  tags: z.lazy(() => TagListRelationFilterSchema).optional(),
  tournaments: z.lazy(() => TournamentListRelationFilterSchema).optional(),
  notifications: z.lazy(() => NotificationListRelationFilterSchema).optional(),
  questionOptions: z.lazy(() => QuestionOptionListRelationFilterSchema).optional(),
  accounts: z.lazy(() => AccountListRelationFilterSchema).optional()
}).strict();

export const UserOrderByWithRelationInputSchema: z.ZodType<Prisma.UserOrderByWithRelationInput> = z.object({
  id: z.lazy(() => SortOrderSchema).optional(),
  name: z.union([ z.lazy(() => SortOrderSchema),z.lazy(() => SortOrderInputSchema) ]).optional(),
  createdAt: z.lazy(() => SortOrderSchema).optional(),
  email: z.lazy(() => SortOrderSchema).optional(),
  image: z.union([ z.lazy(() => SortOrderSchema),z.lazy(() => SortOrderInputSchema) ]).optional(),
  staleReminder: z.lazy(() => SortOrderSchema).optional(),
  unsubscribedFromEmailsAt: z.union([ z.lazy(() => SortOrderSchema),z.lazy(() => SortOrderInputSchema) ]).optional(),
  apiKey: z.union([ z.lazy(() => SortOrderSchema),z.lazy(() => SortOrderInputSchema) ]).optional(),
  discordUserId: z.union([ z.lazy(() => SortOrderSchema),z.lazy(() => SortOrderInputSchema) ]).optional(),
  emailVerified: z.union([ z.lazy(() => SortOrderSchema),z.lazy(() => SortOrderInputSchema) ]).optional(),
  forecasts: z.lazy(() => ForecastOrderByRelationAggregateInputSchema).optional(),
  profiles: z.lazy(() => ProfileOrderByRelationAggregateInputSchema).optional(),
  questions: z.lazy(() => QuestionOrderByRelationAggregateInputSchema).optional(),
  questionScores: z.lazy(() => QuestionScoreOrderByRelationAggregateInputSchema).optional(),
  questionsSharedWith: z.lazy(() => QuestionOrderByRelationAggregateInputSchema).optional(),
  comments: z.lazy(() => CommentOrderByRelationAggregateInputSchema).optional(),
  target: z.lazy(() => TargetOrderByWithRelationInputSchema).optional(),
  authorOfLists: z.lazy(() => UserListOrderByRelationAggregateInputSchema).optional(),
  memberOfLists: z.lazy(() => UserListOrderByRelationAggregateInputSchema).optional(),
  tags: z.lazy(() => TagOrderByRelationAggregateInputSchema).optional(),
  tournaments: z.lazy(() => TournamentOrderByRelationAggregateInputSchema).optional(),
  notifications: z.lazy(() => NotificationOrderByRelationAggregateInputSchema).optional(),
  questionOptions: z.lazy(() => QuestionOptionOrderByRelationAggregateInputSchema).optional(),
  accounts: z.lazy(() => AccountOrderByRelationAggregateInputSchema).optional(),
  _relevance: z.lazy(() => UserOrderByRelevanceInputSchema).optional()
}).strict();

export const UserWhereUniqueInputSchema: z.ZodType<Prisma.UserWhereUniqueInput> = z.union([
  z.object({
    id: z.string().cuid(),
    email: z.string(),
    discordUserId: z.string()
  }),
  z.object({
    id: z.string().cuid(),
    email: z.string(),
  }),
  z.object({
    id: z.string().cuid(),
    discordUserId: z.string(),
  }),
  z.object({
    id: z.string().cuid(),
  }),
  z.object({
    email: z.string(),
    discordUserId: z.string(),
  }),
  z.object({
    email: z.string(),
  }),
  z.object({
    discordUserId: z.string(),
  }),
])
.and(z.object({
  id: z.string().cuid().optional(),
  email: z.string().optional(),
  discordUserId: z.string().optional(),
  AND: z.union([ z.lazy(() => UserWhereInputSchema),z.lazy(() => UserWhereInputSchema).array() ]).optional(),
  OR: z.lazy(() => UserWhereInputSchema).array().optional(),
  NOT: z.union([ z.lazy(() => UserWhereInputSchema),z.lazy(() => UserWhereInputSchema).array() ]).optional(),
  name: z.union([ z.lazy(() => StringNullableFilterSchema),z.string() ]).optional().nullable(),
  createdAt: z.union([ z.lazy(() => DateTimeFilterSchema),z.coerce.date() ]).optional(),
  image: z.union([ z.lazy(() => StringNullableFilterSchema),z.string() ]).optional().nullable(),
  staleReminder: z.union([ z.lazy(() => BoolFilterSchema),z.boolean() ]).optional(),
  unsubscribedFromEmailsAt: z.union([ z.lazy(() => DateTimeNullableFilterSchema),z.coerce.date() ]).optional().nullable(),
  apiKey: z.union([ z.lazy(() => StringNullableFilterSchema),z.string() ]).optional().nullable(),
  emailVerified: z.union([ z.lazy(() => DateTimeNullableFilterSchema),z.coerce.date() ]).optional().nullable(),
  forecasts: z.lazy(() => ForecastListRelationFilterSchema).optional(),
  profiles: z.lazy(() => ProfileListRelationFilterSchema).optional(),
  questions: z.lazy(() => QuestionListRelationFilterSchema).optional(),
  questionScores: z.lazy(() => QuestionScoreListRelationFilterSchema).optional(),
  questionsSharedWith: z.lazy(() => QuestionListRelationFilterSchema).optional(),
  comments: z.lazy(() => CommentListRelationFilterSchema).optional(),
  target: z.union([ z.lazy(() => TargetNullableRelationFilterSchema),z.lazy(() => TargetWhereInputSchema) ]).optional().nullable(),
  authorOfLists: z.lazy(() => UserListListRelationFilterSchema).optional(),
  memberOfLists: z.lazy(() => UserListListRelationFilterSchema).optional(),
  tags: z.lazy(() => TagListRelationFilterSchema).optional(),
  tournaments: z.lazy(() => TournamentListRelationFilterSchema).optional(),
  notifications: z.lazy(() => NotificationListRelationFilterSchema).optional(),
  questionOptions: z.lazy(() => QuestionOptionListRelationFilterSchema).optional(),
  accounts: z.lazy(() => AccountListRelationFilterSchema).optional()
}).strict());

export const UserOrderByWithAggregationInputSchema: z.ZodType<Prisma.UserOrderByWithAggregationInput> = z.object({
  id: z.lazy(() => SortOrderSchema).optional(),
  name: z.union([ z.lazy(() => SortOrderSchema),z.lazy(() => SortOrderInputSchema) ]).optional(),
  createdAt: z.lazy(() => SortOrderSchema).optional(),
  email: z.lazy(() => SortOrderSchema).optional(),
  image: z.union([ z.lazy(() => SortOrderSchema),z.lazy(() => SortOrderInputSchema) ]).optional(),
  staleReminder: z.lazy(() => SortOrderSchema).optional(),
  unsubscribedFromEmailsAt: z.union([ z.lazy(() => SortOrderSchema),z.lazy(() => SortOrderInputSchema) ]).optional(),
  apiKey: z.union([ z.lazy(() => SortOrderSchema),z.lazy(() => SortOrderInputSchema) ]).optional(),
  discordUserId: z.union([ z.lazy(() => SortOrderSchema),z.lazy(() => SortOrderInputSchema) ]).optional(),
  emailVerified: z.union([ z.lazy(() => SortOrderSchema),z.lazy(() => SortOrderInputSchema) ]).optional(),
  _count: z.lazy(() => UserCountOrderByAggregateInputSchema).optional(),
  _max: z.lazy(() => UserMaxOrderByAggregateInputSchema).optional(),
  _min: z.lazy(() => UserMinOrderByAggregateInputSchema).optional()
}).strict();

export const UserScalarWhereWithAggregatesInputSchema: z.ZodType<Prisma.UserScalarWhereWithAggregatesInput> = z.object({
  AND: z.union([ z.lazy(() => UserScalarWhereWithAggregatesInputSchema),z.lazy(() => UserScalarWhereWithAggregatesInputSchema).array() ]).optional(),
  OR: z.lazy(() => UserScalarWhereWithAggregatesInputSchema).array().optional(),
  NOT: z.union([ z.lazy(() => UserScalarWhereWithAggregatesInputSchema),z.lazy(() => UserScalarWhereWithAggregatesInputSchema).array() ]).optional(),
  id: z.union([ z.lazy(() => StringWithAggregatesFilterSchema),z.string() ]).optional(),
  name: z.union([ z.lazy(() => StringNullableWithAggregatesFilterSchema),z.string() ]).optional().nullable(),
  createdAt: z.union([ z.lazy(() => DateTimeWithAggregatesFilterSchema),z.coerce.date() ]).optional(),
  email: z.union([ z.lazy(() => StringWithAggregatesFilterSchema),z.string() ]).optional(),
  image: z.union([ z.lazy(() => StringNullableWithAggregatesFilterSchema),z.string() ]).optional().nullable(),
  staleReminder: z.union([ z.lazy(() => BoolWithAggregatesFilterSchema),z.boolean() ]).optional(),
  unsubscribedFromEmailsAt: z.union([ z.lazy(() => DateTimeNullableWithAggregatesFilterSchema),z.coerce.date() ]).optional().nullable(),
  apiKey: z.union([ z.lazy(() => StringNullableWithAggregatesFilterSchema),z.string() ]).optional().nullable(),
  discordUserId: z.union([ z.lazy(() => StringNullableWithAggregatesFilterSchema),z.string() ]).optional().nullable(),
  emailVerified: z.union([ z.lazy(() => DateTimeNullableWithAggregatesFilterSchema),z.coerce.date() ]).optional().nullable(),
}).strict();

export const ProfileWhereInputSchema: z.ZodType<Prisma.ProfileWhereInput> = z.object({
  AND: z.union([ z.lazy(() => ProfileWhereInputSchema),z.lazy(() => ProfileWhereInputSchema).array() ]).optional(),
  OR: z.lazy(() => ProfileWhereInputSchema).array().optional(),
  NOT: z.union([ z.lazy(() => ProfileWhereInputSchema),z.lazy(() => ProfileWhereInputSchema).array() ]).optional(),
  id: z.union([ z.lazy(() => IntFilterSchema),z.number() ]).optional(),
  createdAt: z.union([ z.lazy(() => DateTimeFilterSchema),z.coerce.date() ]).optional(),
  slackId: z.union([ z.lazy(() => StringNullableFilterSchema),z.string() ]).optional().nullable(),
  slackTeamId: z.union([ z.lazy(() => StringNullableFilterSchema),z.string() ]).optional().nullable(),
  userId: z.union([ z.lazy(() => StringFilterSchema),z.string() ]).optional(),
  forecasts: z.lazy(() => ForecastListRelationFilterSchema).optional(),
  user: z.union([ z.lazy(() => UserRelationFilterSchema),z.lazy(() => UserWhereInputSchema) ]).optional(),
  questions: z.lazy(() => QuestionListRelationFilterSchema).optional(),
  resolutionMessages: z.lazy(() => ResolutionSlackMessageListRelationFilterSchema).optional(),
  target: z.union([ z.lazy(() => TargetNullableRelationFilterSchema),z.lazy(() => TargetWhereInputSchema) ]).optional().nullable(),
}).strict();

export const ProfileOrderByWithRelationInputSchema: z.ZodType<Prisma.ProfileOrderByWithRelationInput> = z.object({
  id: z.lazy(() => SortOrderSchema).optional(),
  createdAt: z.lazy(() => SortOrderSchema).optional(),
  slackId: z.union([ z.lazy(() => SortOrderSchema),z.lazy(() => SortOrderInputSchema) ]).optional(),
  slackTeamId: z.union([ z.lazy(() => SortOrderSchema),z.lazy(() => SortOrderInputSchema) ]).optional(),
  userId: z.lazy(() => SortOrderSchema).optional(),
  forecasts: z.lazy(() => ForecastOrderByRelationAggregateInputSchema).optional(),
  user: z.lazy(() => UserOrderByWithRelationInputSchema).optional(),
  questions: z.lazy(() => QuestionOrderByRelationAggregateInputSchema).optional(),
  resolutionMessages: z.lazy(() => ResolutionSlackMessageOrderByRelationAggregateInputSchema).optional(),
  target: z.lazy(() => TargetOrderByWithRelationInputSchema).optional(),
  _relevance: z.lazy(() => ProfileOrderByRelevanceInputSchema).optional()
}).strict();

export const ProfileWhereUniqueInputSchema: z.ZodType<Prisma.ProfileWhereUniqueInput> = z.object({
  id: z.number().int()
})
.and(z.object({
  id: z.number().int().optional(),
  AND: z.union([ z.lazy(() => ProfileWhereInputSchema),z.lazy(() => ProfileWhereInputSchema).array() ]).optional(),
  OR: z.lazy(() => ProfileWhereInputSchema).array().optional(),
  NOT: z.union([ z.lazy(() => ProfileWhereInputSchema),z.lazy(() => ProfileWhereInputSchema).array() ]).optional(),
  createdAt: z.union([ z.lazy(() => DateTimeFilterSchema),z.coerce.date() ]).optional(),
  slackId: z.union([ z.lazy(() => StringNullableFilterSchema),z.string() ]).optional().nullable(),
  slackTeamId: z.union([ z.lazy(() => StringNullableFilterSchema),z.string() ]).optional().nullable(),
  userId: z.union([ z.lazy(() => StringFilterSchema),z.string() ]).optional(),
  forecasts: z.lazy(() => ForecastListRelationFilterSchema).optional(),
  user: z.union([ z.lazy(() => UserRelationFilterSchema),z.lazy(() => UserWhereInputSchema) ]).optional(),
  questions: z.lazy(() => QuestionListRelationFilterSchema).optional(),
  resolutionMessages: z.lazy(() => ResolutionSlackMessageListRelationFilterSchema).optional(),
  target: z.union([ z.lazy(() => TargetNullableRelationFilterSchema),z.lazy(() => TargetWhereInputSchema) ]).optional().nullable(),
}).strict());

export const ProfileOrderByWithAggregationInputSchema: z.ZodType<Prisma.ProfileOrderByWithAggregationInput> = z.object({
  id: z.lazy(() => SortOrderSchema).optional(),
  createdAt: z.lazy(() => SortOrderSchema).optional(),
  slackId: z.union([ z.lazy(() => SortOrderSchema),z.lazy(() => SortOrderInputSchema) ]).optional(),
  slackTeamId: z.union([ z.lazy(() => SortOrderSchema),z.lazy(() => SortOrderInputSchema) ]).optional(),
  userId: z.lazy(() => SortOrderSchema).optional(),
  _count: z.lazy(() => ProfileCountOrderByAggregateInputSchema).optional(),
  _avg: z.lazy(() => ProfileAvgOrderByAggregateInputSchema).optional(),
  _max: z.lazy(() => ProfileMaxOrderByAggregateInputSchema).optional(),
  _min: z.lazy(() => ProfileMinOrderByAggregateInputSchema).optional(),
  _sum: z.lazy(() => ProfileSumOrderByAggregateInputSchema).optional()
}).strict();

export const ProfileScalarWhereWithAggregatesInputSchema: z.ZodType<Prisma.ProfileScalarWhereWithAggregatesInput> = z.object({
  AND: z.union([ z.lazy(() => ProfileScalarWhereWithAggregatesInputSchema),z.lazy(() => ProfileScalarWhereWithAggregatesInputSchema).array() ]).optional(),
  OR: z.lazy(() => ProfileScalarWhereWithAggregatesInputSchema).array().optional(),
  NOT: z.union([ z.lazy(() => ProfileScalarWhereWithAggregatesInputSchema),z.lazy(() => ProfileScalarWhereWithAggregatesInputSchema).array() ]).optional(),
  id: z.union([ z.lazy(() => IntWithAggregatesFilterSchema),z.number() ]).optional(),
  createdAt: z.union([ z.lazy(() => DateTimeWithAggregatesFilterSchema),z.coerce.date() ]).optional(),
  slackId: z.union([ z.lazy(() => StringNullableWithAggregatesFilterSchema),z.string() ]).optional().nullable(),
  slackTeamId: z.union([ z.lazy(() => StringNullableWithAggregatesFilterSchema),z.string() ]).optional().nullable(),
  userId: z.union([ z.lazy(() => StringWithAggregatesFilterSchema),z.string() ]).optional(),
}).strict();

export const GroupWhereInputSchema: z.ZodType<Prisma.GroupWhereInput> = z.object({
  AND: z.union([ z.lazy(() => GroupWhereInputSchema),z.lazy(() => GroupWhereInputSchema).array() ]).optional(),
  OR: z.lazy(() => GroupWhereInputSchema).array().optional(),
  NOT: z.union([ z.lazy(() => GroupWhereInputSchema),z.lazy(() => GroupWhereInputSchema).array() ]).optional(),
  id: z.union([ z.lazy(() => IntFilterSchema),z.number() ]).optional(),
  type: z.union([ z.lazy(() => EnumGroupTypeFilterSchema),z.lazy(() => GroupTypeSchema) ]).optional(),
  createdAt: z.union([ z.lazy(() => DateTimeFilterSchema),z.coerce.date() ]).optional(),
  name: z.union([ z.lazy(() => StringFilterSchema),z.string() ]).optional(),
  slackTeamId: z.union([ z.lazy(() => StringNullableFilterSchema),z.string() ]).optional().nullable(),
}).strict();

export const GroupOrderByWithRelationInputSchema: z.ZodType<Prisma.GroupOrderByWithRelationInput> = z.object({
  id: z.lazy(() => SortOrderSchema).optional(),
  type: z.lazy(() => SortOrderSchema).optional(),
  createdAt: z.lazy(() => SortOrderSchema).optional(),
  name: z.lazy(() => SortOrderSchema).optional(),
  slackTeamId: z.union([ z.lazy(() => SortOrderSchema),z.lazy(() => SortOrderInputSchema) ]).optional(),
  _relevance: z.lazy(() => GroupOrderByRelevanceInputSchema).optional()
}).strict();

export const GroupWhereUniqueInputSchema: z.ZodType<Prisma.GroupWhereUniqueInput> = z.object({
  id: z.number().int()
})
.and(z.object({
  id: z.number().int().optional(),
  AND: z.union([ z.lazy(() => GroupWhereInputSchema),z.lazy(() => GroupWhereInputSchema).array() ]).optional(),
  OR: z.lazy(() => GroupWhereInputSchema).array().optional(),
  NOT: z.union([ z.lazy(() => GroupWhereInputSchema),z.lazy(() => GroupWhereInputSchema).array() ]).optional(),
  type: z.union([ z.lazy(() => EnumGroupTypeFilterSchema),z.lazy(() => GroupTypeSchema) ]).optional(),
  createdAt: z.union([ z.lazy(() => DateTimeFilterSchema),z.coerce.date() ]).optional(),
  name: z.union([ z.lazy(() => StringFilterSchema),z.string() ]).optional(),
  slackTeamId: z.union([ z.lazy(() => StringNullableFilterSchema),z.string() ]).optional().nullable(),
}).strict());

export const GroupOrderByWithAggregationInputSchema: z.ZodType<Prisma.GroupOrderByWithAggregationInput> = z.object({
  id: z.lazy(() => SortOrderSchema).optional(),
  type: z.lazy(() => SortOrderSchema).optional(),
  createdAt: z.lazy(() => SortOrderSchema).optional(),
  name: z.lazy(() => SortOrderSchema).optional(),
  slackTeamId: z.union([ z.lazy(() => SortOrderSchema),z.lazy(() => SortOrderInputSchema) ]).optional(),
  _count: z.lazy(() => GroupCountOrderByAggregateInputSchema).optional(),
  _avg: z.lazy(() => GroupAvgOrderByAggregateInputSchema).optional(),
  _max: z.lazy(() => GroupMaxOrderByAggregateInputSchema).optional(),
  _min: z.lazy(() => GroupMinOrderByAggregateInputSchema).optional(),
  _sum: z.lazy(() => GroupSumOrderByAggregateInputSchema).optional()
}).strict();

export const GroupScalarWhereWithAggregatesInputSchema: z.ZodType<Prisma.GroupScalarWhereWithAggregatesInput> = z.object({
  AND: z.union([ z.lazy(() => GroupScalarWhereWithAggregatesInputSchema),z.lazy(() => GroupScalarWhereWithAggregatesInputSchema).array() ]).optional(),
  OR: z.lazy(() => GroupScalarWhereWithAggregatesInputSchema).array().optional(),
  NOT: z.union([ z.lazy(() => GroupScalarWhereWithAggregatesInputSchema),z.lazy(() => GroupScalarWhereWithAggregatesInputSchema).array() ]).optional(),
  id: z.union([ z.lazy(() => IntWithAggregatesFilterSchema),z.number() ]).optional(),
  type: z.union([ z.lazy(() => EnumGroupTypeWithAggregatesFilterSchema),z.lazy(() => GroupTypeSchema) ]).optional(),
  createdAt: z.union([ z.lazy(() => DateTimeWithAggregatesFilterSchema),z.coerce.date() ]).optional(),
  name: z.union([ z.lazy(() => StringWithAggregatesFilterSchema),z.string() ]).optional(),
  slackTeamId: z.union([ z.lazy(() => StringNullableWithAggregatesFilterSchema),z.string() ]).optional().nullable(),
}).strict();

export const TargetWhereInputSchema: z.ZodType<Prisma.TargetWhereInput> = z.object({
  AND: z.union([ z.lazy(() => TargetWhereInputSchema),z.lazy(() => TargetWhereInputSchema).array() ]).optional(),
  OR: z.lazy(() => TargetWhereInputSchema).array().optional(),
  NOT: z.union([ z.lazy(() => TargetWhereInputSchema),z.lazy(() => TargetWhereInputSchema).array() ]).optional(),
  id: z.union([ z.lazy(() => IntFilterSchema),z.number() ]).optional(),
  userId: z.union([ z.lazy(() => StringFilterSchema),z.string() ]).optional(),
  profileId: z.union([ z.lazy(() => IntNullableFilterSchema),z.number() ]).optional().nullable(),
  type: z.union([ z.lazy(() => EnumTargetTypeFilterSchema),z.lazy(() => TargetTypeSchema) ]).optional(),
  goal: z.union([ z.lazy(() => IntFilterSchema),z.number() ]).optional(),
  lastFailedAt: z.union([ z.lazy(() => DateTimeFilterSchema),z.coerce.date() ]).optional(),
  notifyOn: z.union([ z.lazy(() => EnumDayOfTheWeekFilterSchema),z.lazy(() => DayOfTheWeekSchema) ]).optional(),
  lastNotified: z.union([ z.lazy(() => DateTimeFilterSchema),z.coerce.date() ]).optional(),
  user: z.union([ z.lazy(() => UserRelationFilterSchema),z.lazy(() => UserWhereInputSchema) ]).optional(),
  profile: z.union([ z.lazy(() => ProfileNullableRelationFilterSchema),z.lazy(() => ProfileWhereInputSchema) ]).optional().nullable(),
}).strict();

export const TargetOrderByWithRelationInputSchema: z.ZodType<Prisma.TargetOrderByWithRelationInput> = z.object({
  id: z.lazy(() => SortOrderSchema).optional(),
  userId: z.lazy(() => SortOrderSchema).optional(),
  profileId: z.union([ z.lazy(() => SortOrderSchema),z.lazy(() => SortOrderInputSchema) ]).optional(),
  type: z.lazy(() => SortOrderSchema).optional(),
  goal: z.lazy(() => SortOrderSchema).optional(),
  lastFailedAt: z.lazy(() => SortOrderSchema).optional(),
  notifyOn: z.lazy(() => SortOrderSchema).optional(),
  lastNotified: z.lazy(() => SortOrderSchema).optional(),
  user: z.lazy(() => UserOrderByWithRelationInputSchema).optional(),
  profile: z.lazy(() => ProfileOrderByWithRelationInputSchema).optional(),
  _relevance: z.lazy(() => TargetOrderByRelevanceInputSchema).optional()
}).strict();

export const TargetWhereUniqueInputSchema: z.ZodType<Prisma.TargetWhereUniqueInput> = z.union([
  z.object({
    id: z.number().int(),
    userId: z.string(),
    profileId: z.number().int()
  }),
  z.object({
    id: z.number().int(),
    userId: z.string(),
  }),
  z.object({
    id: z.number().int(),
    profileId: z.number().int(),
  }),
  z.object({
    id: z.number().int(),
  }),
  z.object({
    userId: z.string(),
    profileId: z.number().int(),
  }),
  z.object({
    userId: z.string(),
  }),
  z.object({
    profileId: z.number().int(),
  }),
])
.and(z.object({
  id: z.number().int().optional(),
  userId: z.string().optional(),
  profileId: z.number().int().optional(),
  AND: z.union([ z.lazy(() => TargetWhereInputSchema),z.lazy(() => TargetWhereInputSchema).array() ]).optional(),
  OR: z.lazy(() => TargetWhereInputSchema).array().optional(),
  NOT: z.union([ z.lazy(() => TargetWhereInputSchema),z.lazy(() => TargetWhereInputSchema).array() ]).optional(),
  type: z.union([ z.lazy(() => EnumTargetTypeFilterSchema),z.lazy(() => TargetTypeSchema) ]).optional(),
  goal: z.union([ z.lazy(() => IntFilterSchema),z.number().int() ]).optional(),
  lastFailedAt: z.union([ z.lazy(() => DateTimeFilterSchema),z.coerce.date() ]).optional(),
  notifyOn: z.union([ z.lazy(() => EnumDayOfTheWeekFilterSchema),z.lazy(() => DayOfTheWeekSchema) ]).optional(),
  lastNotified: z.union([ z.lazy(() => DateTimeFilterSchema),z.coerce.date() ]).optional(),
  user: z.union([ z.lazy(() => UserRelationFilterSchema),z.lazy(() => UserWhereInputSchema) ]).optional(),
  profile: z.union([ z.lazy(() => ProfileNullableRelationFilterSchema),z.lazy(() => ProfileWhereInputSchema) ]).optional().nullable(),
}).strict());

export const TargetOrderByWithAggregationInputSchema: z.ZodType<Prisma.TargetOrderByWithAggregationInput> = z.object({
  id: z.lazy(() => SortOrderSchema).optional(),
  userId: z.lazy(() => SortOrderSchema).optional(),
  profileId: z.union([ z.lazy(() => SortOrderSchema),z.lazy(() => SortOrderInputSchema) ]).optional(),
  type: z.lazy(() => SortOrderSchema).optional(),
  goal: z.lazy(() => SortOrderSchema).optional(),
  lastFailedAt: z.lazy(() => SortOrderSchema).optional(),
  notifyOn: z.lazy(() => SortOrderSchema).optional(),
  lastNotified: z.lazy(() => SortOrderSchema).optional(),
  _count: z.lazy(() => TargetCountOrderByAggregateInputSchema).optional(),
  _avg: z.lazy(() => TargetAvgOrderByAggregateInputSchema).optional(),
  _max: z.lazy(() => TargetMaxOrderByAggregateInputSchema).optional(),
  _min: z.lazy(() => TargetMinOrderByAggregateInputSchema).optional(),
  _sum: z.lazy(() => TargetSumOrderByAggregateInputSchema).optional()
}).strict();

export const TargetScalarWhereWithAggregatesInputSchema: z.ZodType<Prisma.TargetScalarWhereWithAggregatesInput> = z.object({
  AND: z.union([ z.lazy(() => TargetScalarWhereWithAggregatesInputSchema),z.lazy(() => TargetScalarWhereWithAggregatesInputSchema).array() ]).optional(),
  OR: z.lazy(() => TargetScalarWhereWithAggregatesInputSchema).array().optional(),
  NOT: z.union([ z.lazy(() => TargetScalarWhereWithAggregatesInputSchema),z.lazy(() => TargetScalarWhereWithAggregatesInputSchema).array() ]).optional(),
  id: z.union([ z.lazy(() => IntWithAggregatesFilterSchema),z.number() ]).optional(),
  userId: z.union([ z.lazy(() => StringWithAggregatesFilterSchema),z.string() ]).optional(),
  profileId: z.union([ z.lazy(() => IntNullableWithAggregatesFilterSchema),z.number() ]).optional().nullable(),
  type: z.union([ z.lazy(() => EnumTargetTypeWithAggregatesFilterSchema),z.lazy(() => TargetTypeSchema) ]).optional(),
  goal: z.union([ z.lazy(() => IntWithAggregatesFilterSchema),z.number() ]).optional(),
  lastFailedAt: z.union([ z.lazy(() => DateTimeWithAggregatesFilterSchema),z.coerce.date() ]).optional(),
  notifyOn: z.union([ z.lazy(() => EnumDayOfTheWeekWithAggregatesFilterSchema),z.lazy(() => DayOfTheWeekSchema) ]).optional(),
  lastNotified: z.union([ z.lazy(() => DateTimeWithAggregatesFilterSchema),z.coerce.date() ]).optional(),
}).strict();

export const AccountWhereInputSchema: z.ZodType<Prisma.AccountWhereInput> = z.object({
  AND: z.union([ z.lazy(() => AccountWhereInputSchema),z.lazy(() => AccountWhereInputSchema).array() ]).optional(),
  OR: z.lazy(() => AccountWhereInputSchema).array().optional(),
  NOT: z.union([ z.lazy(() => AccountWhereInputSchema),z.lazy(() => AccountWhereInputSchema).array() ]).optional(),
  id: z.union([ z.lazy(() => StringFilterSchema),z.string() ]).optional(),
  userId: z.union([ z.lazy(() => StringFilterSchema),z.string() ]).optional(),
  type: z.union([ z.lazy(() => StringFilterSchema),z.string() ]).optional(),
  provider: z.union([ z.lazy(() => StringFilterSchema),z.string() ]).optional(),
  providerAccountId: z.union([ z.lazy(() => StringFilterSchema),z.string() ]).optional(),
  refresh_token: z.union([ z.lazy(() => StringNullableFilterSchema),z.string() ]).optional().nullable(),
  access_token: z.union([ z.lazy(() => StringNullableFilterSchema),z.string() ]).optional().nullable(),
  expires_at: z.union([ z.lazy(() => IntNullableFilterSchema),z.number() ]).optional().nullable(),
  token_type: z.union([ z.lazy(() => StringNullableFilterSchema),z.string() ]).optional().nullable(),
  scope: z.union([ z.lazy(() => StringNullableFilterSchema),z.string() ]).optional().nullable(),
  id_token: z.union([ z.lazy(() => StringNullableFilterSchema),z.string() ]).optional().nullable(),
  session_state: z.union([ z.lazy(() => StringNullableFilterSchema),z.string() ]).optional().nullable(),
  user: z.union([ z.lazy(() => UserRelationFilterSchema),z.lazy(() => UserWhereInputSchema) ]).optional(),
}).strict();

export const AccountOrderByWithRelationInputSchema: z.ZodType<Prisma.AccountOrderByWithRelationInput> = z.object({
  id: z.lazy(() => SortOrderSchema).optional(),
  userId: z.lazy(() => SortOrderSchema).optional(),
  type: z.lazy(() => SortOrderSchema).optional(),
  provider: z.lazy(() => SortOrderSchema).optional(),
  providerAccountId: z.lazy(() => SortOrderSchema).optional(),
  refresh_token: z.union([ z.lazy(() => SortOrderSchema),z.lazy(() => SortOrderInputSchema) ]).optional(),
  access_token: z.union([ z.lazy(() => SortOrderSchema),z.lazy(() => SortOrderInputSchema) ]).optional(),
  expires_at: z.union([ z.lazy(() => SortOrderSchema),z.lazy(() => SortOrderInputSchema) ]).optional(),
  token_type: z.union([ z.lazy(() => SortOrderSchema),z.lazy(() => SortOrderInputSchema) ]).optional(),
  scope: z.union([ z.lazy(() => SortOrderSchema),z.lazy(() => SortOrderInputSchema) ]).optional(),
  id_token: z.union([ z.lazy(() => SortOrderSchema),z.lazy(() => SortOrderInputSchema) ]).optional(),
  session_state: z.union([ z.lazy(() => SortOrderSchema),z.lazy(() => SortOrderInputSchema) ]).optional(),
  user: z.lazy(() => UserOrderByWithRelationInputSchema).optional(),
  _relevance: z.lazy(() => AccountOrderByRelevanceInputSchema).optional()
}).strict();

export const AccountWhereUniqueInputSchema: z.ZodType<Prisma.AccountWhereUniqueInput> = z.union([
  z.object({
    id: z.string().cuid(),
    provider_providerAccountId: z.lazy(() => AccountProviderProviderAccountIdCompoundUniqueInputSchema)
  }),
  z.object({
    id: z.string().cuid(),
  }),
  z.object({
    provider_providerAccountId: z.lazy(() => AccountProviderProviderAccountIdCompoundUniqueInputSchema),
  }),
])
.and(z.object({
  id: z.string().cuid().optional(),
  provider_providerAccountId: z.lazy(() => AccountProviderProviderAccountIdCompoundUniqueInputSchema).optional(),
  AND: z.union([ z.lazy(() => AccountWhereInputSchema),z.lazy(() => AccountWhereInputSchema).array() ]).optional(),
  OR: z.lazy(() => AccountWhereInputSchema).array().optional(),
  NOT: z.union([ z.lazy(() => AccountWhereInputSchema),z.lazy(() => AccountWhereInputSchema).array() ]).optional(),
  userId: z.union([ z.lazy(() => StringFilterSchema),z.string() ]).optional(),
  type: z.union([ z.lazy(() => StringFilterSchema),z.string() ]).optional(),
  provider: z.union([ z.lazy(() => StringFilterSchema),z.string() ]).optional(),
  providerAccountId: z.union([ z.lazy(() => StringFilterSchema),z.string() ]).optional(),
  refresh_token: z.union([ z.lazy(() => StringNullableFilterSchema),z.string() ]).optional().nullable(),
  access_token: z.union([ z.lazy(() => StringNullableFilterSchema),z.string() ]).optional().nullable(),
  expires_at: z.union([ z.lazy(() => IntNullableFilterSchema),z.number().int() ]).optional().nullable(),
  token_type: z.union([ z.lazy(() => StringNullableFilterSchema),z.string() ]).optional().nullable(),
  scope: z.union([ z.lazy(() => StringNullableFilterSchema),z.string() ]).optional().nullable(),
  id_token: z.union([ z.lazy(() => StringNullableFilterSchema),z.string() ]).optional().nullable(),
  session_state: z.union([ z.lazy(() => StringNullableFilterSchema),z.string() ]).optional().nullable(),
  user: z.union([ z.lazy(() => UserRelationFilterSchema),z.lazy(() => UserWhereInputSchema) ]).optional(),
}).strict());

export const AccountOrderByWithAggregationInputSchema: z.ZodType<Prisma.AccountOrderByWithAggregationInput> = z.object({
  id: z.lazy(() => SortOrderSchema).optional(),
  userId: z.lazy(() => SortOrderSchema).optional(),
  type: z.lazy(() => SortOrderSchema).optional(),
  provider: z.lazy(() => SortOrderSchema).optional(),
  providerAccountId: z.lazy(() => SortOrderSchema).optional(),
  refresh_token: z.union([ z.lazy(() => SortOrderSchema),z.lazy(() => SortOrderInputSchema) ]).optional(),
  access_token: z.union([ z.lazy(() => SortOrderSchema),z.lazy(() => SortOrderInputSchema) ]).optional(),
  expires_at: z.union([ z.lazy(() => SortOrderSchema),z.lazy(() => SortOrderInputSchema) ]).optional(),
  token_type: z.union([ z.lazy(() => SortOrderSchema),z.lazy(() => SortOrderInputSchema) ]).optional(),
  scope: z.union([ z.lazy(() => SortOrderSchema),z.lazy(() => SortOrderInputSchema) ]).optional(),
  id_token: z.union([ z.lazy(() => SortOrderSchema),z.lazy(() => SortOrderInputSchema) ]).optional(),
  session_state: z.union([ z.lazy(() => SortOrderSchema),z.lazy(() => SortOrderInputSchema) ]).optional(),
  _count: z.lazy(() => AccountCountOrderByAggregateInputSchema).optional(),
  _avg: z.lazy(() => AccountAvgOrderByAggregateInputSchema).optional(),
  _max: z.lazy(() => AccountMaxOrderByAggregateInputSchema).optional(),
  _min: z.lazy(() => AccountMinOrderByAggregateInputSchema).optional(),
  _sum: z.lazy(() => AccountSumOrderByAggregateInputSchema).optional()
}).strict();

export const AccountScalarWhereWithAggregatesInputSchema: z.ZodType<Prisma.AccountScalarWhereWithAggregatesInput> = z.object({
  AND: z.union([ z.lazy(() => AccountScalarWhereWithAggregatesInputSchema),z.lazy(() => AccountScalarWhereWithAggregatesInputSchema).array() ]).optional(),
  OR: z.lazy(() => AccountScalarWhereWithAggregatesInputSchema).array().optional(),
  NOT: z.union([ z.lazy(() => AccountScalarWhereWithAggregatesInputSchema),z.lazy(() => AccountScalarWhereWithAggregatesInputSchema).array() ]).optional(),
  id: z.union([ z.lazy(() => StringWithAggregatesFilterSchema),z.string() ]).optional(),
  userId: z.union([ z.lazy(() => StringWithAggregatesFilterSchema),z.string() ]).optional(),
  type: z.union([ z.lazy(() => StringWithAggregatesFilterSchema),z.string() ]).optional(),
  provider: z.union([ z.lazy(() => StringWithAggregatesFilterSchema),z.string() ]).optional(),
  providerAccountId: z.union([ z.lazy(() => StringWithAggregatesFilterSchema),z.string() ]).optional(),
  refresh_token: z.union([ z.lazy(() => StringNullableWithAggregatesFilterSchema),z.string() ]).optional().nullable(),
  access_token: z.union([ z.lazy(() => StringNullableWithAggregatesFilterSchema),z.string() ]).optional().nullable(),
  expires_at: z.union([ z.lazy(() => IntNullableWithAggregatesFilterSchema),z.number() ]).optional().nullable(),
  token_type: z.union([ z.lazy(() => StringNullableWithAggregatesFilterSchema),z.string() ]).optional().nullable(),
  scope: z.union([ z.lazy(() => StringNullableWithAggregatesFilterSchema),z.string() ]).optional().nullable(),
  id_token: z.union([ z.lazy(() => StringNullableWithAggregatesFilterSchema),z.string() ]).optional().nullable(),
  session_state: z.union([ z.lazy(() => StringNullableWithAggregatesFilterSchema),z.string() ]).optional().nullable(),
}).strict();

export const CommentWhereInputSchema: z.ZodType<Prisma.CommentWhereInput> = z.object({
  AND: z.union([ z.lazy(() => CommentWhereInputSchema),z.lazy(() => CommentWhereInputSchema).array() ]).optional(),
  OR: z.lazy(() => CommentWhereInputSchema).array().optional(),
  NOT: z.union([ z.lazy(() => CommentWhereInputSchema),z.lazy(() => CommentWhereInputSchema).array() ]).optional(),
  id: z.union([ z.lazy(() => IntFilterSchema),z.number() ]).optional(),
  createdAt: z.union([ z.lazy(() => DateTimeFilterSchema),z.coerce.date() ]).optional(),
  comment: z.union([ z.lazy(() => StringFilterSchema),z.string() ]).optional(),
  questionId: z.union([ z.lazy(() => StringFilterSchema),z.string() ]).optional(),
  userId: z.union([ z.lazy(() => StringFilterSchema),z.string() ]).optional(),
  question: z.union([ z.lazy(() => QuestionRelationFilterSchema),z.lazy(() => QuestionWhereInputSchema) ]).optional(),
  user: z.union([ z.lazy(() => UserRelationFilterSchema),z.lazy(() => UserWhereInputSchema) ]).optional(),
}).strict();

export const CommentOrderByWithRelationInputSchema: z.ZodType<Prisma.CommentOrderByWithRelationInput> = z.object({
  id: z.lazy(() => SortOrderSchema).optional(),
  createdAt: z.lazy(() => SortOrderSchema).optional(),
  comment: z.lazy(() => SortOrderSchema).optional(),
  questionId: z.lazy(() => SortOrderSchema).optional(),
  userId: z.lazy(() => SortOrderSchema).optional(),
  question: z.lazy(() => QuestionOrderByWithRelationInputSchema).optional(),
  user: z.lazy(() => UserOrderByWithRelationInputSchema).optional(),
  _relevance: z.lazy(() => CommentOrderByRelevanceInputSchema).optional()
}).strict();

export const CommentWhereUniqueInputSchema: z.ZodType<Prisma.CommentWhereUniqueInput> = z.object({
  id: z.number().int()
})
.and(z.object({
  id: z.number().int().optional(),
  AND: z.union([ z.lazy(() => CommentWhereInputSchema),z.lazy(() => CommentWhereInputSchema).array() ]).optional(),
  OR: z.lazy(() => CommentWhereInputSchema).array().optional(),
  NOT: z.union([ z.lazy(() => CommentWhereInputSchema),z.lazy(() => CommentWhereInputSchema).array() ]).optional(),
  createdAt: z.union([ z.lazy(() => DateTimeFilterSchema),z.coerce.date() ]).optional(),
  comment: z.union([ z.lazy(() => StringFilterSchema),z.string() ]).optional(),
  questionId: z.union([ z.lazy(() => StringFilterSchema),z.string() ]).optional(),
  userId: z.union([ z.lazy(() => StringFilterSchema),z.string() ]).optional(),
  question: z.union([ z.lazy(() => QuestionRelationFilterSchema),z.lazy(() => QuestionWhereInputSchema) ]).optional(),
  user: z.union([ z.lazy(() => UserRelationFilterSchema),z.lazy(() => UserWhereInputSchema) ]).optional(),
}).strict());

export const CommentOrderByWithAggregationInputSchema: z.ZodType<Prisma.CommentOrderByWithAggregationInput> = z.object({
  id: z.lazy(() => SortOrderSchema).optional(),
  createdAt: z.lazy(() => SortOrderSchema).optional(),
  comment: z.lazy(() => SortOrderSchema).optional(),
  questionId: z.lazy(() => SortOrderSchema).optional(),
  userId: z.lazy(() => SortOrderSchema).optional(),
  _count: z.lazy(() => CommentCountOrderByAggregateInputSchema).optional(),
  _avg: z.lazy(() => CommentAvgOrderByAggregateInputSchema).optional(),
  _max: z.lazy(() => CommentMaxOrderByAggregateInputSchema).optional(),
  _min: z.lazy(() => CommentMinOrderByAggregateInputSchema).optional(),
  _sum: z.lazy(() => CommentSumOrderByAggregateInputSchema).optional()
}).strict();

export const CommentScalarWhereWithAggregatesInputSchema: z.ZodType<Prisma.CommentScalarWhereWithAggregatesInput> = z.object({
  AND: z.union([ z.lazy(() => CommentScalarWhereWithAggregatesInputSchema),z.lazy(() => CommentScalarWhereWithAggregatesInputSchema).array() ]).optional(),
  OR: z.lazy(() => CommentScalarWhereWithAggregatesInputSchema).array().optional(),
  NOT: z.union([ z.lazy(() => CommentScalarWhereWithAggregatesInputSchema),z.lazy(() => CommentScalarWhereWithAggregatesInputSchema).array() ]).optional(),
  id: z.union([ z.lazy(() => IntWithAggregatesFilterSchema),z.number() ]).optional(),
  createdAt: z.union([ z.lazy(() => DateTimeWithAggregatesFilterSchema),z.coerce.date() ]).optional(),
  comment: z.union([ z.lazy(() => StringWithAggregatesFilterSchema),z.string() ]).optional(),
  questionId: z.union([ z.lazy(() => StringWithAggregatesFilterSchema),z.string() ]).optional(),
  userId: z.union([ z.lazy(() => StringWithAggregatesFilterSchema),z.string() ]).optional(),
}).strict();

export const UserListWhereInputSchema: z.ZodType<Prisma.UserListWhereInput> = z.object({
  AND: z.union([ z.lazy(() => UserListWhereInputSchema),z.lazy(() => UserListWhereInputSchema).array() ]).optional(),
  OR: z.lazy(() => UserListWhereInputSchema).array().optional(),
  NOT: z.union([ z.lazy(() => UserListWhereInputSchema),z.lazy(() => UserListWhereInputSchema).array() ]).optional(),
  id: z.union([ z.lazy(() => StringFilterSchema),z.string() ]).optional(),
  createdAt: z.union([ z.lazy(() => DateTimeFilterSchema),z.coerce.date() ]).optional(),
  inviteId: z.union([ z.lazy(() => StringNullableFilterSchema),z.string() ]).optional().nullable(),
  name: z.union([ z.lazy(() => StringFilterSchema),z.string() ]).optional(),
  emailDomains: z.lazy(() => StringNullableListFilterSchema).optional(),
  syncToSlackTeamId: z.union([ z.lazy(() => StringNullableFilterSchema),z.string() ]).optional().nullable(),
  syncToSlackChannelId: z.union([ z.lazy(() => StringNullableFilterSchema),z.string() ]).optional().nullable(),
  authorId: z.union([ z.lazy(() => StringFilterSchema),z.string() ]).optional(),
  author: z.union([ z.lazy(() => UserRelationFilterSchema),z.lazy(() => UserWhereInputSchema) ]).optional(),
  users: z.lazy(() => UserListRelationFilterSchema).optional(),
  questions: z.lazy(() => QuestionListRelationFilterSchema).optional(),
  tournaments: z.lazy(() => TournamentListRelationFilterSchema).optional()
}).strict();

export const UserListOrderByWithRelationInputSchema: z.ZodType<Prisma.UserListOrderByWithRelationInput> = z.object({
  id: z.lazy(() => SortOrderSchema).optional(),
  createdAt: z.lazy(() => SortOrderSchema).optional(),
  inviteId: z.union([ z.lazy(() => SortOrderSchema),z.lazy(() => SortOrderInputSchema) ]).optional(),
  name: z.lazy(() => SortOrderSchema).optional(),
  emailDomains: z.lazy(() => SortOrderSchema).optional(),
  syncToSlackTeamId: z.union([ z.lazy(() => SortOrderSchema),z.lazy(() => SortOrderInputSchema) ]).optional(),
  syncToSlackChannelId: z.union([ z.lazy(() => SortOrderSchema),z.lazy(() => SortOrderInputSchema) ]).optional(),
  authorId: z.lazy(() => SortOrderSchema).optional(),
  author: z.lazy(() => UserOrderByWithRelationInputSchema).optional(),
  users: z.lazy(() => UserOrderByRelationAggregateInputSchema).optional(),
  questions: z.lazy(() => QuestionOrderByRelationAggregateInputSchema).optional(),
  tournaments: z.lazy(() => TournamentOrderByRelationAggregateInputSchema).optional(),
  _relevance: z.lazy(() => UserListOrderByRelevanceInputSchema).optional()
}).strict();

export const UserListWhereUniqueInputSchema: z.ZodType<Prisma.UserListWhereUniqueInput> = z.union([
  z.object({
    id: z.string().cuid(),
    inviteId: z.string().cuid()
  }),
  z.object({
    id: z.string().cuid(),
  }),
  z.object({
    inviteId: z.string().cuid(),
  }),
])
.and(z.object({
  id: z.string().cuid().optional(),
  inviteId: z.string().cuid().optional(),
  AND: z.union([ z.lazy(() => UserListWhereInputSchema),z.lazy(() => UserListWhereInputSchema).array() ]).optional(),
  OR: z.lazy(() => UserListWhereInputSchema).array().optional(),
  NOT: z.union([ z.lazy(() => UserListWhereInputSchema),z.lazy(() => UserListWhereInputSchema).array() ]).optional(),
  createdAt: z.union([ z.lazy(() => DateTimeFilterSchema),z.coerce.date() ]).optional(),
  name: z.union([ z.lazy(() => StringFilterSchema),z.string() ]).optional(),
  emailDomains: z.lazy(() => StringNullableListFilterSchema).optional(),
  syncToSlackTeamId: z.union([ z.lazy(() => StringNullableFilterSchema),z.string() ]).optional().nullable(),
  syncToSlackChannelId: z.union([ z.lazy(() => StringNullableFilterSchema),z.string() ]).optional().nullable(),
  authorId: z.union([ z.lazy(() => StringFilterSchema),z.string() ]).optional(),
  author: z.union([ z.lazy(() => UserRelationFilterSchema),z.lazy(() => UserWhereInputSchema) ]).optional(),
  users: z.lazy(() => UserListRelationFilterSchema).optional(),
  questions: z.lazy(() => QuestionListRelationFilterSchema).optional(),
  tournaments: z.lazy(() => TournamentListRelationFilterSchema).optional()
}).strict());

export const UserListOrderByWithAggregationInputSchema: z.ZodType<Prisma.UserListOrderByWithAggregationInput> = z.object({
  id: z.lazy(() => SortOrderSchema).optional(),
  createdAt: z.lazy(() => SortOrderSchema).optional(),
  inviteId: z.union([ z.lazy(() => SortOrderSchema),z.lazy(() => SortOrderInputSchema) ]).optional(),
  name: z.lazy(() => SortOrderSchema).optional(),
  emailDomains: z.lazy(() => SortOrderSchema).optional(),
  syncToSlackTeamId: z.union([ z.lazy(() => SortOrderSchema),z.lazy(() => SortOrderInputSchema) ]).optional(),
  syncToSlackChannelId: z.union([ z.lazy(() => SortOrderSchema),z.lazy(() => SortOrderInputSchema) ]).optional(),
  authorId: z.lazy(() => SortOrderSchema).optional(),
  _count: z.lazy(() => UserListCountOrderByAggregateInputSchema).optional(),
  _max: z.lazy(() => UserListMaxOrderByAggregateInputSchema).optional(),
  _min: z.lazy(() => UserListMinOrderByAggregateInputSchema).optional()
}).strict();

export const UserListScalarWhereWithAggregatesInputSchema: z.ZodType<Prisma.UserListScalarWhereWithAggregatesInput> = z.object({
  AND: z.union([ z.lazy(() => UserListScalarWhereWithAggregatesInputSchema),z.lazy(() => UserListScalarWhereWithAggregatesInputSchema).array() ]).optional(),
  OR: z.lazy(() => UserListScalarWhereWithAggregatesInputSchema).array().optional(),
  NOT: z.union([ z.lazy(() => UserListScalarWhereWithAggregatesInputSchema),z.lazy(() => UserListScalarWhereWithAggregatesInputSchema).array() ]).optional(),
  id: z.union([ z.lazy(() => StringWithAggregatesFilterSchema),z.string() ]).optional(),
  createdAt: z.union([ z.lazy(() => DateTimeWithAggregatesFilterSchema),z.coerce.date() ]).optional(),
  inviteId: z.union([ z.lazy(() => StringNullableWithAggregatesFilterSchema),z.string() ]).optional().nullable(),
  name: z.union([ z.lazy(() => StringWithAggregatesFilterSchema),z.string() ]).optional(),
  emailDomains: z.lazy(() => StringNullableListFilterSchema).optional(),
  syncToSlackTeamId: z.union([ z.lazy(() => StringNullableWithAggregatesFilterSchema),z.string() ]).optional().nullable(),
  syncToSlackChannelId: z.union([ z.lazy(() => StringNullableWithAggregatesFilterSchema),z.string() ]).optional().nullable(),
  authorId: z.union([ z.lazy(() => StringWithAggregatesFilterSchema),z.string() ]).optional(),
}).strict();

export const TournamentWhereInputSchema: z.ZodType<Prisma.TournamentWhereInput> = z.object({
  AND: z.union([ z.lazy(() => TournamentWhereInputSchema),z.lazy(() => TournamentWhereInputSchema).array() ]).optional(),
  OR: z.lazy(() => TournamentWhereInputSchema).array().optional(),
  NOT: z.union([ z.lazy(() => TournamentWhereInputSchema),z.lazy(() => TournamentWhereInputSchema).array() ]).optional(),
  id: z.union([ z.lazy(() => StringFilterSchema),z.string() ]).optional(),
  createdAt: z.union([ z.lazy(() => DateTimeFilterSchema),z.coerce.date() ]).optional(),
  name: z.union([ z.lazy(() => StringFilterSchema),z.string() ]).optional(),
  description: z.union([ z.lazy(() => StringNullableFilterSchema),z.string() ]).optional().nullable(),
  authorId: z.union([ z.lazy(() => StringFilterSchema),z.string() ]).optional(),
  sharedPublicly: z.union([ z.lazy(() => BoolFilterSchema),z.boolean() ]).optional(),
  unlisted: z.union([ z.lazy(() => BoolFilterSchema),z.boolean() ]).optional(),
  userListId: z.union([ z.lazy(() => StringNullableFilterSchema),z.string() ]).optional().nullable(),
  anyoneInListCanEdit: z.union([ z.lazy(() => BoolFilterSchema),z.boolean() ]).optional(),
  showLeaderboard: z.union([ z.lazy(() => BoolFilterSchema),z.boolean() ]).optional(),
  predictYourYear: z.union([ z.lazy(() => IntNullableFilterSchema),z.number() ]).optional().nullable(),
  syncToSlackTeamId: z.union([ z.lazy(() => StringNullableFilterSchema),z.string() ]).optional().nullable(),
  syncToSlackChannelId: z.union([ z.lazy(() => StringNullableFilterSchema),z.string() ]).optional().nullable(),
  questions: z.lazy(() => QuestionListRelationFilterSchema).optional(),
  author: z.union([ z.lazy(() => UserRelationFilterSchema),z.lazy(() => UserWhereInputSchema) ]).optional(),
  userList: z.union([ z.lazy(() => UserListNullableRelationFilterSchema),z.lazy(() => UserListWhereInputSchema) ]).optional().nullable(),
}).strict();

export const TournamentOrderByWithRelationInputSchema: z.ZodType<Prisma.TournamentOrderByWithRelationInput> = z.object({
  id: z.lazy(() => SortOrderSchema).optional(),
  createdAt: z.lazy(() => SortOrderSchema).optional(),
  name: z.lazy(() => SortOrderSchema).optional(),
  description: z.union([ z.lazy(() => SortOrderSchema),z.lazy(() => SortOrderInputSchema) ]).optional(),
  authorId: z.lazy(() => SortOrderSchema).optional(),
  sharedPublicly: z.lazy(() => SortOrderSchema).optional(),
  unlisted: z.lazy(() => SortOrderSchema).optional(),
  userListId: z.union([ z.lazy(() => SortOrderSchema),z.lazy(() => SortOrderInputSchema) ]).optional(),
  anyoneInListCanEdit: z.lazy(() => SortOrderSchema).optional(),
  showLeaderboard: z.lazy(() => SortOrderSchema).optional(),
  predictYourYear: z.union([ z.lazy(() => SortOrderSchema),z.lazy(() => SortOrderInputSchema) ]).optional(),
  syncToSlackTeamId: z.union([ z.lazy(() => SortOrderSchema),z.lazy(() => SortOrderInputSchema) ]).optional(),
  syncToSlackChannelId: z.union([ z.lazy(() => SortOrderSchema),z.lazy(() => SortOrderInputSchema) ]).optional(),
  questions: z.lazy(() => QuestionOrderByRelationAggregateInputSchema).optional(),
  author: z.lazy(() => UserOrderByWithRelationInputSchema).optional(),
  userList: z.lazy(() => UserListOrderByWithRelationInputSchema).optional(),
  _relevance: z.lazy(() => TournamentOrderByRelevanceInputSchema).optional()
}).strict();

export const TournamentWhereUniqueInputSchema: z.ZodType<Prisma.TournamentWhereUniqueInput> = z.object({
  id: z.string().cuid()
})
.and(z.object({
  id: z.string().cuid().optional(),
  AND: z.union([ z.lazy(() => TournamentWhereInputSchema),z.lazy(() => TournamentWhereInputSchema).array() ]).optional(),
  OR: z.lazy(() => TournamentWhereInputSchema).array().optional(),
  NOT: z.union([ z.lazy(() => TournamentWhereInputSchema),z.lazy(() => TournamentWhereInputSchema).array() ]).optional(),
  createdAt: z.union([ z.lazy(() => DateTimeFilterSchema),z.coerce.date() ]).optional(),
  name: z.union([ z.lazy(() => StringFilterSchema),z.string() ]).optional(),
  description: z.union([ z.lazy(() => StringNullableFilterSchema),z.string() ]).optional().nullable(),
  authorId: z.union([ z.lazy(() => StringFilterSchema),z.string() ]).optional(),
  sharedPublicly: z.union([ z.lazy(() => BoolFilterSchema),z.boolean() ]).optional(),
  unlisted: z.union([ z.lazy(() => BoolFilterSchema),z.boolean() ]).optional(),
  userListId: z.union([ z.lazy(() => StringNullableFilterSchema),z.string() ]).optional().nullable(),
  anyoneInListCanEdit: z.union([ z.lazy(() => BoolFilterSchema),z.boolean() ]).optional(),
  showLeaderboard: z.union([ z.lazy(() => BoolFilterSchema),z.boolean() ]).optional(),
  predictYourYear: z.union([ z.lazy(() => IntNullableFilterSchema),z.number().int() ]).optional().nullable(),
  syncToSlackTeamId: z.union([ z.lazy(() => StringNullableFilterSchema),z.string() ]).optional().nullable(),
  syncToSlackChannelId: z.union([ z.lazy(() => StringNullableFilterSchema),z.string() ]).optional().nullable(),
  questions: z.lazy(() => QuestionListRelationFilterSchema).optional(),
  author: z.union([ z.lazy(() => UserRelationFilterSchema),z.lazy(() => UserWhereInputSchema) ]).optional(),
  userList: z.union([ z.lazy(() => UserListNullableRelationFilterSchema),z.lazy(() => UserListWhereInputSchema) ]).optional().nullable(),
}).strict());

export const TournamentOrderByWithAggregationInputSchema: z.ZodType<Prisma.TournamentOrderByWithAggregationInput> = z.object({
  id: z.lazy(() => SortOrderSchema).optional(),
  createdAt: z.lazy(() => SortOrderSchema).optional(),
  name: z.lazy(() => SortOrderSchema).optional(),
  description: z.union([ z.lazy(() => SortOrderSchema),z.lazy(() => SortOrderInputSchema) ]).optional(),
  authorId: z.lazy(() => SortOrderSchema).optional(),
  sharedPublicly: z.lazy(() => SortOrderSchema).optional(),
  unlisted: z.lazy(() => SortOrderSchema).optional(),
  userListId: z.union([ z.lazy(() => SortOrderSchema),z.lazy(() => SortOrderInputSchema) ]).optional(),
  anyoneInListCanEdit: z.lazy(() => SortOrderSchema).optional(),
  showLeaderboard: z.lazy(() => SortOrderSchema).optional(),
  predictYourYear: z.union([ z.lazy(() => SortOrderSchema),z.lazy(() => SortOrderInputSchema) ]).optional(),
  syncToSlackTeamId: z.union([ z.lazy(() => SortOrderSchema),z.lazy(() => SortOrderInputSchema) ]).optional(),
  syncToSlackChannelId: z.union([ z.lazy(() => SortOrderSchema),z.lazy(() => SortOrderInputSchema) ]).optional(),
  _count: z.lazy(() => TournamentCountOrderByAggregateInputSchema).optional(),
  _avg: z.lazy(() => TournamentAvgOrderByAggregateInputSchema).optional(),
  _max: z.lazy(() => TournamentMaxOrderByAggregateInputSchema).optional(),
  _min: z.lazy(() => TournamentMinOrderByAggregateInputSchema).optional(),
  _sum: z.lazy(() => TournamentSumOrderByAggregateInputSchema).optional()
}).strict();

export const TournamentScalarWhereWithAggregatesInputSchema: z.ZodType<Prisma.TournamentScalarWhereWithAggregatesInput> = z.object({
  AND: z.union([ z.lazy(() => TournamentScalarWhereWithAggregatesInputSchema),z.lazy(() => TournamentScalarWhereWithAggregatesInputSchema).array() ]).optional(),
  OR: z.lazy(() => TournamentScalarWhereWithAggregatesInputSchema).array().optional(),
  NOT: z.union([ z.lazy(() => TournamentScalarWhereWithAggregatesInputSchema),z.lazy(() => TournamentScalarWhereWithAggregatesInputSchema).array() ]).optional(),
  id: z.union([ z.lazy(() => StringWithAggregatesFilterSchema),z.string() ]).optional(),
  createdAt: z.union([ z.lazy(() => DateTimeWithAggregatesFilterSchema),z.coerce.date() ]).optional(),
  name: z.union([ z.lazy(() => StringWithAggregatesFilterSchema),z.string() ]).optional(),
  description: z.union([ z.lazy(() => StringNullableWithAggregatesFilterSchema),z.string() ]).optional().nullable(),
  authorId: z.union([ z.lazy(() => StringWithAggregatesFilterSchema),z.string() ]).optional(),
  sharedPublicly: z.union([ z.lazy(() => BoolWithAggregatesFilterSchema),z.boolean() ]).optional(),
  unlisted: z.union([ z.lazy(() => BoolWithAggregatesFilterSchema),z.boolean() ]).optional(),
  userListId: z.union([ z.lazy(() => StringNullableWithAggregatesFilterSchema),z.string() ]).optional().nullable(),
  anyoneInListCanEdit: z.union([ z.lazy(() => BoolWithAggregatesFilterSchema),z.boolean() ]).optional(),
  showLeaderboard: z.union([ z.lazy(() => BoolWithAggregatesFilterSchema),z.boolean() ]).optional(),
  predictYourYear: z.union([ z.lazy(() => IntNullableWithAggregatesFilterSchema),z.number() ]).optional().nullable(),
  syncToSlackTeamId: z.union([ z.lazy(() => StringNullableWithAggregatesFilterSchema),z.string() ]).optional().nullable(),
  syncToSlackChannelId: z.union([ z.lazy(() => StringNullableWithAggregatesFilterSchema),z.string() ]).optional().nullable(),
}).strict();

export const NotificationWhereInputSchema: z.ZodType<Prisma.NotificationWhereInput> = z.object({
  AND: z.union([ z.lazy(() => NotificationWhereInputSchema),z.lazy(() => NotificationWhereInputSchema).array() ]).optional(),
  OR: z.lazy(() => NotificationWhereInputSchema).array().optional(),
  NOT: z.union([ z.lazy(() => NotificationWhereInputSchema),z.lazy(() => NotificationWhereInputSchema).array() ]).optional(),
  id: z.union([ z.lazy(() => StringFilterSchema),z.string() ]).optional(),
  createdAt: z.union([ z.lazy(() => DateTimeFilterSchema),z.coerce.date() ]).optional(),
  emailSentAt: z.union([ z.lazy(() => DateTimeNullableFilterSchema),z.coerce.date() ]).optional().nullable(),
  title: z.union([ z.lazy(() => StringFilterSchema),z.string() ]).optional(),
  content: z.union([ z.lazy(() => StringFilterSchema),z.string() ]).optional(),
  url: z.union([ z.lazy(() => StringNullableFilterSchema),z.string() ]).optional().nullable(),
  tags: z.lazy(() => StringNullableListFilterSchema).optional(),
  read: z.union([ z.lazy(() => BoolFilterSchema),z.boolean() ]).optional(),
  userId: z.union([ z.lazy(() => StringFilterSchema),z.string() ]).optional(),
  questionId: z.union([ z.lazy(() => StringNullableFilterSchema),z.string() ]).optional().nullable(),
  user: z.union([ z.lazy(() => UserRelationFilterSchema),z.lazy(() => UserWhereInputSchema) ]).optional(),
  question: z.union([ z.lazy(() => QuestionNullableRelationFilterSchema),z.lazy(() => QuestionWhereInputSchema) ]).optional().nullable(),
}).strict();

export const NotificationOrderByWithRelationInputSchema: z.ZodType<Prisma.NotificationOrderByWithRelationInput> = z.object({
  id: z.lazy(() => SortOrderSchema).optional(),
  createdAt: z.lazy(() => SortOrderSchema).optional(),
  emailSentAt: z.union([ z.lazy(() => SortOrderSchema),z.lazy(() => SortOrderInputSchema) ]).optional(),
  title: z.lazy(() => SortOrderSchema).optional(),
  content: z.lazy(() => SortOrderSchema).optional(),
  url: z.union([ z.lazy(() => SortOrderSchema),z.lazy(() => SortOrderInputSchema) ]).optional(),
  tags: z.lazy(() => SortOrderSchema).optional(),
  read: z.lazy(() => SortOrderSchema).optional(),
  userId: z.lazy(() => SortOrderSchema).optional(),
  questionId: z.union([ z.lazy(() => SortOrderSchema),z.lazy(() => SortOrderInputSchema) ]).optional(),
  user: z.lazy(() => UserOrderByWithRelationInputSchema).optional(),
  question: z.lazy(() => QuestionOrderByWithRelationInputSchema).optional(),
  _relevance: z.lazy(() => NotificationOrderByRelevanceInputSchema).optional()
}).strict();

export const NotificationWhereUniqueInputSchema: z.ZodType<Prisma.NotificationWhereUniqueInput> = z.object({
  id: z.string().cuid()
})
.and(z.object({
  id: z.string().cuid().optional(),
  AND: z.union([ z.lazy(() => NotificationWhereInputSchema),z.lazy(() => NotificationWhereInputSchema).array() ]).optional(),
  OR: z.lazy(() => NotificationWhereInputSchema).array().optional(),
  NOT: z.union([ z.lazy(() => NotificationWhereInputSchema),z.lazy(() => NotificationWhereInputSchema).array() ]).optional(),
  createdAt: z.union([ z.lazy(() => DateTimeFilterSchema),z.coerce.date() ]).optional(),
  emailSentAt: z.union([ z.lazy(() => DateTimeNullableFilterSchema),z.coerce.date() ]).optional().nullable(),
  title: z.union([ z.lazy(() => StringFilterSchema),z.string() ]).optional(),
  content: z.union([ z.lazy(() => StringFilterSchema),z.string() ]).optional(),
  url: z.union([ z.lazy(() => StringNullableFilterSchema),z.string() ]).optional().nullable(),
  tags: z.lazy(() => StringNullableListFilterSchema).optional(),
  read: z.union([ z.lazy(() => BoolFilterSchema),z.boolean() ]).optional(),
  userId: z.union([ z.lazy(() => StringFilterSchema),z.string() ]).optional(),
  questionId: z.union([ z.lazy(() => StringNullableFilterSchema),z.string() ]).optional().nullable(),
  user: z.union([ z.lazy(() => UserRelationFilterSchema),z.lazy(() => UserWhereInputSchema) ]).optional(),
  question: z.union([ z.lazy(() => QuestionNullableRelationFilterSchema),z.lazy(() => QuestionWhereInputSchema) ]).optional().nullable(),
}).strict());

export const NotificationOrderByWithAggregationInputSchema: z.ZodType<Prisma.NotificationOrderByWithAggregationInput> = z.object({
  id: z.lazy(() => SortOrderSchema).optional(),
  createdAt: z.lazy(() => SortOrderSchema).optional(),
  emailSentAt: z.union([ z.lazy(() => SortOrderSchema),z.lazy(() => SortOrderInputSchema) ]).optional(),
  title: z.lazy(() => SortOrderSchema).optional(),
  content: z.lazy(() => SortOrderSchema).optional(),
  url: z.union([ z.lazy(() => SortOrderSchema),z.lazy(() => SortOrderInputSchema) ]).optional(),
  tags: z.lazy(() => SortOrderSchema).optional(),
  read: z.lazy(() => SortOrderSchema).optional(),
  userId: z.lazy(() => SortOrderSchema).optional(),
  questionId: z.union([ z.lazy(() => SortOrderSchema),z.lazy(() => SortOrderInputSchema) ]).optional(),
  _count: z.lazy(() => NotificationCountOrderByAggregateInputSchema).optional(),
  _max: z.lazy(() => NotificationMaxOrderByAggregateInputSchema).optional(),
  _min: z.lazy(() => NotificationMinOrderByAggregateInputSchema).optional()
}).strict();

export const NotificationScalarWhereWithAggregatesInputSchema: z.ZodType<Prisma.NotificationScalarWhereWithAggregatesInput> = z.object({
  AND: z.union([ z.lazy(() => NotificationScalarWhereWithAggregatesInputSchema),z.lazy(() => NotificationScalarWhereWithAggregatesInputSchema).array() ]).optional(),
  OR: z.lazy(() => NotificationScalarWhereWithAggregatesInputSchema).array().optional(),
  NOT: z.union([ z.lazy(() => NotificationScalarWhereWithAggregatesInputSchema),z.lazy(() => NotificationScalarWhereWithAggregatesInputSchema).array() ]).optional(),
  id: z.union([ z.lazy(() => StringWithAggregatesFilterSchema),z.string() ]).optional(),
  createdAt: z.union([ z.lazy(() => DateTimeWithAggregatesFilterSchema),z.coerce.date() ]).optional(),
  emailSentAt: z.union([ z.lazy(() => DateTimeNullableWithAggregatesFilterSchema),z.coerce.date() ]).optional().nullable(),
  title: z.union([ z.lazy(() => StringWithAggregatesFilterSchema),z.string() ]).optional(),
  content: z.union([ z.lazy(() => StringWithAggregatesFilterSchema),z.string() ]).optional(),
  url: z.union([ z.lazy(() => StringNullableWithAggregatesFilterSchema),z.string() ]).optional().nullable(),
  tags: z.lazy(() => StringNullableListFilterSchema).optional(),
  read: z.union([ z.lazy(() => BoolWithAggregatesFilterSchema),z.boolean() ]).optional(),
  userId: z.union([ z.lazy(() => StringWithAggregatesFilterSchema),z.string() ]).optional(),
  questionId: z.union([ z.lazy(() => StringNullableWithAggregatesFilterSchema),z.string() ]).optional().nullable(),
}).strict();

export const FeedbackWhereInputSchema: z.ZodType<Prisma.FeedbackWhereInput> = z.object({
  AND: z.union([ z.lazy(() => FeedbackWhereInputSchema),z.lazy(() => FeedbackWhereInputSchema).array() ]).optional(),
  OR: z.lazy(() => FeedbackWhereInputSchema).array().optional(),
  NOT: z.union([ z.lazy(() => FeedbackWhereInputSchema),z.lazy(() => FeedbackWhereInputSchema).array() ]).optional(),
  id: z.union([ z.lazy(() => StringFilterSchema),z.string() ]).optional(),
  createdAt: z.union([ z.lazy(() => DateTimeFilterSchema),z.coerce.date() ]).optional(),
  type: z.union([ z.lazy(() => StringFilterSchema),z.string() ]).optional(),
  message: z.union([ z.lazy(() => StringFilterSchema),z.string() ]).optional(),
  email: z.union([ z.lazy(() => StringNullableFilterSchema),z.string() ]).optional().nullable(),
  userId: z.union([ z.lazy(() => StringNullableFilterSchema),z.string() ]).optional().nullable(),
}).strict();

export const FeedbackOrderByWithRelationInputSchema: z.ZodType<Prisma.FeedbackOrderByWithRelationInput> = z.object({
  id: z.lazy(() => SortOrderSchema).optional(),
  createdAt: z.lazy(() => SortOrderSchema).optional(),
  type: z.lazy(() => SortOrderSchema).optional(),
  message: z.lazy(() => SortOrderSchema).optional(),
  email: z.union([ z.lazy(() => SortOrderSchema),z.lazy(() => SortOrderInputSchema) ]).optional(),
  userId: z.union([ z.lazy(() => SortOrderSchema),z.lazy(() => SortOrderInputSchema) ]).optional(),
  _relevance: z.lazy(() => FeedbackOrderByRelevanceInputSchema).optional()
}).strict();

export const FeedbackWhereUniqueInputSchema: z.ZodType<Prisma.FeedbackWhereUniqueInput> = z.object({
  id: z.string().cuid()
})
.and(z.object({
  id: z.string().cuid().optional(),
  AND: z.union([ z.lazy(() => FeedbackWhereInputSchema),z.lazy(() => FeedbackWhereInputSchema).array() ]).optional(),
  OR: z.lazy(() => FeedbackWhereInputSchema).array().optional(),
  NOT: z.union([ z.lazy(() => FeedbackWhereInputSchema),z.lazy(() => FeedbackWhereInputSchema).array() ]).optional(),
  createdAt: z.union([ z.lazy(() => DateTimeFilterSchema),z.coerce.date() ]).optional(),
  type: z.union([ z.lazy(() => StringFilterSchema),z.string() ]).optional(),
  message: z.union([ z.lazy(() => StringFilterSchema),z.string() ]).optional(),
  email: z.union([ z.lazy(() => StringNullableFilterSchema),z.string() ]).optional().nullable(),
  userId: z.union([ z.lazy(() => StringNullableFilterSchema),z.string() ]).optional().nullable(),
}).strict());

export const FeedbackOrderByWithAggregationInputSchema: z.ZodType<Prisma.FeedbackOrderByWithAggregationInput> = z.object({
  id: z.lazy(() => SortOrderSchema).optional(),
  createdAt: z.lazy(() => SortOrderSchema).optional(),
  type: z.lazy(() => SortOrderSchema).optional(),
  message: z.lazy(() => SortOrderSchema).optional(),
  email: z.union([ z.lazy(() => SortOrderSchema),z.lazy(() => SortOrderInputSchema) ]).optional(),
  userId: z.union([ z.lazy(() => SortOrderSchema),z.lazy(() => SortOrderInputSchema) ]).optional(),
  _count: z.lazy(() => FeedbackCountOrderByAggregateInputSchema).optional(),
  _max: z.lazy(() => FeedbackMaxOrderByAggregateInputSchema).optional(),
  _min: z.lazy(() => FeedbackMinOrderByAggregateInputSchema).optional()
}).strict();

export const FeedbackScalarWhereWithAggregatesInputSchema: z.ZodType<Prisma.FeedbackScalarWhereWithAggregatesInput> = z.object({
  AND: z.union([ z.lazy(() => FeedbackScalarWhereWithAggregatesInputSchema),z.lazy(() => FeedbackScalarWhereWithAggregatesInputSchema).array() ]).optional(),
  OR: z.lazy(() => FeedbackScalarWhereWithAggregatesInputSchema).array().optional(),
  NOT: z.union([ z.lazy(() => FeedbackScalarWhereWithAggregatesInputSchema),z.lazy(() => FeedbackScalarWhereWithAggregatesInputSchema).array() ]).optional(),
  id: z.union([ z.lazy(() => StringWithAggregatesFilterSchema),z.string() ]).optional(),
  createdAt: z.union([ z.lazy(() => DateTimeWithAggregatesFilterSchema),z.coerce.date() ]).optional(),
  type: z.union([ z.lazy(() => StringWithAggregatesFilterSchema),z.string() ]).optional(),
  message: z.union([ z.lazy(() => StringWithAggregatesFilterSchema),z.string() ]).optional(),
  email: z.union([ z.lazy(() => StringNullableWithAggregatesFilterSchema),z.string() ]).optional().nullable(),
  userId: z.union([ z.lazy(() => StringNullableWithAggregatesFilterSchema),z.string() ]).optional().nullable(),
}).strict();

export const WorkspaceCreateInputSchema: z.ZodType<Prisma.WorkspaceCreateInput> = z.object({
  teamId: z.string(),
  teamName: z.string(),
  token: z.string(),
  createdAt: z.coerce.date().optional()
}).strict();

export const WorkspaceUncheckedCreateInputSchema: z.ZodType<Prisma.WorkspaceUncheckedCreateInput> = z.object({
  teamId: z.string(),
  teamName: z.string(),
  token: z.string(),
  createdAt: z.coerce.date().optional()
}).strict();

export const WorkspaceUpdateInputSchema: z.ZodType<Prisma.WorkspaceUpdateInput> = z.object({
  teamId: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  teamName: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  token: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  createdAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
}).strict();

export const WorkspaceUncheckedUpdateInputSchema: z.ZodType<Prisma.WorkspaceUncheckedUpdateInput> = z.object({
  teamId: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  teamName: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  token: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  createdAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
}).strict();

export const WorkspaceCreateManyInputSchema: z.ZodType<Prisma.WorkspaceCreateManyInput> = z.object({
  teamId: z.string(),
  teamName: z.string(),
  token: z.string(),
  createdAt: z.coerce.date().optional()
}).strict();

export const WorkspaceUpdateManyMutationInputSchema: z.ZodType<Prisma.WorkspaceUpdateManyMutationInput> = z.object({
  teamId: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  teamName: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  token: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  createdAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
}).strict();

export const WorkspaceUncheckedUpdateManyInputSchema: z.ZodType<Prisma.WorkspaceUncheckedUpdateManyInput> = z.object({
  teamId: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  teamName: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  token: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  createdAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
}).strict();

export const ForecastCreateInputSchema: z.ZodType<Prisma.ForecastCreateInput> = z.object({
  createdAt: z.coerce.date().optional(),
  comment: z.string().optional().nullable(),
  forecast: z.union([z.number(),z.string(),z.instanceof(Decimal),z.instanceof(Prisma.Decimal),DecimalJsLikeSchema,]).refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' }),
  option: z.lazy(() => QuestionOptionCreateNestedOneWithoutForecastsInputSchema).optional(),
  profile: z.lazy(() => ProfileCreateNestedOneWithoutForecastsInputSchema).optional(),
  question: z.lazy(() => QuestionCreateNestedOneWithoutForecastsInputSchema),
  user: z.lazy(() => UserCreateNestedOneWithoutForecastsInputSchema)
}).strict();

export const ForecastUncheckedCreateInputSchema: z.ZodType<Prisma.ForecastUncheckedCreateInput> = z.object({
  id: z.number().int().optional(),
  createdAt: z.coerce.date().optional(),
  comment: z.string().optional().nullable(),
  forecast: z.union([z.number(),z.string(),z.instanceof(Decimal),z.instanceof(Prisma.Decimal),DecimalJsLikeSchema,]).refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' }),
  profileId: z.number().int().optional().nullable(),
  questionId: z.string(),
  optionId: z.string().optional().nullable(),
  userId: z.string()
}).strict();

export const ForecastUpdateInputSchema: z.ZodType<Prisma.ForecastUpdateInput> = z.object({
  createdAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  comment: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  forecast: z.union([ z.union([z.number(),z.string(),z.instanceof(Decimal),z.instanceof(Prisma.Decimal),DecimalJsLikeSchema,]).refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' }),z.lazy(() => DecimalFieldUpdateOperationsInputSchema) ]).optional(),
  option: z.lazy(() => QuestionOptionUpdateOneWithoutForecastsNestedInputSchema).optional(),
  profile: z.lazy(() => ProfileUpdateOneWithoutForecastsNestedInputSchema).optional(),
  question: z.lazy(() => QuestionUpdateOneRequiredWithoutForecastsNestedInputSchema).optional(),
  user: z.lazy(() => UserUpdateOneRequiredWithoutForecastsNestedInputSchema).optional()
}).strict();

export const ForecastUncheckedUpdateInputSchema: z.ZodType<Prisma.ForecastUncheckedUpdateInput> = z.object({
  id: z.union([ z.number().int(),z.lazy(() => IntFieldUpdateOperationsInputSchema) ]).optional(),
  createdAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  comment: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  forecast: z.union([ z.union([z.number(),z.string(),z.instanceof(Decimal),z.instanceof(Prisma.Decimal),DecimalJsLikeSchema,]).refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' }),z.lazy(() => DecimalFieldUpdateOperationsInputSchema) ]).optional(),
  profileId: z.union([ z.number().int(),z.lazy(() => NullableIntFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  questionId: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  optionId: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  userId: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
}).strict();

export const ForecastCreateManyInputSchema: z.ZodType<Prisma.ForecastCreateManyInput> = z.object({
  id: z.number().int().optional(),
  createdAt: z.coerce.date().optional(),
  comment: z.string().optional().nullable(),
  forecast: z.union([z.number(),z.string(),z.instanceof(Decimal),z.instanceof(Prisma.Decimal),DecimalJsLikeSchema,]).refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' }),
  profileId: z.number().int().optional().nullable(),
  questionId: z.string(),
  optionId: z.string().optional().nullable(),
  userId: z.string()
}).strict();

export const ForecastUpdateManyMutationInputSchema: z.ZodType<Prisma.ForecastUpdateManyMutationInput> = z.object({
  createdAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  comment: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  forecast: z.union([ z.union([z.number(),z.string(),z.instanceof(Decimal),z.instanceof(Prisma.Decimal),DecimalJsLikeSchema,]).refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' }),z.lazy(() => DecimalFieldUpdateOperationsInputSchema) ]).optional(),
}).strict();

export const ForecastUncheckedUpdateManyInputSchema: z.ZodType<Prisma.ForecastUncheckedUpdateManyInput> = z.object({
  id: z.union([ z.number().int(),z.lazy(() => IntFieldUpdateOperationsInputSchema) ]).optional(),
  createdAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  comment: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  forecast: z.union([ z.union([z.number(),z.string(),z.instanceof(Decimal),z.instanceof(Prisma.Decimal),DecimalJsLikeSchema,]).refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' }),z.lazy(() => DecimalFieldUpdateOperationsInputSchema) ]).optional(),
  profileId: z.union([ z.number().int(),z.lazy(() => NullableIntFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  questionId: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  optionId: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  userId: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
}).strict();

export const QuestionScoreCreateInputSchema: z.ZodType<Prisma.QuestionScoreCreateInput> = z.object({
  createdAt: z.coerce.date().optional(),
  relativeScore: z.union([z.number(),z.string(),z.instanceof(Decimal),z.instanceof(Prisma.Decimal),DecimalJsLikeSchema,]).refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' }).optional().nullable(),
  userQuestionComboId: z.string(),
  absoluteScore: z.union([z.number(),z.string(),z.instanceof(Decimal),z.instanceof(Prisma.Decimal),DecimalJsLikeSchema,]).refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' }),
  rank: z.number().int(),
  question: z.lazy(() => QuestionCreateNestedOneWithoutQuestionScoresInputSchema),
  user: z.lazy(() => UserCreateNestedOneWithoutQuestionScoresInputSchema),
  QuestionOption: z.lazy(() => QuestionOptionCreateNestedOneWithoutQuestionScoresInputSchema).optional()
}).strict();

export const QuestionScoreUncheckedCreateInputSchema: z.ZodType<Prisma.QuestionScoreUncheckedCreateInput> = z.object({
  id: z.number().int().optional(),
  createdAt: z.coerce.date().optional(),
  relativeScore: z.union([z.number(),z.string(),z.instanceof(Decimal),z.instanceof(Prisma.Decimal),DecimalJsLikeSchema,]).refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' }).optional().nullable(),
  questionId: z.string(),
  userQuestionComboId: z.string(),
  absoluteScore: z.union([z.number(),z.string(),z.instanceof(Decimal),z.instanceof(Prisma.Decimal),DecimalJsLikeSchema,]).refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' }),
  rank: z.number().int(),
  userId: z.string(),
  questionOptionId: z.string().optional().nullable()
}).strict();

export const QuestionScoreUpdateInputSchema: z.ZodType<Prisma.QuestionScoreUpdateInput> = z.object({
  createdAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  relativeScore: z.union([ z.union([z.number(),z.string(),z.instanceof(Decimal),z.instanceof(Prisma.Decimal),DecimalJsLikeSchema,]).refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' }),z.lazy(() => NullableDecimalFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  userQuestionComboId: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  absoluteScore: z.union([ z.union([z.number(),z.string(),z.instanceof(Decimal),z.instanceof(Prisma.Decimal),DecimalJsLikeSchema,]).refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' }),z.lazy(() => DecimalFieldUpdateOperationsInputSchema) ]).optional(),
  rank: z.union([ z.number().int(),z.lazy(() => IntFieldUpdateOperationsInputSchema) ]).optional(),
  question: z.lazy(() => QuestionUpdateOneRequiredWithoutQuestionScoresNestedInputSchema).optional(),
  user: z.lazy(() => UserUpdateOneRequiredWithoutQuestionScoresNestedInputSchema).optional(),
  QuestionOption: z.lazy(() => QuestionOptionUpdateOneWithoutQuestionScoresNestedInputSchema).optional()
}).strict();

export const QuestionScoreUncheckedUpdateInputSchema: z.ZodType<Prisma.QuestionScoreUncheckedUpdateInput> = z.object({
  id: z.union([ z.number().int(),z.lazy(() => IntFieldUpdateOperationsInputSchema) ]).optional(),
  createdAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  relativeScore: z.union([ z.union([z.number(),z.string(),z.instanceof(Decimal),z.instanceof(Prisma.Decimal),DecimalJsLikeSchema,]).refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' }),z.lazy(() => NullableDecimalFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  questionId: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  userQuestionComboId: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  absoluteScore: z.union([ z.union([z.number(),z.string(),z.instanceof(Decimal),z.instanceof(Prisma.Decimal),DecimalJsLikeSchema,]).refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' }),z.lazy(() => DecimalFieldUpdateOperationsInputSchema) ]).optional(),
  rank: z.union([ z.number().int(),z.lazy(() => IntFieldUpdateOperationsInputSchema) ]).optional(),
  userId: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  questionOptionId: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
}).strict();

export const QuestionScoreCreateManyInputSchema: z.ZodType<Prisma.QuestionScoreCreateManyInput> = z.object({
  id: z.number().int().optional(),
  createdAt: z.coerce.date().optional(),
  relativeScore: z.union([z.number(),z.string(),z.instanceof(Decimal),z.instanceof(Prisma.Decimal),DecimalJsLikeSchema,]).refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' }).optional().nullable(),
  questionId: z.string(),
  userQuestionComboId: z.string(),
  absoluteScore: z.union([z.number(),z.string(),z.instanceof(Decimal),z.instanceof(Prisma.Decimal),DecimalJsLikeSchema,]).refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' }),
  rank: z.number().int(),
  userId: z.string(),
  questionOptionId: z.string().optional().nullable()
}).strict();

export const QuestionScoreUpdateManyMutationInputSchema: z.ZodType<Prisma.QuestionScoreUpdateManyMutationInput> = z.object({
  createdAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  relativeScore: z.union([ z.union([z.number(),z.string(),z.instanceof(Decimal),z.instanceof(Prisma.Decimal),DecimalJsLikeSchema,]).refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' }),z.lazy(() => NullableDecimalFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  userQuestionComboId: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  absoluteScore: z.union([ z.union([z.number(),z.string(),z.instanceof(Decimal),z.instanceof(Prisma.Decimal),DecimalJsLikeSchema,]).refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' }),z.lazy(() => DecimalFieldUpdateOperationsInputSchema) ]).optional(),
  rank: z.union([ z.number().int(),z.lazy(() => IntFieldUpdateOperationsInputSchema) ]).optional(),
}).strict();

export const QuestionScoreUncheckedUpdateManyInputSchema: z.ZodType<Prisma.QuestionScoreUncheckedUpdateManyInput> = z.object({
  id: z.union([ z.number().int(),z.lazy(() => IntFieldUpdateOperationsInputSchema) ]).optional(),
  createdAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  relativeScore: z.union([ z.union([z.number(),z.string(),z.instanceof(Decimal),z.instanceof(Prisma.Decimal),DecimalJsLikeSchema,]).refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' }),z.lazy(() => NullableDecimalFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  questionId: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  userQuestionComboId: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  absoluteScore: z.union([ z.union([z.number(),z.string(),z.instanceof(Decimal),z.instanceof(Prisma.Decimal),DecimalJsLikeSchema,]).refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' }),z.lazy(() => DecimalFieldUpdateOperationsInputSchema) ]).optional(),
  rank: z.union([ z.number().int(),z.lazy(() => IntFieldUpdateOperationsInputSchema) ]).optional(),
  userId: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  questionOptionId: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
}).strict();

export const QuestionOptionCreateInputSchema: z.ZodType<Prisma.QuestionOptionCreateInput> = z.object({
  id: z.string().cuid().optional(),
  text: z.string(),
  resolution: z.lazy(() => ResolutionSchema).optional().nullable(),
  createdAt: z.coerce.date().optional(),
  resolvedAt: z.coerce.date().optional().nullable(),
  question: z.lazy(() => QuestionCreateNestedOneWithoutOptionsInputSchema),
  forecasts: z.lazy(() => ForecastCreateNestedManyWithoutOptionInputSchema).optional(),
  user: z.lazy(() => UserCreateNestedOneWithoutQuestionOptionsInputSchema),
  questionScores: z.lazy(() => QuestionScoreCreateNestedManyWithoutQuestionOptionInputSchema).optional()
}).strict();

export const QuestionOptionUncheckedCreateInputSchema: z.ZodType<Prisma.QuestionOptionUncheckedCreateInput> = z.object({
  id: z.string().cuid().optional(),
  questionId: z.string(),
  text: z.string(),
  resolution: z.lazy(() => ResolutionSchema).optional().nullable(),
  createdAt: z.coerce.date().optional(),
  userId: z.string(),
  resolvedAt: z.coerce.date().optional().nullable(),
  forecasts: z.lazy(() => ForecastUncheckedCreateNestedManyWithoutOptionInputSchema).optional(),
  questionScores: z.lazy(() => QuestionScoreUncheckedCreateNestedManyWithoutQuestionOptionInputSchema).optional()
}).strict();

export const QuestionOptionUpdateInputSchema: z.ZodType<Prisma.QuestionOptionUpdateInput> = z.object({
  id: z.union([ z.string().cuid(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  text: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  resolution: z.union([ z.lazy(() => ResolutionSchema),z.lazy(() => NullableEnumResolutionFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  createdAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  resolvedAt: z.union([ z.coerce.date(),z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  question: z.lazy(() => QuestionUpdateOneRequiredWithoutOptionsNestedInputSchema).optional(),
  forecasts: z.lazy(() => ForecastUpdateManyWithoutOptionNestedInputSchema).optional(),
  user: z.lazy(() => UserUpdateOneRequiredWithoutQuestionOptionsNestedInputSchema).optional(),
  questionScores: z.lazy(() => QuestionScoreUpdateManyWithoutQuestionOptionNestedInputSchema).optional()
}).strict();

export const QuestionOptionUncheckedUpdateInputSchema: z.ZodType<Prisma.QuestionOptionUncheckedUpdateInput> = z.object({
  id: z.union([ z.string().cuid(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  questionId: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  text: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  resolution: z.union([ z.lazy(() => ResolutionSchema),z.lazy(() => NullableEnumResolutionFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  createdAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  userId: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  resolvedAt: z.union([ z.coerce.date(),z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  forecasts: z.lazy(() => ForecastUncheckedUpdateManyWithoutOptionNestedInputSchema).optional(),
  questionScores: z.lazy(() => QuestionScoreUncheckedUpdateManyWithoutQuestionOptionNestedInputSchema).optional()
}).strict();

export const QuestionOptionCreateManyInputSchema: z.ZodType<Prisma.QuestionOptionCreateManyInput> = z.object({
  id: z.string().cuid().optional(),
  questionId: z.string(),
  text: z.string(),
  resolution: z.lazy(() => ResolutionSchema).optional().nullable(),
  createdAt: z.coerce.date().optional(),
  userId: z.string(),
  resolvedAt: z.coerce.date().optional().nullable()
}).strict();

export const QuestionOptionUpdateManyMutationInputSchema: z.ZodType<Prisma.QuestionOptionUpdateManyMutationInput> = z.object({
  id: z.union([ z.string().cuid(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  text: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  resolution: z.union([ z.lazy(() => ResolutionSchema),z.lazy(() => NullableEnumResolutionFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  createdAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  resolvedAt: z.union([ z.coerce.date(),z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema) ]).optional().nullable(),
}).strict();

export const QuestionOptionUncheckedUpdateManyInputSchema: z.ZodType<Prisma.QuestionOptionUncheckedUpdateManyInput> = z.object({
  id: z.union([ z.string().cuid(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  questionId: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  text: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  resolution: z.union([ z.lazy(() => ResolutionSchema),z.lazy(() => NullableEnumResolutionFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  createdAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  userId: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  resolvedAt: z.union([ z.coerce.date(),z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema) ]).optional().nullable(),
}).strict();

export const QuestionCreateInputSchema: z.ZodType<Prisma.QuestionCreateInput> = z.object({
  id: z.string().cuid().optional(),
  createdAt: z.coerce.date().optional(),
  comment: z.string().optional().nullable(),
  title: z.string(),
  type: z.lazy(() => QuestionTypeSchema).optional(),
  resolveBy: z.coerce.date(),
  resolved: z.boolean().optional(),
  pingedForResolution: z.boolean().optional(),
  resolution: z.lazy(() => ResolutionSchema).optional().nullable(),
  resolvedAt: z.coerce.date().optional().nullable(),
  notes: z.string().optional().nullable(),
  hideForecastsUntil: z.coerce.date().optional().nullable(),
  hideForecastsUntilPrediction: z.boolean().optional().nullable(),
  sharedPublicly: z.boolean().optional(),
  unlisted: z.boolean().optional(),
  exclusiveAnswers: z.boolean().optional().nullable(),
  options: z.lazy(() => QuestionOptionCreateNestedManyWithoutQuestionInputSchema).optional(),
  forecasts: z.lazy(() => ForecastCreateNestedManyWithoutQuestionInputSchema).optional(),
  pingResolveMessages: z.lazy(() => PingSlackMessageCreateNestedManyWithoutQuestionInputSchema).optional(),
  profile: z.lazy(() => ProfileCreateNestedOneWithoutQuestionsInputSchema).optional(),
  user: z.lazy(() => UserCreateNestedOneWithoutQuestionsInputSchema),
  sharedWith: z.lazy(() => UserCreateNestedManyWithoutQuestionsSharedWithInputSchema).optional(),
  sharedWithLists: z.lazy(() => UserListCreateNestedManyWithoutQuestionsInputSchema).optional(),
  questionScores: z.lazy(() => QuestionScoreCreateNestedManyWithoutQuestionInputSchema).optional(),
  questionMessages: z.lazy(() => QuestionSlackMessageCreateNestedManyWithoutQuestionInputSchema).optional(),
  resolutionMessages: z.lazy(() => ResolutionSlackMessageCreateNestedManyWithoutQuestionInputSchema).optional(),
  comments: z.lazy(() => CommentCreateNestedManyWithoutQuestionInputSchema).optional(),
  tags: z.lazy(() => TagCreateNestedManyWithoutQuestionsInputSchema).optional(),
  tournaments: z.lazy(() => TournamentCreateNestedManyWithoutQuestionsInputSchema).optional(),
  notifications: z.lazy(() => NotificationCreateNestedManyWithoutQuestionInputSchema).optional()
}).strict();

export const QuestionUncheckedCreateInputSchema: z.ZodType<Prisma.QuestionUncheckedCreateInput> = z.object({
  id: z.string().cuid().optional(),
  createdAt: z.coerce.date().optional(),
  comment: z.string().optional().nullable(),
  profileId: z.number().int().optional().nullable(),
  title: z.string(),
  type: z.lazy(() => QuestionTypeSchema).optional(),
  resolveBy: z.coerce.date(),
  resolved: z.boolean().optional(),
  pingedForResolution: z.boolean().optional(),
  resolution: z.lazy(() => ResolutionSchema).optional().nullable(),
  resolvedAt: z.coerce.date().optional().nullable(),
  notes: z.string().optional().nullable(),
  hideForecastsUntil: z.coerce.date().optional().nullable(),
  hideForecastsUntilPrediction: z.boolean().optional().nullable(),
  userId: z.string(),
  sharedPublicly: z.boolean().optional(),
  unlisted: z.boolean().optional(),
  exclusiveAnswers: z.boolean().optional().nullable(),
  options: z.lazy(() => QuestionOptionUncheckedCreateNestedManyWithoutQuestionInputSchema).optional(),
  forecasts: z.lazy(() => ForecastUncheckedCreateNestedManyWithoutQuestionInputSchema).optional(),
  pingResolveMessages: z.lazy(() => PingSlackMessageUncheckedCreateNestedManyWithoutQuestionInputSchema).optional(),
  sharedWith: z.lazy(() => UserUncheckedCreateNestedManyWithoutQuestionsSharedWithInputSchema).optional(),
  sharedWithLists: z.lazy(() => UserListUncheckedCreateNestedManyWithoutQuestionsInputSchema).optional(),
  questionScores: z.lazy(() => QuestionScoreUncheckedCreateNestedManyWithoutQuestionInputSchema).optional(),
  questionMessages: z.lazy(() => QuestionSlackMessageUncheckedCreateNestedManyWithoutQuestionInputSchema).optional(),
  resolutionMessages: z.lazy(() => ResolutionSlackMessageUncheckedCreateNestedManyWithoutQuestionInputSchema).optional(),
  comments: z.lazy(() => CommentUncheckedCreateNestedManyWithoutQuestionInputSchema).optional(),
  tags: z.lazy(() => TagUncheckedCreateNestedManyWithoutQuestionsInputSchema).optional(),
  tournaments: z.lazy(() => TournamentUncheckedCreateNestedManyWithoutQuestionsInputSchema).optional(),
  notifications: z.lazy(() => NotificationUncheckedCreateNestedManyWithoutQuestionInputSchema).optional()
}).strict();

export const QuestionUpdateInputSchema: z.ZodType<Prisma.QuestionUpdateInput> = z.object({
  id: z.union([ z.string().cuid(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  createdAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  comment: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  title: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  type: z.union([ z.lazy(() => QuestionTypeSchema),z.lazy(() => EnumQuestionTypeFieldUpdateOperationsInputSchema) ]).optional(),
  resolveBy: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  resolved: z.union([ z.boolean(),z.lazy(() => BoolFieldUpdateOperationsInputSchema) ]).optional(),
  pingedForResolution: z.union([ z.boolean(),z.lazy(() => BoolFieldUpdateOperationsInputSchema) ]).optional(),
  resolution: z.union([ z.lazy(() => ResolutionSchema),z.lazy(() => NullableEnumResolutionFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  resolvedAt: z.union([ z.coerce.date(),z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  notes: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  hideForecastsUntil: z.union([ z.coerce.date(),z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  hideForecastsUntilPrediction: z.union([ z.boolean(),z.lazy(() => NullableBoolFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  sharedPublicly: z.union([ z.boolean(),z.lazy(() => BoolFieldUpdateOperationsInputSchema) ]).optional(),
  unlisted: z.union([ z.boolean(),z.lazy(() => BoolFieldUpdateOperationsInputSchema) ]).optional(),
  exclusiveAnswers: z.union([ z.boolean(),z.lazy(() => NullableBoolFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  options: z.lazy(() => QuestionOptionUpdateManyWithoutQuestionNestedInputSchema).optional(),
  forecasts: z.lazy(() => ForecastUpdateManyWithoutQuestionNestedInputSchema).optional(),
  pingResolveMessages: z.lazy(() => PingSlackMessageUpdateManyWithoutQuestionNestedInputSchema).optional(),
  profile: z.lazy(() => ProfileUpdateOneWithoutQuestionsNestedInputSchema).optional(),
  user: z.lazy(() => UserUpdateOneRequiredWithoutQuestionsNestedInputSchema).optional(),
  sharedWith: z.lazy(() => UserUpdateManyWithoutQuestionsSharedWithNestedInputSchema).optional(),
  sharedWithLists: z.lazy(() => UserListUpdateManyWithoutQuestionsNestedInputSchema).optional(),
  questionScores: z.lazy(() => QuestionScoreUpdateManyWithoutQuestionNestedInputSchema).optional(),
  questionMessages: z.lazy(() => QuestionSlackMessageUpdateManyWithoutQuestionNestedInputSchema).optional(),
  resolutionMessages: z.lazy(() => ResolutionSlackMessageUpdateManyWithoutQuestionNestedInputSchema).optional(),
  comments: z.lazy(() => CommentUpdateManyWithoutQuestionNestedInputSchema).optional(),
  tags: z.lazy(() => TagUpdateManyWithoutQuestionsNestedInputSchema).optional(),
  tournaments: z.lazy(() => TournamentUpdateManyWithoutQuestionsNestedInputSchema).optional(),
  notifications: z.lazy(() => NotificationUpdateManyWithoutQuestionNestedInputSchema).optional()
}).strict();

export const QuestionUncheckedUpdateInputSchema: z.ZodType<Prisma.QuestionUncheckedUpdateInput> = z.object({
  id: z.union([ z.string().cuid(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  createdAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  comment: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  profileId: z.union([ z.number().int(),z.lazy(() => NullableIntFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  title: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  type: z.union([ z.lazy(() => QuestionTypeSchema),z.lazy(() => EnumQuestionTypeFieldUpdateOperationsInputSchema) ]).optional(),
  resolveBy: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  resolved: z.union([ z.boolean(),z.lazy(() => BoolFieldUpdateOperationsInputSchema) ]).optional(),
  pingedForResolution: z.union([ z.boolean(),z.lazy(() => BoolFieldUpdateOperationsInputSchema) ]).optional(),
  resolution: z.union([ z.lazy(() => ResolutionSchema),z.lazy(() => NullableEnumResolutionFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  resolvedAt: z.union([ z.coerce.date(),z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  notes: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  hideForecastsUntil: z.union([ z.coerce.date(),z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  hideForecastsUntilPrediction: z.union([ z.boolean(),z.lazy(() => NullableBoolFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  userId: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  sharedPublicly: z.union([ z.boolean(),z.lazy(() => BoolFieldUpdateOperationsInputSchema) ]).optional(),
  unlisted: z.union([ z.boolean(),z.lazy(() => BoolFieldUpdateOperationsInputSchema) ]).optional(),
  exclusiveAnswers: z.union([ z.boolean(),z.lazy(() => NullableBoolFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  options: z.lazy(() => QuestionOptionUncheckedUpdateManyWithoutQuestionNestedInputSchema).optional(),
  forecasts: z.lazy(() => ForecastUncheckedUpdateManyWithoutQuestionNestedInputSchema).optional(),
  pingResolveMessages: z.lazy(() => PingSlackMessageUncheckedUpdateManyWithoutQuestionNestedInputSchema).optional(),
  sharedWith: z.lazy(() => UserUncheckedUpdateManyWithoutQuestionsSharedWithNestedInputSchema).optional(),
  sharedWithLists: z.lazy(() => UserListUncheckedUpdateManyWithoutQuestionsNestedInputSchema).optional(),
  questionScores: z.lazy(() => QuestionScoreUncheckedUpdateManyWithoutQuestionNestedInputSchema).optional(),
  questionMessages: z.lazy(() => QuestionSlackMessageUncheckedUpdateManyWithoutQuestionNestedInputSchema).optional(),
  resolutionMessages: z.lazy(() => ResolutionSlackMessageUncheckedUpdateManyWithoutQuestionNestedInputSchema).optional(),
  comments: z.lazy(() => CommentUncheckedUpdateManyWithoutQuestionNestedInputSchema).optional(),
  tags: z.lazy(() => TagUncheckedUpdateManyWithoutQuestionsNestedInputSchema).optional(),
  tournaments: z.lazy(() => TournamentUncheckedUpdateManyWithoutQuestionsNestedInputSchema).optional(),
  notifications: z.lazy(() => NotificationUncheckedUpdateManyWithoutQuestionNestedInputSchema).optional()
}).strict();

export const QuestionCreateManyInputSchema: z.ZodType<Prisma.QuestionCreateManyInput> = z.object({
  id: z.string().cuid().optional(),
  createdAt: z.coerce.date().optional(),
  comment: z.string().optional().nullable(),
  profileId: z.number().int().optional().nullable(),
  title: z.string(),
  type: z.lazy(() => QuestionTypeSchema).optional(),
  resolveBy: z.coerce.date(),
  resolved: z.boolean().optional(),
  pingedForResolution: z.boolean().optional(),
  resolution: z.lazy(() => ResolutionSchema).optional().nullable(),
  resolvedAt: z.coerce.date().optional().nullable(),
  notes: z.string().optional().nullable(),
  hideForecastsUntil: z.coerce.date().optional().nullable(),
  hideForecastsUntilPrediction: z.boolean().optional().nullable(),
  userId: z.string(),
  sharedPublicly: z.boolean().optional(),
  unlisted: z.boolean().optional(),
  exclusiveAnswers: z.boolean().optional().nullable()
}).strict();

export const QuestionUpdateManyMutationInputSchema: z.ZodType<Prisma.QuestionUpdateManyMutationInput> = z.object({
  id: z.union([ z.string().cuid(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  createdAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  comment: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  title: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  type: z.union([ z.lazy(() => QuestionTypeSchema),z.lazy(() => EnumQuestionTypeFieldUpdateOperationsInputSchema) ]).optional(),
  resolveBy: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  resolved: z.union([ z.boolean(),z.lazy(() => BoolFieldUpdateOperationsInputSchema) ]).optional(),
  pingedForResolution: z.union([ z.boolean(),z.lazy(() => BoolFieldUpdateOperationsInputSchema) ]).optional(),
  resolution: z.union([ z.lazy(() => ResolutionSchema),z.lazy(() => NullableEnumResolutionFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  resolvedAt: z.union([ z.coerce.date(),z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  notes: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  hideForecastsUntil: z.union([ z.coerce.date(),z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  hideForecastsUntilPrediction: z.union([ z.boolean(),z.lazy(() => NullableBoolFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  sharedPublicly: z.union([ z.boolean(),z.lazy(() => BoolFieldUpdateOperationsInputSchema) ]).optional(),
  unlisted: z.union([ z.boolean(),z.lazy(() => BoolFieldUpdateOperationsInputSchema) ]).optional(),
  exclusiveAnswers: z.union([ z.boolean(),z.lazy(() => NullableBoolFieldUpdateOperationsInputSchema) ]).optional().nullable(),
}).strict();

export const QuestionUncheckedUpdateManyInputSchema: z.ZodType<Prisma.QuestionUncheckedUpdateManyInput> = z.object({
  id: z.union([ z.string().cuid(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  createdAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  comment: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  profileId: z.union([ z.number().int(),z.lazy(() => NullableIntFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  title: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  type: z.union([ z.lazy(() => QuestionTypeSchema),z.lazy(() => EnumQuestionTypeFieldUpdateOperationsInputSchema) ]).optional(),
  resolveBy: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  resolved: z.union([ z.boolean(),z.lazy(() => BoolFieldUpdateOperationsInputSchema) ]).optional(),
  pingedForResolution: z.union([ z.boolean(),z.lazy(() => BoolFieldUpdateOperationsInputSchema) ]).optional(),
  resolution: z.union([ z.lazy(() => ResolutionSchema),z.lazy(() => NullableEnumResolutionFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  resolvedAt: z.union([ z.coerce.date(),z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  notes: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  hideForecastsUntil: z.union([ z.coerce.date(),z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  hideForecastsUntilPrediction: z.union([ z.boolean(),z.lazy(() => NullableBoolFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  userId: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  sharedPublicly: z.union([ z.boolean(),z.lazy(() => BoolFieldUpdateOperationsInputSchema) ]).optional(),
  unlisted: z.union([ z.boolean(),z.lazy(() => BoolFieldUpdateOperationsInputSchema) ]).optional(),
  exclusiveAnswers: z.union([ z.boolean(),z.lazy(() => NullableBoolFieldUpdateOperationsInputSchema) ]).optional().nullable(),
}).strict();

export const TagCreateInputSchema: z.ZodType<Prisma.TagCreateInput> = z.object({
  id: z.string().cuid().optional(),
  createdAt: z.coerce.date().optional(),
  name: z.string(),
  user: z.lazy(() => UserCreateNestedOneWithoutTagsInputSchema),
  questions: z.lazy(() => QuestionCreateNestedManyWithoutTagsInputSchema).optional()
}).strict();

export const TagUncheckedCreateInputSchema: z.ZodType<Prisma.TagUncheckedCreateInput> = z.object({
  id: z.string().cuid().optional(),
  createdAt: z.coerce.date().optional(),
  name: z.string(),
  userId: z.string(),
  questions: z.lazy(() => QuestionUncheckedCreateNestedManyWithoutTagsInputSchema).optional()
}).strict();

export const TagUpdateInputSchema: z.ZodType<Prisma.TagUpdateInput> = z.object({
  id: z.union([ z.string().cuid(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  createdAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  name: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  user: z.lazy(() => UserUpdateOneRequiredWithoutTagsNestedInputSchema).optional(),
  questions: z.lazy(() => QuestionUpdateManyWithoutTagsNestedInputSchema).optional()
}).strict();

export const TagUncheckedUpdateInputSchema: z.ZodType<Prisma.TagUncheckedUpdateInput> = z.object({
  id: z.union([ z.string().cuid(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  createdAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  name: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  userId: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  questions: z.lazy(() => QuestionUncheckedUpdateManyWithoutTagsNestedInputSchema).optional()
}).strict();

export const TagCreateManyInputSchema: z.ZodType<Prisma.TagCreateManyInput> = z.object({
  id: z.string().cuid().optional(),
  createdAt: z.coerce.date().optional(),
  name: z.string(),
  userId: z.string()
}).strict();

export const TagUpdateManyMutationInputSchema: z.ZodType<Prisma.TagUpdateManyMutationInput> = z.object({
  id: z.union([ z.string().cuid(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  createdAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  name: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
}).strict();

export const TagUncheckedUpdateManyInputSchema: z.ZodType<Prisma.TagUncheckedUpdateManyInput> = z.object({
  id: z.union([ z.string().cuid(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  createdAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  name: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  userId: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
}).strict();

export const ResolutionSlackMessageCreateInputSchema: z.ZodType<Prisma.ResolutionSlackMessageCreateInput> = z.object({
  message: z.lazy(() => SlackMessageCreateNestedOneWithoutResolutionSlackMessageInputSchema),
  profile: z.lazy(() => ProfileCreateNestedOneWithoutResolutionMessagesInputSchema).optional(),
  question: z.lazy(() => QuestionCreateNestedOneWithoutResolutionMessagesInputSchema)
}).strict();

export const ResolutionSlackMessageUncheckedCreateInputSchema: z.ZodType<Prisma.ResolutionSlackMessageUncheckedCreateInput> = z.object({
  id: z.number().int().optional(),
  questionId: z.string(),
  detailsId: z.number().int(),
  profileId: z.number().int().optional().nullable()
}).strict();

export const ResolutionSlackMessageUpdateInputSchema: z.ZodType<Prisma.ResolutionSlackMessageUpdateInput> = z.object({
  message: z.lazy(() => SlackMessageUpdateOneRequiredWithoutResolutionSlackMessageNestedInputSchema).optional(),
  profile: z.lazy(() => ProfileUpdateOneWithoutResolutionMessagesNestedInputSchema).optional(),
  question: z.lazy(() => QuestionUpdateOneRequiredWithoutResolutionMessagesNestedInputSchema).optional()
}).strict();

export const ResolutionSlackMessageUncheckedUpdateInputSchema: z.ZodType<Prisma.ResolutionSlackMessageUncheckedUpdateInput> = z.object({
  id: z.union([ z.number().int(),z.lazy(() => IntFieldUpdateOperationsInputSchema) ]).optional(),
  questionId: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  detailsId: z.union([ z.number().int(),z.lazy(() => IntFieldUpdateOperationsInputSchema) ]).optional(),
  profileId: z.union([ z.number().int(),z.lazy(() => NullableIntFieldUpdateOperationsInputSchema) ]).optional().nullable(),
}).strict();

export const ResolutionSlackMessageCreateManyInputSchema: z.ZodType<Prisma.ResolutionSlackMessageCreateManyInput> = z.object({
  id: z.number().int().optional(),
  questionId: z.string(),
  detailsId: z.number().int(),
  profileId: z.number().int().optional().nullable()
}).strict();

export const ResolutionSlackMessageUpdateManyMutationInputSchema: z.ZodType<Prisma.ResolutionSlackMessageUpdateManyMutationInput> = z.object({
}).strict();

export const ResolutionSlackMessageUncheckedUpdateManyInputSchema: z.ZodType<Prisma.ResolutionSlackMessageUncheckedUpdateManyInput> = z.object({
  id: z.union([ z.number().int(),z.lazy(() => IntFieldUpdateOperationsInputSchema) ]).optional(),
  questionId: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  detailsId: z.union([ z.number().int(),z.lazy(() => IntFieldUpdateOperationsInputSchema) ]).optional(),
  profileId: z.union([ z.number().int(),z.lazy(() => NullableIntFieldUpdateOperationsInputSchema) ]).optional().nullable(),
}).strict();

export const PingSlackMessageCreateInputSchema: z.ZodType<Prisma.PingSlackMessageCreateInput> = z.object({
  message: z.lazy(() => SlackMessageCreateNestedOneWithoutPingSlackMessageInputSchema),
  question: z.lazy(() => QuestionCreateNestedOneWithoutPingResolveMessagesInputSchema)
}).strict();

export const PingSlackMessageUncheckedCreateInputSchema: z.ZodType<Prisma.PingSlackMessageUncheckedCreateInput> = z.object({
  id: z.number().int().optional(),
  questionId: z.string(),
  detailsId: z.number().int()
}).strict();

export const PingSlackMessageUpdateInputSchema: z.ZodType<Prisma.PingSlackMessageUpdateInput> = z.object({
  message: z.lazy(() => SlackMessageUpdateOneRequiredWithoutPingSlackMessageNestedInputSchema).optional(),
  question: z.lazy(() => QuestionUpdateOneRequiredWithoutPingResolveMessagesNestedInputSchema).optional()
}).strict();

export const PingSlackMessageUncheckedUpdateInputSchema: z.ZodType<Prisma.PingSlackMessageUncheckedUpdateInput> = z.object({
  id: z.union([ z.number().int(),z.lazy(() => IntFieldUpdateOperationsInputSchema) ]).optional(),
  questionId: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  detailsId: z.union([ z.number().int(),z.lazy(() => IntFieldUpdateOperationsInputSchema) ]).optional(),
}).strict();

export const PingSlackMessageCreateManyInputSchema: z.ZodType<Prisma.PingSlackMessageCreateManyInput> = z.object({
  id: z.number().int().optional(),
  questionId: z.string(),
  detailsId: z.number().int()
}).strict();

export const PingSlackMessageUpdateManyMutationInputSchema: z.ZodType<Prisma.PingSlackMessageUpdateManyMutationInput> = z.object({
}).strict();

export const PingSlackMessageUncheckedUpdateManyInputSchema: z.ZodType<Prisma.PingSlackMessageUncheckedUpdateManyInput> = z.object({
  id: z.union([ z.number().int(),z.lazy(() => IntFieldUpdateOperationsInputSchema) ]).optional(),
  questionId: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  detailsId: z.union([ z.number().int(),z.lazy(() => IntFieldUpdateOperationsInputSchema) ]).optional(),
}).strict();

export const QuestionSlackMessageCreateInputSchema: z.ZodType<Prisma.QuestionSlackMessageCreateInput> = z.object({
  updatedAt: z.coerce.date().optional(),
  message: z.lazy(() => SlackMessageCreateNestedOneWithoutQuestionSlackMessageInputSchema),
  question: z.lazy(() => QuestionCreateNestedOneWithoutQuestionMessagesInputSchema)
}).strict();

export const QuestionSlackMessageUncheckedCreateInputSchema: z.ZodType<Prisma.QuestionSlackMessageUncheckedCreateInput> = z.object({
  id: z.number().int().optional(),
  questionId: z.string(),
  detailsId: z.number().int(),
  updatedAt: z.coerce.date().optional()
}).strict();

export const QuestionSlackMessageUpdateInputSchema: z.ZodType<Prisma.QuestionSlackMessageUpdateInput> = z.object({
  updatedAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  message: z.lazy(() => SlackMessageUpdateOneRequiredWithoutQuestionSlackMessageNestedInputSchema).optional(),
  question: z.lazy(() => QuestionUpdateOneRequiredWithoutQuestionMessagesNestedInputSchema).optional()
}).strict();

export const QuestionSlackMessageUncheckedUpdateInputSchema: z.ZodType<Prisma.QuestionSlackMessageUncheckedUpdateInput> = z.object({
  id: z.union([ z.number().int(),z.lazy(() => IntFieldUpdateOperationsInputSchema) ]).optional(),
  questionId: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  detailsId: z.union([ z.number().int(),z.lazy(() => IntFieldUpdateOperationsInputSchema) ]).optional(),
  updatedAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
}).strict();

export const QuestionSlackMessageCreateManyInputSchema: z.ZodType<Prisma.QuestionSlackMessageCreateManyInput> = z.object({
  id: z.number().int().optional(),
  questionId: z.string(),
  detailsId: z.number().int(),
  updatedAt: z.coerce.date().optional()
}).strict();

export const QuestionSlackMessageUpdateManyMutationInputSchema: z.ZodType<Prisma.QuestionSlackMessageUpdateManyMutationInput> = z.object({
  updatedAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
}).strict();

export const QuestionSlackMessageUncheckedUpdateManyInputSchema: z.ZodType<Prisma.QuestionSlackMessageUncheckedUpdateManyInput> = z.object({
  id: z.union([ z.number().int(),z.lazy(() => IntFieldUpdateOperationsInputSchema) ]).optional(),
  questionId: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  detailsId: z.union([ z.number().int(),z.lazy(() => IntFieldUpdateOperationsInputSchema) ]).optional(),
  updatedAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
}).strict();

export const SlackMessageCreateInputSchema: z.ZodType<Prisma.SlackMessageCreateInput> = z.object({
  ts: z.string(),
  channel: z.string(),
  teamId: z.string(),
  pingSlackMessage: z.lazy(() => PingSlackMessageCreateNestedOneWithoutMessageInputSchema).optional(),
  questionSlackMessage: z.lazy(() => QuestionSlackMessageCreateNestedOneWithoutMessageInputSchema).optional(),
  resolutionSlackMessage: z.lazy(() => ResolutionSlackMessageCreateNestedOneWithoutMessageInputSchema).optional()
}).strict();

export const SlackMessageUncheckedCreateInputSchema: z.ZodType<Prisma.SlackMessageUncheckedCreateInput> = z.object({
  id: z.number().int().optional(),
  ts: z.string(),
  channel: z.string(),
  teamId: z.string(),
  pingSlackMessage: z.lazy(() => PingSlackMessageUncheckedCreateNestedOneWithoutMessageInputSchema).optional(),
  questionSlackMessage: z.lazy(() => QuestionSlackMessageUncheckedCreateNestedOneWithoutMessageInputSchema).optional(),
  resolutionSlackMessage: z.lazy(() => ResolutionSlackMessageUncheckedCreateNestedOneWithoutMessageInputSchema).optional()
}).strict();

export const SlackMessageUpdateInputSchema: z.ZodType<Prisma.SlackMessageUpdateInput> = z.object({
  ts: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  channel: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  teamId: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  pingSlackMessage: z.lazy(() => PingSlackMessageUpdateOneWithoutMessageNestedInputSchema).optional(),
  questionSlackMessage: z.lazy(() => QuestionSlackMessageUpdateOneWithoutMessageNestedInputSchema).optional(),
  resolutionSlackMessage: z.lazy(() => ResolutionSlackMessageUpdateOneWithoutMessageNestedInputSchema).optional()
}).strict();

export const SlackMessageUncheckedUpdateInputSchema: z.ZodType<Prisma.SlackMessageUncheckedUpdateInput> = z.object({
  id: z.union([ z.number().int(),z.lazy(() => IntFieldUpdateOperationsInputSchema) ]).optional(),
  ts: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  channel: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  teamId: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  pingSlackMessage: z.lazy(() => PingSlackMessageUncheckedUpdateOneWithoutMessageNestedInputSchema).optional(),
  questionSlackMessage: z.lazy(() => QuestionSlackMessageUncheckedUpdateOneWithoutMessageNestedInputSchema).optional(),
  resolutionSlackMessage: z.lazy(() => ResolutionSlackMessageUncheckedUpdateOneWithoutMessageNestedInputSchema).optional()
}).strict();

export const SlackMessageCreateManyInputSchema: z.ZodType<Prisma.SlackMessageCreateManyInput> = z.object({
  id: z.number().int().optional(),
  ts: z.string(),
  channel: z.string(),
  teamId: z.string()
}).strict();

export const SlackMessageUpdateManyMutationInputSchema: z.ZodType<Prisma.SlackMessageUpdateManyMutationInput> = z.object({
  ts: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  channel: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  teamId: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
}).strict();

export const SlackMessageUncheckedUpdateManyInputSchema: z.ZodType<Prisma.SlackMessageUncheckedUpdateManyInput> = z.object({
  id: z.union([ z.number().int(),z.lazy(() => IntFieldUpdateOperationsInputSchema) ]).optional(),
  ts: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  channel: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  teamId: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
}).strict();

export const UserCreateInputSchema: z.ZodType<Prisma.UserCreateInput> = z.object({
  id: z.string().cuid().optional(),
  name: z.string().optional().nullable(),
  createdAt: z.coerce.date().optional(),
  email: z.string(),
  image: z.string().optional().nullable(),
  staleReminder: z.boolean().optional(),
  unsubscribedFromEmailsAt: z.coerce.date().optional().nullable(),
  apiKey: z.string().optional().nullable(),
  discordUserId: z.string().optional().nullable(),
  emailVerified: z.coerce.date().optional().nullable(),
  forecasts: z.lazy(() => ForecastCreateNestedManyWithoutUserInputSchema).optional(),
  profiles: z.lazy(() => ProfileCreateNestedManyWithoutUserInputSchema).optional(),
  questions: z.lazy(() => QuestionCreateNestedManyWithoutUserInputSchema).optional(),
  questionScores: z.lazy(() => QuestionScoreCreateNestedManyWithoutUserInputSchema).optional(),
  questionsSharedWith: z.lazy(() => QuestionCreateNestedManyWithoutSharedWithInputSchema).optional(),
  comments: z.lazy(() => CommentCreateNestedManyWithoutUserInputSchema).optional(),
  target: z.lazy(() => TargetCreateNestedOneWithoutUserInputSchema).optional(),
  authorOfLists: z.lazy(() => UserListCreateNestedManyWithoutAuthorInputSchema).optional(),
  memberOfLists: z.lazy(() => UserListCreateNestedManyWithoutUsersInputSchema).optional(),
  tags: z.lazy(() => TagCreateNestedManyWithoutUserInputSchema).optional(),
  tournaments: z.lazy(() => TournamentCreateNestedManyWithoutAuthorInputSchema).optional(),
  notifications: z.lazy(() => NotificationCreateNestedManyWithoutUserInputSchema).optional(),
  questionOptions: z.lazy(() => QuestionOptionCreateNestedManyWithoutUserInputSchema).optional(),
  accounts: z.lazy(() => AccountCreateNestedManyWithoutUserInputSchema).optional()
}).strict();

export const UserUncheckedCreateInputSchema: z.ZodType<Prisma.UserUncheckedCreateInput> = z.object({
  id: z.string().cuid().optional(),
  name: z.string().optional().nullable(),
  createdAt: z.coerce.date().optional(),
  email: z.string(),
  image: z.string().optional().nullable(),
  staleReminder: z.boolean().optional(),
  unsubscribedFromEmailsAt: z.coerce.date().optional().nullable(),
  apiKey: z.string().optional().nullable(),
  discordUserId: z.string().optional().nullable(),
  emailVerified: z.coerce.date().optional().nullable(),
  forecasts: z.lazy(() => ForecastUncheckedCreateNestedManyWithoutUserInputSchema).optional(),
  profiles: z.lazy(() => ProfileUncheckedCreateNestedManyWithoutUserInputSchema).optional(),
  questions: z.lazy(() => QuestionUncheckedCreateNestedManyWithoutUserInputSchema).optional(),
  questionScores: z.lazy(() => QuestionScoreUncheckedCreateNestedManyWithoutUserInputSchema).optional(),
  questionsSharedWith: z.lazy(() => QuestionUncheckedCreateNestedManyWithoutSharedWithInputSchema).optional(),
  comments: z.lazy(() => CommentUncheckedCreateNestedManyWithoutUserInputSchema).optional(),
  target: z.lazy(() => TargetUncheckedCreateNestedOneWithoutUserInputSchema).optional(),
  authorOfLists: z.lazy(() => UserListUncheckedCreateNestedManyWithoutAuthorInputSchema).optional(),
  memberOfLists: z.lazy(() => UserListUncheckedCreateNestedManyWithoutUsersInputSchema).optional(),
  tags: z.lazy(() => TagUncheckedCreateNestedManyWithoutUserInputSchema).optional(),
  tournaments: z.lazy(() => TournamentUncheckedCreateNestedManyWithoutAuthorInputSchema).optional(),
  notifications: z.lazy(() => NotificationUncheckedCreateNestedManyWithoutUserInputSchema).optional(),
  questionOptions: z.lazy(() => QuestionOptionUncheckedCreateNestedManyWithoutUserInputSchema).optional(),
  accounts: z.lazy(() => AccountUncheckedCreateNestedManyWithoutUserInputSchema).optional()
}).strict();

export const UserUpdateInputSchema: z.ZodType<Prisma.UserUpdateInput> = z.object({
  id: z.union([ z.string().cuid(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  name: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  createdAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  email: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  image: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  staleReminder: z.union([ z.boolean(),z.lazy(() => BoolFieldUpdateOperationsInputSchema) ]).optional(),
  unsubscribedFromEmailsAt: z.union([ z.coerce.date(),z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  apiKey: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  discordUserId: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  emailVerified: z.union([ z.coerce.date(),z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  forecasts: z.lazy(() => ForecastUpdateManyWithoutUserNestedInputSchema).optional(),
  profiles: z.lazy(() => ProfileUpdateManyWithoutUserNestedInputSchema).optional(),
  questions: z.lazy(() => QuestionUpdateManyWithoutUserNestedInputSchema).optional(),
  questionScores: z.lazy(() => QuestionScoreUpdateManyWithoutUserNestedInputSchema).optional(),
  questionsSharedWith: z.lazy(() => QuestionUpdateManyWithoutSharedWithNestedInputSchema).optional(),
  comments: z.lazy(() => CommentUpdateManyWithoutUserNestedInputSchema).optional(),
  target: z.lazy(() => TargetUpdateOneWithoutUserNestedInputSchema).optional(),
  authorOfLists: z.lazy(() => UserListUpdateManyWithoutAuthorNestedInputSchema).optional(),
  memberOfLists: z.lazy(() => UserListUpdateManyWithoutUsersNestedInputSchema).optional(),
  tags: z.lazy(() => TagUpdateManyWithoutUserNestedInputSchema).optional(),
  tournaments: z.lazy(() => TournamentUpdateManyWithoutAuthorNestedInputSchema).optional(),
  notifications: z.lazy(() => NotificationUpdateManyWithoutUserNestedInputSchema).optional(),
  questionOptions: z.lazy(() => QuestionOptionUpdateManyWithoutUserNestedInputSchema).optional(),
  accounts: z.lazy(() => AccountUpdateManyWithoutUserNestedInputSchema).optional()
}).strict();

export const UserUncheckedUpdateInputSchema: z.ZodType<Prisma.UserUncheckedUpdateInput> = z.object({
  id: z.union([ z.string().cuid(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  name: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  createdAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  email: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  image: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  staleReminder: z.union([ z.boolean(),z.lazy(() => BoolFieldUpdateOperationsInputSchema) ]).optional(),
  unsubscribedFromEmailsAt: z.union([ z.coerce.date(),z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  apiKey: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  discordUserId: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  emailVerified: z.union([ z.coerce.date(),z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  forecasts: z.lazy(() => ForecastUncheckedUpdateManyWithoutUserNestedInputSchema).optional(),
  profiles: z.lazy(() => ProfileUncheckedUpdateManyWithoutUserNestedInputSchema).optional(),
  questions: z.lazy(() => QuestionUncheckedUpdateManyWithoutUserNestedInputSchema).optional(),
  questionScores: z.lazy(() => QuestionScoreUncheckedUpdateManyWithoutUserNestedInputSchema).optional(),
  questionsSharedWith: z.lazy(() => QuestionUncheckedUpdateManyWithoutSharedWithNestedInputSchema).optional(),
  comments: z.lazy(() => CommentUncheckedUpdateManyWithoutUserNestedInputSchema).optional(),
  target: z.lazy(() => TargetUncheckedUpdateOneWithoutUserNestedInputSchema).optional(),
  authorOfLists: z.lazy(() => UserListUncheckedUpdateManyWithoutAuthorNestedInputSchema).optional(),
  memberOfLists: z.lazy(() => UserListUncheckedUpdateManyWithoutUsersNestedInputSchema).optional(),
  tags: z.lazy(() => TagUncheckedUpdateManyWithoutUserNestedInputSchema).optional(),
  tournaments: z.lazy(() => TournamentUncheckedUpdateManyWithoutAuthorNestedInputSchema).optional(),
  notifications: z.lazy(() => NotificationUncheckedUpdateManyWithoutUserNestedInputSchema).optional(),
  questionOptions: z.lazy(() => QuestionOptionUncheckedUpdateManyWithoutUserNestedInputSchema).optional(),
  accounts: z.lazy(() => AccountUncheckedUpdateManyWithoutUserNestedInputSchema).optional()
}).strict();

export const UserCreateManyInputSchema: z.ZodType<Prisma.UserCreateManyInput> = z.object({
  id: z.string().cuid().optional(),
  name: z.string().optional().nullable(),
  createdAt: z.coerce.date().optional(),
  email: z.string(),
  image: z.string().optional().nullable(),
  staleReminder: z.boolean().optional(),
  unsubscribedFromEmailsAt: z.coerce.date().optional().nullable(),
  apiKey: z.string().optional().nullable(),
  discordUserId: z.string().optional().nullable(),
  emailVerified: z.coerce.date().optional().nullable()
}).strict();

export const UserUpdateManyMutationInputSchema: z.ZodType<Prisma.UserUpdateManyMutationInput> = z.object({
  id: z.union([ z.string().cuid(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  name: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  createdAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  email: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  image: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  staleReminder: z.union([ z.boolean(),z.lazy(() => BoolFieldUpdateOperationsInputSchema) ]).optional(),
  unsubscribedFromEmailsAt: z.union([ z.coerce.date(),z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  apiKey: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  discordUserId: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  emailVerified: z.union([ z.coerce.date(),z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema) ]).optional().nullable(),
}).strict();

export const UserUncheckedUpdateManyInputSchema: z.ZodType<Prisma.UserUncheckedUpdateManyInput> = z.object({
  id: z.union([ z.string().cuid(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  name: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  createdAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  email: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  image: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  staleReminder: z.union([ z.boolean(),z.lazy(() => BoolFieldUpdateOperationsInputSchema) ]).optional(),
  unsubscribedFromEmailsAt: z.union([ z.coerce.date(),z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  apiKey: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  discordUserId: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  emailVerified: z.union([ z.coerce.date(),z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema) ]).optional().nullable(),
}).strict();

export const ProfileCreateInputSchema: z.ZodType<Prisma.ProfileCreateInput> = z.object({
  createdAt: z.coerce.date().optional(),
  slackId: z.string().optional().nullable(),
  slackTeamId: z.string().optional().nullable(),
  forecasts: z.lazy(() => ForecastCreateNestedManyWithoutProfileInputSchema).optional(),
  user: z.lazy(() => UserCreateNestedOneWithoutProfilesInputSchema),
  questions: z.lazy(() => QuestionCreateNestedManyWithoutProfileInputSchema).optional(),
  resolutionMessages: z.lazy(() => ResolutionSlackMessageCreateNestedManyWithoutProfileInputSchema).optional(),
  target: z.lazy(() => TargetCreateNestedOneWithoutProfileInputSchema).optional()
}).strict();

export const ProfileUncheckedCreateInputSchema: z.ZodType<Prisma.ProfileUncheckedCreateInput> = z.object({
  id: z.number().int().optional(),
  createdAt: z.coerce.date().optional(),
  slackId: z.string().optional().nullable(),
  slackTeamId: z.string().optional().nullable(),
  userId: z.string(),
  forecasts: z.lazy(() => ForecastUncheckedCreateNestedManyWithoutProfileInputSchema).optional(),
  questions: z.lazy(() => QuestionUncheckedCreateNestedManyWithoutProfileInputSchema).optional(),
  resolutionMessages: z.lazy(() => ResolutionSlackMessageUncheckedCreateNestedManyWithoutProfileInputSchema).optional(),
  target: z.lazy(() => TargetUncheckedCreateNestedOneWithoutProfileInputSchema).optional()
}).strict();

export const ProfileUpdateInputSchema: z.ZodType<Prisma.ProfileUpdateInput> = z.object({
  createdAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  slackId: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  slackTeamId: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  forecasts: z.lazy(() => ForecastUpdateManyWithoutProfileNestedInputSchema).optional(),
  user: z.lazy(() => UserUpdateOneRequiredWithoutProfilesNestedInputSchema).optional(),
  questions: z.lazy(() => QuestionUpdateManyWithoutProfileNestedInputSchema).optional(),
  resolutionMessages: z.lazy(() => ResolutionSlackMessageUpdateManyWithoutProfileNestedInputSchema).optional(),
  target: z.lazy(() => TargetUpdateOneWithoutProfileNestedInputSchema).optional()
}).strict();

export const ProfileUncheckedUpdateInputSchema: z.ZodType<Prisma.ProfileUncheckedUpdateInput> = z.object({
  id: z.union([ z.number().int(),z.lazy(() => IntFieldUpdateOperationsInputSchema) ]).optional(),
  createdAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  slackId: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  slackTeamId: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  userId: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  forecasts: z.lazy(() => ForecastUncheckedUpdateManyWithoutProfileNestedInputSchema).optional(),
  questions: z.lazy(() => QuestionUncheckedUpdateManyWithoutProfileNestedInputSchema).optional(),
  resolutionMessages: z.lazy(() => ResolutionSlackMessageUncheckedUpdateManyWithoutProfileNestedInputSchema).optional(),
  target: z.lazy(() => TargetUncheckedUpdateOneWithoutProfileNestedInputSchema).optional()
}).strict();

export const ProfileCreateManyInputSchema: z.ZodType<Prisma.ProfileCreateManyInput> = z.object({
  id: z.number().int().optional(),
  createdAt: z.coerce.date().optional(),
  slackId: z.string().optional().nullable(),
  slackTeamId: z.string().optional().nullable(),
  userId: z.string()
}).strict();

export const ProfileUpdateManyMutationInputSchema: z.ZodType<Prisma.ProfileUpdateManyMutationInput> = z.object({
  createdAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  slackId: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  slackTeamId: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
}).strict();

export const ProfileUncheckedUpdateManyInputSchema: z.ZodType<Prisma.ProfileUncheckedUpdateManyInput> = z.object({
  id: z.union([ z.number().int(),z.lazy(() => IntFieldUpdateOperationsInputSchema) ]).optional(),
  createdAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  slackId: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  slackTeamId: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  userId: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
}).strict();

export const GroupCreateInputSchema: z.ZodType<Prisma.GroupCreateInput> = z.object({
  type: z.lazy(() => GroupTypeSchema),
  createdAt: z.coerce.date().optional(),
  name: z.string(),
  slackTeamId: z.string().optional().nullable()
}).strict();

export const GroupUncheckedCreateInputSchema: z.ZodType<Prisma.GroupUncheckedCreateInput> = z.object({
  id: z.number().int().optional(),
  type: z.lazy(() => GroupTypeSchema),
  createdAt: z.coerce.date().optional(),
  name: z.string(),
  slackTeamId: z.string().optional().nullable()
}).strict();

export const GroupUpdateInputSchema: z.ZodType<Prisma.GroupUpdateInput> = z.object({
  type: z.union([ z.lazy(() => GroupTypeSchema),z.lazy(() => EnumGroupTypeFieldUpdateOperationsInputSchema) ]).optional(),
  createdAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  name: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  slackTeamId: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
}).strict();

export const GroupUncheckedUpdateInputSchema: z.ZodType<Prisma.GroupUncheckedUpdateInput> = z.object({
  id: z.union([ z.number().int(),z.lazy(() => IntFieldUpdateOperationsInputSchema) ]).optional(),
  type: z.union([ z.lazy(() => GroupTypeSchema),z.lazy(() => EnumGroupTypeFieldUpdateOperationsInputSchema) ]).optional(),
  createdAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  name: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  slackTeamId: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
}).strict();

export const GroupCreateManyInputSchema: z.ZodType<Prisma.GroupCreateManyInput> = z.object({
  id: z.number().int().optional(),
  type: z.lazy(() => GroupTypeSchema),
  createdAt: z.coerce.date().optional(),
  name: z.string(),
  slackTeamId: z.string().optional().nullable()
}).strict();

export const GroupUpdateManyMutationInputSchema: z.ZodType<Prisma.GroupUpdateManyMutationInput> = z.object({
  type: z.union([ z.lazy(() => GroupTypeSchema),z.lazy(() => EnumGroupTypeFieldUpdateOperationsInputSchema) ]).optional(),
  createdAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  name: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  slackTeamId: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
}).strict();

export const GroupUncheckedUpdateManyInputSchema: z.ZodType<Prisma.GroupUncheckedUpdateManyInput> = z.object({
  id: z.union([ z.number().int(),z.lazy(() => IntFieldUpdateOperationsInputSchema) ]).optional(),
  type: z.union([ z.lazy(() => GroupTypeSchema),z.lazy(() => EnumGroupTypeFieldUpdateOperationsInputSchema) ]).optional(),
  createdAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  name: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  slackTeamId: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
}).strict();

export const TargetCreateInputSchema: z.ZodType<Prisma.TargetCreateInput> = z.object({
  type: z.lazy(() => TargetTypeSchema),
  goal: z.number().int(),
  lastFailedAt: z.coerce.date().optional(),
  notifyOn: z.lazy(() => DayOfTheWeekSchema),
  lastNotified: z.coerce.date().optional(),
  user: z.lazy(() => UserCreateNestedOneWithoutTargetInputSchema),
  profile: z.lazy(() => ProfileCreateNestedOneWithoutTargetInputSchema).optional()
}).strict();

export const TargetUncheckedCreateInputSchema: z.ZodType<Prisma.TargetUncheckedCreateInput> = z.object({
  id: z.number().int().optional(),
  userId: z.string(),
  profileId: z.number().int().optional().nullable(),
  type: z.lazy(() => TargetTypeSchema),
  goal: z.number().int(),
  lastFailedAt: z.coerce.date().optional(),
  notifyOn: z.lazy(() => DayOfTheWeekSchema),
  lastNotified: z.coerce.date().optional()
}).strict();

export const TargetUpdateInputSchema: z.ZodType<Prisma.TargetUpdateInput> = z.object({
  type: z.union([ z.lazy(() => TargetTypeSchema),z.lazy(() => EnumTargetTypeFieldUpdateOperationsInputSchema) ]).optional(),
  goal: z.union([ z.number().int(),z.lazy(() => IntFieldUpdateOperationsInputSchema) ]).optional(),
  lastFailedAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  notifyOn: z.union([ z.lazy(() => DayOfTheWeekSchema),z.lazy(() => EnumDayOfTheWeekFieldUpdateOperationsInputSchema) ]).optional(),
  lastNotified: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  user: z.lazy(() => UserUpdateOneRequiredWithoutTargetNestedInputSchema).optional(),
  profile: z.lazy(() => ProfileUpdateOneWithoutTargetNestedInputSchema).optional()
}).strict();

export const TargetUncheckedUpdateInputSchema: z.ZodType<Prisma.TargetUncheckedUpdateInput> = z.object({
  id: z.union([ z.number().int(),z.lazy(() => IntFieldUpdateOperationsInputSchema) ]).optional(),
  userId: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  profileId: z.union([ z.number().int(),z.lazy(() => NullableIntFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  type: z.union([ z.lazy(() => TargetTypeSchema),z.lazy(() => EnumTargetTypeFieldUpdateOperationsInputSchema) ]).optional(),
  goal: z.union([ z.number().int(),z.lazy(() => IntFieldUpdateOperationsInputSchema) ]).optional(),
  lastFailedAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  notifyOn: z.union([ z.lazy(() => DayOfTheWeekSchema),z.lazy(() => EnumDayOfTheWeekFieldUpdateOperationsInputSchema) ]).optional(),
  lastNotified: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
}).strict();

export const TargetCreateManyInputSchema: z.ZodType<Prisma.TargetCreateManyInput> = z.object({
  id: z.number().int().optional(),
  userId: z.string(),
  profileId: z.number().int().optional().nullable(),
  type: z.lazy(() => TargetTypeSchema),
  goal: z.number().int(),
  lastFailedAt: z.coerce.date().optional(),
  notifyOn: z.lazy(() => DayOfTheWeekSchema),
  lastNotified: z.coerce.date().optional()
}).strict();

export const TargetUpdateManyMutationInputSchema: z.ZodType<Prisma.TargetUpdateManyMutationInput> = z.object({
  type: z.union([ z.lazy(() => TargetTypeSchema),z.lazy(() => EnumTargetTypeFieldUpdateOperationsInputSchema) ]).optional(),
  goal: z.union([ z.number().int(),z.lazy(() => IntFieldUpdateOperationsInputSchema) ]).optional(),
  lastFailedAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  notifyOn: z.union([ z.lazy(() => DayOfTheWeekSchema),z.lazy(() => EnumDayOfTheWeekFieldUpdateOperationsInputSchema) ]).optional(),
  lastNotified: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
}).strict();

export const TargetUncheckedUpdateManyInputSchema: z.ZodType<Prisma.TargetUncheckedUpdateManyInput> = z.object({
  id: z.union([ z.number().int(),z.lazy(() => IntFieldUpdateOperationsInputSchema) ]).optional(),
  userId: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  profileId: z.union([ z.number().int(),z.lazy(() => NullableIntFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  type: z.union([ z.lazy(() => TargetTypeSchema),z.lazy(() => EnumTargetTypeFieldUpdateOperationsInputSchema) ]).optional(),
  goal: z.union([ z.number().int(),z.lazy(() => IntFieldUpdateOperationsInputSchema) ]).optional(),
  lastFailedAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  notifyOn: z.union([ z.lazy(() => DayOfTheWeekSchema),z.lazy(() => EnumDayOfTheWeekFieldUpdateOperationsInputSchema) ]).optional(),
  lastNotified: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
}).strict();

export const AccountCreateInputSchema: z.ZodType<Prisma.AccountCreateInput> = z.object({
  id: z.string().cuid().optional(),
  type: z.string(),
  provider: z.string(),
  providerAccountId: z.string(),
  refresh_token: z.string().optional().nullable(),
  access_token: z.string().optional().nullable(),
  expires_at: z.number().int().optional().nullable(),
  token_type: z.string().optional().nullable(),
  scope: z.string().optional().nullable(),
  id_token: z.string().optional().nullable(),
  session_state: z.string().optional().nullable(),
  user: z.lazy(() => UserCreateNestedOneWithoutAccountsInputSchema)
}).strict();

export const AccountUncheckedCreateInputSchema: z.ZodType<Prisma.AccountUncheckedCreateInput> = z.object({
  id: z.string().cuid().optional(),
  userId: z.string(),
  type: z.string(),
  provider: z.string(),
  providerAccountId: z.string(),
  refresh_token: z.string().optional().nullable(),
  access_token: z.string().optional().nullable(),
  expires_at: z.number().int().optional().nullable(),
  token_type: z.string().optional().nullable(),
  scope: z.string().optional().nullable(),
  id_token: z.string().optional().nullable(),
  session_state: z.string().optional().nullable()
}).strict();

export const AccountUpdateInputSchema: z.ZodType<Prisma.AccountUpdateInput> = z.object({
  id: z.union([ z.string().cuid(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  type: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  provider: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  providerAccountId: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  refresh_token: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  access_token: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  expires_at: z.union([ z.number().int(),z.lazy(() => NullableIntFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  token_type: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  scope: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  id_token: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  session_state: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  user: z.lazy(() => UserUpdateOneRequiredWithoutAccountsNestedInputSchema).optional()
}).strict();

export const AccountUncheckedUpdateInputSchema: z.ZodType<Prisma.AccountUncheckedUpdateInput> = z.object({
  id: z.union([ z.string().cuid(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  userId: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  type: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  provider: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  providerAccountId: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  refresh_token: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  access_token: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  expires_at: z.union([ z.number().int(),z.lazy(() => NullableIntFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  token_type: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  scope: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  id_token: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  session_state: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
}).strict();

export const AccountCreateManyInputSchema: z.ZodType<Prisma.AccountCreateManyInput> = z.object({
  id: z.string().cuid().optional(),
  userId: z.string(),
  type: z.string(),
  provider: z.string(),
  providerAccountId: z.string(),
  refresh_token: z.string().optional().nullable(),
  access_token: z.string().optional().nullable(),
  expires_at: z.number().int().optional().nullable(),
  token_type: z.string().optional().nullable(),
  scope: z.string().optional().nullable(),
  id_token: z.string().optional().nullable(),
  session_state: z.string().optional().nullable()
}).strict();

export const AccountUpdateManyMutationInputSchema: z.ZodType<Prisma.AccountUpdateManyMutationInput> = z.object({
  id: z.union([ z.string().cuid(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  type: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  provider: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  providerAccountId: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  refresh_token: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  access_token: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  expires_at: z.union([ z.number().int(),z.lazy(() => NullableIntFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  token_type: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  scope: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  id_token: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  session_state: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
}).strict();

export const AccountUncheckedUpdateManyInputSchema: z.ZodType<Prisma.AccountUncheckedUpdateManyInput> = z.object({
  id: z.union([ z.string().cuid(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  userId: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  type: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  provider: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  providerAccountId: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  refresh_token: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  access_token: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  expires_at: z.union([ z.number().int(),z.lazy(() => NullableIntFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  token_type: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  scope: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  id_token: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  session_state: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
}).strict();

export const CommentCreateInputSchema: z.ZodType<Prisma.CommentCreateInput> = z.object({
  createdAt: z.coerce.date().optional(),
  comment: z.string(),
  question: z.lazy(() => QuestionCreateNestedOneWithoutCommentsInputSchema),
  user: z.lazy(() => UserCreateNestedOneWithoutCommentsInputSchema)
}).strict();

export const CommentUncheckedCreateInputSchema: z.ZodType<Prisma.CommentUncheckedCreateInput> = z.object({
  id: z.number().int().optional(),
  createdAt: z.coerce.date().optional(),
  comment: z.string(),
  questionId: z.string(),
  userId: z.string()
}).strict();

export const CommentUpdateInputSchema: z.ZodType<Prisma.CommentUpdateInput> = z.object({
  createdAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  comment: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  question: z.lazy(() => QuestionUpdateOneRequiredWithoutCommentsNestedInputSchema).optional(),
  user: z.lazy(() => UserUpdateOneRequiredWithoutCommentsNestedInputSchema).optional()
}).strict();

export const CommentUncheckedUpdateInputSchema: z.ZodType<Prisma.CommentUncheckedUpdateInput> = z.object({
  id: z.union([ z.number().int(),z.lazy(() => IntFieldUpdateOperationsInputSchema) ]).optional(),
  createdAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  comment: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  questionId: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  userId: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
}).strict();

export const CommentCreateManyInputSchema: z.ZodType<Prisma.CommentCreateManyInput> = z.object({
  id: z.number().int().optional(),
  createdAt: z.coerce.date().optional(),
  comment: z.string(),
  questionId: z.string(),
  userId: z.string()
}).strict();

export const CommentUpdateManyMutationInputSchema: z.ZodType<Prisma.CommentUpdateManyMutationInput> = z.object({
  createdAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  comment: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
}).strict();

export const CommentUncheckedUpdateManyInputSchema: z.ZodType<Prisma.CommentUncheckedUpdateManyInput> = z.object({
  id: z.union([ z.number().int(),z.lazy(() => IntFieldUpdateOperationsInputSchema) ]).optional(),
  createdAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  comment: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  questionId: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  userId: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
}).strict();

export const UserListCreateInputSchema: z.ZodType<Prisma.UserListCreateInput> = z.object({
  id: z.string().cuid().optional(),
  createdAt: z.coerce.date().optional(),
  inviteId: z.string().cuid().optional().nullable(),
  name: z.string(),
  emailDomains: z.union([ z.lazy(() => UserListCreateemailDomainsInputSchema),z.string().array() ]).optional(),
  syncToSlackTeamId: z.string().optional().nullable(),
  syncToSlackChannelId: z.string().optional().nullable(),
  author: z.lazy(() => UserCreateNestedOneWithoutAuthorOfListsInputSchema),
  users: z.lazy(() => UserCreateNestedManyWithoutMemberOfListsInputSchema).optional(),
  questions: z.lazy(() => QuestionCreateNestedManyWithoutSharedWithListsInputSchema).optional(),
  tournaments: z.lazy(() => TournamentCreateNestedManyWithoutUserListInputSchema).optional()
}).strict();

export const UserListUncheckedCreateInputSchema: z.ZodType<Prisma.UserListUncheckedCreateInput> = z.object({
  id: z.string().cuid().optional(),
  createdAt: z.coerce.date().optional(),
  inviteId: z.string().cuid().optional().nullable(),
  name: z.string(),
  emailDomains: z.union([ z.lazy(() => UserListCreateemailDomainsInputSchema),z.string().array() ]).optional(),
  syncToSlackTeamId: z.string().optional().nullable(),
  syncToSlackChannelId: z.string().optional().nullable(),
  authorId: z.string(),
  users: z.lazy(() => UserUncheckedCreateNestedManyWithoutMemberOfListsInputSchema).optional(),
  questions: z.lazy(() => QuestionUncheckedCreateNestedManyWithoutSharedWithListsInputSchema).optional(),
  tournaments: z.lazy(() => TournamentUncheckedCreateNestedManyWithoutUserListInputSchema).optional()
}).strict();

export const UserListUpdateInputSchema: z.ZodType<Prisma.UserListUpdateInput> = z.object({
  id: z.union([ z.string().cuid(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  createdAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  inviteId: z.union([ z.string().cuid(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  name: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  emailDomains: z.union([ z.lazy(() => UserListUpdateemailDomainsInputSchema),z.string().array() ]).optional(),
  syncToSlackTeamId: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  syncToSlackChannelId: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  author: z.lazy(() => UserUpdateOneRequiredWithoutAuthorOfListsNestedInputSchema).optional(),
  users: z.lazy(() => UserUpdateManyWithoutMemberOfListsNestedInputSchema).optional(),
  questions: z.lazy(() => QuestionUpdateManyWithoutSharedWithListsNestedInputSchema).optional(),
  tournaments: z.lazy(() => TournamentUpdateManyWithoutUserListNestedInputSchema).optional()
}).strict();

export const UserListUncheckedUpdateInputSchema: z.ZodType<Prisma.UserListUncheckedUpdateInput> = z.object({
  id: z.union([ z.string().cuid(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  createdAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  inviteId: z.union([ z.string().cuid(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  name: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  emailDomains: z.union([ z.lazy(() => UserListUpdateemailDomainsInputSchema),z.string().array() ]).optional(),
  syncToSlackTeamId: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  syncToSlackChannelId: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  authorId: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  users: z.lazy(() => UserUncheckedUpdateManyWithoutMemberOfListsNestedInputSchema).optional(),
  questions: z.lazy(() => QuestionUncheckedUpdateManyWithoutSharedWithListsNestedInputSchema).optional(),
  tournaments: z.lazy(() => TournamentUncheckedUpdateManyWithoutUserListNestedInputSchema).optional()
}).strict();

export const UserListCreateManyInputSchema: z.ZodType<Prisma.UserListCreateManyInput> = z.object({
  id: z.string().cuid().optional(),
  createdAt: z.coerce.date().optional(),
  inviteId: z.string().cuid().optional().nullable(),
  name: z.string(),
  emailDomains: z.union([ z.lazy(() => UserListCreateemailDomainsInputSchema),z.string().array() ]).optional(),
  syncToSlackTeamId: z.string().optional().nullable(),
  syncToSlackChannelId: z.string().optional().nullable(),
  authorId: z.string()
}).strict();

export const UserListUpdateManyMutationInputSchema: z.ZodType<Prisma.UserListUpdateManyMutationInput> = z.object({
  id: z.union([ z.string().cuid(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  createdAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  inviteId: z.union([ z.string().cuid(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  name: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  emailDomains: z.union([ z.lazy(() => UserListUpdateemailDomainsInputSchema),z.string().array() ]).optional(),
  syncToSlackTeamId: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  syncToSlackChannelId: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
}).strict();

export const UserListUncheckedUpdateManyInputSchema: z.ZodType<Prisma.UserListUncheckedUpdateManyInput> = z.object({
  id: z.union([ z.string().cuid(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  createdAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  inviteId: z.union([ z.string().cuid(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  name: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  emailDomains: z.union([ z.lazy(() => UserListUpdateemailDomainsInputSchema),z.string().array() ]).optional(),
  syncToSlackTeamId: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  syncToSlackChannelId: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  authorId: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
}).strict();

export const TournamentCreateInputSchema: z.ZodType<Prisma.TournamentCreateInput> = z.object({
  id: z.string().cuid().optional(),
  createdAt: z.coerce.date().optional(),
  name: z.string(),
  description: z.string().optional().nullable(),
  sharedPublicly: z.boolean().optional(),
  unlisted: z.boolean().optional(),
  anyoneInListCanEdit: z.boolean().optional(),
  showLeaderboard: z.boolean().optional(),
  predictYourYear: z.number().int().optional().nullable(),
  syncToSlackTeamId: z.string().optional().nullable(),
  syncToSlackChannelId: z.string().optional().nullable(),
  questions: z.lazy(() => QuestionCreateNestedManyWithoutTournamentsInputSchema).optional(),
  author: z.lazy(() => UserCreateNestedOneWithoutTournamentsInputSchema),
  userList: z.lazy(() => UserListCreateNestedOneWithoutTournamentsInputSchema).optional()
}).strict();

export const TournamentUncheckedCreateInputSchema: z.ZodType<Prisma.TournamentUncheckedCreateInput> = z.object({
  id: z.string().cuid().optional(),
  createdAt: z.coerce.date().optional(),
  name: z.string(),
  description: z.string().optional().nullable(),
  authorId: z.string(),
  sharedPublicly: z.boolean().optional(),
  unlisted: z.boolean().optional(),
  userListId: z.string().optional().nullable(),
  anyoneInListCanEdit: z.boolean().optional(),
  showLeaderboard: z.boolean().optional(),
  predictYourYear: z.number().int().optional().nullable(),
  syncToSlackTeamId: z.string().optional().nullable(),
  syncToSlackChannelId: z.string().optional().nullable(),
  questions: z.lazy(() => QuestionUncheckedCreateNestedManyWithoutTournamentsInputSchema).optional()
}).strict();

export const TournamentUpdateInputSchema: z.ZodType<Prisma.TournamentUpdateInput> = z.object({
  id: z.union([ z.string().cuid(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  createdAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  name: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  description: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  sharedPublicly: z.union([ z.boolean(),z.lazy(() => BoolFieldUpdateOperationsInputSchema) ]).optional(),
  unlisted: z.union([ z.boolean(),z.lazy(() => BoolFieldUpdateOperationsInputSchema) ]).optional(),
  anyoneInListCanEdit: z.union([ z.boolean(),z.lazy(() => BoolFieldUpdateOperationsInputSchema) ]).optional(),
  showLeaderboard: z.union([ z.boolean(),z.lazy(() => BoolFieldUpdateOperationsInputSchema) ]).optional(),
  predictYourYear: z.union([ z.number().int(),z.lazy(() => NullableIntFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  syncToSlackTeamId: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  syncToSlackChannelId: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  questions: z.lazy(() => QuestionUpdateManyWithoutTournamentsNestedInputSchema).optional(),
  author: z.lazy(() => UserUpdateOneRequiredWithoutTournamentsNestedInputSchema).optional(),
  userList: z.lazy(() => UserListUpdateOneWithoutTournamentsNestedInputSchema).optional()
}).strict();

export const TournamentUncheckedUpdateInputSchema: z.ZodType<Prisma.TournamentUncheckedUpdateInput> = z.object({
  id: z.union([ z.string().cuid(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  createdAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  name: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  description: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  authorId: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  sharedPublicly: z.union([ z.boolean(),z.lazy(() => BoolFieldUpdateOperationsInputSchema) ]).optional(),
  unlisted: z.union([ z.boolean(),z.lazy(() => BoolFieldUpdateOperationsInputSchema) ]).optional(),
  userListId: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  anyoneInListCanEdit: z.union([ z.boolean(),z.lazy(() => BoolFieldUpdateOperationsInputSchema) ]).optional(),
  showLeaderboard: z.union([ z.boolean(),z.lazy(() => BoolFieldUpdateOperationsInputSchema) ]).optional(),
  predictYourYear: z.union([ z.number().int(),z.lazy(() => NullableIntFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  syncToSlackTeamId: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  syncToSlackChannelId: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  questions: z.lazy(() => QuestionUncheckedUpdateManyWithoutTournamentsNestedInputSchema).optional()
}).strict();

export const TournamentCreateManyInputSchema: z.ZodType<Prisma.TournamentCreateManyInput> = z.object({
  id: z.string().cuid().optional(),
  createdAt: z.coerce.date().optional(),
  name: z.string(),
  description: z.string().optional().nullable(),
  authorId: z.string(),
  sharedPublicly: z.boolean().optional(),
  unlisted: z.boolean().optional(),
  userListId: z.string().optional().nullable(),
  anyoneInListCanEdit: z.boolean().optional(),
  showLeaderboard: z.boolean().optional(),
  predictYourYear: z.number().int().optional().nullable(),
  syncToSlackTeamId: z.string().optional().nullable(),
  syncToSlackChannelId: z.string().optional().nullable()
}).strict();

export const TournamentUpdateManyMutationInputSchema: z.ZodType<Prisma.TournamentUpdateManyMutationInput> = z.object({
  id: z.union([ z.string().cuid(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  createdAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  name: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  description: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  sharedPublicly: z.union([ z.boolean(),z.lazy(() => BoolFieldUpdateOperationsInputSchema) ]).optional(),
  unlisted: z.union([ z.boolean(),z.lazy(() => BoolFieldUpdateOperationsInputSchema) ]).optional(),
  anyoneInListCanEdit: z.union([ z.boolean(),z.lazy(() => BoolFieldUpdateOperationsInputSchema) ]).optional(),
  showLeaderboard: z.union([ z.boolean(),z.lazy(() => BoolFieldUpdateOperationsInputSchema) ]).optional(),
  predictYourYear: z.union([ z.number().int(),z.lazy(() => NullableIntFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  syncToSlackTeamId: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  syncToSlackChannelId: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
}).strict();

export const TournamentUncheckedUpdateManyInputSchema: z.ZodType<Prisma.TournamentUncheckedUpdateManyInput> = z.object({
  id: z.union([ z.string().cuid(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  createdAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  name: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  description: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  authorId: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  sharedPublicly: z.union([ z.boolean(),z.lazy(() => BoolFieldUpdateOperationsInputSchema) ]).optional(),
  unlisted: z.union([ z.boolean(),z.lazy(() => BoolFieldUpdateOperationsInputSchema) ]).optional(),
  userListId: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  anyoneInListCanEdit: z.union([ z.boolean(),z.lazy(() => BoolFieldUpdateOperationsInputSchema) ]).optional(),
  showLeaderboard: z.union([ z.boolean(),z.lazy(() => BoolFieldUpdateOperationsInputSchema) ]).optional(),
  predictYourYear: z.union([ z.number().int(),z.lazy(() => NullableIntFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  syncToSlackTeamId: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  syncToSlackChannelId: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
}).strict();

export const NotificationCreateInputSchema: z.ZodType<Prisma.NotificationCreateInput> = z.object({
  id: z.string().cuid().optional(),
  createdAt: z.coerce.date().optional(),
  emailSentAt: z.coerce.date().optional().nullable(),
  title: z.string(),
  content: z.string(),
  url: z.string().optional().nullable(),
  tags: z.union([ z.lazy(() => NotificationCreatetagsInputSchema),z.string().array() ]).optional(),
  read: z.boolean().optional(),
  user: z.lazy(() => UserCreateNestedOneWithoutNotificationsInputSchema),
  question: z.lazy(() => QuestionCreateNestedOneWithoutNotificationsInputSchema).optional()
}).strict();

export const NotificationUncheckedCreateInputSchema: z.ZodType<Prisma.NotificationUncheckedCreateInput> = z.object({
  id: z.string().cuid().optional(),
  createdAt: z.coerce.date().optional(),
  emailSentAt: z.coerce.date().optional().nullable(),
  title: z.string(),
  content: z.string(),
  url: z.string().optional().nullable(),
  tags: z.union([ z.lazy(() => NotificationCreatetagsInputSchema),z.string().array() ]).optional(),
  read: z.boolean().optional(),
  userId: z.string(),
  questionId: z.string().optional().nullable()
}).strict();

export const NotificationUpdateInputSchema: z.ZodType<Prisma.NotificationUpdateInput> = z.object({
  id: z.union([ z.string().cuid(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  createdAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  emailSentAt: z.union([ z.coerce.date(),z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  title: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  content: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  url: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  tags: z.union([ z.lazy(() => NotificationUpdatetagsInputSchema),z.string().array() ]).optional(),
  read: z.union([ z.boolean(),z.lazy(() => BoolFieldUpdateOperationsInputSchema) ]).optional(),
  user: z.lazy(() => UserUpdateOneRequiredWithoutNotificationsNestedInputSchema).optional(),
  question: z.lazy(() => QuestionUpdateOneWithoutNotificationsNestedInputSchema).optional()
}).strict();

export const NotificationUncheckedUpdateInputSchema: z.ZodType<Prisma.NotificationUncheckedUpdateInput> = z.object({
  id: z.union([ z.string().cuid(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  createdAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  emailSentAt: z.union([ z.coerce.date(),z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  title: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  content: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  url: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  tags: z.union([ z.lazy(() => NotificationUpdatetagsInputSchema),z.string().array() ]).optional(),
  read: z.union([ z.boolean(),z.lazy(() => BoolFieldUpdateOperationsInputSchema) ]).optional(),
  userId: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  questionId: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
}).strict();

export const NotificationCreateManyInputSchema: z.ZodType<Prisma.NotificationCreateManyInput> = z.object({
  id: z.string().cuid().optional(),
  createdAt: z.coerce.date().optional(),
  emailSentAt: z.coerce.date().optional().nullable(),
  title: z.string(),
  content: z.string(),
  url: z.string().optional().nullable(),
  tags: z.union([ z.lazy(() => NotificationCreatetagsInputSchema),z.string().array() ]).optional(),
  read: z.boolean().optional(),
  userId: z.string(),
  questionId: z.string().optional().nullable()
}).strict();

export const NotificationUpdateManyMutationInputSchema: z.ZodType<Prisma.NotificationUpdateManyMutationInput> = z.object({
  id: z.union([ z.string().cuid(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  createdAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  emailSentAt: z.union([ z.coerce.date(),z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  title: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  content: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  url: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  tags: z.union([ z.lazy(() => NotificationUpdatetagsInputSchema),z.string().array() ]).optional(),
  read: z.union([ z.boolean(),z.lazy(() => BoolFieldUpdateOperationsInputSchema) ]).optional(),
}).strict();

export const NotificationUncheckedUpdateManyInputSchema: z.ZodType<Prisma.NotificationUncheckedUpdateManyInput> = z.object({
  id: z.union([ z.string().cuid(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  createdAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  emailSentAt: z.union([ z.coerce.date(),z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  title: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  content: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  url: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  tags: z.union([ z.lazy(() => NotificationUpdatetagsInputSchema),z.string().array() ]).optional(),
  read: z.union([ z.boolean(),z.lazy(() => BoolFieldUpdateOperationsInputSchema) ]).optional(),
  userId: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  questionId: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
}).strict();

export const FeedbackCreateInputSchema: z.ZodType<Prisma.FeedbackCreateInput> = z.object({
  id: z.string().cuid().optional(),
  createdAt: z.coerce.date().optional(),
  type: z.string(),
  message: z.string(),
  email: z.string().optional().nullable(),
  userId: z.string().optional().nullable()
}).strict();

export const FeedbackUncheckedCreateInputSchema: z.ZodType<Prisma.FeedbackUncheckedCreateInput> = z.object({
  id: z.string().cuid().optional(),
  createdAt: z.coerce.date().optional(),
  type: z.string(),
  message: z.string(),
  email: z.string().optional().nullable(),
  userId: z.string().optional().nullable()
}).strict();

export const FeedbackUpdateInputSchema: z.ZodType<Prisma.FeedbackUpdateInput> = z.object({
  id: z.union([ z.string().cuid(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  createdAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  type: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  message: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  email: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  userId: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
}).strict();

export const FeedbackUncheckedUpdateInputSchema: z.ZodType<Prisma.FeedbackUncheckedUpdateInput> = z.object({
  id: z.union([ z.string().cuid(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  createdAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  type: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  message: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  email: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  userId: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
}).strict();

export const FeedbackCreateManyInputSchema: z.ZodType<Prisma.FeedbackCreateManyInput> = z.object({
  id: z.string().cuid().optional(),
  createdAt: z.coerce.date().optional(),
  type: z.string(),
  message: z.string(),
  email: z.string().optional().nullable(),
  userId: z.string().optional().nullable()
}).strict();

export const FeedbackUpdateManyMutationInputSchema: z.ZodType<Prisma.FeedbackUpdateManyMutationInput> = z.object({
  id: z.union([ z.string().cuid(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  createdAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  type: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  message: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  email: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  userId: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
}).strict();

export const FeedbackUncheckedUpdateManyInputSchema: z.ZodType<Prisma.FeedbackUncheckedUpdateManyInput> = z.object({
  id: z.union([ z.string().cuid(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  createdAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  type: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  message: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  email: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  userId: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
}).strict();

export const StringFilterSchema: z.ZodType<Prisma.StringFilter> = z.object({
  equals: z.string().optional(),
  in: z.string().array().optional(),
  notIn: z.string().array().optional(),
  lt: z.string().optional(),
  lte: z.string().optional(),
  gt: z.string().optional(),
  gte: z.string().optional(),
  contains: z.string().optional(),
  startsWith: z.string().optional(),
  endsWith: z.string().optional(),
  search: z.string().optional(),
  mode: z.lazy(() => QueryModeSchema).optional(),
  not: z.union([ z.string(),z.lazy(() => NestedStringFilterSchema) ]).optional(),
}).strict();

export const DateTimeFilterSchema: z.ZodType<Prisma.DateTimeFilter> = z.object({
  equals: z.coerce.date().optional(),
  in: z.coerce.date().array().optional(),
  notIn: z.coerce.date().array().optional(),
  lt: z.coerce.date().optional(),
  lte: z.coerce.date().optional(),
  gt: z.coerce.date().optional(),
  gte: z.coerce.date().optional(),
  not: z.union([ z.coerce.date(),z.lazy(() => NestedDateTimeFilterSchema) ]).optional(),
}).strict();

export const WorkspaceOrderByRelevanceInputSchema: z.ZodType<Prisma.WorkspaceOrderByRelevanceInput> = z.object({
  fields: z.union([ z.lazy(() => WorkspaceOrderByRelevanceFieldEnumSchema),z.lazy(() => WorkspaceOrderByRelevanceFieldEnumSchema).array() ]),
  sort: z.lazy(() => SortOrderSchema),
  search: z.string()
}).strict();

export const WorkspaceCountOrderByAggregateInputSchema: z.ZodType<Prisma.WorkspaceCountOrderByAggregateInput> = z.object({
  teamId: z.lazy(() => SortOrderSchema).optional(),
  teamName: z.lazy(() => SortOrderSchema).optional(),
  token: z.lazy(() => SortOrderSchema).optional(),
  createdAt: z.lazy(() => SortOrderSchema).optional()
}).strict();

export const WorkspaceMaxOrderByAggregateInputSchema: z.ZodType<Prisma.WorkspaceMaxOrderByAggregateInput> = z.object({
  teamId: z.lazy(() => SortOrderSchema).optional(),
  teamName: z.lazy(() => SortOrderSchema).optional(),
  token: z.lazy(() => SortOrderSchema).optional(),
  createdAt: z.lazy(() => SortOrderSchema).optional()
}).strict();

export const WorkspaceMinOrderByAggregateInputSchema: z.ZodType<Prisma.WorkspaceMinOrderByAggregateInput> = z.object({
  teamId: z.lazy(() => SortOrderSchema).optional(),
  teamName: z.lazy(() => SortOrderSchema).optional(),
  token: z.lazy(() => SortOrderSchema).optional(),
  createdAt: z.lazy(() => SortOrderSchema).optional()
}).strict();

export const StringWithAggregatesFilterSchema: z.ZodType<Prisma.StringWithAggregatesFilter> = z.object({
  equals: z.string().optional(),
  in: z.string().array().optional(),
  notIn: z.string().array().optional(),
  lt: z.string().optional(),
  lte: z.string().optional(),
  gt: z.string().optional(),
  gte: z.string().optional(),
  contains: z.string().optional(),
  startsWith: z.string().optional(),
  endsWith: z.string().optional(),
  search: z.string().optional(),
  mode: z.lazy(() => QueryModeSchema).optional(),
  not: z.union([ z.string(),z.lazy(() => NestedStringWithAggregatesFilterSchema) ]).optional(),
  _count: z.lazy(() => NestedIntFilterSchema).optional(),
  _min: z.lazy(() => NestedStringFilterSchema).optional(),
  _max: z.lazy(() => NestedStringFilterSchema).optional()
}).strict();

export const DateTimeWithAggregatesFilterSchema: z.ZodType<Prisma.DateTimeWithAggregatesFilter> = z.object({
  equals: z.coerce.date().optional(),
  in: z.coerce.date().array().optional(),
  notIn: z.coerce.date().array().optional(),
  lt: z.coerce.date().optional(),
  lte: z.coerce.date().optional(),
  gt: z.coerce.date().optional(),
  gte: z.coerce.date().optional(),
  not: z.union([ z.coerce.date(),z.lazy(() => NestedDateTimeWithAggregatesFilterSchema) ]).optional(),
  _count: z.lazy(() => NestedIntFilterSchema).optional(),
  _min: z.lazy(() => NestedDateTimeFilterSchema).optional(),
  _max: z.lazy(() => NestedDateTimeFilterSchema).optional()
}).strict();

export const IntFilterSchema: z.ZodType<Prisma.IntFilter> = z.object({
  equals: z.number().optional(),
  in: z.number().array().optional(),
  notIn: z.number().array().optional(),
  lt: z.number().optional(),
  lte: z.number().optional(),
  gt: z.number().optional(),
  gte: z.number().optional(),
  not: z.union([ z.number(),z.lazy(() => NestedIntFilterSchema) ]).optional(),
}).strict();

export const StringNullableFilterSchema: z.ZodType<Prisma.StringNullableFilter> = z.object({
  equals: z.string().optional().nullable(),
  in: z.string().array().optional().nullable(),
  notIn: z.string().array().optional().nullable(),
  lt: z.string().optional(),
  lte: z.string().optional(),
  gt: z.string().optional(),
  gte: z.string().optional(),
  contains: z.string().optional(),
  startsWith: z.string().optional(),
  endsWith: z.string().optional(),
  search: z.string().optional(),
  mode: z.lazy(() => QueryModeSchema).optional(),
  not: z.union([ z.string(),z.lazy(() => NestedStringNullableFilterSchema) ]).optional().nullable(),
}).strict();

export const DecimalFilterSchema: z.ZodType<Prisma.DecimalFilter> = z.object({
  equals: z.union([z.number(),z.string(),z.instanceof(Decimal),z.instanceof(Prisma.Decimal),DecimalJsLikeSchema,]).refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' }).optional(),
  in: z.union([z.number().array(),z.string().array(),z.instanceof(Decimal).array(),z.instanceof(Prisma.Decimal).array(),DecimalJsLikeSchema.array(),]).refine((v) => Array.isArray(v) && (v as any[]).every((v) => isValidDecimalInput(v)), { message: 'Must be a Decimal' }).optional(),
  notIn: z.union([z.number().array(),z.string().array(),z.instanceof(Decimal).array(),z.instanceof(Prisma.Decimal).array(),DecimalJsLikeSchema.array(),]).refine((v) => Array.isArray(v) && (v as any[]).every((v) => isValidDecimalInput(v)), { message: 'Must be a Decimal' }).optional(),
  lt: z.union([z.number(),z.string(),z.instanceof(Decimal),z.instanceof(Prisma.Decimal),DecimalJsLikeSchema,]).refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' }).optional(),
  lte: z.union([z.number(),z.string(),z.instanceof(Decimal),z.instanceof(Prisma.Decimal),DecimalJsLikeSchema,]).refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' }).optional(),
  gt: z.union([z.number(),z.string(),z.instanceof(Decimal),z.instanceof(Prisma.Decimal),DecimalJsLikeSchema,]).refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' }).optional(),
  gte: z.union([z.number(),z.string(),z.instanceof(Decimal),z.instanceof(Prisma.Decimal),DecimalJsLikeSchema,]).refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' }).optional(),
  not: z.union([ z.union([z.number(),z.string(),z.instanceof(Decimal),z.instanceof(Prisma.Decimal),DecimalJsLikeSchema,]).refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' }),z.lazy(() => NestedDecimalFilterSchema) ]).optional(),
}).strict();

export const IntNullableFilterSchema: z.ZodType<Prisma.IntNullableFilter> = z.object({
  equals: z.number().optional().nullable(),
  in: z.number().array().optional().nullable(),
  notIn: z.number().array().optional().nullable(),
  lt: z.number().optional(),
  lte: z.number().optional(),
  gt: z.number().optional(),
  gte: z.number().optional(),
  not: z.union([ z.number(),z.lazy(() => NestedIntNullableFilterSchema) ]).optional().nullable(),
}).strict();

export const QuestionOptionNullableRelationFilterSchema: z.ZodType<Prisma.QuestionOptionNullableRelationFilter> = z.object({
  is: z.lazy(() => QuestionOptionWhereInputSchema).optional().nullable(),
  isNot: z.lazy(() => QuestionOptionWhereInputSchema).optional().nullable()
}).strict();

export const ProfileNullableRelationFilterSchema: z.ZodType<Prisma.ProfileNullableRelationFilter> = z.object({
  is: z.lazy(() => ProfileWhereInputSchema).optional().nullable(),
  isNot: z.lazy(() => ProfileWhereInputSchema).optional().nullable()
}).strict();

export const QuestionRelationFilterSchema: z.ZodType<Prisma.QuestionRelationFilter> = z.object({
  is: z.lazy(() => QuestionWhereInputSchema).optional(),
  isNot: z.lazy(() => QuestionWhereInputSchema).optional()
}).strict();

export const UserRelationFilterSchema: z.ZodType<Prisma.UserRelationFilter> = z.object({
  is: z.lazy(() => UserWhereInputSchema).optional(),
  isNot: z.lazy(() => UserWhereInputSchema).optional()
}).strict();

export const SortOrderInputSchema: z.ZodType<Prisma.SortOrderInput> = z.object({
  sort: z.lazy(() => SortOrderSchema),
  nulls: z.lazy(() => NullsOrderSchema).optional()
}).strict();

export const ForecastOrderByRelevanceInputSchema: z.ZodType<Prisma.ForecastOrderByRelevanceInput> = z.object({
  fields: z.union([ z.lazy(() => ForecastOrderByRelevanceFieldEnumSchema),z.lazy(() => ForecastOrderByRelevanceFieldEnumSchema).array() ]),
  sort: z.lazy(() => SortOrderSchema),
  search: z.string()
}).strict();

export const ForecastCountOrderByAggregateInputSchema: z.ZodType<Prisma.ForecastCountOrderByAggregateInput> = z.object({
  id: z.lazy(() => SortOrderSchema).optional(),
  createdAt: z.lazy(() => SortOrderSchema).optional(),
  comment: z.lazy(() => SortOrderSchema).optional(),
  forecast: z.lazy(() => SortOrderSchema).optional(),
  profileId: z.lazy(() => SortOrderSchema).optional(),
  questionId: z.lazy(() => SortOrderSchema).optional(),
  optionId: z.lazy(() => SortOrderSchema).optional(),
  userId: z.lazy(() => SortOrderSchema).optional()
}).strict();

export const ForecastAvgOrderByAggregateInputSchema: z.ZodType<Prisma.ForecastAvgOrderByAggregateInput> = z.object({
  id: z.lazy(() => SortOrderSchema).optional(),
  forecast: z.lazy(() => SortOrderSchema).optional(),
  profileId: z.lazy(() => SortOrderSchema).optional()
}).strict();

export const ForecastMaxOrderByAggregateInputSchema: z.ZodType<Prisma.ForecastMaxOrderByAggregateInput> = z.object({
  id: z.lazy(() => SortOrderSchema).optional(),
  createdAt: z.lazy(() => SortOrderSchema).optional(),
  comment: z.lazy(() => SortOrderSchema).optional(),
  forecast: z.lazy(() => SortOrderSchema).optional(),
  profileId: z.lazy(() => SortOrderSchema).optional(),
  questionId: z.lazy(() => SortOrderSchema).optional(),
  optionId: z.lazy(() => SortOrderSchema).optional(),
  userId: z.lazy(() => SortOrderSchema).optional()
}).strict();

export const ForecastMinOrderByAggregateInputSchema: z.ZodType<Prisma.ForecastMinOrderByAggregateInput> = z.object({
  id: z.lazy(() => SortOrderSchema).optional(),
  createdAt: z.lazy(() => SortOrderSchema).optional(),
  comment: z.lazy(() => SortOrderSchema).optional(),
  forecast: z.lazy(() => SortOrderSchema).optional(),
  profileId: z.lazy(() => SortOrderSchema).optional(),
  questionId: z.lazy(() => SortOrderSchema).optional(),
  optionId: z.lazy(() => SortOrderSchema).optional(),
  userId: z.lazy(() => SortOrderSchema).optional()
}).strict();

export const ForecastSumOrderByAggregateInputSchema: z.ZodType<Prisma.ForecastSumOrderByAggregateInput> = z.object({
  id: z.lazy(() => SortOrderSchema).optional(),
  forecast: z.lazy(() => SortOrderSchema).optional(),
  profileId: z.lazy(() => SortOrderSchema).optional()
}).strict();

export const IntWithAggregatesFilterSchema: z.ZodType<Prisma.IntWithAggregatesFilter> = z.object({
  equals: z.number().optional(),
  in: z.number().array().optional(),
  notIn: z.number().array().optional(),
  lt: z.number().optional(),
  lte: z.number().optional(),
  gt: z.number().optional(),
  gte: z.number().optional(),
  not: z.union([ z.number(),z.lazy(() => NestedIntWithAggregatesFilterSchema) ]).optional(),
  _count: z.lazy(() => NestedIntFilterSchema).optional(),
  _avg: z.lazy(() => NestedFloatFilterSchema).optional(),
  _sum: z.lazy(() => NestedIntFilterSchema).optional(),
  _min: z.lazy(() => NestedIntFilterSchema).optional(),
  _max: z.lazy(() => NestedIntFilterSchema).optional()
}).strict();

export const StringNullableWithAggregatesFilterSchema: z.ZodType<Prisma.StringNullableWithAggregatesFilter> = z.object({
  equals: z.string().optional().nullable(),
  in: z.string().array().optional().nullable(),
  notIn: z.string().array().optional().nullable(),
  lt: z.string().optional(),
  lte: z.string().optional(),
  gt: z.string().optional(),
  gte: z.string().optional(),
  contains: z.string().optional(),
  startsWith: z.string().optional(),
  endsWith: z.string().optional(),
  search: z.string().optional(),
  mode: z.lazy(() => QueryModeSchema).optional(),
  not: z.union([ z.string(),z.lazy(() => NestedStringNullableWithAggregatesFilterSchema) ]).optional().nullable(),
  _count: z.lazy(() => NestedIntNullableFilterSchema).optional(),
  _min: z.lazy(() => NestedStringNullableFilterSchema).optional(),
  _max: z.lazy(() => NestedStringNullableFilterSchema).optional()
}).strict();

export const DecimalWithAggregatesFilterSchema: z.ZodType<Prisma.DecimalWithAggregatesFilter> = z.object({
  equals: z.union([z.number(),z.string(),z.instanceof(Decimal),z.instanceof(Prisma.Decimal),DecimalJsLikeSchema,]).refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' }).optional(),
  in: z.union([z.number().array(),z.string().array(),z.instanceof(Decimal).array(),z.instanceof(Prisma.Decimal).array(),DecimalJsLikeSchema.array(),]).refine((v) => Array.isArray(v) && (v as any[]).every((v) => isValidDecimalInput(v)), { message: 'Must be a Decimal' }).optional(),
  notIn: z.union([z.number().array(),z.string().array(),z.instanceof(Decimal).array(),z.instanceof(Prisma.Decimal).array(),DecimalJsLikeSchema.array(),]).refine((v) => Array.isArray(v) && (v as any[]).every((v) => isValidDecimalInput(v)), { message: 'Must be a Decimal' }).optional(),
  lt: z.union([z.number(),z.string(),z.instanceof(Decimal),z.instanceof(Prisma.Decimal),DecimalJsLikeSchema,]).refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' }).optional(),
  lte: z.union([z.number(),z.string(),z.instanceof(Decimal),z.instanceof(Prisma.Decimal),DecimalJsLikeSchema,]).refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' }).optional(),
  gt: z.union([z.number(),z.string(),z.instanceof(Decimal),z.instanceof(Prisma.Decimal),DecimalJsLikeSchema,]).refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' }).optional(),
  gte: z.union([z.number(),z.string(),z.instanceof(Decimal),z.instanceof(Prisma.Decimal),DecimalJsLikeSchema,]).refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' }).optional(),
  not: z.union([ z.union([z.number(),z.string(),z.instanceof(Decimal),z.instanceof(Prisma.Decimal),DecimalJsLikeSchema,]).refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' }),z.lazy(() => NestedDecimalWithAggregatesFilterSchema) ]).optional(),
  _count: z.lazy(() => NestedIntFilterSchema).optional(),
  _avg: z.lazy(() => NestedDecimalFilterSchema).optional(),
  _sum: z.lazy(() => NestedDecimalFilterSchema).optional(),
  _min: z.lazy(() => NestedDecimalFilterSchema).optional(),
  _max: z.lazy(() => NestedDecimalFilterSchema).optional()
}).strict();

export const IntNullableWithAggregatesFilterSchema: z.ZodType<Prisma.IntNullableWithAggregatesFilter> = z.object({
  equals: z.number().optional().nullable(),
  in: z.number().array().optional().nullable(),
  notIn: z.number().array().optional().nullable(),
  lt: z.number().optional(),
  lte: z.number().optional(),
  gt: z.number().optional(),
  gte: z.number().optional(),
  not: z.union([ z.number(),z.lazy(() => NestedIntNullableWithAggregatesFilterSchema) ]).optional().nullable(),
  _count: z.lazy(() => NestedIntNullableFilterSchema).optional(),
  _avg: z.lazy(() => NestedFloatNullableFilterSchema).optional(),
  _sum: z.lazy(() => NestedIntNullableFilterSchema).optional(),
  _min: z.lazy(() => NestedIntNullableFilterSchema).optional(),
  _max: z.lazy(() => NestedIntNullableFilterSchema).optional()
}).strict();

export const DecimalNullableFilterSchema: z.ZodType<Prisma.DecimalNullableFilter> = z.object({
  equals: z.union([z.number(),z.string(),z.instanceof(Decimal),z.instanceof(Prisma.Decimal),DecimalJsLikeSchema,]).refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' }).optional().nullable(),
  in: z.union([z.number().array(),z.string().array(),z.instanceof(Decimal).array(),z.instanceof(Prisma.Decimal).array(),DecimalJsLikeSchema.array(),]).refine((v) => Array.isArray(v) && (v as any[]).every((v) => isValidDecimalInput(v)), { message: 'Must be a Decimal' }).optional().nullable(),
  notIn: z.union([z.number().array(),z.string().array(),z.instanceof(Decimal).array(),z.instanceof(Prisma.Decimal).array(),DecimalJsLikeSchema.array(),]).refine((v) => Array.isArray(v) && (v as any[]).every((v) => isValidDecimalInput(v)), { message: 'Must be a Decimal' }).optional().nullable(),
  lt: z.union([z.number(),z.string(),z.instanceof(Decimal),z.instanceof(Prisma.Decimal),DecimalJsLikeSchema,]).refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' }).optional(),
  lte: z.union([z.number(),z.string(),z.instanceof(Decimal),z.instanceof(Prisma.Decimal),DecimalJsLikeSchema,]).refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' }).optional(),
  gt: z.union([z.number(),z.string(),z.instanceof(Decimal),z.instanceof(Prisma.Decimal),DecimalJsLikeSchema,]).refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' }).optional(),
  gte: z.union([z.number(),z.string(),z.instanceof(Decimal),z.instanceof(Prisma.Decimal),DecimalJsLikeSchema,]).refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' }).optional(),
  not: z.union([ z.union([z.number(),z.string(),z.instanceof(Decimal),z.instanceof(Prisma.Decimal),DecimalJsLikeSchema,]).refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' }),z.lazy(() => NestedDecimalNullableFilterSchema) ]).optional().nullable(),
}).strict();

export const QuestionScoreOrderByRelevanceInputSchema: z.ZodType<Prisma.QuestionScoreOrderByRelevanceInput> = z.object({
  fields: z.union([ z.lazy(() => QuestionScoreOrderByRelevanceFieldEnumSchema),z.lazy(() => QuestionScoreOrderByRelevanceFieldEnumSchema).array() ]),
  sort: z.lazy(() => SortOrderSchema),
  search: z.string()
}).strict();

export const QuestionScoreCountOrderByAggregateInputSchema: z.ZodType<Prisma.QuestionScoreCountOrderByAggregateInput> = z.object({
  id: z.lazy(() => SortOrderSchema).optional(),
  createdAt: z.lazy(() => SortOrderSchema).optional(),
  relativeScore: z.lazy(() => SortOrderSchema).optional(),
  questionId: z.lazy(() => SortOrderSchema).optional(),
  userQuestionComboId: z.lazy(() => SortOrderSchema).optional(),
  absoluteScore: z.lazy(() => SortOrderSchema).optional(),
  rank: z.lazy(() => SortOrderSchema).optional(),
  userId: z.lazy(() => SortOrderSchema).optional(),
  questionOptionId: z.lazy(() => SortOrderSchema).optional()
}).strict();

export const QuestionScoreAvgOrderByAggregateInputSchema: z.ZodType<Prisma.QuestionScoreAvgOrderByAggregateInput> = z.object({
  id: z.lazy(() => SortOrderSchema).optional(),
  relativeScore: z.lazy(() => SortOrderSchema).optional(),
  absoluteScore: z.lazy(() => SortOrderSchema).optional(),
  rank: z.lazy(() => SortOrderSchema).optional()
}).strict();

export const QuestionScoreMaxOrderByAggregateInputSchema: z.ZodType<Prisma.QuestionScoreMaxOrderByAggregateInput> = z.object({
  id: z.lazy(() => SortOrderSchema).optional(),
  createdAt: z.lazy(() => SortOrderSchema).optional(),
  relativeScore: z.lazy(() => SortOrderSchema).optional(),
  questionId: z.lazy(() => SortOrderSchema).optional(),
  userQuestionComboId: z.lazy(() => SortOrderSchema).optional(),
  absoluteScore: z.lazy(() => SortOrderSchema).optional(),
  rank: z.lazy(() => SortOrderSchema).optional(),
  userId: z.lazy(() => SortOrderSchema).optional(),
  questionOptionId: z.lazy(() => SortOrderSchema).optional()
}).strict();

export const QuestionScoreMinOrderByAggregateInputSchema: z.ZodType<Prisma.QuestionScoreMinOrderByAggregateInput> = z.object({
  id: z.lazy(() => SortOrderSchema).optional(),
  createdAt: z.lazy(() => SortOrderSchema).optional(),
  relativeScore: z.lazy(() => SortOrderSchema).optional(),
  questionId: z.lazy(() => SortOrderSchema).optional(),
  userQuestionComboId: z.lazy(() => SortOrderSchema).optional(),
  absoluteScore: z.lazy(() => SortOrderSchema).optional(),
  rank: z.lazy(() => SortOrderSchema).optional(),
  userId: z.lazy(() => SortOrderSchema).optional(),
  questionOptionId: z.lazy(() => SortOrderSchema).optional()
}).strict();

export const QuestionScoreSumOrderByAggregateInputSchema: z.ZodType<Prisma.QuestionScoreSumOrderByAggregateInput> = z.object({
  id: z.lazy(() => SortOrderSchema).optional(),
  relativeScore: z.lazy(() => SortOrderSchema).optional(),
  absoluteScore: z.lazy(() => SortOrderSchema).optional(),
  rank: z.lazy(() => SortOrderSchema).optional()
}).strict();

export const DecimalNullableWithAggregatesFilterSchema: z.ZodType<Prisma.DecimalNullableWithAggregatesFilter> = z.object({
  equals: z.union([z.number(),z.string(),z.instanceof(Decimal),z.instanceof(Prisma.Decimal),DecimalJsLikeSchema,]).refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' }).optional().nullable(),
  in: z.union([z.number().array(),z.string().array(),z.instanceof(Decimal).array(),z.instanceof(Prisma.Decimal).array(),DecimalJsLikeSchema.array(),]).refine((v) => Array.isArray(v) && (v as any[]).every((v) => isValidDecimalInput(v)), { message: 'Must be a Decimal' }).optional().nullable(),
  notIn: z.union([z.number().array(),z.string().array(),z.instanceof(Decimal).array(),z.instanceof(Prisma.Decimal).array(),DecimalJsLikeSchema.array(),]).refine((v) => Array.isArray(v) && (v as any[]).every((v) => isValidDecimalInput(v)), { message: 'Must be a Decimal' }).optional().nullable(),
  lt: z.union([z.number(),z.string(),z.instanceof(Decimal),z.instanceof(Prisma.Decimal),DecimalJsLikeSchema,]).refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' }).optional(),
  lte: z.union([z.number(),z.string(),z.instanceof(Decimal),z.instanceof(Prisma.Decimal),DecimalJsLikeSchema,]).refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' }).optional(),
  gt: z.union([z.number(),z.string(),z.instanceof(Decimal),z.instanceof(Prisma.Decimal),DecimalJsLikeSchema,]).refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' }).optional(),
  gte: z.union([z.number(),z.string(),z.instanceof(Decimal),z.instanceof(Prisma.Decimal),DecimalJsLikeSchema,]).refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' }).optional(),
  not: z.union([ z.union([z.number(),z.string(),z.instanceof(Decimal),z.instanceof(Prisma.Decimal),DecimalJsLikeSchema,]).refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' }),z.lazy(() => NestedDecimalNullableWithAggregatesFilterSchema) ]).optional().nullable(),
  _count: z.lazy(() => NestedIntNullableFilterSchema).optional(),
  _avg: z.lazy(() => NestedDecimalNullableFilterSchema).optional(),
  _sum: z.lazy(() => NestedDecimalNullableFilterSchema).optional(),
  _min: z.lazy(() => NestedDecimalNullableFilterSchema).optional(),
  _max: z.lazy(() => NestedDecimalNullableFilterSchema).optional()
}).strict();

export const EnumResolutionNullableFilterSchema: z.ZodType<Prisma.EnumResolutionNullableFilter> = z.object({
  equals: z.lazy(() => ResolutionSchema).optional().nullable(),
  in: z.lazy(() => ResolutionSchema).array().optional().nullable(),
  notIn: z.lazy(() => ResolutionSchema).array().optional().nullable(),
  not: z.union([ z.lazy(() => ResolutionSchema),z.lazy(() => NestedEnumResolutionNullableFilterSchema) ]).optional().nullable(),
}).strict();

export const DateTimeNullableFilterSchema: z.ZodType<Prisma.DateTimeNullableFilter> = z.object({
  equals: z.coerce.date().optional().nullable(),
  in: z.coerce.date().array().optional().nullable(),
  notIn: z.coerce.date().array().optional().nullable(),
  lt: z.coerce.date().optional(),
  lte: z.coerce.date().optional(),
  gt: z.coerce.date().optional(),
  gte: z.coerce.date().optional(),
  not: z.union([ z.coerce.date(),z.lazy(() => NestedDateTimeNullableFilterSchema) ]).optional().nullable(),
}).strict();

export const ForecastListRelationFilterSchema: z.ZodType<Prisma.ForecastListRelationFilter> = z.object({
  every: z.lazy(() => ForecastWhereInputSchema).optional(),
  some: z.lazy(() => ForecastWhereInputSchema).optional(),
  none: z.lazy(() => ForecastWhereInputSchema).optional()
}).strict();

export const QuestionScoreListRelationFilterSchema: z.ZodType<Prisma.QuestionScoreListRelationFilter> = z.object({
  every: z.lazy(() => QuestionScoreWhereInputSchema).optional(),
  some: z.lazy(() => QuestionScoreWhereInputSchema).optional(),
  none: z.lazy(() => QuestionScoreWhereInputSchema).optional()
}).strict();

export const ForecastOrderByRelationAggregateInputSchema: z.ZodType<Prisma.ForecastOrderByRelationAggregateInput> = z.object({
  _count: z.lazy(() => SortOrderSchema).optional()
}).strict();

export const QuestionScoreOrderByRelationAggregateInputSchema: z.ZodType<Prisma.QuestionScoreOrderByRelationAggregateInput> = z.object({
  _count: z.lazy(() => SortOrderSchema).optional()
}).strict();

export const QuestionOptionOrderByRelevanceInputSchema: z.ZodType<Prisma.QuestionOptionOrderByRelevanceInput> = z.object({
  fields: z.union([ z.lazy(() => QuestionOptionOrderByRelevanceFieldEnumSchema),z.lazy(() => QuestionOptionOrderByRelevanceFieldEnumSchema).array() ]),
  sort: z.lazy(() => SortOrderSchema),
  search: z.string()
}).strict();

export const QuestionOptionCountOrderByAggregateInputSchema: z.ZodType<Prisma.QuestionOptionCountOrderByAggregateInput> = z.object({
  id: z.lazy(() => SortOrderSchema).optional(),
  questionId: z.lazy(() => SortOrderSchema).optional(),
  text: z.lazy(() => SortOrderSchema).optional(),
  resolution: z.lazy(() => SortOrderSchema).optional(),
  createdAt: z.lazy(() => SortOrderSchema).optional(),
  userId: z.lazy(() => SortOrderSchema).optional(),
  resolvedAt: z.lazy(() => SortOrderSchema).optional()
}).strict();

export const QuestionOptionMaxOrderByAggregateInputSchema: z.ZodType<Prisma.QuestionOptionMaxOrderByAggregateInput> = z.object({
  id: z.lazy(() => SortOrderSchema).optional(),
  questionId: z.lazy(() => SortOrderSchema).optional(),
  text: z.lazy(() => SortOrderSchema).optional(),
  resolution: z.lazy(() => SortOrderSchema).optional(),
  createdAt: z.lazy(() => SortOrderSchema).optional(),
  userId: z.lazy(() => SortOrderSchema).optional(),
  resolvedAt: z.lazy(() => SortOrderSchema).optional()
}).strict();

export const QuestionOptionMinOrderByAggregateInputSchema: z.ZodType<Prisma.QuestionOptionMinOrderByAggregateInput> = z.object({
  id: z.lazy(() => SortOrderSchema).optional(),
  questionId: z.lazy(() => SortOrderSchema).optional(),
  text: z.lazy(() => SortOrderSchema).optional(),
  resolution: z.lazy(() => SortOrderSchema).optional(),
  createdAt: z.lazy(() => SortOrderSchema).optional(),
  userId: z.lazy(() => SortOrderSchema).optional(),
  resolvedAt: z.lazy(() => SortOrderSchema).optional()
}).strict();

export const EnumResolutionNullableWithAggregatesFilterSchema: z.ZodType<Prisma.EnumResolutionNullableWithAggregatesFilter> = z.object({
  equals: z.lazy(() => ResolutionSchema).optional().nullable(),
  in: z.lazy(() => ResolutionSchema).array().optional().nullable(),
  notIn: z.lazy(() => ResolutionSchema).array().optional().nullable(),
  not: z.union([ z.lazy(() => ResolutionSchema),z.lazy(() => NestedEnumResolutionNullableWithAggregatesFilterSchema) ]).optional().nullable(),
  _count: z.lazy(() => NestedIntNullableFilterSchema).optional(),
  _min: z.lazy(() => NestedEnumResolutionNullableFilterSchema).optional(),
  _max: z.lazy(() => NestedEnumResolutionNullableFilterSchema).optional()
}).strict();

export const DateTimeNullableWithAggregatesFilterSchema: z.ZodType<Prisma.DateTimeNullableWithAggregatesFilter> = z.object({
  equals: z.coerce.date().optional().nullable(),
  in: z.coerce.date().array().optional().nullable(),
  notIn: z.coerce.date().array().optional().nullable(),
  lt: z.coerce.date().optional(),
  lte: z.coerce.date().optional(),
  gt: z.coerce.date().optional(),
  gte: z.coerce.date().optional(),
  not: z.union([ z.coerce.date(),z.lazy(() => NestedDateTimeNullableWithAggregatesFilterSchema) ]).optional().nullable(),
  _count: z.lazy(() => NestedIntNullableFilterSchema).optional(),
  _min: z.lazy(() => NestedDateTimeNullableFilterSchema).optional(),
  _max: z.lazy(() => NestedDateTimeNullableFilterSchema).optional()
}).strict();

export const EnumQuestionTypeFilterSchema: z.ZodType<Prisma.EnumQuestionTypeFilter> = z.object({
  equals: z.lazy(() => QuestionTypeSchema).optional(),
  in: z.lazy(() => QuestionTypeSchema).array().optional(),
  notIn: z.lazy(() => QuestionTypeSchema).array().optional(),
  not: z.union([ z.lazy(() => QuestionTypeSchema),z.lazy(() => NestedEnumQuestionTypeFilterSchema) ]).optional(),
}).strict();

export const BoolFilterSchema: z.ZodType<Prisma.BoolFilter> = z.object({
  equals: z.boolean().optional(),
  not: z.union([ z.boolean(),z.lazy(() => NestedBoolFilterSchema) ]).optional(),
}).strict();

export const BoolNullableFilterSchema: z.ZodType<Prisma.BoolNullableFilter> = z.object({
  equals: z.boolean().optional().nullable(),
  not: z.union([ z.boolean(),z.lazy(() => NestedBoolNullableFilterSchema) ]).optional().nullable(),
}).strict();

export const QuestionOptionListRelationFilterSchema: z.ZodType<Prisma.QuestionOptionListRelationFilter> = z.object({
  every: z.lazy(() => QuestionOptionWhereInputSchema).optional(),
  some: z.lazy(() => QuestionOptionWhereInputSchema).optional(),
  none: z.lazy(() => QuestionOptionWhereInputSchema).optional()
}).strict();

export const PingSlackMessageListRelationFilterSchema: z.ZodType<Prisma.PingSlackMessageListRelationFilter> = z.object({
  every: z.lazy(() => PingSlackMessageWhereInputSchema).optional(),
  some: z.lazy(() => PingSlackMessageWhereInputSchema).optional(),
  none: z.lazy(() => PingSlackMessageWhereInputSchema).optional()
}).strict();

export const UserListRelationFilterSchema: z.ZodType<Prisma.UserListRelationFilter> = z.object({
  every: z.lazy(() => UserWhereInputSchema).optional(),
  some: z.lazy(() => UserWhereInputSchema).optional(),
  none: z.lazy(() => UserWhereInputSchema).optional()
}).strict();

export const UserListListRelationFilterSchema: z.ZodType<Prisma.UserListListRelationFilter> = z.object({
  every: z.lazy(() => UserListWhereInputSchema).optional(),
  some: z.lazy(() => UserListWhereInputSchema).optional(),
  none: z.lazy(() => UserListWhereInputSchema).optional()
}).strict();

export const QuestionSlackMessageListRelationFilterSchema: z.ZodType<Prisma.QuestionSlackMessageListRelationFilter> = z.object({
  every: z.lazy(() => QuestionSlackMessageWhereInputSchema).optional(),
  some: z.lazy(() => QuestionSlackMessageWhereInputSchema).optional(),
  none: z.lazy(() => QuestionSlackMessageWhereInputSchema).optional()
}).strict();

export const ResolutionSlackMessageListRelationFilterSchema: z.ZodType<Prisma.ResolutionSlackMessageListRelationFilter> = z.object({
  every: z.lazy(() => ResolutionSlackMessageWhereInputSchema).optional(),
  some: z.lazy(() => ResolutionSlackMessageWhereInputSchema).optional(),
  none: z.lazy(() => ResolutionSlackMessageWhereInputSchema).optional()
}).strict();

export const CommentListRelationFilterSchema: z.ZodType<Prisma.CommentListRelationFilter> = z.object({
  every: z.lazy(() => CommentWhereInputSchema).optional(),
  some: z.lazy(() => CommentWhereInputSchema).optional(),
  none: z.lazy(() => CommentWhereInputSchema).optional()
}).strict();

export const TagListRelationFilterSchema: z.ZodType<Prisma.TagListRelationFilter> = z.object({
  every: z.lazy(() => TagWhereInputSchema).optional(),
  some: z.lazy(() => TagWhereInputSchema).optional(),
  none: z.lazy(() => TagWhereInputSchema).optional()
}).strict();

export const TournamentListRelationFilterSchema: z.ZodType<Prisma.TournamentListRelationFilter> = z.object({
  every: z.lazy(() => TournamentWhereInputSchema).optional(),
  some: z.lazy(() => TournamentWhereInputSchema).optional(),
  none: z.lazy(() => TournamentWhereInputSchema).optional()
}).strict();

export const NotificationListRelationFilterSchema: z.ZodType<Prisma.NotificationListRelationFilter> = z.object({
  every: z.lazy(() => NotificationWhereInputSchema).optional(),
  some: z.lazy(() => NotificationWhereInputSchema).optional(),
  none: z.lazy(() => NotificationWhereInputSchema).optional()
}).strict();

export const QuestionOptionOrderByRelationAggregateInputSchema: z.ZodType<Prisma.QuestionOptionOrderByRelationAggregateInput> = z.object({
  _count: z.lazy(() => SortOrderSchema).optional()
}).strict();

export const PingSlackMessageOrderByRelationAggregateInputSchema: z.ZodType<Prisma.PingSlackMessageOrderByRelationAggregateInput> = z.object({
  _count: z.lazy(() => SortOrderSchema).optional()
}).strict();

export const UserOrderByRelationAggregateInputSchema: z.ZodType<Prisma.UserOrderByRelationAggregateInput> = z.object({
  _count: z.lazy(() => SortOrderSchema).optional()
}).strict();

export const UserListOrderByRelationAggregateInputSchema: z.ZodType<Prisma.UserListOrderByRelationAggregateInput> = z.object({
  _count: z.lazy(() => SortOrderSchema).optional()
}).strict();

export const QuestionSlackMessageOrderByRelationAggregateInputSchema: z.ZodType<Prisma.QuestionSlackMessageOrderByRelationAggregateInput> = z.object({
  _count: z.lazy(() => SortOrderSchema).optional()
}).strict();

export const ResolutionSlackMessageOrderByRelationAggregateInputSchema: z.ZodType<Prisma.ResolutionSlackMessageOrderByRelationAggregateInput> = z.object({
  _count: z.lazy(() => SortOrderSchema).optional()
}).strict();

export const CommentOrderByRelationAggregateInputSchema: z.ZodType<Prisma.CommentOrderByRelationAggregateInput> = z.object({
  _count: z.lazy(() => SortOrderSchema).optional()
}).strict();

export const TagOrderByRelationAggregateInputSchema: z.ZodType<Prisma.TagOrderByRelationAggregateInput> = z.object({
  _count: z.lazy(() => SortOrderSchema).optional()
}).strict();

export const TournamentOrderByRelationAggregateInputSchema: z.ZodType<Prisma.TournamentOrderByRelationAggregateInput> = z.object({
  _count: z.lazy(() => SortOrderSchema).optional()
}).strict();

export const NotificationOrderByRelationAggregateInputSchema: z.ZodType<Prisma.NotificationOrderByRelationAggregateInput> = z.object({
  _count: z.lazy(() => SortOrderSchema).optional()
}).strict();

export const QuestionOrderByRelevanceInputSchema: z.ZodType<Prisma.QuestionOrderByRelevanceInput> = z.object({
  fields: z.union([ z.lazy(() => QuestionOrderByRelevanceFieldEnumSchema),z.lazy(() => QuestionOrderByRelevanceFieldEnumSchema).array() ]),
  sort: z.lazy(() => SortOrderSchema),
  search: z.string()
}).strict();

export const QuestionCountOrderByAggregateInputSchema: z.ZodType<Prisma.QuestionCountOrderByAggregateInput> = z.object({
  id: z.lazy(() => SortOrderSchema).optional(),
  createdAt: z.lazy(() => SortOrderSchema).optional(),
  comment: z.lazy(() => SortOrderSchema).optional(),
  profileId: z.lazy(() => SortOrderSchema).optional(),
  title: z.lazy(() => SortOrderSchema).optional(),
  type: z.lazy(() => SortOrderSchema).optional(),
  resolveBy: z.lazy(() => SortOrderSchema).optional(),
  resolved: z.lazy(() => SortOrderSchema).optional(),
  pingedForResolution: z.lazy(() => SortOrderSchema).optional(),
  resolution: z.lazy(() => SortOrderSchema).optional(),
  resolvedAt: z.lazy(() => SortOrderSchema).optional(),
  notes: z.lazy(() => SortOrderSchema).optional(),
  hideForecastsUntil: z.lazy(() => SortOrderSchema).optional(),
  hideForecastsUntilPrediction: z.lazy(() => SortOrderSchema).optional(),
  userId: z.lazy(() => SortOrderSchema).optional(),
  sharedPublicly: z.lazy(() => SortOrderSchema).optional(),
  unlisted: z.lazy(() => SortOrderSchema).optional(),
  exclusiveAnswers: z.lazy(() => SortOrderSchema).optional()
}).strict();

export const QuestionAvgOrderByAggregateInputSchema: z.ZodType<Prisma.QuestionAvgOrderByAggregateInput> = z.object({
  profileId: z.lazy(() => SortOrderSchema).optional()
}).strict();

export const QuestionMaxOrderByAggregateInputSchema: z.ZodType<Prisma.QuestionMaxOrderByAggregateInput> = z.object({
  id: z.lazy(() => SortOrderSchema).optional(),
  createdAt: z.lazy(() => SortOrderSchema).optional(),
  comment: z.lazy(() => SortOrderSchema).optional(),
  profileId: z.lazy(() => SortOrderSchema).optional(),
  title: z.lazy(() => SortOrderSchema).optional(),
  type: z.lazy(() => SortOrderSchema).optional(),
  resolveBy: z.lazy(() => SortOrderSchema).optional(),
  resolved: z.lazy(() => SortOrderSchema).optional(),
  pingedForResolution: z.lazy(() => SortOrderSchema).optional(),
  resolution: z.lazy(() => SortOrderSchema).optional(),
  resolvedAt: z.lazy(() => SortOrderSchema).optional(),
  notes: z.lazy(() => SortOrderSchema).optional(),
  hideForecastsUntil: z.lazy(() => SortOrderSchema).optional(),
  hideForecastsUntilPrediction: z.lazy(() => SortOrderSchema).optional(),
  userId: z.lazy(() => SortOrderSchema).optional(),
  sharedPublicly: z.lazy(() => SortOrderSchema).optional(),
  unlisted: z.lazy(() => SortOrderSchema).optional(),
  exclusiveAnswers: z.lazy(() => SortOrderSchema).optional()
}).strict();

export const QuestionMinOrderByAggregateInputSchema: z.ZodType<Prisma.QuestionMinOrderByAggregateInput> = z.object({
  id: z.lazy(() => SortOrderSchema).optional(),
  createdAt: z.lazy(() => SortOrderSchema).optional(),
  comment: z.lazy(() => SortOrderSchema).optional(),
  profileId: z.lazy(() => SortOrderSchema).optional(),
  title: z.lazy(() => SortOrderSchema).optional(),
  type: z.lazy(() => SortOrderSchema).optional(),
  resolveBy: z.lazy(() => SortOrderSchema).optional(),
  resolved: z.lazy(() => SortOrderSchema).optional(),
  pingedForResolution: z.lazy(() => SortOrderSchema).optional(),
  resolution: z.lazy(() => SortOrderSchema).optional(),
  resolvedAt: z.lazy(() => SortOrderSchema).optional(),
  notes: z.lazy(() => SortOrderSchema).optional(),
  hideForecastsUntil: z.lazy(() => SortOrderSchema).optional(),
  hideForecastsUntilPrediction: z.lazy(() => SortOrderSchema).optional(),
  userId: z.lazy(() => SortOrderSchema).optional(),
  sharedPublicly: z.lazy(() => SortOrderSchema).optional(),
  unlisted: z.lazy(() => SortOrderSchema).optional(),
  exclusiveAnswers: z.lazy(() => SortOrderSchema).optional()
}).strict();

export const QuestionSumOrderByAggregateInputSchema: z.ZodType<Prisma.QuestionSumOrderByAggregateInput> = z.object({
  profileId: z.lazy(() => SortOrderSchema).optional()
}).strict();

export const EnumQuestionTypeWithAggregatesFilterSchema: z.ZodType<Prisma.EnumQuestionTypeWithAggregatesFilter> = z.object({
  equals: z.lazy(() => QuestionTypeSchema).optional(),
  in: z.lazy(() => QuestionTypeSchema).array().optional(),
  notIn: z.lazy(() => QuestionTypeSchema).array().optional(),
  not: z.union([ z.lazy(() => QuestionTypeSchema),z.lazy(() => NestedEnumQuestionTypeWithAggregatesFilterSchema) ]).optional(),
  _count: z.lazy(() => NestedIntFilterSchema).optional(),
  _min: z.lazy(() => NestedEnumQuestionTypeFilterSchema).optional(),
  _max: z.lazy(() => NestedEnumQuestionTypeFilterSchema).optional()
}).strict();

export const BoolWithAggregatesFilterSchema: z.ZodType<Prisma.BoolWithAggregatesFilter> = z.object({
  equals: z.boolean().optional(),
  not: z.union([ z.boolean(),z.lazy(() => NestedBoolWithAggregatesFilterSchema) ]).optional(),
  _count: z.lazy(() => NestedIntFilterSchema).optional(),
  _min: z.lazy(() => NestedBoolFilterSchema).optional(),
  _max: z.lazy(() => NestedBoolFilterSchema).optional()
}).strict();

export const BoolNullableWithAggregatesFilterSchema: z.ZodType<Prisma.BoolNullableWithAggregatesFilter> = z.object({
  equals: z.boolean().optional().nullable(),
  not: z.union([ z.boolean(),z.lazy(() => NestedBoolNullableWithAggregatesFilterSchema) ]).optional().nullable(),
  _count: z.lazy(() => NestedIntNullableFilterSchema).optional(),
  _min: z.lazy(() => NestedBoolNullableFilterSchema).optional(),
  _max: z.lazy(() => NestedBoolNullableFilterSchema).optional()
}).strict();

export const QuestionListRelationFilterSchema: z.ZodType<Prisma.QuestionListRelationFilter> = z.object({
  every: z.lazy(() => QuestionWhereInputSchema).optional(),
  some: z.lazy(() => QuestionWhereInputSchema).optional(),
  none: z.lazy(() => QuestionWhereInputSchema).optional()
}).strict();

export const QuestionOrderByRelationAggregateInputSchema: z.ZodType<Prisma.QuestionOrderByRelationAggregateInput> = z.object({
  _count: z.lazy(() => SortOrderSchema).optional()
}).strict();

export const TagOrderByRelevanceInputSchema: z.ZodType<Prisma.TagOrderByRelevanceInput> = z.object({
  fields: z.union([ z.lazy(() => TagOrderByRelevanceFieldEnumSchema),z.lazy(() => TagOrderByRelevanceFieldEnumSchema).array() ]),
  sort: z.lazy(() => SortOrderSchema),
  search: z.string()
}).strict();

export const TagNameUserIdCompoundUniqueInputSchema: z.ZodType<Prisma.TagNameUserIdCompoundUniqueInput> = z.object({
  name: z.string(),
  userId: z.string()
}).strict();

export const TagCountOrderByAggregateInputSchema: z.ZodType<Prisma.TagCountOrderByAggregateInput> = z.object({
  id: z.lazy(() => SortOrderSchema).optional(),
  createdAt: z.lazy(() => SortOrderSchema).optional(),
  name: z.lazy(() => SortOrderSchema).optional(),
  userId: z.lazy(() => SortOrderSchema).optional()
}).strict();

export const TagMaxOrderByAggregateInputSchema: z.ZodType<Prisma.TagMaxOrderByAggregateInput> = z.object({
  id: z.lazy(() => SortOrderSchema).optional(),
  createdAt: z.lazy(() => SortOrderSchema).optional(),
  name: z.lazy(() => SortOrderSchema).optional(),
  userId: z.lazy(() => SortOrderSchema).optional()
}).strict();

export const TagMinOrderByAggregateInputSchema: z.ZodType<Prisma.TagMinOrderByAggregateInput> = z.object({
  id: z.lazy(() => SortOrderSchema).optional(),
  createdAt: z.lazy(() => SortOrderSchema).optional(),
  name: z.lazy(() => SortOrderSchema).optional(),
  userId: z.lazy(() => SortOrderSchema).optional()
}).strict();

export const SlackMessageRelationFilterSchema: z.ZodType<Prisma.SlackMessageRelationFilter> = z.object({
  is: z.lazy(() => SlackMessageWhereInputSchema).optional(),
  isNot: z.lazy(() => SlackMessageWhereInputSchema).optional()
}).strict();

export const ResolutionSlackMessageOrderByRelevanceInputSchema: z.ZodType<Prisma.ResolutionSlackMessageOrderByRelevanceInput> = z.object({
  fields: z.union([ z.lazy(() => ResolutionSlackMessageOrderByRelevanceFieldEnumSchema),z.lazy(() => ResolutionSlackMessageOrderByRelevanceFieldEnumSchema).array() ]),
  sort: z.lazy(() => SortOrderSchema),
  search: z.string()
}).strict();

export const ResolutionSlackMessageCountOrderByAggregateInputSchema: z.ZodType<Prisma.ResolutionSlackMessageCountOrderByAggregateInput> = z.object({
  id: z.lazy(() => SortOrderSchema).optional(),
  questionId: z.lazy(() => SortOrderSchema).optional(),
  detailsId: z.lazy(() => SortOrderSchema).optional(),
  profileId: z.lazy(() => SortOrderSchema).optional()
}).strict();

export const ResolutionSlackMessageAvgOrderByAggregateInputSchema: z.ZodType<Prisma.ResolutionSlackMessageAvgOrderByAggregateInput> = z.object({
  id: z.lazy(() => SortOrderSchema).optional(),
  detailsId: z.lazy(() => SortOrderSchema).optional(),
  profileId: z.lazy(() => SortOrderSchema).optional()
}).strict();

export const ResolutionSlackMessageMaxOrderByAggregateInputSchema: z.ZodType<Prisma.ResolutionSlackMessageMaxOrderByAggregateInput> = z.object({
  id: z.lazy(() => SortOrderSchema).optional(),
  questionId: z.lazy(() => SortOrderSchema).optional(),
  detailsId: z.lazy(() => SortOrderSchema).optional(),
  profileId: z.lazy(() => SortOrderSchema).optional()
}).strict();

export const ResolutionSlackMessageMinOrderByAggregateInputSchema: z.ZodType<Prisma.ResolutionSlackMessageMinOrderByAggregateInput> = z.object({
  id: z.lazy(() => SortOrderSchema).optional(),
  questionId: z.lazy(() => SortOrderSchema).optional(),
  detailsId: z.lazy(() => SortOrderSchema).optional(),
  profileId: z.lazy(() => SortOrderSchema).optional()
}).strict();

export const ResolutionSlackMessageSumOrderByAggregateInputSchema: z.ZodType<Prisma.ResolutionSlackMessageSumOrderByAggregateInput> = z.object({
  id: z.lazy(() => SortOrderSchema).optional(),
  detailsId: z.lazy(() => SortOrderSchema).optional(),
  profileId: z.lazy(() => SortOrderSchema).optional()
}).strict();

export const PingSlackMessageOrderByRelevanceInputSchema: z.ZodType<Prisma.PingSlackMessageOrderByRelevanceInput> = z.object({
  fields: z.union([ z.lazy(() => PingSlackMessageOrderByRelevanceFieldEnumSchema),z.lazy(() => PingSlackMessageOrderByRelevanceFieldEnumSchema).array() ]),
  sort: z.lazy(() => SortOrderSchema),
  search: z.string()
}).strict();

export const PingSlackMessageCountOrderByAggregateInputSchema: z.ZodType<Prisma.PingSlackMessageCountOrderByAggregateInput> = z.object({
  id: z.lazy(() => SortOrderSchema).optional(),
  questionId: z.lazy(() => SortOrderSchema).optional(),
  detailsId: z.lazy(() => SortOrderSchema).optional()
}).strict();

export const PingSlackMessageAvgOrderByAggregateInputSchema: z.ZodType<Prisma.PingSlackMessageAvgOrderByAggregateInput> = z.object({
  id: z.lazy(() => SortOrderSchema).optional(),
  detailsId: z.lazy(() => SortOrderSchema).optional()
}).strict();

export const PingSlackMessageMaxOrderByAggregateInputSchema: z.ZodType<Prisma.PingSlackMessageMaxOrderByAggregateInput> = z.object({
  id: z.lazy(() => SortOrderSchema).optional(),
  questionId: z.lazy(() => SortOrderSchema).optional(),
  detailsId: z.lazy(() => SortOrderSchema).optional()
}).strict();

export const PingSlackMessageMinOrderByAggregateInputSchema: z.ZodType<Prisma.PingSlackMessageMinOrderByAggregateInput> = z.object({
  id: z.lazy(() => SortOrderSchema).optional(),
  questionId: z.lazy(() => SortOrderSchema).optional(),
  detailsId: z.lazy(() => SortOrderSchema).optional()
}).strict();

export const PingSlackMessageSumOrderByAggregateInputSchema: z.ZodType<Prisma.PingSlackMessageSumOrderByAggregateInput> = z.object({
  id: z.lazy(() => SortOrderSchema).optional(),
  detailsId: z.lazy(() => SortOrderSchema).optional()
}).strict();

export const QuestionSlackMessageOrderByRelevanceInputSchema: z.ZodType<Prisma.QuestionSlackMessageOrderByRelevanceInput> = z.object({
  fields: z.union([ z.lazy(() => QuestionSlackMessageOrderByRelevanceFieldEnumSchema),z.lazy(() => QuestionSlackMessageOrderByRelevanceFieldEnumSchema).array() ]),
  sort: z.lazy(() => SortOrderSchema),
  search: z.string()
}).strict();

export const QuestionSlackMessageCountOrderByAggregateInputSchema: z.ZodType<Prisma.QuestionSlackMessageCountOrderByAggregateInput> = z.object({
  id: z.lazy(() => SortOrderSchema).optional(),
  questionId: z.lazy(() => SortOrderSchema).optional(),
  detailsId: z.lazy(() => SortOrderSchema).optional(),
  updatedAt: z.lazy(() => SortOrderSchema).optional()
}).strict();

export const QuestionSlackMessageAvgOrderByAggregateInputSchema: z.ZodType<Prisma.QuestionSlackMessageAvgOrderByAggregateInput> = z.object({
  id: z.lazy(() => SortOrderSchema).optional(),
  detailsId: z.lazy(() => SortOrderSchema).optional()
}).strict();

export const QuestionSlackMessageMaxOrderByAggregateInputSchema: z.ZodType<Prisma.QuestionSlackMessageMaxOrderByAggregateInput> = z.object({
  id: z.lazy(() => SortOrderSchema).optional(),
  questionId: z.lazy(() => SortOrderSchema).optional(),
  detailsId: z.lazy(() => SortOrderSchema).optional(),
  updatedAt: z.lazy(() => SortOrderSchema).optional()
}).strict();

export const QuestionSlackMessageMinOrderByAggregateInputSchema: z.ZodType<Prisma.QuestionSlackMessageMinOrderByAggregateInput> = z.object({
  id: z.lazy(() => SortOrderSchema).optional(),
  questionId: z.lazy(() => SortOrderSchema).optional(),
  detailsId: z.lazy(() => SortOrderSchema).optional(),
  updatedAt: z.lazy(() => SortOrderSchema).optional()
}).strict();

export const QuestionSlackMessageSumOrderByAggregateInputSchema: z.ZodType<Prisma.QuestionSlackMessageSumOrderByAggregateInput> = z.object({
  id: z.lazy(() => SortOrderSchema).optional(),
  detailsId: z.lazy(() => SortOrderSchema).optional()
}).strict();

export const PingSlackMessageNullableRelationFilterSchema: z.ZodType<Prisma.PingSlackMessageNullableRelationFilter> = z.object({
  is: z.lazy(() => PingSlackMessageWhereInputSchema).optional().nullable(),
  isNot: z.lazy(() => PingSlackMessageWhereInputSchema).optional().nullable()
}).strict();

export const QuestionSlackMessageNullableRelationFilterSchema: z.ZodType<Prisma.QuestionSlackMessageNullableRelationFilter> = z.object({
  is: z.lazy(() => QuestionSlackMessageWhereInputSchema).optional().nullable(),
  isNot: z.lazy(() => QuestionSlackMessageWhereInputSchema).optional().nullable()
}).strict();

export const ResolutionSlackMessageNullableRelationFilterSchema: z.ZodType<Prisma.ResolutionSlackMessageNullableRelationFilter> = z.object({
  is: z.lazy(() => ResolutionSlackMessageWhereInputSchema).optional().nullable(),
  isNot: z.lazy(() => ResolutionSlackMessageWhereInputSchema).optional().nullable()
}).strict();

export const SlackMessageOrderByRelevanceInputSchema: z.ZodType<Prisma.SlackMessageOrderByRelevanceInput> = z.object({
  fields: z.union([ z.lazy(() => SlackMessageOrderByRelevanceFieldEnumSchema),z.lazy(() => SlackMessageOrderByRelevanceFieldEnumSchema).array() ]),
  sort: z.lazy(() => SortOrderSchema),
  search: z.string()
}).strict();

export const SlackMessageCountOrderByAggregateInputSchema: z.ZodType<Prisma.SlackMessageCountOrderByAggregateInput> = z.object({
  id: z.lazy(() => SortOrderSchema).optional(),
  ts: z.lazy(() => SortOrderSchema).optional(),
  channel: z.lazy(() => SortOrderSchema).optional(),
  teamId: z.lazy(() => SortOrderSchema).optional()
}).strict();

export const SlackMessageAvgOrderByAggregateInputSchema: z.ZodType<Prisma.SlackMessageAvgOrderByAggregateInput> = z.object({
  id: z.lazy(() => SortOrderSchema).optional()
}).strict();

export const SlackMessageMaxOrderByAggregateInputSchema: z.ZodType<Prisma.SlackMessageMaxOrderByAggregateInput> = z.object({
  id: z.lazy(() => SortOrderSchema).optional(),
  ts: z.lazy(() => SortOrderSchema).optional(),
  channel: z.lazy(() => SortOrderSchema).optional(),
  teamId: z.lazy(() => SortOrderSchema).optional()
}).strict();

export const SlackMessageMinOrderByAggregateInputSchema: z.ZodType<Prisma.SlackMessageMinOrderByAggregateInput> = z.object({
  id: z.lazy(() => SortOrderSchema).optional(),
  ts: z.lazy(() => SortOrderSchema).optional(),
  channel: z.lazy(() => SortOrderSchema).optional(),
  teamId: z.lazy(() => SortOrderSchema).optional()
}).strict();

export const SlackMessageSumOrderByAggregateInputSchema: z.ZodType<Prisma.SlackMessageSumOrderByAggregateInput> = z.object({
  id: z.lazy(() => SortOrderSchema).optional()
}).strict();

export const ProfileListRelationFilterSchema: z.ZodType<Prisma.ProfileListRelationFilter> = z.object({
  every: z.lazy(() => ProfileWhereInputSchema).optional(),
  some: z.lazy(() => ProfileWhereInputSchema).optional(),
  none: z.lazy(() => ProfileWhereInputSchema).optional()
}).strict();

export const TargetNullableRelationFilterSchema: z.ZodType<Prisma.TargetNullableRelationFilter> = z.object({
  is: z.lazy(() => TargetWhereInputSchema).optional().nullable(),
  isNot: z.lazy(() => TargetWhereInputSchema).optional().nullable()
}).strict();

export const AccountListRelationFilterSchema: z.ZodType<Prisma.AccountListRelationFilter> = z.object({
  every: z.lazy(() => AccountWhereInputSchema).optional(),
  some: z.lazy(() => AccountWhereInputSchema).optional(),
  none: z.lazy(() => AccountWhereInputSchema).optional()
}).strict();

export const ProfileOrderByRelationAggregateInputSchema: z.ZodType<Prisma.ProfileOrderByRelationAggregateInput> = z.object({
  _count: z.lazy(() => SortOrderSchema).optional()
}).strict();

export const AccountOrderByRelationAggregateInputSchema: z.ZodType<Prisma.AccountOrderByRelationAggregateInput> = z.object({
  _count: z.lazy(() => SortOrderSchema).optional()
}).strict();

export const UserOrderByRelevanceInputSchema: z.ZodType<Prisma.UserOrderByRelevanceInput> = z.object({
  fields: z.union([ z.lazy(() => UserOrderByRelevanceFieldEnumSchema),z.lazy(() => UserOrderByRelevanceFieldEnumSchema).array() ]),
  sort: z.lazy(() => SortOrderSchema),
  search: z.string()
}).strict();

export const UserCountOrderByAggregateInputSchema: z.ZodType<Prisma.UserCountOrderByAggregateInput> = z.object({
  id: z.lazy(() => SortOrderSchema).optional(),
  name: z.lazy(() => SortOrderSchema).optional(),
  createdAt: z.lazy(() => SortOrderSchema).optional(),
  email: z.lazy(() => SortOrderSchema).optional(),
  image: z.lazy(() => SortOrderSchema).optional(),
  staleReminder: z.lazy(() => SortOrderSchema).optional(),
  unsubscribedFromEmailsAt: z.lazy(() => SortOrderSchema).optional(),
  apiKey: z.lazy(() => SortOrderSchema).optional(),
  discordUserId: z.lazy(() => SortOrderSchema).optional(),
  emailVerified: z.lazy(() => SortOrderSchema).optional()
}).strict();

export const UserMaxOrderByAggregateInputSchema: z.ZodType<Prisma.UserMaxOrderByAggregateInput> = z.object({
  id: z.lazy(() => SortOrderSchema).optional(),
  name: z.lazy(() => SortOrderSchema).optional(),
  createdAt: z.lazy(() => SortOrderSchema).optional(),
  email: z.lazy(() => SortOrderSchema).optional(),
  image: z.lazy(() => SortOrderSchema).optional(),
  staleReminder: z.lazy(() => SortOrderSchema).optional(),
  unsubscribedFromEmailsAt: z.lazy(() => SortOrderSchema).optional(),
  apiKey: z.lazy(() => SortOrderSchema).optional(),
  discordUserId: z.lazy(() => SortOrderSchema).optional(),
  emailVerified: z.lazy(() => SortOrderSchema).optional()
}).strict();

export const UserMinOrderByAggregateInputSchema: z.ZodType<Prisma.UserMinOrderByAggregateInput> = z.object({
  id: z.lazy(() => SortOrderSchema).optional(),
  name: z.lazy(() => SortOrderSchema).optional(),
  createdAt: z.lazy(() => SortOrderSchema).optional(),
  email: z.lazy(() => SortOrderSchema).optional(),
  image: z.lazy(() => SortOrderSchema).optional(),
  staleReminder: z.lazy(() => SortOrderSchema).optional(),
  unsubscribedFromEmailsAt: z.lazy(() => SortOrderSchema).optional(),
  apiKey: z.lazy(() => SortOrderSchema).optional(),
  discordUserId: z.lazy(() => SortOrderSchema).optional(),
  emailVerified: z.lazy(() => SortOrderSchema).optional()
}).strict();

export const ProfileOrderByRelevanceInputSchema: z.ZodType<Prisma.ProfileOrderByRelevanceInput> = z.object({
  fields: z.union([ z.lazy(() => ProfileOrderByRelevanceFieldEnumSchema),z.lazy(() => ProfileOrderByRelevanceFieldEnumSchema).array() ]),
  sort: z.lazy(() => SortOrderSchema),
  search: z.string()
}).strict();

export const ProfileCountOrderByAggregateInputSchema: z.ZodType<Prisma.ProfileCountOrderByAggregateInput> = z.object({
  id: z.lazy(() => SortOrderSchema).optional(),
  createdAt: z.lazy(() => SortOrderSchema).optional(),
  slackId: z.lazy(() => SortOrderSchema).optional(),
  slackTeamId: z.lazy(() => SortOrderSchema).optional(),
  userId: z.lazy(() => SortOrderSchema).optional()
}).strict();

export const ProfileAvgOrderByAggregateInputSchema: z.ZodType<Prisma.ProfileAvgOrderByAggregateInput> = z.object({
  id: z.lazy(() => SortOrderSchema).optional()
}).strict();

export const ProfileMaxOrderByAggregateInputSchema: z.ZodType<Prisma.ProfileMaxOrderByAggregateInput> = z.object({
  id: z.lazy(() => SortOrderSchema).optional(),
  createdAt: z.lazy(() => SortOrderSchema).optional(),
  slackId: z.lazy(() => SortOrderSchema).optional(),
  slackTeamId: z.lazy(() => SortOrderSchema).optional(),
  userId: z.lazy(() => SortOrderSchema).optional()
}).strict();

export const ProfileMinOrderByAggregateInputSchema: z.ZodType<Prisma.ProfileMinOrderByAggregateInput> = z.object({
  id: z.lazy(() => SortOrderSchema).optional(),
  createdAt: z.lazy(() => SortOrderSchema).optional(),
  slackId: z.lazy(() => SortOrderSchema).optional(),
  slackTeamId: z.lazy(() => SortOrderSchema).optional(),
  userId: z.lazy(() => SortOrderSchema).optional()
}).strict();

export const ProfileSumOrderByAggregateInputSchema: z.ZodType<Prisma.ProfileSumOrderByAggregateInput> = z.object({
  id: z.lazy(() => SortOrderSchema).optional()
}).strict();

export const EnumGroupTypeFilterSchema: z.ZodType<Prisma.EnumGroupTypeFilter> = z.object({
  equals: z.lazy(() => GroupTypeSchema).optional(),
  in: z.lazy(() => GroupTypeSchema).array().optional(),
  notIn: z.lazy(() => GroupTypeSchema).array().optional(),
  not: z.union([ z.lazy(() => GroupTypeSchema),z.lazy(() => NestedEnumGroupTypeFilterSchema) ]).optional(),
}).strict();

export const GroupOrderByRelevanceInputSchema: z.ZodType<Prisma.GroupOrderByRelevanceInput> = z.object({
  fields: z.union([ z.lazy(() => GroupOrderByRelevanceFieldEnumSchema),z.lazy(() => GroupOrderByRelevanceFieldEnumSchema).array() ]),
  sort: z.lazy(() => SortOrderSchema),
  search: z.string()
}).strict();

export const GroupCountOrderByAggregateInputSchema: z.ZodType<Prisma.GroupCountOrderByAggregateInput> = z.object({
  id: z.lazy(() => SortOrderSchema).optional(),
  type: z.lazy(() => SortOrderSchema).optional(),
  createdAt: z.lazy(() => SortOrderSchema).optional(),
  name: z.lazy(() => SortOrderSchema).optional(),
  slackTeamId: z.lazy(() => SortOrderSchema).optional()
}).strict();

export const GroupAvgOrderByAggregateInputSchema: z.ZodType<Prisma.GroupAvgOrderByAggregateInput> = z.object({
  id: z.lazy(() => SortOrderSchema).optional()
}).strict();

export const GroupMaxOrderByAggregateInputSchema: z.ZodType<Prisma.GroupMaxOrderByAggregateInput> = z.object({
  id: z.lazy(() => SortOrderSchema).optional(),
  type: z.lazy(() => SortOrderSchema).optional(),
  createdAt: z.lazy(() => SortOrderSchema).optional(),
  name: z.lazy(() => SortOrderSchema).optional(),
  slackTeamId: z.lazy(() => SortOrderSchema).optional()
}).strict();

export const GroupMinOrderByAggregateInputSchema: z.ZodType<Prisma.GroupMinOrderByAggregateInput> = z.object({
  id: z.lazy(() => SortOrderSchema).optional(),
  type: z.lazy(() => SortOrderSchema).optional(),
  createdAt: z.lazy(() => SortOrderSchema).optional(),
  name: z.lazy(() => SortOrderSchema).optional(),
  slackTeamId: z.lazy(() => SortOrderSchema).optional()
}).strict();

export const GroupSumOrderByAggregateInputSchema: z.ZodType<Prisma.GroupSumOrderByAggregateInput> = z.object({
  id: z.lazy(() => SortOrderSchema).optional()
}).strict();

export const EnumGroupTypeWithAggregatesFilterSchema: z.ZodType<Prisma.EnumGroupTypeWithAggregatesFilter> = z.object({
  equals: z.lazy(() => GroupTypeSchema).optional(),
  in: z.lazy(() => GroupTypeSchema).array().optional(),
  notIn: z.lazy(() => GroupTypeSchema).array().optional(),
  not: z.union([ z.lazy(() => GroupTypeSchema),z.lazy(() => NestedEnumGroupTypeWithAggregatesFilterSchema) ]).optional(),
  _count: z.lazy(() => NestedIntFilterSchema).optional(),
  _min: z.lazy(() => NestedEnumGroupTypeFilterSchema).optional(),
  _max: z.lazy(() => NestedEnumGroupTypeFilterSchema).optional()
}).strict();

export const EnumTargetTypeFilterSchema: z.ZodType<Prisma.EnumTargetTypeFilter> = z.object({
  equals: z.lazy(() => TargetTypeSchema).optional(),
  in: z.lazy(() => TargetTypeSchema).array().optional(),
  notIn: z.lazy(() => TargetTypeSchema).array().optional(),
  not: z.union([ z.lazy(() => TargetTypeSchema),z.lazy(() => NestedEnumTargetTypeFilterSchema) ]).optional(),
}).strict();

export const EnumDayOfTheWeekFilterSchema: z.ZodType<Prisma.EnumDayOfTheWeekFilter> = z.object({
  equals: z.lazy(() => DayOfTheWeekSchema).optional(),
  in: z.lazy(() => DayOfTheWeekSchema).array().optional(),
  notIn: z.lazy(() => DayOfTheWeekSchema).array().optional(),
  not: z.union([ z.lazy(() => DayOfTheWeekSchema),z.lazy(() => NestedEnumDayOfTheWeekFilterSchema) ]).optional(),
}).strict();

export const TargetOrderByRelevanceInputSchema: z.ZodType<Prisma.TargetOrderByRelevanceInput> = z.object({
  fields: z.union([ z.lazy(() => TargetOrderByRelevanceFieldEnumSchema),z.lazy(() => TargetOrderByRelevanceFieldEnumSchema).array() ]),
  sort: z.lazy(() => SortOrderSchema),
  search: z.string()
}).strict();

export const TargetCountOrderByAggregateInputSchema: z.ZodType<Prisma.TargetCountOrderByAggregateInput> = z.object({
  id: z.lazy(() => SortOrderSchema).optional(),
  userId: z.lazy(() => SortOrderSchema).optional(),
  profileId: z.lazy(() => SortOrderSchema).optional(),
  type: z.lazy(() => SortOrderSchema).optional(),
  goal: z.lazy(() => SortOrderSchema).optional(),
  lastFailedAt: z.lazy(() => SortOrderSchema).optional(),
  notifyOn: z.lazy(() => SortOrderSchema).optional(),
  lastNotified: z.lazy(() => SortOrderSchema).optional()
}).strict();

export const TargetAvgOrderByAggregateInputSchema: z.ZodType<Prisma.TargetAvgOrderByAggregateInput> = z.object({
  id: z.lazy(() => SortOrderSchema).optional(),
  profileId: z.lazy(() => SortOrderSchema).optional(),
  goal: z.lazy(() => SortOrderSchema).optional()
}).strict();

export const TargetMaxOrderByAggregateInputSchema: z.ZodType<Prisma.TargetMaxOrderByAggregateInput> = z.object({
  id: z.lazy(() => SortOrderSchema).optional(),
  userId: z.lazy(() => SortOrderSchema).optional(),
  profileId: z.lazy(() => SortOrderSchema).optional(),
  type: z.lazy(() => SortOrderSchema).optional(),
  goal: z.lazy(() => SortOrderSchema).optional(),
  lastFailedAt: z.lazy(() => SortOrderSchema).optional(),
  notifyOn: z.lazy(() => SortOrderSchema).optional(),
  lastNotified: z.lazy(() => SortOrderSchema).optional()
}).strict();

export const TargetMinOrderByAggregateInputSchema: z.ZodType<Prisma.TargetMinOrderByAggregateInput> = z.object({
  id: z.lazy(() => SortOrderSchema).optional(),
  userId: z.lazy(() => SortOrderSchema).optional(),
  profileId: z.lazy(() => SortOrderSchema).optional(),
  type: z.lazy(() => SortOrderSchema).optional(),
  goal: z.lazy(() => SortOrderSchema).optional(),
  lastFailedAt: z.lazy(() => SortOrderSchema).optional(),
  notifyOn: z.lazy(() => SortOrderSchema).optional(),
  lastNotified: z.lazy(() => SortOrderSchema).optional()
}).strict();

export const TargetSumOrderByAggregateInputSchema: z.ZodType<Prisma.TargetSumOrderByAggregateInput> = z.object({
  id: z.lazy(() => SortOrderSchema).optional(),
  profileId: z.lazy(() => SortOrderSchema).optional(),
  goal: z.lazy(() => SortOrderSchema).optional()
}).strict();

export const EnumTargetTypeWithAggregatesFilterSchema: z.ZodType<Prisma.EnumTargetTypeWithAggregatesFilter> = z.object({
  equals: z.lazy(() => TargetTypeSchema).optional(),
  in: z.lazy(() => TargetTypeSchema).array().optional(),
  notIn: z.lazy(() => TargetTypeSchema).array().optional(),
  not: z.union([ z.lazy(() => TargetTypeSchema),z.lazy(() => NestedEnumTargetTypeWithAggregatesFilterSchema) ]).optional(),
  _count: z.lazy(() => NestedIntFilterSchema).optional(),
  _min: z.lazy(() => NestedEnumTargetTypeFilterSchema).optional(),
  _max: z.lazy(() => NestedEnumTargetTypeFilterSchema).optional()
}).strict();

export const EnumDayOfTheWeekWithAggregatesFilterSchema: z.ZodType<Prisma.EnumDayOfTheWeekWithAggregatesFilter> = z.object({
  equals: z.lazy(() => DayOfTheWeekSchema).optional(),
  in: z.lazy(() => DayOfTheWeekSchema).array().optional(),
  notIn: z.lazy(() => DayOfTheWeekSchema).array().optional(),
  not: z.union([ z.lazy(() => DayOfTheWeekSchema),z.lazy(() => NestedEnumDayOfTheWeekWithAggregatesFilterSchema) ]).optional(),
  _count: z.lazy(() => NestedIntFilterSchema).optional(),
  _min: z.lazy(() => NestedEnumDayOfTheWeekFilterSchema).optional(),
  _max: z.lazy(() => NestedEnumDayOfTheWeekFilterSchema).optional()
}).strict();

export const AccountOrderByRelevanceInputSchema: z.ZodType<Prisma.AccountOrderByRelevanceInput> = z.object({
  fields: z.union([ z.lazy(() => AccountOrderByRelevanceFieldEnumSchema),z.lazy(() => AccountOrderByRelevanceFieldEnumSchema).array() ]),
  sort: z.lazy(() => SortOrderSchema),
  search: z.string()
}).strict();

export const AccountProviderProviderAccountIdCompoundUniqueInputSchema: z.ZodType<Prisma.AccountProviderProviderAccountIdCompoundUniqueInput> = z.object({
  provider: z.string(),
  providerAccountId: z.string()
}).strict();

export const AccountCountOrderByAggregateInputSchema: z.ZodType<Prisma.AccountCountOrderByAggregateInput> = z.object({
  id: z.lazy(() => SortOrderSchema).optional(),
  userId: z.lazy(() => SortOrderSchema).optional(),
  type: z.lazy(() => SortOrderSchema).optional(),
  provider: z.lazy(() => SortOrderSchema).optional(),
  providerAccountId: z.lazy(() => SortOrderSchema).optional(),
  refresh_token: z.lazy(() => SortOrderSchema).optional(),
  access_token: z.lazy(() => SortOrderSchema).optional(),
  expires_at: z.lazy(() => SortOrderSchema).optional(),
  token_type: z.lazy(() => SortOrderSchema).optional(),
  scope: z.lazy(() => SortOrderSchema).optional(),
  id_token: z.lazy(() => SortOrderSchema).optional(),
  session_state: z.lazy(() => SortOrderSchema).optional()
}).strict();

export const AccountAvgOrderByAggregateInputSchema: z.ZodType<Prisma.AccountAvgOrderByAggregateInput> = z.object({
  expires_at: z.lazy(() => SortOrderSchema).optional()
}).strict();

export const AccountMaxOrderByAggregateInputSchema: z.ZodType<Prisma.AccountMaxOrderByAggregateInput> = z.object({
  id: z.lazy(() => SortOrderSchema).optional(),
  userId: z.lazy(() => SortOrderSchema).optional(),
  type: z.lazy(() => SortOrderSchema).optional(),
  provider: z.lazy(() => SortOrderSchema).optional(),
  providerAccountId: z.lazy(() => SortOrderSchema).optional(),
  refresh_token: z.lazy(() => SortOrderSchema).optional(),
  access_token: z.lazy(() => SortOrderSchema).optional(),
  expires_at: z.lazy(() => SortOrderSchema).optional(),
  token_type: z.lazy(() => SortOrderSchema).optional(),
  scope: z.lazy(() => SortOrderSchema).optional(),
  id_token: z.lazy(() => SortOrderSchema).optional(),
  session_state: z.lazy(() => SortOrderSchema).optional()
}).strict();

export const AccountMinOrderByAggregateInputSchema: z.ZodType<Prisma.AccountMinOrderByAggregateInput> = z.object({
  id: z.lazy(() => SortOrderSchema).optional(),
  userId: z.lazy(() => SortOrderSchema).optional(),
  type: z.lazy(() => SortOrderSchema).optional(),
  provider: z.lazy(() => SortOrderSchema).optional(),
  providerAccountId: z.lazy(() => SortOrderSchema).optional(),
  refresh_token: z.lazy(() => SortOrderSchema).optional(),
  access_token: z.lazy(() => SortOrderSchema).optional(),
  expires_at: z.lazy(() => SortOrderSchema).optional(),
  token_type: z.lazy(() => SortOrderSchema).optional(),
  scope: z.lazy(() => SortOrderSchema).optional(),
  id_token: z.lazy(() => SortOrderSchema).optional(),
  session_state: z.lazy(() => SortOrderSchema).optional()
}).strict();

export const AccountSumOrderByAggregateInputSchema: z.ZodType<Prisma.AccountSumOrderByAggregateInput> = z.object({
  expires_at: z.lazy(() => SortOrderSchema).optional()
}).strict();

export const CommentOrderByRelevanceInputSchema: z.ZodType<Prisma.CommentOrderByRelevanceInput> = z.object({
  fields: z.union([ z.lazy(() => CommentOrderByRelevanceFieldEnumSchema),z.lazy(() => CommentOrderByRelevanceFieldEnumSchema).array() ]),
  sort: z.lazy(() => SortOrderSchema),
  search: z.string()
}).strict();

export const CommentCountOrderByAggregateInputSchema: z.ZodType<Prisma.CommentCountOrderByAggregateInput> = z.object({
  id: z.lazy(() => SortOrderSchema).optional(),
  createdAt: z.lazy(() => SortOrderSchema).optional(),
  comment: z.lazy(() => SortOrderSchema).optional(),
  questionId: z.lazy(() => SortOrderSchema).optional(),
  userId: z.lazy(() => SortOrderSchema).optional()
}).strict();

export const CommentAvgOrderByAggregateInputSchema: z.ZodType<Prisma.CommentAvgOrderByAggregateInput> = z.object({
  id: z.lazy(() => SortOrderSchema).optional()
}).strict();

export const CommentMaxOrderByAggregateInputSchema: z.ZodType<Prisma.CommentMaxOrderByAggregateInput> = z.object({
  id: z.lazy(() => SortOrderSchema).optional(),
  createdAt: z.lazy(() => SortOrderSchema).optional(),
  comment: z.lazy(() => SortOrderSchema).optional(),
  questionId: z.lazy(() => SortOrderSchema).optional(),
  userId: z.lazy(() => SortOrderSchema).optional()
}).strict();

export const CommentMinOrderByAggregateInputSchema: z.ZodType<Prisma.CommentMinOrderByAggregateInput> = z.object({
  id: z.lazy(() => SortOrderSchema).optional(),
  createdAt: z.lazy(() => SortOrderSchema).optional(),
  comment: z.lazy(() => SortOrderSchema).optional(),
  questionId: z.lazy(() => SortOrderSchema).optional(),
  userId: z.lazy(() => SortOrderSchema).optional()
}).strict();

export const CommentSumOrderByAggregateInputSchema: z.ZodType<Prisma.CommentSumOrderByAggregateInput> = z.object({
  id: z.lazy(() => SortOrderSchema).optional()
}).strict();

export const StringNullableListFilterSchema: z.ZodType<Prisma.StringNullableListFilter> = z.object({
  equals: z.string().array().optional().nullable(),
  has: z.string().optional().nullable(),
  hasEvery: z.string().array().optional(),
  hasSome: z.string().array().optional(),
  isEmpty: z.boolean().optional()
}).strict();

export const UserListOrderByRelevanceInputSchema: z.ZodType<Prisma.UserListOrderByRelevanceInput> = z.object({
  fields: z.union([ z.lazy(() => UserListOrderByRelevanceFieldEnumSchema),z.lazy(() => UserListOrderByRelevanceFieldEnumSchema).array() ]),
  sort: z.lazy(() => SortOrderSchema),
  search: z.string()
}).strict();

export const UserListCountOrderByAggregateInputSchema: z.ZodType<Prisma.UserListCountOrderByAggregateInput> = z.object({
  id: z.lazy(() => SortOrderSchema).optional(),
  createdAt: z.lazy(() => SortOrderSchema).optional(),
  inviteId: z.lazy(() => SortOrderSchema).optional(),
  name: z.lazy(() => SortOrderSchema).optional(),
  emailDomains: z.lazy(() => SortOrderSchema).optional(),
  syncToSlackTeamId: z.lazy(() => SortOrderSchema).optional(),
  syncToSlackChannelId: z.lazy(() => SortOrderSchema).optional(),
  authorId: z.lazy(() => SortOrderSchema).optional()
}).strict();

export const UserListMaxOrderByAggregateInputSchema: z.ZodType<Prisma.UserListMaxOrderByAggregateInput> = z.object({
  id: z.lazy(() => SortOrderSchema).optional(),
  createdAt: z.lazy(() => SortOrderSchema).optional(),
  inviteId: z.lazy(() => SortOrderSchema).optional(),
  name: z.lazy(() => SortOrderSchema).optional(),
  syncToSlackTeamId: z.lazy(() => SortOrderSchema).optional(),
  syncToSlackChannelId: z.lazy(() => SortOrderSchema).optional(),
  authorId: z.lazy(() => SortOrderSchema).optional()
}).strict();

export const UserListMinOrderByAggregateInputSchema: z.ZodType<Prisma.UserListMinOrderByAggregateInput> = z.object({
  id: z.lazy(() => SortOrderSchema).optional(),
  createdAt: z.lazy(() => SortOrderSchema).optional(),
  inviteId: z.lazy(() => SortOrderSchema).optional(),
  name: z.lazy(() => SortOrderSchema).optional(),
  syncToSlackTeamId: z.lazy(() => SortOrderSchema).optional(),
  syncToSlackChannelId: z.lazy(() => SortOrderSchema).optional(),
  authorId: z.lazy(() => SortOrderSchema).optional()
}).strict();

export const UserListNullableRelationFilterSchema: z.ZodType<Prisma.UserListNullableRelationFilter> = z.object({
  is: z.lazy(() => UserListWhereInputSchema).optional().nullable(),
  isNot: z.lazy(() => UserListWhereInputSchema).optional().nullable()
}).strict();

export const TournamentOrderByRelevanceInputSchema: z.ZodType<Prisma.TournamentOrderByRelevanceInput> = z.object({
  fields: z.union([ z.lazy(() => TournamentOrderByRelevanceFieldEnumSchema),z.lazy(() => TournamentOrderByRelevanceFieldEnumSchema).array() ]),
  sort: z.lazy(() => SortOrderSchema),
  search: z.string()
}).strict();

export const TournamentCountOrderByAggregateInputSchema: z.ZodType<Prisma.TournamentCountOrderByAggregateInput> = z.object({
  id: z.lazy(() => SortOrderSchema).optional(),
  createdAt: z.lazy(() => SortOrderSchema).optional(),
  name: z.lazy(() => SortOrderSchema).optional(),
  description: z.lazy(() => SortOrderSchema).optional(),
  authorId: z.lazy(() => SortOrderSchema).optional(),
  sharedPublicly: z.lazy(() => SortOrderSchema).optional(),
  unlisted: z.lazy(() => SortOrderSchema).optional(),
  userListId: z.lazy(() => SortOrderSchema).optional(),
  anyoneInListCanEdit: z.lazy(() => SortOrderSchema).optional(),
  showLeaderboard: z.lazy(() => SortOrderSchema).optional(),
  predictYourYear: z.lazy(() => SortOrderSchema).optional(),
  syncToSlackTeamId: z.lazy(() => SortOrderSchema).optional(),
  syncToSlackChannelId: z.lazy(() => SortOrderSchema).optional()
}).strict();

export const TournamentAvgOrderByAggregateInputSchema: z.ZodType<Prisma.TournamentAvgOrderByAggregateInput> = z.object({
  predictYourYear: z.lazy(() => SortOrderSchema).optional()
}).strict();

export const TournamentMaxOrderByAggregateInputSchema: z.ZodType<Prisma.TournamentMaxOrderByAggregateInput> = z.object({
  id: z.lazy(() => SortOrderSchema).optional(),
  createdAt: z.lazy(() => SortOrderSchema).optional(),
  name: z.lazy(() => SortOrderSchema).optional(),
  description: z.lazy(() => SortOrderSchema).optional(),
  authorId: z.lazy(() => SortOrderSchema).optional(),
  sharedPublicly: z.lazy(() => SortOrderSchema).optional(),
  unlisted: z.lazy(() => SortOrderSchema).optional(),
  userListId: z.lazy(() => SortOrderSchema).optional(),
  anyoneInListCanEdit: z.lazy(() => SortOrderSchema).optional(),
  showLeaderboard: z.lazy(() => SortOrderSchema).optional(),
  predictYourYear: z.lazy(() => SortOrderSchema).optional(),
  syncToSlackTeamId: z.lazy(() => SortOrderSchema).optional(),
  syncToSlackChannelId: z.lazy(() => SortOrderSchema).optional()
}).strict();

export const TournamentMinOrderByAggregateInputSchema: z.ZodType<Prisma.TournamentMinOrderByAggregateInput> = z.object({
  id: z.lazy(() => SortOrderSchema).optional(),
  createdAt: z.lazy(() => SortOrderSchema).optional(),
  name: z.lazy(() => SortOrderSchema).optional(),
  description: z.lazy(() => SortOrderSchema).optional(),
  authorId: z.lazy(() => SortOrderSchema).optional(),
  sharedPublicly: z.lazy(() => SortOrderSchema).optional(),
  unlisted: z.lazy(() => SortOrderSchema).optional(),
  userListId: z.lazy(() => SortOrderSchema).optional(),
  anyoneInListCanEdit: z.lazy(() => SortOrderSchema).optional(),
  showLeaderboard: z.lazy(() => SortOrderSchema).optional(),
  predictYourYear: z.lazy(() => SortOrderSchema).optional(),
  syncToSlackTeamId: z.lazy(() => SortOrderSchema).optional(),
  syncToSlackChannelId: z.lazy(() => SortOrderSchema).optional()
}).strict();

export const TournamentSumOrderByAggregateInputSchema: z.ZodType<Prisma.TournamentSumOrderByAggregateInput> = z.object({
  predictYourYear: z.lazy(() => SortOrderSchema).optional()
}).strict();

export const QuestionNullableRelationFilterSchema: z.ZodType<Prisma.QuestionNullableRelationFilter> = z.object({
  is: z.lazy(() => QuestionWhereInputSchema).optional().nullable(),
  isNot: z.lazy(() => QuestionWhereInputSchema).optional().nullable()
}).strict();

export const NotificationOrderByRelevanceInputSchema: z.ZodType<Prisma.NotificationOrderByRelevanceInput> = z.object({
  fields: z.union([ z.lazy(() => NotificationOrderByRelevanceFieldEnumSchema),z.lazy(() => NotificationOrderByRelevanceFieldEnumSchema).array() ]),
  sort: z.lazy(() => SortOrderSchema),
  search: z.string()
}).strict();

export const NotificationCountOrderByAggregateInputSchema: z.ZodType<Prisma.NotificationCountOrderByAggregateInput> = z.object({
  id: z.lazy(() => SortOrderSchema).optional(),
  createdAt: z.lazy(() => SortOrderSchema).optional(),
  emailSentAt: z.lazy(() => SortOrderSchema).optional(),
  title: z.lazy(() => SortOrderSchema).optional(),
  content: z.lazy(() => SortOrderSchema).optional(),
  url: z.lazy(() => SortOrderSchema).optional(),
  tags: z.lazy(() => SortOrderSchema).optional(),
  read: z.lazy(() => SortOrderSchema).optional(),
  userId: z.lazy(() => SortOrderSchema).optional(),
  questionId: z.lazy(() => SortOrderSchema).optional()
}).strict();

export const NotificationMaxOrderByAggregateInputSchema: z.ZodType<Prisma.NotificationMaxOrderByAggregateInput> = z.object({
  id: z.lazy(() => SortOrderSchema).optional(),
  createdAt: z.lazy(() => SortOrderSchema).optional(),
  emailSentAt: z.lazy(() => SortOrderSchema).optional(),
  title: z.lazy(() => SortOrderSchema).optional(),
  content: z.lazy(() => SortOrderSchema).optional(),
  url: z.lazy(() => SortOrderSchema).optional(),
  read: z.lazy(() => SortOrderSchema).optional(),
  userId: z.lazy(() => SortOrderSchema).optional(),
  questionId: z.lazy(() => SortOrderSchema).optional()
}).strict();

export const NotificationMinOrderByAggregateInputSchema: z.ZodType<Prisma.NotificationMinOrderByAggregateInput> = z.object({
  id: z.lazy(() => SortOrderSchema).optional(),
  createdAt: z.lazy(() => SortOrderSchema).optional(),
  emailSentAt: z.lazy(() => SortOrderSchema).optional(),
  title: z.lazy(() => SortOrderSchema).optional(),
  content: z.lazy(() => SortOrderSchema).optional(),
  url: z.lazy(() => SortOrderSchema).optional(),
  read: z.lazy(() => SortOrderSchema).optional(),
  userId: z.lazy(() => SortOrderSchema).optional(),
  questionId: z.lazy(() => SortOrderSchema).optional()
}).strict();

export const FeedbackOrderByRelevanceInputSchema: z.ZodType<Prisma.FeedbackOrderByRelevanceInput> = z.object({
  fields: z.union([ z.lazy(() => FeedbackOrderByRelevanceFieldEnumSchema),z.lazy(() => FeedbackOrderByRelevanceFieldEnumSchema).array() ]),
  sort: z.lazy(() => SortOrderSchema),
  search: z.string()
}).strict();

export const FeedbackCountOrderByAggregateInputSchema: z.ZodType<Prisma.FeedbackCountOrderByAggregateInput> = z.object({
  id: z.lazy(() => SortOrderSchema).optional(),
  createdAt: z.lazy(() => SortOrderSchema).optional(),
  type: z.lazy(() => SortOrderSchema).optional(),
  message: z.lazy(() => SortOrderSchema).optional(),
  email: z.lazy(() => SortOrderSchema).optional(),
  userId: z.lazy(() => SortOrderSchema).optional()
}).strict();

export const FeedbackMaxOrderByAggregateInputSchema: z.ZodType<Prisma.FeedbackMaxOrderByAggregateInput> = z.object({
  id: z.lazy(() => SortOrderSchema).optional(),
  createdAt: z.lazy(() => SortOrderSchema).optional(),
  type: z.lazy(() => SortOrderSchema).optional(),
  message: z.lazy(() => SortOrderSchema).optional(),
  email: z.lazy(() => SortOrderSchema).optional(),
  userId: z.lazy(() => SortOrderSchema).optional()
}).strict();

export const FeedbackMinOrderByAggregateInputSchema: z.ZodType<Prisma.FeedbackMinOrderByAggregateInput> = z.object({
  id: z.lazy(() => SortOrderSchema).optional(),
  createdAt: z.lazy(() => SortOrderSchema).optional(),
  type: z.lazy(() => SortOrderSchema).optional(),
  message: z.lazy(() => SortOrderSchema).optional(),
  email: z.lazy(() => SortOrderSchema).optional(),
  userId: z.lazy(() => SortOrderSchema).optional()
}).strict();

export const StringFieldUpdateOperationsInputSchema: z.ZodType<Prisma.StringFieldUpdateOperationsInput> = z.object({
  set: z.string().optional()
}).strict();

export const DateTimeFieldUpdateOperationsInputSchema: z.ZodType<Prisma.DateTimeFieldUpdateOperationsInput> = z.object({
  set: z.coerce.date().optional()
}).strict();

export const QuestionOptionCreateNestedOneWithoutForecastsInputSchema: z.ZodType<Prisma.QuestionOptionCreateNestedOneWithoutForecastsInput> = z.object({
  create: z.union([ z.lazy(() => QuestionOptionCreateWithoutForecastsInputSchema),z.lazy(() => QuestionOptionUncheckedCreateWithoutForecastsInputSchema) ]).optional(),
  connectOrCreate: z.lazy(() => QuestionOptionCreateOrConnectWithoutForecastsInputSchema).optional(),
  connect: z.lazy(() => QuestionOptionWhereUniqueInputSchema).optional()
}).strict();

export const ProfileCreateNestedOneWithoutForecastsInputSchema: z.ZodType<Prisma.ProfileCreateNestedOneWithoutForecastsInput> = z.object({
  create: z.union([ z.lazy(() => ProfileCreateWithoutForecastsInputSchema),z.lazy(() => ProfileUncheckedCreateWithoutForecastsInputSchema) ]).optional(),
  connectOrCreate: z.lazy(() => ProfileCreateOrConnectWithoutForecastsInputSchema).optional(),
  connect: z.lazy(() => ProfileWhereUniqueInputSchema).optional()
}).strict();

export const QuestionCreateNestedOneWithoutForecastsInputSchema: z.ZodType<Prisma.QuestionCreateNestedOneWithoutForecastsInput> = z.object({
  create: z.union([ z.lazy(() => QuestionCreateWithoutForecastsInputSchema),z.lazy(() => QuestionUncheckedCreateWithoutForecastsInputSchema) ]).optional(),
  connectOrCreate: z.lazy(() => QuestionCreateOrConnectWithoutForecastsInputSchema).optional(),
  connect: z.lazy(() => QuestionWhereUniqueInputSchema).optional()
}).strict();

export const UserCreateNestedOneWithoutForecastsInputSchema: z.ZodType<Prisma.UserCreateNestedOneWithoutForecastsInput> = z.object({
  create: z.union([ z.lazy(() => UserCreateWithoutForecastsInputSchema),z.lazy(() => UserUncheckedCreateWithoutForecastsInputSchema) ]).optional(),
  connectOrCreate: z.lazy(() => UserCreateOrConnectWithoutForecastsInputSchema).optional(),
  connect: z.lazy(() => UserWhereUniqueInputSchema).optional()
}).strict();

export const NullableStringFieldUpdateOperationsInputSchema: z.ZodType<Prisma.NullableStringFieldUpdateOperationsInput> = z.object({
  set: z.string().optional().nullable()
}).strict();

export const DecimalFieldUpdateOperationsInputSchema: z.ZodType<Prisma.DecimalFieldUpdateOperationsInput> = z.object({
  set: z.union([z.number(),z.string(),z.instanceof(Decimal),z.instanceof(Prisma.Decimal),DecimalJsLikeSchema,]).refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' }).optional(),
  increment: z.union([z.number(),z.string(),z.instanceof(Decimal),z.instanceof(Prisma.Decimal),DecimalJsLikeSchema,]).refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' }).optional(),
  decrement: z.union([z.number(),z.string(),z.instanceof(Decimal),z.instanceof(Prisma.Decimal),DecimalJsLikeSchema,]).refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' }).optional(),
  multiply: z.union([z.number(),z.string(),z.instanceof(Decimal),z.instanceof(Prisma.Decimal),DecimalJsLikeSchema,]).refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' }).optional(),
  divide: z.union([z.number(),z.string(),z.instanceof(Decimal),z.instanceof(Prisma.Decimal),DecimalJsLikeSchema,]).refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' }).optional()
}).strict();

export const QuestionOptionUpdateOneWithoutForecastsNestedInputSchema: z.ZodType<Prisma.QuestionOptionUpdateOneWithoutForecastsNestedInput> = z.object({
  create: z.union([ z.lazy(() => QuestionOptionCreateWithoutForecastsInputSchema),z.lazy(() => QuestionOptionUncheckedCreateWithoutForecastsInputSchema) ]).optional(),
  connectOrCreate: z.lazy(() => QuestionOptionCreateOrConnectWithoutForecastsInputSchema).optional(),
  upsert: z.lazy(() => QuestionOptionUpsertWithoutForecastsInputSchema).optional(),
  disconnect: z.union([ z.boolean(),z.lazy(() => QuestionOptionWhereInputSchema) ]).optional(),
  delete: z.union([ z.boolean(),z.lazy(() => QuestionOptionWhereInputSchema) ]).optional(),
  connect: z.lazy(() => QuestionOptionWhereUniqueInputSchema).optional(),
  update: z.union([ z.lazy(() => QuestionOptionUpdateToOneWithWhereWithoutForecastsInputSchema),z.lazy(() => QuestionOptionUpdateWithoutForecastsInputSchema),z.lazy(() => QuestionOptionUncheckedUpdateWithoutForecastsInputSchema) ]).optional(),
}).strict();

export const ProfileUpdateOneWithoutForecastsNestedInputSchema: z.ZodType<Prisma.ProfileUpdateOneWithoutForecastsNestedInput> = z.object({
  create: z.union([ z.lazy(() => ProfileCreateWithoutForecastsInputSchema),z.lazy(() => ProfileUncheckedCreateWithoutForecastsInputSchema) ]).optional(),
  connectOrCreate: z.lazy(() => ProfileCreateOrConnectWithoutForecastsInputSchema).optional(),
  upsert: z.lazy(() => ProfileUpsertWithoutForecastsInputSchema).optional(),
  disconnect: z.union([ z.boolean(),z.lazy(() => ProfileWhereInputSchema) ]).optional(),
  delete: z.union([ z.boolean(),z.lazy(() => ProfileWhereInputSchema) ]).optional(),
  connect: z.lazy(() => ProfileWhereUniqueInputSchema).optional(),
  update: z.union([ z.lazy(() => ProfileUpdateToOneWithWhereWithoutForecastsInputSchema),z.lazy(() => ProfileUpdateWithoutForecastsInputSchema),z.lazy(() => ProfileUncheckedUpdateWithoutForecastsInputSchema) ]).optional(),
}).strict();

export const QuestionUpdateOneRequiredWithoutForecastsNestedInputSchema: z.ZodType<Prisma.QuestionUpdateOneRequiredWithoutForecastsNestedInput> = z.object({
  create: z.union([ z.lazy(() => QuestionCreateWithoutForecastsInputSchema),z.lazy(() => QuestionUncheckedCreateWithoutForecastsInputSchema) ]).optional(),
  connectOrCreate: z.lazy(() => QuestionCreateOrConnectWithoutForecastsInputSchema).optional(),
  upsert: z.lazy(() => QuestionUpsertWithoutForecastsInputSchema).optional(),
  connect: z.lazy(() => QuestionWhereUniqueInputSchema).optional(),
  update: z.union([ z.lazy(() => QuestionUpdateToOneWithWhereWithoutForecastsInputSchema),z.lazy(() => QuestionUpdateWithoutForecastsInputSchema),z.lazy(() => QuestionUncheckedUpdateWithoutForecastsInputSchema) ]).optional(),
}).strict();

export const UserUpdateOneRequiredWithoutForecastsNestedInputSchema: z.ZodType<Prisma.UserUpdateOneRequiredWithoutForecastsNestedInput> = z.object({
  create: z.union([ z.lazy(() => UserCreateWithoutForecastsInputSchema),z.lazy(() => UserUncheckedCreateWithoutForecastsInputSchema) ]).optional(),
  connectOrCreate: z.lazy(() => UserCreateOrConnectWithoutForecastsInputSchema).optional(),
  upsert: z.lazy(() => UserUpsertWithoutForecastsInputSchema).optional(),
  connect: z.lazy(() => UserWhereUniqueInputSchema).optional(),
  update: z.union([ z.lazy(() => UserUpdateToOneWithWhereWithoutForecastsInputSchema),z.lazy(() => UserUpdateWithoutForecastsInputSchema),z.lazy(() => UserUncheckedUpdateWithoutForecastsInputSchema) ]).optional(),
}).strict();

export const IntFieldUpdateOperationsInputSchema: z.ZodType<Prisma.IntFieldUpdateOperationsInput> = z.object({
  set: z.number().optional(),
  increment: z.number().optional(),
  decrement: z.number().optional(),
  multiply: z.number().optional(),
  divide: z.number().optional()
}).strict();

export const NullableIntFieldUpdateOperationsInputSchema: z.ZodType<Prisma.NullableIntFieldUpdateOperationsInput> = z.object({
  set: z.number().optional().nullable(),
  increment: z.number().optional(),
  decrement: z.number().optional(),
  multiply: z.number().optional(),
  divide: z.number().optional()
}).strict();

export const QuestionCreateNestedOneWithoutQuestionScoresInputSchema: z.ZodType<Prisma.QuestionCreateNestedOneWithoutQuestionScoresInput> = z.object({
  create: z.union([ z.lazy(() => QuestionCreateWithoutQuestionScoresInputSchema),z.lazy(() => QuestionUncheckedCreateWithoutQuestionScoresInputSchema) ]).optional(),
  connectOrCreate: z.lazy(() => QuestionCreateOrConnectWithoutQuestionScoresInputSchema).optional(),
  connect: z.lazy(() => QuestionWhereUniqueInputSchema).optional()
}).strict();

export const UserCreateNestedOneWithoutQuestionScoresInputSchema: z.ZodType<Prisma.UserCreateNestedOneWithoutQuestionScoresInput> = z.object({
  create: z.union([ z.lazy(() => UserCreateWithoutQuestionScoresInputSchema),z.lazy(() => UserUncheckedCreateWithoutQuestionScoresInputSchema) ]).optional(),
  connectOrCreate: z.lazy(() => UserCreateOrConnectWithoutQuestionScoresInputSchema).optional(),
  connect: z.lazy(() => UserWhereUniqueInputSchema).optional()
}).strict();

export const QuestionOptionCreateNestedOneWithoutQuestionScoresInputSchema: z.ZodType<Prisma.QuestionOptionCreateNestedOneWithoutQuestionScoresInput> = z.object({
  create: z.union([ z.lazy(() => QuestionOptionCreateWithoutQuestionScoresInputSchema),z.lazy(() => QuestionOptionUncheckedCreateWithoutQuestionScoresInputSchema) ]).optional(),
  connectOrCreate: z.lazy(() => QuestionOptionCreateOrConnectWithoutQuestionScoresInputSchema).optional(),
  connect: z.lazy(() => QuestionOptionWhereUniqueInputSchema).optional()
}).strict();

export const NullableDecimalFieldUpdateOperationsInputSchema: z.ZodType<Prisma.NullableDecimalFieldUpdateOperationsInput> = z.object({
  set: z.union([z.number(),z.string(),z.instanceof(Decimal),z.instanceof(Prisma.Decimal),DecimalJsLikeSchema,]).refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' }).optional().nullable(),
  increment: z.union([z.number(),z.string(),z.instanceof(Decimal),z.instanceof(Prisma.Decimal),DecimalJsLikeSchema,]).refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' }).optional(),
  decrement: z.union([z.number(),z.string(),z.instanceof(Decimal),z.instanceof(Prisma.Decimal),DecimalJsLikeSchema,]).refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' }).optional(),
  multiply: z.union([z.number(),z.string(),z.instanceof(Decimal),z.instanceof(Prisma.Decimal),DecimalJsLikeSchema,]).refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' }).optional(),
  divide: z.union([z.number(),z.string(),z.instanceof(Decimal),z.instanceof(Prisma.Decimal),DecimalJsLikeSchema,]).refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' }).optional()
}).strict();

export const QuestionUpdateOneRequiredWithoutQuestionScoresNestedInputSchema: z.ZodType<Prisma.QuestionUpdateOneRequiredWithoutQuestionScoresNestedInput> = z.object({
  create: z.union([ z.lazy(() => QuestionCreateWithoutQuestionScoresInputSchema),z.lazy(() => QuestionUncheckedCreateWithoutQuestionScoresInputSchema) ]).optional(),
  connectOrCreate: z.lazy(() => QuestionCreateOrConnectWithoutQuestionScoresInputSchema).optional(),
  upsert: z.lazy(() => QuestionUpsertWithoutQuestionScoresInputSchema).optional(),
  connect: z.lazy(() => QuestionWhereUniqueInputSchema).optional(),
  update: z.union([ z.lazy(() => QuestionUpdateToOneWithWhereWithoutQuestionScoresInputSchema),z.lazy(() => QuestionUpdateWithoutQuestionScoresInputSchema),z.lazy(() => QuestionUncheckedUpdateWithoutQuestionScoresInputSchema) ]).optional(),
}).strict();

export const UserUpdateOneRequiredWithoutQuestionScoresNestedInputSchema: z.ZodType<Prisma.UserUpdateOneRequiredWithoutQuestionScoresNestedInput> = z.object({
  create: z.union([ z.lazy(() => UserCreateWithoutQuestionScoresInputSchema),z.lazy(() => UserUncheckedCreateWithoutQuestionScoresInputSchema) ]).optional(),
  connectOrCreate: z.lazy(() => UserCreateOrConnectWithoutQuestionScoresInputSchema).optional(),
  upsert: z.lazy(() => UserUpsertWithoutQuestionScoresInputSchema).optional(),
  connect: z.lazy(() => UserWhereUniqueInputSchema).optional(),
  update: z.union([ z.lazy(() => UserUpdateToOneWithWhereWithoutQuestionScoresInputSchema),z.lazy(() => UserUpdateWithoutQuestionScoresInputSchema),z.lazy(() => UserUncheckedUpdateWithoutQuestionScoresInputSchema) ]).optional(),
}).strict();

export const QuestionOptionUpdateOneWithoutQuestionScoresNestedInputSchema: z.ZodType<Prisma.QuestionOptionUpdateOneWithoutQuestionScoresNestedInput> = z.object({
  create: z.union([ z.lazy(() => QuestionOptionCreateWithoutQuestionScoresInputSchema),z.lazy(() => QuestionOptionUncheckedCreateWithoutQuestionScoresInputSchema) ]).optional(),
  connectOrCreate: z.lazy(() => QuestionOptionCreateOrConnectWithoutQuestionScoresInputSchema).optional(),
  upsert: z.lazy(() => QuestionOptionUpsertWithoutQuestionScoresInputSchema).optional(),
  disconnect: z.union([ z.boolean(),z.lazy(() => QuestionOptionWhereInputSchema) ]).optional(),
  delete: z.union([ z.boolean(),z.lazy(() => QuestionOptionWhereInputSchema) ]).optional(),
  connect: z.lazy(() => QuestionOptionWhereUniqueInputSchema).optional(),
  update: z.union([ z.lazy(() => QuestionOptionUpdateToOneWithWhereWithoutQuestionScoresInputSchema),z.lazy(() => QuestionOptionUpdateWithoutQuestionScoresInputSchema),z.lazy(() => QuestionOptionUncheckedUpdateWithoutQuestionScoresInputSchema) ]).optional(),
}).strict();

export const QuestionCreateNestedOneWithoutOptionsInputSchema: z.ZodType<Prisma.QuestionCreateNestedOneWithoutOptionsInput> = z.object({
  create: z.union([ z.lazy(() => QuestionCreateWithoutOptionsInputSchema),z.lazy(() => QuestionUncheckedCreateWithoutOptionsInputSchema) ]).optional(),
  connectOrCreate: z.lazy(() => QuestionCreateOrConnectWithoutOptionsInputSchema).optional(),
  connect: z.lazy(() => QuestionWhereUniqueInputSchema).optional()
}).strict();

export const ForecastCreateNestedManyWithoutOptionInputSchema: z.ZodType<Prisma.ForecastCreateNestedManyWithoutOptionInput> = z.object({
  create: z.union([ z.lazy(() => ForecastCreateWithoutOptionInputSchema),z.lazy(() => ForecastCreateWithoutOptionInputSchema).array(),z.lazy(() => ForecastUncheckedCreateWithoutOptionInputSchema),z.lazy(() => ForecastUncheckedCreateWithoutOptionInputSchema).array() ]).optional(),
  connectOrCreate: z.union([ z.lazy(() => ForecastCreateOrConnectWithoutOptionInputSchema),z.lazy(() => ForecastCreateOrConnectWithoutOptionInputSchema).array() ]).optional(),
  createMany: z.lazy(() => ForecastCreateManyOptionInputEnvelopeSchema).optional(),
  connect: z.union([ z.lazy(() => ForecastWhereUniqueInputSchema),z.lazy(() => ForecastWhereUniqueInputSchema).array() ]).optional(),
}).strict();

export const UserCreateNestedOneWithoutQuestionOptionsInputSchema: z.ZodType<Prisma.UserCreateNestedOneWithoutQuestionOptionsInput> = z.object({
  create: z.union([ z.lazy(() => UserCreateWithoutQuestionOptionsInputSchema),z.lazy(() => UserUncheckedCreateWithoutQuestionOptionsInputSchema) ]).optional(),
  connectOrCreate: z.lazy(() => UserCreateOrConnectWithoutQuestionOptionsInputSchema).optional(),
  connect: z.lazy(() => UserWhereUniqueInputSchema).optional()
}).strict();

export const QuestionScoreCreateNestedManyWithoutQuestionOptionInputSchema: z.ZodType<Prisma.QuestionScoreCreateNestedManyWithoutQuestionOptionInput> = z.object({
  create: z.union([ z.lazy(() => QuestionScoreCreateWithoutQuestionOptionInputSchema),z.lazy(() => QuestionScoreCreateWithoutQuestionOptionInputSchema).array(),z.lazy(() => QuestionScoreUncheckedCreateWithoutQuestionOptionInputSchema),z.lazy(() => QuestionScoreUncheckedCreateWithoutQuestionOptionInputSchema).array() ]).optional(),
  connectOrCreate: z.union([ z.lazy(() => QuestionScoreCreateOrConnectWithoutQuestionOptionInputSchema),z.lazy(() => QuestionScoreCreateOrConnectWithoutQuestionOptionInputSchema).array() ]).optional(),
  createMany: z.lazy(() => QuestionScoreCreateManyQuestionOptionInputEnvelopeSchema).optional(),
  connect: z.union([ z.lazy(() => QuestionScoreWhereUniqueInputSchema),z.lazy(() => QuestionScoreWhereUniqueInputSchema).array() ]).optional(),
}).strict();

export const ForecastUncheckedCreateNestedManyWithoutOptionInputSchema: z.ZodType<Prisma.ForecastUncheckedCreateNestedManyWithoutOptionInput> = z.object({
  create: z.union([ z.lazy(() => ForecastCreateWithoutOptionInputSchema),z.lazy(() => ForecastCreateWithoutOptionInputSchema).array(),z.lazy(() => ForecastUncheckedCreateWithoutOptionInputSchema),z.lazy(() => ForecastUncheckedCreateWithoutOptionInputSchema).array() ]).optional(),
  connectOrCreate: z.union([ z.lazy(() => ForecastCreateOrConnectWithoutOptionInputSchema),z.lazy(() => ForecastCreateOrConnectWithoutOptionInputSchema).array() ]).optional(),
  createMany: z.lazy(() => ForecastCreateManyOptionInputEnvelopeSchema).optional(),
  connect: z.union([ z.lazy(() => ForecastWhereUniqueInputSchema),z.lazy(() => ForecastWhereUniqueInputSchema).array() ]).optional(),
}).strict();

export const QuestionScoreUncheckedCreateNestedManyWithoutQuestionOptionInputSchema: z.ZodType<Prisma.QuestionScoreUncheckedCreateNestedManyWithoutQuestionOptionInput> = z.object({
  create: z.union([ z.lazy(() => QuestionScoreCreateWithoutQuestionOptionInputSchema),z.lazy(() => QuestionScoreCreateWithoutQuestionOptionInputSchema).array(),z.lazy(() => QuestionScoreUncheckedCreateWithoutQuestionOptionInputSchema),z.lazy(() => QuestionScoreUncheckedCreateWithoutQuestionOptionInputSchema).array() ]).optional(),
  connectOrCreate: z.union([ z.lazy(() => QuestionScoreCreateOrConnectWithoutQuestionOptionInputSchema),z.lazy(() => QuestionScoreCreateOrConnectWithoutQuestionOptionInputSchema).array() ]).optional(),
  createMany: z.lazy(() => QuestionScoreCreateManyQuestionOptionInputEnvelopeSchema).optional(),
  connect: z.union([ z.lazy(() => QuestionScoreWhereUniqueInputSchema),z.lazy(() => QuestionScoreWhereUniqueInputSchema).array() ]).optional(),
}).strict();

export const NullableEnumResolutionFieldUpdateOperationsInputSchema: z.ZodType<Prisma.NullableEnumResolutionFieldUpdateOperationsInput> = z.object({
  set: z.lazy(() => ResolutionSchema).optional().nullable()
}).strict();

export const NullableDateTimeFieldUpdateOperationsInputSchema: z.ZodType<Prisma.NullableDateTimeFieldUpdateOperationsInput> = z.object({
  set: z.coerce.date().optional().nullable()
}).strict();

export const QuestionUpdateOneRequiredWithoutOptionsNestedInputSchema: z.ZodType<Prisma.QuestionUpdateOneRequiredWithoutOptionsNestedInput> = z.object({
  create: z.union([ z.lazy(() => QuestionCreateWithoutOptionsInputSchema),z.lazy(() => QuestionUncheckedCreateWithoutOptionsInputSchema) ]).optional(),
  connectOrCreate: z.lazy(() => QuestionCreateOrConnectWithoutOptionsInputSchema).optional(),
  upsert: z.lazy(() => QuestionUpsertWithoutOptionsInputSchema).optional(),
  connect: z.lazy(() => QuestionWhereUniqueInputSchema).optional(),
  update: z.union([ z.lazy(() => QuestionUpdateToOneWithWhereWithoutOptionsInputSchema),z.lazy(() => QuestionUpdateWithoutOptionsInputSchema),z.lazy(() => QuestionUncheckedUpdateWithoutOptionsInputSchema) ]).optional(),
}).strict();

export const ForecastUpdateManyWithoutOptionNestedInputSchema: z.ZodType<Prisma.ForecastUpdateManyWithoutOptionNestedInput> = z.object({
  create: z.union([ z.lazy(() => ForecastCreateWithoutOptionInputSchema),z.lazy(() => ForecastCreateWithoutOptionInputSchema).array(),z.lazy(() => ForecastUncheckedCreateWithoutOptionInputSchema),z.lazy(() => ForecastUncheckedCreateWithoutOptionInputSchema).array() ]).optional(),
  connectOrCreate: z.union([ z.lazy(() => ForecastCreateOrConnectWithoutOptionInputSchema),z.lazy(() => ForecastCreateOrConnectWithoutOptionInputSchema).array() ]).optional(),
  upsert: z.union([ z.lazy(() => ForecastUpsertWithWhereUniqueWithoutOptionInputSchema),z.lazy(() => ForecastUpsertWithWhereUniqueWithoutOptionInputSchema).array() ]).optional(),
  createMany: z.lazy(() => ForecastCreateManyOptionInputEnvelopeSchema).optional(),
  set: z.union([ z.lazy(() => ForecastWhereUniqueInputSchema),z.lazy(() => ForecastWhereUniqueInputSchema).array() ]).optional(),
  disconnect: z.union([ z.lazy(() => ForecastWhereUniqueInputSchema),z.lazy(() => ForecastWhereUniqueInputSchema).array() ]).optional(),
  delete: z.union([ z.lazy(() => ForecastWhereUniqueInputSchema),z.lazy(() => ForecastWhereUniqueInputSchema).array() ]).optional(),
  connect: z.union([ z.lazy(() => ForecastWhereUniqueInputSchema),z.lazy(() => ForecastWhereUniqueInputSchema).array() ]).optional(),
  update: z.union([ z.lazy(() => ForecastUpdateWithWhereUniqueWithoutOptionInputSchema),z.lazy(() => ForecastUpdateWithWhereUniqueWithoutOptionInputSchema).array() ]).optional(),
  updateMany: z.union([ z.lazy(() => ForecastUpdateManyWithWhereWithoutOptionInputSchema),z.lazy(() => ForecastUpdateManyWithWhereWithoutOptionInputSchema).array() ]).optional(),
  deleteMany: z.union([ z.lazy(() => ForecastScalarWhereInputSchema),z.lazy(() => ForecastScalarWhereInputSchema).array() ]).optional(),
}).strict();

export const UserUpdateOneRequiredWithoutQuestionOptionsNestedInputSchema: z.ZodType<Prisma.UserUpdateOneRequiredWithoutQuestionOptionsNestedInput> = z.object({
  create: z.union([ z.lazy(() => UserCreateWithoutQuestionOptionsInputSchema),z.lazy(() => UserUncheckedCreateWithoutQuestionOptionsInputSchema) ]).optional(),
  connectOrCreate: z.lazy(() => UserCreateOrConnectWithoutQuestionOptionsInputSchema).optional(),
  upsert: z.lazy(() => UserUpsertWithoutQuestionOptionsInputSchema).optional(),
  connect: z.lazy(() => UserWhereUniqueInputSchema).optional(),
  update: z.union([ z.lazy(() => UserUpdateToOneWithWhereWithoutQuestionOptionsInputSchema),z.lazy(() => UserUpdateWithoutQuestionOptionsInputSchema),z.lazy(() => UserUncheckedUpdateWithoutQuestionOptionsInputSchema) ]).optional(),
}).strict();

export const QuestionScoreUpdateManyWithoutQuestionOptionNestedInputSchema: z.ZodType<Prisma.QuestionScoreUpdateManyWithoutQuestionOptionNestedInput> = z.object({
  create: z.union([ z.lazy(() => QuestionScoreCreateWithoutQuestionOptionInputSchema),z.lazy(() => QuestionScoreCreateWithoutQuestionOptionInputSchema).array(),z.lazy(() => QuestionScoreUncheckedCreateWithoutQuestionOptionInputSchema),z.lazy(() => QuestionScoreUncheckedCreateWithoutQuestionOptionInputSchema).array() ]).optional(),
  connectOrCreate: z.union([ z.lazy(() => QuestionScoreCreateOrConnectWithoutQuestionOptionInputSchema),z.lazy(() => QuestionScoreCreateOrConnectWithoutQuestionOptionInputSchema).array() ]).optional(),
  upsert: z.union([ z.lazy(() => QuestionScoreUpsertWithWhereUniqueWithoutQuestionOptionInputSchema),z.lazy(() => QuestionScoreUpsertWithWhereUniqueWithoutQuestionOptionInputSchema).array() ]).optional(),
  createMany: z.lazy(() => QuestionScoreCreateManyQuestionOptionInputEnvelopeSchema).optional(),
  set: z.union([ z.lazy(() => QuestionScoreWhereUniqueInputSchema),z.lazy(() => QuestionScoreWhereUniqueInputSchema).array() ]).optional(),
  disconnect: z.union([ z.lazy(() => QuestionScoreWhereUniqueInputSchema),z.lazy(() => QuestionScoreWhereUniqueInputSchema).array() ]).optional(),
  delete: z.union([ z.lazy(() => QuestionScoreWhereUniqueInputSchema),z.lazy(() => QuestionScoreWhereUniqueInputSchema).array() ]).optional(),
  connect: z.union([ z.lazy(() => QuestionScoreWhereUniqueInputSchema),z.lazy(() => QuestionScoreWhereUniqueInputSchema).array() ]).optional(),
  update: z.union([ z.lazy(() => QuestionScoreUpdateWithWhereUniqueWithoutQuestionOptionInputSchema),z.lazy(() => QuestionScoreUpdateWithWhereUniqueWithoutQuestionOptionInputSchema).array() ]).optional(),
  updateMany: z.union([ z.lazy(() => QuestionScoreUpdateManyWithWhereWithoutQuestionOptionInputSchema),z.lazy(() => QuestionScoreUpdateManyWithWhereWithoutQuestionOptionInputSchema).array() ]).optional(),
  deleteMany: z.union([ z.lazy(() => QuestionScoreScalarWhereInputSchema),z.lazy(() => QuestionScoreScalarWhereInputSchema).array() ]).optional(),
}).strict();

export const ForecastUncheckedUpdateManyWithoutOptionNestedInputSchema: z.ZodType<Prisma.ForecastUncheckedUpdateManyWithoutOptionNestedInput> = z.object({
  create: z.union([ z.lazy(() => ForecastCreateWithoutOptionInputSchema),z.lazy(() => ForecastCreateWithoutOptionInputSchema).array(),z.lazy(() => ForecastUncheckedCreateWithoutOptionInputSchema),z.lazy(() => ForecastUncheckedCreateWithoutOptionInputSchema).array() ]).optional(),
  connectOrCreate: z.union([ z.lazy(() => ForecastCreateOrConnectWithoutOptionInputSchema),z.lazy(() => ForecastCreateOrConnectWithoutOptionInputSchema).array() ]).optional(),
  upsert: z.union([ z.lazy(() => ForecastUpsertWithWhereUniqueWithoutOptionInputSchema),z.lazy(() => ForecastUpsertWithWhereUniqueWithoutOptionInputSchema).array() ]).optional(),
  createMany: z.lazy(() => ForecastCreateManyOptionInputEnvelopeSchema).optional(),
  set: z.union([ z.lazy(() => ForecastWhereUniqueInputSchema),z.lazy(() => ForecastWhereUniqueInputSchema).array() ]).optional(),
  disconnect: z.union([ z.lazy(() => ForecastWhereUniqueInputSchema),z.lazy(() => ForecastWhereUniqueInputSchema).array() ]).optional(),
  delete: z.union([ z.lazy(() => ForecastWhereUniqueInputSchema),z.lazy(() => ForecastWhereUniqueInputSchema).array() ]).optional(),
  connect: z.union([ z.lazy(() => ForecastWhereUniqueInputSchema),z.lazy(() => ForecastWhereUniqueInputSchema).array() ]).optional(),
  update: z.union([ z.lazy(() => ForecastUpdateWithWhereUniqueWithoutOptionInputSchema),z.lazy(() => ForecastUpdateWithWhereUniqueWithoutOptionInputSchema).array() ]).optional(),
  updateMany: z.union([ z.lazy(() => ForecastUpdateManyWithWhereWithoutOptionInputSchema),z.lazy(() => ForecastUpdateManyWithWhereWithoutOptionInputSchema).array() ]).optional(),
  deleteMany: z.union([ z.lazy(() => ForecastScalarWhereInputSchema),z.lazy(() => ForecastScalarWhereInputSchema).array() ]).optional(),
}).strict();

export const QuestionScoreUncheckedUpdateManyWithoutQuestionOptionNestedInputSchema: z.ZodType<Prisma.QuestionScoreUncheckedUpdateManyWithoutQuestionOptionNestedInput> = z.object({
  create: z.union([ z.lazy(() => QuestionScoreCreateWithoutQuestionOptionInputSchema),z.lazy(() => QuestionScoreCreateWithoutQuestionOptionInputSchema).array(),z.lazy(() => QuestionScoreUncheckedCreateWithoutQuestionOptionInputSchema),z.lazy(() => QuestionScoreUncheckedCreateWithoutQuestionOptionInputSchema).array() ]).optional(),
  connectOrCreate: z.union([ z.lazy(() => QuestionScoreCreateOrConnectWithoutQuestionOptionInputSchema),z.lazy(() => QuestionScoreCreateOrConnectWithoutQuestionOptionInputSchema).array() ]).optional(),
  upsert: z.union([ z.lazy(() => QuestionScoreUpsertWithWhereUniqueWithoutQuestionOptionInputSchema),z.lazy(() => QuestionScoreUpsertWithWhereUniqueWithoutQuestionOptionInputSchema).array() ]).optional(),
  createMany: z.lazy(() => QuestionScoreCreateManyQuestionOptionInputEnvelopeSchema).optional(),
  set: z.union([ z.lazy(() => QuestionScoreWhereUniqueInputSchema),z.lazy(() => QuestionScoreWhereUniqueInputSchema).array() ]).optional(),
  disconnect: z.union([ z.lazy(() => QuestionScoreWhereUniqueInputSchema),z.lazy(() => QuestionScoreWhereUniqueInputSchema).array() ]).optional(),
  delete: z.union([ z.lazy(() => QuestionScoreWhereUniqueInputSchema),z.lazy(() => QuestionScoreWhereUniqueInputSchema).array() ]).optional(),
  connect: z.union([ z.lazy(() => QuestionScoreWhereUniqueInputSchema),z.lazy(() => QuestionScoreWhereUniqueInputSchema).array() ]).optional(),
  update: z.union([ z.lazy(() => QuestionScoreUpdateWithWhereUniqueWithoutQuestionOptionInputSchema),z.lazy(() => QuestionScoreUpdateWithWhereUniqueWithoutQuestionOptionInputSchema).array() ]).optional(),
  updateMany: z.union([ z.lazy(() => QuestionScoreUpdateManyWithWhereWithoutQuestionOptionInputSchema),z.lazy(() => QuestionScoreUpdateManyWithWhereWithoutQuestionOptionInputSchema).array() ]).optional(),
  deleteMany: z.union([ z.lazy(() => QuestionScoreScalarWhereInputSchema),z.lazy(() => QuestionScoreScalarWhereInputSchema).array() ]).optional(),
}).strict();

export const QuestionOptionCreateNestedManyWithoutQuestionInputSchema: z.ZodType<Prisma.QuestionOptionCreateNestedManyWithoutQuestionInput> = z.object({
  create: z.union([ z.lazy(() => QuestionOptionCreateWithoutQuestionInputSchema),z.lazy(() => QuestionOptionCreateWithoutQuestionInputSchema).array(),z.lazy(() => QuestionOptionUncheckedCreateWithoutQuestionInputSchema),z.lazy(() => QuestionOptionUncheckedCreateWithoutQuestionInputSchema).array() ]).optional(),
  connectOrCreate: z.union([ z.lazy(() => QuestionOptionCreateOrConnectWithoutQuestionInputSchema),z.lazy(() => QuestionOptionCreateOrConnectWithoutQuestionInputSchema).array() ]).optional(),
  createMany: z.lazy(() => QuestionOptionCreateManyQuestionInputEnvelopeSchema).optional(),
  connect: z.union([ z.lazy(() => QuestionOptionWhereUniqueInputSchema),z.lazy(() => QuestionOptionWhereUniqueInputSchema).array() ]).optional(),
}).strict();

export const ForecastCreateNestedManyWithoutQuestionInputSchema: z.ZodType<Prisma.ForecastCreateNestedManyWithoutQuestionInput> = z.object({
  create: z.union([ z.lazy(() => ForecastCreateWithoutQuestionInputSchema),z.lazy(() => ForecastCreateWithoutQuestionInputSchema).array(),z.lazy(() => ForecastUncheckedCreateWithoutQuestionInputSchema),z.lazy(() => ForecastUncheckedCreateWithoutQuestionInputSchema).array() ]).optional(),
  connectOrCreate: z.union([ z.lazy(() => ForecastCreateOrConnectWithoutQuestionInputSchema),z.lazy(() => ForecastCreateOrConnectWithoutQuestionInputSchema).array() ]).optional(),
  createMany: z.lazy(() => ForecastCreateManyQuestionInputEnvelopeSchema).optional(),
  connect: z.union([ z.lazy(() => ForecastWhereUniqueInputSchema),z.lazy(() => ForecastWhereUniqueInputSchema).array() ]).optional(),
}).strict();

export const PingSlackMessageCreateNestedManyWithoutQuestionInputSchema: z.ZodType<Prisma.PingSlackMessageCreateNestedManyWithoutQuestionInput> = z.object({
  create: z.union([ z.lazy(() => PingSlackMessageCreateWithoutQuestionInputSchema),z.lazy(() => PingSlackMessageCreateWithoutQuestionInputSchema).array(),z.lazy(() => PingSlackMessageUncheckedCreateWithoutQuestionInputSchema),z.lazy(() => PingSlackMessageUncheckedCreateWithoutQuestionInputSchema).array() ]).optional(),
  connectOrCreate: z.union([ z.lazy(() => PingSlackMessageCreateOrConnectWithoutQuestionInputSchema),z.lazy(() => PingSlackMessageCreateOrConnectWithoutQuestionInputSchema).array() ]).optional(),
  createMany: z.lazy(() => PingSlackMessageCreateManyQuestionInputEnvelopeSchema).optional(),
  connect: z.union([ z.lazy(() => PingSlackMessageWhereUniqueInputSchema),z.lazy(() => PingSlackMessageWhereUniqueInputSchema).array() ]).optional(),
}).strict();

export const ProfileCreateNestedOneWithoutQuestionsInputSchema: z.ZodType<Prisma.ProfileCreateNestedOneWithoutQuestionsInput> = z.object({
  create: z.union([ z.lazy(() => ProfileCreateWithoutQuestionsInputSchema),z.lazy(() => ProfileUncheckedCreateWithoutQuestionsInputSchema) ]).optional(),
  connectOrCreate: z.lazy(() => ProfileCreateOrConnectWithoutQuestionsInputSchema).optional(),
  connect: z.lazy(() => ProfileWhereUniqueInputSchema).optional()
}).strict();

export const UserCreateNestedOneWithoutQuestionsInputSchema: z.ZodType<Prisma.UserCreateNestedOneWithoutQuestionsInput> = z.object({
  create: z.union([ z.lazy(() => UserCreateWithoutQuestionsInputSchema),z.lazy(() => UserUncheckedCreateWithoutQuestionsInputSchema) ]).optional(),
  connectOrCreate: z.lazy(() => UserCreateOrConnectWithoutQuestionsInputSchema).optional(),
  connect: z.lazy(() => UserWhereUniqueInputSchema).optional()
}).strict();

export const UserCreateNestedManyWithoutQuestionsSharedWithInputSchema: z.ZodType<Prisma.UserCreateNestedManyWithoutQuestionsSharedWithInput> = z.object({
  create: z.union([ z.lazy(() => UserCreateWithoutQuestionsSharedWithInputSchema),z.lazy(() => UserCreateWithoutQuestionsSharedWithInputSchema).array(),z.lazy(() => UserUncheckedCreateWithoutQuestionsSharedWithInputSchema),z.lazy(() => UserUncheckedCreateWithoutQuestionsSharedWithInputSchema).array() ]).optional(),
  connectOrCreate: z.union([ z.lazy(() => UserCreateOrConnectWithoutQuestionsSharedWithInputSchema),z.lazy(() => UserCreateOrConnectWithoutQuestionsSharedWithInputSchema).array() ]).optional(),
  connect: z.union([ z.lazy(() => UserWhereUniqueInputSchema),z.lazy(() => UserWhereUniqueInputSchema).array() ]).optional(),
}).strict();

export const UserListCreateNestedManyWithoutQuestionsInputSchema: z.ZodType<Prisma.UserListCreateNestedManyWithoutQuestionsInput> = z.object({
  create: z.union([ z.lazy(() => UserListCreateWithoutQuestionsInputSchema),z.lazy(() => UserListCreateWithoutQuestionsInputSchema).array(),z.lazy(() => UserListUncheckedCreateWithoutQuestionsInputSchema),z.lazy(() => UserListUncheckedCreateWithoutQuestionsInputSchema).array() ]).optional(),
  connectOrCreate: z.union([ z.lazy(() => UserListCreateOrConnectWithoutQuestionsInputSchema),z.lazy(() => UserListCreateOrConnectWithoutQuestionsInputSchema).array() ]).optional(),
  connect: z.union([ z.lazy(() => UserListWhereUniqueInputSchema),z.lazy(() => UserListWhereUniqueInputSchema).array() ]).optional(),
}).strict();

export const QuestionScoreCreateNestedManyWithoutQuestionInputSchema: z.ZodType<Prisma.QuestionScoreCreateNestedManyWithoutQuestionInput> = z.object({
  create: z.union([ z.lazy(() => QuestionScoreCreateWithoutQuestionInputSchema),z.lazy(() => QuestionScoreCreateWithoutQuestionInputSchema).array(),z.lazy(() => QuestionScoreUncheckedCreateWithoutQuestionInputSchema),z.lazy(() => QuestionScoreUncheckedCreateWithoutQuestionInputSchema).array() ]).optional(),
  connectOrCreate: z.union([ z.lazy(() => QuestionScoreCreateOrConnectWithoutQuestionInputSchema),z.lazy(() => QuestionScoreCreateOrConnectWithoutQuestionInputSchema).array() ]).optional(),
  createMany: z.lazy(() => QuestionScoreCreateManyQuestionInputEnvelopeSchema).optional(),
  connect: z.union([ z.lazy(() => QuestionScoreWhereUniqueInputSchema),z.lazy(() => QuestionScoreWhereUniqueInputSchema).array() ]).optional(),
}).strict();

export const QuestionSlackMessageCreateNestedManyWithoutQuestionInputSchema: z.ZodType<Prisma.QuestionSlackMessageCreateNestedManyWithoutQuestionInput> = z.object({
  create: z.union([ z.lazy(() => QuestionSlackMessageCreateWithoutQuestionInputSchema),z.lazy(() => QuestionSlackMessageCreateWithoutQuestionInputSchema).array(),z.lazy(() => QuestionSlackMessageUncheckedCreateWithoutQuestionInputSchema),z.lazy(() => QuestionSlackMessageUncheckedCreateWithoutQuestionInputSchema).array() ]).optional(),
  connectOrCreate: z.union([ z.lazy(() => QuestionSlackMessageCreateOrConnectWithoutQuestionInputSchema),z.lazy(() => QuestionSlackMessageCreateOrConnectWithoutQuestionInputSchema).array() ]).optional(),
  createMany: z.lazy(() => QuestionSlackMessageCreateManyQuestionInputEnvelopeSchema).optional(),
  connect: z.union([ z.lazy(() => QuestionSlackMessageWhereUniqueInputSchema),z.lazy(() => QuestionSlackMessageWhereUniqueInputSchema).array() ]).optional(),
}).strict();

export const ResolutionSlackMessageCreateNestedManyWithoutQuestionInputSchema: z.ZodType<Prisma.ResolutionSlackMessageCreateNestedManyWithoutQuestionInput> = z.object({
  create: z.union([ z.lazy(() => ResolutionSlackMessageCreateWithoutQuestionInputSchema),z.lazy(() => ResolutionSlackMessageCreateWithoutQuestionInputSchema).array(),z.lazy(() => ResolutionSlackMessageUncheckedCreateWithoutQuestionInputSchema),z.lazy(() => ResolutionSlackMessageUncheckedCreateWithoutQuestionInputSchema).array() ]).optional(),
  connectOrCreate: z.union([ z.lazy(() => ResolutionSlackMessageCreateOrConnectWithoutQuestionInputSchema),z.lazy(() => ResolutionSlackMessageCreateOrConnectWithoutQuestionInputSchema).array() ]).optional(),
  createMany: z.lazy(() => ResolutionSlackMessageCreateManyQuestionInputEnvelopeSchema).optional(),
  connect: z.union([ z.lazy(() => ResolutionSlackMessageWhereUniqueInputSchema),z.lazy(() => ResolutionSlackMessageWhereUniqueInputSchema).array() ]).optional(),
}).strict();

export const CommentCreateNestedManyWithoutQuestionInputSchema: z.ZodType<Prisma.CommentCreateNestedManyWithoutQuestionInput> = z.object({
  create: z.union([ z.lazy(() => CommentCreateWithoutQuestionInputSchema),z.lazy(() => CommentCreateWithoutQuestionInputSchema).array(),z.lazy(() => CommentUncheckedCreateWithoutQuestionInputSchema),z.lazy(() => CommentUncheckedCreateWithoutQuestionInputSchema).array() ]).optional(),
  connectOrCreate: z.union([ z.lazy(() => CommentCreateOrConnectWithoutQuestionInputSchema),z.lazy(() => CommentCreateOrConnectWithoutQuestionInputSchema).array() ]).optional(),
  createMany: z.lazy(() => CommentCreateManyQuestionInputEnvelopeSchema).optional(),
  connect: z.union([ z.lazy(() => CommentWhereUniqueInputSchema),z.lazy(() => CommentWhereUniqueInputSchema).array() ]).optional(),
}).strict();

export const TagCreateNestedManyWithoutQuestionsInputSchema: z.ZodType<Prisma.TagCreateNestedManyWithoutQuestionsInput> = z.object({
  create: z.union([ z.lazy(() => TagCreateWithoutQuestionsInputSchema),z.lazy(() => TagCreateWithoutQuestionsInputSchema).array(),z.lazy(() => TagUncheckedCreateWithoutQuestionsInputSchema),z.lazy(() => TagUncheckedCreateWithoutQuestionsInputSchema).array() ]).optional(),
  connectOrCreate: z.union([ z.lazy(() => TagCreateOrConnectWithoutQuestionsInputSchema),z.lazy(() => TagCreateOrConnectWithoutQuestionsInputSchema).array() ]).optional(),
  connect: z.union([ z.lazy(() => TagWhereUniqueInputSchema),z.lazy(() => TagWhereUniqueInputSchema).array() ]).optional(),
}).strict();

export const TournamentCreateNestedManyWithoutQuestionsInputSchema: z.ZodType<Prisma.TournamentCreateNestedManyWithoutQuestionsInput> = z.object({
  create: z.union([ z.lazy(() => TournamentCreateWithoutQuestionsInputSchema),z.lazy(() => TournamentCreateWithoutQuestionsInputSchema).array(),z.lazy(() => TournamentUncheckedCreateWithoutQuestionsInputSchema),z.lazy(() => TournamentUncheckedCreateWithoutQuestionsInputSchema).array() ]).optional(),
  connectOrCreate: z.union([ z.lazy(() => TournamentCreateOrConnectWithoutQuestionsInputSchema),z.lazy(() => TournamentCreateOrConnectWithoutQuestionsInputSchema).array() ]).optional(),
  connect: z.union([ z.lazy(() => TournamentWhereUniqueInputSchema),z.lazy(() => TournamentWhereUniqueInputSchema).array() ]).optional(),
}).strict();

export const NotificationCreateNestedManyWithoutQuestionInputSchema: z.ZodType<Prisma.NotificationCreateNestedManyWithoutQuestionInput> = z.object({
  create: z.union([ z.lazy(() => NotificationCreateWithoutQuestionInputSchema),z.lazy(() => NotificationCreateWithoutQuestionInputSchema).array(),z.lazy(() => NotificationUncheckedCreateWithoutQuestionInputSchema),z.lazy(() => NotificationUncheckedCreateWithoutQuestionInputSchema).array() ]).optional(),
  connectOrCreate: z.union([ z.lazy(() => NotificationCreateOrConnectWithoutQuestionInputSchema),z.lazy(() => NotificationCreateOrConnectWithoutQuestionInputSchema).array() ]).optional(),
  createMany: z.lazy(() => NotificationCreateManyQuestionInputEnvelopeSchema).optional(),
  connect: z.union([ z.lazy(() => NotificationWhereUniqueInputSchema),z.lazy(() => NotificationWhereUniqueInputSchema).array() ]).optional(),
}).strict();

export const QuestionOptionUncheckedCreateNestedManyWithoutQuestionInputSchema: z.ZodType<Prisma.QuestionOptionUncheckedCreateNestedManyWithoutQuestionInput> = z.object({
  create: z.union([ z.lazy(() => QuestionOptionCreateWithoutQuestionInputSchema),z.lazy(() => QuestionOptionCreateWithoutQuestionInputSchema).array(),z.lazy(() => QuestionOptionUncheckedCreateWithoutQuestionInputSchema),z.lazy(() => QuestionOptionUncheckedCreateWithoutQuestionInputSchema).array() ]).optional(),
  connectOrCreate: z.union([ z.lazy(() => QuestionOptionCreateOrConnectWithoutQuestionInputSchema),z.lazy(() => QuestionOptionCreateOrConnectWithoutQuestionInputSchema).array() ]).optional(),
  createMany: z.lazy(() => QuestionOptionCreateManyQuestionInputEnvelopeSchema).optional(),
  connect: z.union([ z.lazy(() => QuestionOptionWhereUniqueInputSchema),z.lazy(() => QuestionOptionWhereUniqueInputSchema).array() ]).optional(),
}).strict();

export const ForecastUncheckedCreateNestedManyWithoutQuestionInputSchema: z.ZodType<Prisma.ForecastUncheckedCreateNestedManyWithoutQuestionInput> = z.object({
  create: z.union([ z.lazy(() => ForecastCreateWithoutQuestionInputSchema),z.lazy(() => ForecastCreateWithoutQuestionInputSchema).array(),z.lazy(() => ForecastUncheckedCreateWithoutQuestionInputSchema),z.lazy(() => ForecastUncheckedCreateWithoutQuestionInputSchema).array() ]).optional(),
  connectOrCreate: z.union([ z.lazy(() => ForecastCreateOrConnectWithoutQuestionInputSchema),z.lazy(() => ForecastCreateOrConnectWithoutQuestionInputSchema).array() ]).optional(),
  createMany: z.lazy(() => ForecastCreateManyQuestionInputEnvelopeSchema).optional(),
  connect: z.union([ z.lazy(() => ForecastWhereUniqueInputSchema),z.lazy(() => ForecastWhereUniqueInputSchema).array() ]).optional(),
}).strict();

export const PingSlackMessageUncheckedCreateNestedManyWithoutQuestionInputSchema: z.ZodType<Prisma.PingSlackMessageUncheckedCreateNestedManyWithoutQuestionInput> = z.object({
  create: z.union([ z.lazy(() => PingSlackMessageCreateWithoutQuestionInputSchema),z.lazy(() => PingSlackMessageCreateWithoutQuestionInputSchema).array(),z.lazy(() => PingSlackMessageUncheckedCreateWithoutQuestionInputSchema),z.lazy(() => PingSlackMessageUncheckedCreateWithoutQuestionInputSchema).array() ]).optional(),
  connectOrCreate: z.union([ z.lazy(() => PingSlackMessageCreateOrConnectWithoutQuestionInputSchema),z.lazy(() => PingSlackMessageCreateOrConnectWithoutQuestionInputSchema).array() ]).optional(),
  createMany: z.lazy(() => PingSlackMessageCreateManyQuestionInputEnvelopeSchema).optional(),
  connect: z.union([ z.lazy(() => PingSlackMessageWhereUniqueInputSchema),z.lazy(() => PingSlackMessageWhereUniqueInputSchema).array() ]).optional(),
}).strict();

export const UserUncheckedCreateNestedManyWithoutQuestionsSharedWithInputSchema: z.ZodType<Prisma.UserUncheckedCreateNestedManyWithoutQuestionsSharedWithInput> = z.object({
  create: z.union([ z.lazy(() => UserCreateWithoutQuestionsSharedWithInputSchema),z.lazy(() => UserCreateWithoutQuestionsSharedWithInputSchema).array(),z.lazy(() => UserUncheckedCreateWithoutQuestionsSharedWithInputSchema),z.lazy(() => UserUncheckedCreateWithoutQuestionsSharedWithInputSchema).array() ]).optional(),
  connectOrCreate: z.union([ z.lazy(() => UserCreateOrConnectWithoutQuestionsSharedWithInputSchema),z.lazy(() => UserCreateOrConnectWithoutQuestionsSharedWithInputSchema).array() ]).optional(),
  connect: z.union([ z.lazy(() => UserWhereUniqueInputSchema),z.lazy(() => UserWhereUniqueInputSchema).array() ]).optional(),
}).strict();

export const UserListUncheckedCreateNestedManyWithoutQuestionsInputSchema: z.ZodType<Prisma.UserListUncheckedCreateNestedManyWithoutQuestionsInput> = z.object({
  create: z.union([ z.lazy(() => UserListCreateWithoutQuestionsInputSchema),z.lazy(() => UserListCreateWithoutQuestionsInputSchema).array(),z.lazy(() => UserListUncheckedCreateWithoutQuestionsInputSchema),z.lazy(() => UserListUncheckedCreateWithoutQuestionsInputSchema).array() ]).optional(),
  connectOrCreate: z.union([ z.lazy(() => UserListCreateOrConnectWithoutQuestionsInputSchema),z.lazy(() => UserListCreateOrConnectWithoutQuestionsInputSchema).array() ]).optional(),
  connect: z.union([ z.lazy(() => UserListWhereUniqueInputSchema),z.lazy(() => UserListWhereUniqueInputSchema).array() ]).optional(),
}).strict();

export const QuestionScoreUncheckedCreateNestedManyWithoutQuestionInputSchema: z.ZodType<Prisma.QuestionScoreUncheckedCreateNestedManyWithoutQuestionInput> = z.object({
  create: z.union([ z.lazy(() => QuestionScoreCreateWithoutQuestionInputSchema),z.lazy(() => QuestionScoreCreateWithoutQuestionInputSchema).array(),z.lazy(() => QuestionScoreUncheckedCreateWithoutQuestionInputSchema),z.lazy(() => QuestionScoreUncheckedCreateWithoutQuestionInputSchema).array() ]).optional(),
  connectOrCreate: z.union([ z.lazy(() => QuestionScoreCreateOrConnectWithoutQuestionInputSchema),z.lazy(() => QuestionScoreCreateOrConnectWithoutQuestionInputSchema).array() ]).optional(),
  createMany: z.lazy(() => QuestionScoreCreateManyQuestionInputEnvelopeSchema).optional(),
  connect: z.union([ z.lazy(() => QuestionScoreWhereUniqueInputSchema),z.lazy(() => QuestionScoreWhereUniqueInputSchema).array() ]).optional(),
}).strict();

export const QuestionSlackMessageUncheckedCreateNestedManyWithoutQuestionInputSchema: z.ZodType<Prisma.QuestionSlackMessageUncheckedCreateNestedManyWithoutQuestionInput> = z.object({
  create: z.union([ z.lazy(() => QuestionSlackMessageCreateWithoutQuestionInputSchema),z.lazy(() => QuestionSlackMessageCreateWithoutQuestionInputSchema).array(),z.lazy(() => QuestionSlackMessageUncheckedCreateWithoutQuestionInputSchema),z.lazy(() => QuestionSlackMessageUncheckedCreateWithoutQuestionInputSchema).array() ]).optional(),
  connectOrCreate: z.union([ z.lazy(() => QuestionSlackMessageCreateOrConnectWithoutQuestionInputSchema),z.lazy(() => QuestionSlackMessageCreateOrConnectWithoutQuestionInputSchema).array() ]).optional(),
  createMany: z.lazy(() => QuestionSlackMessageCreateManyQuestionInputEnvelopeSchema).optional(),
  connect: z.union([ z.lazy(() => QuestionSlackMessageWhereUniqueInputSchema),z.lazy(() => QuestionSlackMessageWhereUniqueInputSchema).array() ]).optional(),
}).strict();

export const ResolutionSlackMessageUncheckedCreateNestedManyWithoutQuestionInputSchema: z.ZodType<Prisma.ResolutionSlackMessageUncheckedCreateNestedManyWithoutQuestionInput> = z.object({
  create: z.union([ z.lazy(() => ResolutionSlackMessageCreateWithoutQuestionInputSchema),z.lazy(() => ResolutionSlackMessageCreateWithoutQuestionInputSchema).array(),z.lazy(() => ResolutionSlackMessageUncheckedCreateWithoutQuestionInputSchema),z.lazy(() => ResolutionSlackMessageUncheckedCreateWithoutQuestionInputSchema).array() ]).optional(),
  connectOrCreate: z.union([ z.lazy(() => ResolutionSlackMessageCreateOrConnectWithoutQuestionInputSchema),z.lazy(() => ResolutionSlackMessageCreateOrConnectWithoutQuestionInputSchema).array() ]).optional(),
  createMany: z.lazy(() => ResolutionSlackMessageCreateManyQuestionInputEnvelopeSchema).optional(),
  connect: z.union([ z.lazy(() => ResolutionSlackMessageWhereUniqueInputSchema),z.lazy(() => ResolutionSlackMessageWhereUniqueInputSchema).array() ]).optional(),
}).strict();

export const CommentUncheckedCreateNestedManyWithoutQuestionInputSchema: z.ZodType<Prisma.CommentUncheckedCreateNestedManyWithoutQuestionInput> = z.object({
  create: z.union([ z.lazy(() => CommentCreateWithoutQuestionInputSchema),z.lazy(() => CommentCreateWithoutQuestionInputSchema).array(),z.lazy(() => CommentUncheckedCreateWithoutQuestionInputSchema),z.lazy(() => CommentUncheckedCreateWithoutQuestionInputSchema).array() ]).optional(),
  connectOrCreate: z.union([ z.lazy(() => CommentCreateOrConnectWithoutQuestionInputSchema),z.lazy(() => CommentCreateOrConnectWithoutQuestionInputSchema).array() ]).optional(),
  createMany: z.lazy(() => CommentCreateManyQuestionInputEnvelopeSchema).optional(),
  connect: z.union([ z.lazy(() => CommentWhereUniqueInputSchema),z.lazy(() => CommentWhereUniqueInputSchema).array() ]).optional(),
}).strict();

export const TagUncheckedCreateNestedManyWithoutQuestionsInputSchema: z.ZodType<Prisma.TagUncheckedCreateNestedManyWithoutQuestionsInput> = z.object({
  create: z.union([ z.lazy(() => TagCreateWithoutQuestionsInputSchema),z.lazy(() => TagCreateWithoutQuestionsInputSchema).array(),z.lazy(() => TagUncheckedCreateWithoutQuestionsInputSchema),z.lazy(() => TagUncheckedCreateWithoutQuestionsInputSchema).array() ]).optional(),
  connectOrCreate: z.union([ z.lazy(() => TagCreateOrConnectWithoutQuestionsInputSchema),z.lazy(() => TagCreateOrConnectWithoutQuestionsInputSchema).array() ]).optional(),
  connect: z.union([ z.lazy(() => TagWhereUniqueInputSchema),z.lazy(() => TagWhereUniqueInputSchema).array() ]).optional(),
}).strict();

export const TournamentUncheckedCreateNestedManyWithoutQuestionsInputSchema: z.ZodType<Prisma.TournamentUncheckedCreateNestedManyWithoutQuestionsInput> = z.object({
  create: z.union([ z.lazy(() => TournamentCreateWithoutQuestionsInputSchema),z.lazy(() => TournamentCreateWithoutQuestionsInputSchema).array(),z.lazy(() => TournamentUncheckedCreateWithoutQuestionsInputSchema),z.lazy(() => TournamentUncheckedCreateWithoutQuestionsInputSchema).array() ]).optional(),
  connectOrCreate: z.union([ z.lazy(() => TournamentCreateOrConnectWithoutQuestionsInputSchema),z.lazy(() => TournamentCreateOrConnectWithoutQuestionsInputSchema).array() ]).optional(),
  connect: z.union([ z.lazy(() => TournamentWhereUniqueInputSchema),z.lazy(() => TournamentWhereUniqueInputSchema).array() ]).optional(),
}).strict();

export const NotificationUncheckedCreateNestedManyWithoutQuestionInputSchema: z.ZodType<Prisma.NotificationUncheckedCreateNestedManyWithoutQuestionInput> = z.object({
  create: z.union([ z.lazy(() => NotificationCreateWithoutQuestionInputSchema),z.lazy(() => NotificationCreateWithoutQuestionInputSchema).array(),z.lazy(() => NotificationUncheckedCreateWithoutQuestionInputSchema),z.lazy(() => NotificationUncheckedCreateWithoutQuestionInputSchema).array() ]).optional(),
  connectOrCreate: z.union([ z.lazy(() => NotificationCreateOrConnectWithoutQuestionInputSchema),z.lazy(() => NotificationCreateOrConnectWithoutQuestionInputSchema).array() ]).optional(),
  createMany: z.lazy(() => NotificationCreateManyQuestionInputEnvelopeSchema).optional(),
  connect: z.union([ z.lazy(() => NotificationWhereUniqueInputSchema),z.lazy(() => NotificationWhereUniqueInputSchema).array() ]).optional(),
}).strict();

export const EnumQuestionTypeFieldUpdateOperationsInputSchema: z.ZodType<Prisma.EnumQuestionTypeFieldUpdateOperationsInput> = z.object({
  set: z.lazy(() => QuestionTypeSchema).optional()
}).strict();

export const BoolFieldUpdateOperationsInputSchema: z.ZodType<Prisma.BoolFieldUpdateOperationsInput> = z.object({
  set: z.boolean().optional()
}).strict();

export const NullableBoolFieldUpdateOperationsInputSchema: z.ZodType<Prisma.NullableBoolFieldUpdateOperationsInput> = z.object({
  set: z.boolean().optional().nullable()
}).strict();

export const QuestionOptionUpdateManyWithoutQuestionNestedInputSchema: z.ZodType<Prisma.QuestionOptionUpdateManyWithoutQuestionNestedInput> = z.object({
  create: z.union([ z.lazy(() => QuestionOptionCreateWithoutQuestionInputSchema),z.lazy(() => QuestionOptionCreateWithoutQuestionInputSchema).array(),z.lazy(() => QuestionOptionUncheckedCreateWithoutQuestionInputSchema),z.lazy(() => QuestionOptionUncheckedCreateWithoutQuestionInputSchema).array() ]).optional(),
  connectOrCreate: z.union([ z.lazy(() => QuestionOptionCreateOrConnectWithoutQuestionInputSchema),z.lazy(() => QuestionOptionCreateOrConnectWithoutQuestionInputSchema).array() ]).optional(),
  upsert: z.union([ z.lazy(() => QuestionOptionUpsertWithWhereUniqueWithoutQuestionInputSchema),z.lazy(() => QuestionOptionUpsertWithWhereUniqueWithoutQuestionInputSchema).array() ]).optional(),
  createMany: z.lazy(() => QuestionOptionCreateManyQuestionInputEnvelopeSchema).optional(),
  set: z.union([ z.lazy(() => QuestionOptionWhereUniqueInputSchema),z.lazy(() => QuestionOptionWhereUniqueInputSchema).array() ]).optional(),
  disconnect: z.union([ z.lazy(() => QuestionOptionWhereUniqueInputSchema),z.lazy(() => QuestionOptionWhereUniqueInputSchema).array() ]).optional(),
  delete: z.union([ z.lazy(() => QuestionOptionWhereUniqueInputSchema),z.lazy(() => QuestionOptionWhereUniqueInputSchema).array() ]).optional(),
  connect: z.union([ z.lazy(() => QuestionOptionWhereUniqueInputSchema),z.lazy(() => QuestionOptionWhereUniqueInputSchema).array() ]).optional(),
  update: z.union([ z.lazy(() => QuestionOptionUpdateWithWhereUniqueWithoutQuestionInputSchema),z.lazy(() => QuestionOptionUpdateWithWhereUniqueWithoutQuestionInputSchema).array() ]).optional(),
  updateMany: z.union([ z.lazy(() => QuestionOptionUpdateManyWithWhereWithoutQuestionInputSchema),z.lazy(() => QuestionOptionUpdateManyWithWhereWithoutQuestionInputSchema).array() ]).optional(),
  deleteMany: z.union([ z.lazy(() => QuestionOptionScalarWhereInputSchema),z.lazy(() => QuestionOptionScalarWhereInputSchema).array() ]).optional(),
}).strict();

export const ForecastUpdateManyWithoutQuestionNestedInputSchema: z.ZodType<Prisma.ForecastUpdateManyWithoutQuestionNestedInput> = z.object({
  create: z.union([ z.lazy(() => ForecastCreateWithoutQuestionInputSchema),z.lazy(() => ForecastCreateWithoutQuestionInputSchema).array(),z.lazy(() => ForecastUncheckedCreateWithoutQuestionInputSchema),z.lazy(() => ForecastUncheckedCreateWithoutQuestionInputSchema).array() ]).optional(),
  connectOrCreate: z.union([ z.lazy(() => ForecastCreateOrConnectWithoutQuestionInputSchema),z.lazy(() => ForecastCreateOrConnectWithoutQuestionInputSchema).array() ]).optional(),
  upsert: z.union([ z.lazy(() => ForecastUpsertWithWhereUniqueWithoutQuestionInputSchema),z.lazy(() => ForecastUpsertWithWhereUniqueWithoutQuestionInputSchema).array() ]).optional(),
  createMany: z.lazy(() => ForecastCreateManyQuestionInputEnvelopeSchema).optional(),
  set: z.union([ z.lazy(() => ForecastWhereUniqueInputSchema),z.lazy(() => ForecastWhereUniqueInputSchema).array() ]).optional(),
  disconnect: z.union([ z.lazy(() => ForecastWhereUniqueInputSchema),z.lazy(() => ForecastWhereUniqueInputSchema).array() ]).optional(),
  delete: z.union([ z.lazy(() => ForecastWhereUniqueInputSchema),z.lazy(() => ForecastWhereUniqueInputSchema).array() ]).optional(),
  connect: z.union([ z.lazy(() => ForecastWhereUniqueInputSchema),z.lazy(() => ForecastWhereUniqueInputSchema).array() ]).optional(),
  update: z.union([ z.lazy(() => ForecastUpdateWithWhereUniqueWithoutQuestionInputSchema),z.lazy(() => ForecastUpdateWithWhereUniqueWithoutQuestionInputSchema).array() ]).optional(),
  updateMany: z.union([ z.lazy(() => ForecastUpdateManyWithWhereWithoutQuestionInputSchema),z.lazy(() => ForecastUpdateManyWithWhereWithoutQuestionInputSchema).array() ]).optional(),
  deleteMany: z.union([ z.lazy(() => ForecastScalarWhereInputSchema),z.lazy(() => ForecastScalarWhereInputSchema).array() ]).optional(),
}).strict();

export const PingSlackMessageUpdateManyWithoutQuestionNestedInputSchema: z.ZodType<Prisma.PingSlackMessageUpdateManyWithoutQuestionNestedInput> = z.object({
  create: z.union([ z.lazy(() => PingSlackMessageCreateWithoutQuestionInputSchema),z.lazy(() => PingSlackMessageCreateWithoutQuestionInputSchema).array(),z.lazy(() => PingSlackMessageUncheckedCreateWithoutQuestionInputSchema),z.lazy(() => PingSlackMessageUncheckedCreateWithoutQuestionInputSchema).array() ]).optional(),
  connectOrCreate: z.union([ z.lazy(() => PingSlackMessageCreateOrConnectWithoutQuestionInputSchema),z.lazy(() => PingSlackMessageCreateOrConnectWithoutQuestionInputSchema).array() ]).optional(),
  upsert: z.union([ z.lazy(() => PingSlackMessageUpsertWithWhereUniqueWithoutQuestionInputSchema),z.lazy(() => PingSlackMessageUpsertWithWhereUniqueWithoutQuestionInputSchema).array() ]).optional(),
  createMany: z.lazy(() => PingSlackMessageCreateManyQuestionInputEnvelopeSchema).optional(),
  set: z.union([ z.lazy(() => PingSlackMessageWhereUniqueInputSchema),z.lazy(() => PingSlackMessageWhereUniqueInputSchema).array() ]).optional(),
  disconnect: z.union([ z.lazy(() => PingSlackMessageWhereUniqueInputSchema),z.lazy(() => PingSlackMessageWhereUniqueInputSchema).array() ]).optional(),
  delete: z.union([ z.lazy(() => PingSlackMessageWhereUniqueInputSchema),z.lazy(() => PingSlackMessageWhereUniqueInputSchema).array() ]).optional(),
  connect: z.union([ z.lazy(() => PingSlackMessageWhereUniqueInputSchema),z.lazy(() => PingSlackMessageWhereUniqueInputSchema).array() ]).optional(),
  update: z.union([ z.lazy(() => PingSlackMessageUpdateWithWhereUniqueWithoutQuestionInputSchema),z.lazy(() => PingSlackMessageUpdateWithWhereUniqueWithoutQuestionInputSchema).array() ]).optional(),
  updateMany: z.union([ z.lazy(() => PingSlackMessageUpdateManyWithWhereWithoutQuestionInputSchema),z.lazy(() => PingSlackMessageUpdateManyWithWhereWithoutQuestionInputSchema).array() ]).optional(),
  deleteMany: z.union([ z.lazy(() => PingSlackMessageScalarWhereInputSchema),z.lazy(() => PingSlackMessageScalarWhereInputSchema).array() ]).optional(),
}).strict();

export const ProfileUpdateOneWithoutQuestionsNestedInputSchema: z.ZodType<Prisma.ProfileUpdateOneWithoutQuestionsNestedInput> = z.object({
  create: z.union([ z.lazy(() => ProfileCreateWithoutQuestionsInputSchema),z.lazy(() => ProfileUncheckedCreateWithoutQuestionsInputSchema) ]).optional(),
  connectOrCreate: z.lazy(() => ProfileCreateOrConnectWithoutQuestionsInputSchema).optional(),
  upsert: z.lazy(() => ProfileUpsertWithoutQuestionsInputSchema).optional(),
  disconnect: z.union([ z.boolean(),z.lazy(() => ProfileWhereInputSchema) ]).optional(),
  delete: z.union([ z.boolean(),z.lazy(() => ProfileWhereInputSchema) ]).optional(),
  connect: z.lazy(() => ProfileWhereUniqueInputSchema).optional(),
  update: z.union([ z.lazy(() => ProfileUpdateToOneWithWhereWithoutQuestionsInputSchema),z.lazy(() => ProfileUpdateWithoutQuestionsInputSchema),z.lazy(() => ProfileUncheckedUpdateWithoutQuestionsInputSchema) ]).optional(),
}).strict();

export const UserUpdateOneRequiredWithoutQuestionsNestedInputSchema: z.ZodType<Prisma.UserUpdateOneRequiredWithoutQuestionsNestedInput> = z.object({
  create: z.union([ z.lazy(() => UserCreateWithoutQuestionsInputSchema),z.lazy(() => UserUncheckedCreateWithoutQuestionsInputSchema) ]).optional(),
  connectOrCreate: z.lazy(() => UserCreateOrConnectWithoutQuestionsInputSchema).optional(),
  upsert: z.lazy(() => UserUpsertWithoutQuestionsInputSchema).optional(),
  connect: z.lazy(() => UserWhereUniqueInputSchema).optional(),
  update: z.union([ z.lazy(() => UserUpdateToOneWithWhereWithoutQuestionsInputSchema),z.lazy(() => UserUpdateWithoutQuestionsInputSchema),z.lazy(() => UserUncheckedUpdateWithoutQuestionsInputSchema) ]).optional(),
}).strict();

export const UserUpdateManyWithoutQuestionsSharedWithNestedInputSchema: z.ZodType<Prisma.UserUpdateManyWithoutQuestionsSharedWithNestedInput> = z.object({
  create: z.union([ z.lazy(() => UserCreateWithoutQuestionsSharedWithInputSchema),z.lazy(() => UserCreateWithoutQuestionsSharedWithInputSchema).array(),z.lazy(() => UserUncheckedCreateWithoutQuestionsSharedWithInputSchema),z.lazy(() => UserUncheckedCreateWithoutQuestionsSharedWithInputSchema).array() ]).optional(),
  connectOrCreate: z.union([ z.lazy(() => UserCreateOrConnectWithoutQuestionsSharedWithInputSchema),z.lazy(() => UserCreateOrConnectWithoutQuestionsSharedWithInputSchema).array() ]).optional(),
  upsert: z.union([ z.lazy(() => UserUpsertWithWhereUniqueWithoutQuestionsSharedWithInputSchema),z.lazy(() => UserUpsertWithWhereUniqueWithoutQuestionsSharedWithInputSchema).array() ]).optional(),
  set: z.union([ z.lazy(() => UserWhereUniqueInputSchema),z.lazy(() => UserWhereUniqueInputSchema).array() ]).optional(),
  disconnect: z.union([ z.lazy(() => UserWhereUniqueInputSchema),z.lazy(() => UserWhereUniqueInputSchema).array() ]).optional(),
  delete: z.union([ z.lazy(() => UserWhereUniqueInputSchema),z.lazy(() => UserWhereUniqueInputSchema).array() ]).optional(),
  connect: z.union([ z.lazy(() => UserWhereUniqueInputSchema),z.lazy(() => UserWhereUniqueInputSchema).array() ]).optional(),
  update: z.union([ z.lazy(() => UserUpdateWithWhereUniqueWithoutQuestionsSharedWithInputSchema),z.lazy(() => UserUpdateWithWhereUniqueWithoutQuestionsSharedWithInputSchema).array() ]).optional(),
  updateMany: z.union([ z.lazy(() => UserUpdateManyWithWhereWithoutQuestionsSharedWithInputSchema),z.lazy(() => UserUpdateManyWithWhereWithoutQuestionsSharedWithInputSchema).array() ]).optional(),
  deleteMany: z.union([ z.lazy(() => UserScalarWhereInputSchema),z.lazy(() => UserScalarWhereInputSchema).array() ]).optional(),
}).strict();

export const UserListUpdateManyWithoutQuestionsNestedInputSchema: z.ZodType<Prisma.UserListUpdateManyWithoutQuestionsNestedInput> = z.object({
  create: z.union([ z.lazy(() => UserListCreateWithoutQuestionsInputSchema),z.lazy(() => UserListCreateWithoutQuestionsInputSchema).array(),z.lazy(() => UserListUncheckedCreateWithoutQuestionsInputSchema),z.lazy(() => UserListUncheckedCreateWithoutQuestionsInputSchema).array() ]).optional(),
  connectOrCreate: z.union([ z.lazy(() => UserListCreateOrConnectWithoutQuestionsInputSchema),z.lazy(() => UserListCreateOrConnectWithoutQuestionsInputSchema).array() ]).optional(),
  upsert: z.union([ z.lazy(() => UserListUpsertWithWhereUniqueWithoutQuestionsInputSchema),z.lazy(() => UserListUpsertWithWhereUniqueWithoutQuestionsInputSchema).array() ]).optional(),
  set: z.union([ z.lazy(() => UserListWhereUniqueInputSchema),z.lazy(() => UserListWhereUniqueInputSchema).array() ]).optional(),
  disconnect: z.union([ z.lazy(() => UserListWhereUniqueInputSchema),z.lazy(() => UserListWhereUniqueInputSchema).array() ]).optional(),
  delete: z.union([ z.lazy(() => UserListWhereUniqueInputSchema),z.lazy(() => UserListWhereUniqueInputSchema).array() ]).optional(),
  connect: z.union([ z.lazy(() => UserListWhereUniqueInputSchema),z.lazy(() => UserListWhereUniqueInputSchema).array() ]).optional(),
  update: z.union([ z.lazy(() => UserListUpdateWithWhereUniqueWithoutQuestionsInputSchema),z.lazy(() => UserListUpdateWithWhereUniqueWithoutQuestionsInputSchema).array() ]).optional(),
  updateMany: z.union([ z.lazy(() => UserListUpdateManyWithWhereWithoutQuestionsInputSchema),z.lazy(() => UserListUpdateManyWithWhereWithoutQuestionsInputSchema).array() ]).optional(),
  deleteMany: z.union([ z.lazy(() => UserListScalarWhereInputSchema),z.lazy(() => UserListScalarWhereInputSchema).array() ]).optional(),
}).strict();

export const QuestionScoreUpdateManyWithoutQuestionNestedInputSchema: z.ZodType<Prisma.QuestionScoreUpdateManyWithoutQuestionNestedInput> = z.object({
  create: z.union([ z.lazy(() => QuestionScoreCreateWithoutQuestionInputSchema),z.lazy(() => QuestionScoreCreateWithoutQuestionInputSchema).array(),z.lazy(() => QuestionScoreUncheckedCreateWithoutQuestionInputSchema),z.lazy(() => QuestionScoreUncheckedCreateWithoutQuestionInputSchema).array() ]).optional(),
  connectOrCreate: z.union([ z.lazy(() => QuestionScoreCreateOrConnectWithoutQuestionInputSchema),z.lazy(() => QuestionScoreCreateOrConnectWithoutQuestionInputSchema).array() ]).optional(),
  upsert: z.union([ z.lazy(() => QuestionScoreUpsertWithWhereUniqueWithoutQuestionInputSchema),z.lazy(() => QuestionScoreUpsertWithWhereUniqueWithoutQuestionInputSchema).array() ]).optional(),
  createMany: z.lazy(() => QuestionScoreCreateManyQuestionInputEnvelopeSchema).optional(),
  set: z.union([ z.lazy(() => QuestionScoreWhereUniqueInputSchema),z.lazy(() => QuestionScoreWhereUniqueInputSchema).array() ]).optional(),
  disconnect: z.union([ z.lazy(() => QuestionScoreWhereUniqueInputSchema),z.lazy(() => QuestionScoreWhereUniqueInputSchema).array() ]).optional(),
  delete: z.union([ z.lazy(() => QuestionScoreWhereUniqueInputSchema),z.lazy(() => QuestionScoreWhereUniqueInputSchema).array() ]).optional(),
  connect: z.union([ z.lazy(() => QuestionScoreWhereUniqueInputSchema),z.lazy(() => QuestionScoreWhereUniqueInputSchema).array() ]).optional(),
  update: z.union([ z.lazy(() => QuestionScoreUpdateWithWhereUniqueWithoutQuestionInputSchema),z.lazy(() => QuestionScoreUpdateWithWhereUniqueWithoutQuestionInputSchema).array() ]).optional(),
  updateMany: z.union([ z.lazy(() => QuestionScoreUpdateManyWithWhereWithoutQuestionInputSchema),z.lazy(() => QuestionScoreUpdateManyWithWhereWithoutQuestionInputSchema).array() ]).optional(),
  deleteMany: z.union([ z.lazy(() => QuestionScoreScalarWhereInputSchema),z.lazy(() => QuestionScoreScalarWhereInputSchema).array() ]).optional(),
}).strict();

export const QuestionSlackMessageUpdateManyWithoutQuestionNestedInputSchema: z.ZodType<Prisma.QuestionSlackMessageUpdateManyWithoutQuestionNestedInput> = z.object({
  create: z.union([ z.lazy(() => QuestionSlackMessageCreateWithoutQuestionInputSchema),z.lazy(() => QuestionSlackMessageCreateWithoutQuestionInputSchema).array(),z.lazy(() => QuestionSlackMessageUncheckedCreateWithoutQuestionInputSchema),z.lazy(() => QuestionSlackMessageUncheckedCreateWithoutQuestionInputSchema).array() ]).optional(),
  connectOrCreate: z.union([ z.lazy(() => QuestionSlackMessageCreateOrConnectWithoutQuestionInputSchema),z.lazy(() => QuestionSlackMessageCreateOrConnectWithoutQuestionInputSchema).array() ]).optional(),
  upsert: z.union([ z.lazy(() => QuestionSlackMessageUpsertWithWhereUniqueWithoutQuestionInputSchema),z.lazy(() => QuestionSlackMessageUpsertWithWhereUniqueWithoutQuestionInputSchema).array() ]).optional(),
  createMany: z.lazy(() => QuestionSlackMessageCreateManyQuestionInputEnvelopeSchema).optional(),
  set: z.union([ z.lazy(() => QuestionSlackMessageWhereUniqueInputSchema),z.lazy(() => QuestionSlackMessageWhereUniqueInputSchema).array() ]).optional(),
  disconnect: z.union([ z.lazy(() => QuestionSlackMessageWhereUniqueInputSchema),z.lazy(() => QuestionSlackMessageWhereUniqueInputSchema).array() ]).optional(),
  delete: z.union([ z.lazy(() => QuestionSlackMessageWhereUniqueInputSchema),z.lazy(() => QuestionSlackMessageWhereUniqueInputSchema).array() ]).optional(),
  connect: z.union([ z.lazy(() => QuestionSlackMessageWhereUniqueInputSchema),z.lazy(() => QuestionSlackMessageWhereUniqueInputSchema).array() ]).optional(),
  update: z.union([ z.lazy(() => QuestionSlackMessageUpdateWithWhereUniqueWithoutQuestionInputSchema),z.lazy(() => QuestionSlackMessageUpdateWithWhereUniqueWithoutQuestionInputSchema).array() ]).optional(),
  updateMany: z.union([ z.lazy(() => QuestionSlackMessageUpdateManyWithWhereWithoutQuestionInputSchema),z.lazy(() => QuestionSlackMessageUpdateManyWithWhereWithoutQuestionInputSchema).array() ]).optional(),
  deleteMany: z.union([ z.lazy(() => QuestionSlackMessageScalarWhereInputSchema),z.lazy(() => QuestionSlackMessageScalarWhereInputSchema).array() ]).optional(),
}).strict();

export const ResolutionSlackMessageUpdateManyWithoutQuestionNestedInputSchema: z.ZodType<Prisma.ResolutionSlackMessageUpdateManyWithoutQuestionNestedInput> = z.object({
  create: z.union([ z.lazy(() => ResolutionSlackMessageCreateWithoutQuestionInputSchema),z.lazy(() => ResolutionSlackMessageCreateWithoutQuestionInputSchema).array(),z.lazy(() => ResolutionSlackMessageUncheckedCreateWithoutQuestionInputSchema),z.lazy(() => ResolutionSlackMessageUncheckedCreateWithoutQuestionInputSchema).array() ]).optional(),
  connectOrCreate: z.union([ z.lazy(() => ResolutionSlackMessageCreateOrConnectWithoutQuestionInputSchema),z.lazy(() => ResolutionSlackMessageCreateOrConnectWithoutQuestionInputSchema).array() ]).optional(),
  upsert: z.union([ z.lazy(() => ResolutionSlackMessageUpsertWithWhereUniqueWithoutQuestionInputSchema),z.lazy(() => ResolutionSlackMessageUpsertWithWhereUniqueWithoutQuestionInputSchema).array() ]).optional(),
  createMany: z.lazy(() => ResolutionSlackMessageCreateManyQuestionInputEnvelopeSchema).optional(),
  set: z.union([ z.lazy(() => ResolutionSlackMessageWhereUniqueInputSchema),z.lazy(() => ResolutionSlackMessageWhereUniqueInputSchema).array() ]).optional(),
  disconnect: z.union([ z.lazy(() => ResolutionSlackMessageWhereUniqueInputSchema),z.lazy(() => ResolutionSlackMessageWhereUniqueInputSchema).array() ]).optional(),
  delete: z.union([ z.lazy(() => ResolutionSlackMessageWhereUniqueInputSchema),z.lazy(() => ResolutionSlackMessageWhereUniqueInputSchema).array() ]).optional(),
  connect: z.union([ z.lazy(() => ResolutionSlackMessageWhereUniqueInputSchema),z.lazy(() => ResolutionSlackMessageWhereUniqueInputSchema).array() ]).optional(),
  update: z.union([ z.lazy(() => ResolutionSlackMessageUpdateWithWhereUniqueWithoutQuestionInputSchema),z.lazy(() => ResolutionSlackMessageUpdateWithWhereUniqueWithoutQuestionInputSchema).array() ]).optional(),
  updateMany: z.union([ z.lazy(() => ResolutionSlackMessageUpdateManyWithWhereWithoutQuestionInputSchema),z.lazy(() => ResolutionSlackMessageUpdateManyWithWhereWithoutQuestionInputSchema).array() ]).optional(),
  deleteMany: z.union([ z.lazy(() => ResolutionSlackMessageScalarWhereInputSchema),z.lazy(() => ResolutionSlackMessageScalarWhereInputSchema).array() ]).optional(),
}).strict();

export const CommentUpdateManyWithoutQuestionNestedInputSchema: z.ZodType<Prisma.CommentUpdateManyWithoutQuestionNestedInput> = z.object({
  create: z.union([ z.lazy(() => CommentCreateWithoutQuestionInputSchema),z.lazy(() => CommentCreateWithoutQuestionInputSchema).array(),z.lazy(() => CommentUncheckedCreateWithoutQuestionInputSchema),z.lazy(() => CommentUncheckedCreateWithoutQuestionInputSchema).array() ]).optional(),
  connectOrCreate: z.union([ z.lazy(() => CommentCreateOrConnectWithoutQuestionInputSchema),z.lazy(() => CommentCreateOrConnectWithoutQuestionInputSchema).array() ]).optional(),
  upsert: z.union([ z.lazy(() => CommentUpsertWithWhereUniqueWithoutQuestionInputSchema),z.lazy(() => CommentUpsertWithWhereUniqueWithoutQuestionInputSchema).array() ]).optional(),
  createMany: z.lazy(() => CommentCreateManyQuestionInputEnvelopeSchema).optional(),
  set: z.union([ z.lazy(() => CommentWhereUniqueInputSchema),z.lazy(() => CommentWhereUniqueInputSchema).array() ]).optional(),
  disconnect: z.union([ z.lazy(() => CommentWhereUniqueInputSchema),z.lazy(() => CommentWhereUniqueInputSchema).array() ]).optional(),
  delete: z.union([ z.lazy(() => CommentWhereUniqueInputSchema),z.lazy(() => CommentWhereUniqueInputSchema).array() ]).optional(),
  connect: z.union([ z.lazy(() => CommentWhereUniqueInputSchema),z.lazy(() => CommentWhereUniqueInputSchema).array() ]).optional(),
  update: z.union([ z.lazy(() => CommentUpdateWithWhereUniqueWithoutQuestionInputSchema),z.lazy(() => CommentUpdateWithWhereUniqueWithoutQuestionInputSchema).array() ]).optional(),
  updateMany: z.union([ z.lazy(() => CommentUpdateManyWithWhereWithoutQuestionInputSchema),z.lazy(() => CommentUpdateManyWithWhereWithoutQuestionInputSchema).array() ]).optional(),
  deleteMany: z.union([ z.lazy(() => CommentScalarWhereInputSchema),z.lazy(() => CommentScalarWhereInputSchema).array() ]).optional(),
}).strict();

export const TagUpdateManyWithoutQuestionsNestedInputSchema: z.ZodType<Prisma.TagUpdateManyWithoutQuestionsNestedInput> = z.object({
  create: z.union([ z.lazy(() => TagCreateWithoutQuestionsInputSchema),z.lazy(() => TagCreateWithoutQuestionsInputSchema).array(),z.lazy(() => TagUncheckedCreateWithoutQuestionsInputSchema),z.lazy(() => TagUncheckedCreateWithoutQuestionsInputSchema).array() ]).optional(),
  connectOrCreate: z.union([ z.lazy(() => TagCreateOrConnectWithoutQuestionsInputSchema),z.lazy(() => TagCreateOrConnectWithoutQuestionsInputSchema).array() ]).optional(),
  upsert: z.union([ z.lazy(() => TagUpsertWithWhereUniqueWithoutQuestionsInputSchema),z.lazy(() => TagUpsertWithWhereUniqueWithoutQuestionsInputSchema).array() ]).optional(),
  set: z.union([ z.lazy(() => TagWhereUniqueInputSchema),z.lazy(() => TagWhereUniqueInputSchema).array() ]).optional(),
  disconnect: z.union([ z.lazy(() => TagWhereUniqueInputSchema),z.lazy(() => TagWhereUniqueInputSchema).array() ]).optional(),
  delete: z.union([ z.lazy(() => TagWhereUniqueInputSchema),z.lazy(() => TagWhereUniqueInputSchema).array() ]).optional(),
  connect: z.union([ z.lazy(() => TagWhereUniqueInputSchema),z.lazy(() => TagWhereUniqueInputSchema).array() ]).optional(),
  update: z.union([ z.lazy(() => TagUpdateWithWhereUniqueWithoutQuestionsInputSchema),z.lazy(() => TagUpdateWithWhereUniqueWithoutQuestionsInputSchema).array() ]).optional(),
  updateMany: z.union([ z.lazy(() => TagUpdateManyWithWhereWithoutQuestionsInputSchema),z.lazy(() => TagUpdateManyWithWhereWithoutQuestionsInputSchema).array() ]).optional(),
  deleteMany: z.union([ z.lazy(() => TagScalarWhereInputSchema),z.lazy(() => TagScalarWhereInputSchema).array() ]).optional(),
}).strict();

export const TournamentUpdateManyWithoutQuestionsNestedInputSchema: z.ZodType<Prisma.TournamentUpdateManyWithoutQuestionsNestedInput> = z.object({
  create: z.union([ z.lazy(() => TournamentCreateWithoutQuestionsInputSchema),z.lazy(() => TournamentCreateWithoutQuestionsInputSchema).array(),z.lazy(() => TournamentUncheckedCreateWithoutQuestionsInputSchema),z.lazy(() => TournamentUncheckedCreateWithoutQuestionsInputSchema).array() ]).optional(),
  connectOrCreate: z.union([ z.lazy(() => TournamentCreateOrConnectWithoutQuestionsInputSchema),z.lazy(() => TournamentCreateOrConnectWithoutQuestionsInputSchema).array() ]).optional(),
  upsert: z.union([ z.lazy(() => TournamentUpsertWithWhereUniqueWithoutQuestionsInputSchema),z.lazy(() => TournamentUpsertWithWhereUniqueWithoutQuestionsInputSchema).array() ]).optional(),
  set: z.union([ z.lazy(() => TournamentWhereUniqueInputSchema),z.lazy(() => TournamentWhereUniqueInputSchema).array() ]).optional(),
  disconnect: z.union([ z.lazy(() => TournamentWhereUniqueInputSchema),z.lazy(() => TournamentWhereUniqueInputSchema).array() ]).optional(),
  delete: z.union([ z.lazy(() => TournamentWhereUniqueInputSchema),z.lazy(() => TournamentWhereUniqueInputSchema).array() ]).optional(),
  connect: z.union([ z.lazy(() => TournamentWhereUniqueInputSchema),z.lazy(() => TournamentWhereUniqueInputSchema).array() ]).optional(),
  update: z.union([ z.lazy(() => TournamentUpdateWithWhereUniqueWithoutQuestionsInputSchema),z.lazy(() => TournamentUpdateWithWhereUniqueWithoutQuestionsInputSchema).array() ]).optional(),
  updateMany: z.union([ z.lazy(() => TournamentUpdateManyWithWhereWithoutQuestionsInputSchema),z.lazy(() => TournamentUpdateManyWithWhereWithoutQuestionsInputSchema).array() ]).optional(),
  deleteMany: z.union([ z.lazy(() => TournamentScalarWhereInputSchema),z.lazy(() => TournamentScalarWhereInputSchema).array() ]).optional(),
}).strict();

export const NotificationUpdateManyWithoutQuestionNestedInputSchema: z.ZodType<Prisma.NotificationUpdateManyWithoutQuestionNestedInput> = z.object({
  create: z.union([ z.lazy(() => NotificationCreateWithoutQuestionInputSchema),z.lazy(() => NotificationCreateWithoutQuestionInputSchema).array(),z.lazy(() => NotificationUncheckedCreateWithoutQuestionInputSchema),z.lazy(() => NotificationUncheckedCreateWithoutQuestionInputSchema).array() ]).optional(),
  connectOrCreate: z.union([ z.lazy(() => NotificationCreateOrConnectWithoutQuestionInputSchema),z.lazy(() => NotificationCreateOrConnectWithoutQuestionInputSchema).array() ]).optional(),
  upsert: z.union([ z.lazy(() => NotificationUpsertWithWhereUniqueWithoutQuestionInputSchema),z.lazy(() => NotificationUpsertWithWhereUniqueWithoutQuestionInputSchema).array() ]).optional(),
  createMany: z.lazy(() => NotificationCreateManyQuestionInputEnvelopeSchema).optional(),
  set: z.union([ z.lazy(() => NotificationWhereUniqueInputSchema),z.lazy(() => NotificationWhereUniqueInputSchema).array() ]).optional(),
  disconnect: z.union([ z.lazy(() => NotificationWhereUniqueInputSchema),z.lazy(() => NotificationWhereUniqueInputSchema).array() ]).optional(),
  delete: z.union([ z.lazy(() => NotificationWhereUniqueInputSchema),z.lazy(() => NotificationWhereUniqueInputSchema).array() ]).optional(),
  connect: z.union([ z.lazy(() => NotificationWhereUniqueInputSchema),z.lazy(() => NotificationWhereUniqueInputSchema).array() ]).optional(),
  update: z.union([ z.lazy(() => NotificationUpdateWithWhereUniqueWithoutQuestionInputSchema),z.lazy(() => NotificationUpdateWithWhereUniqueWithoutQuestionInputSchema).array() ]).optional(),
  updateMany: z.union([ z.lazy(() => NotificationUpdateManyWithWhereWithoutQuestionInputSchema),z.lazy(() => NotificationUpdateManyWithWhereWithoutQuestionInputSchema).array() ]).optional(),
  deleteMany: z.union([ z.lazy(() => NotificationScalarWhereInputSchema),z.lazy(() => NotificationScalarWhereInputSchema).array() ]).optional(),
}).strict();

export const QuestionOptionUncheckedUpdateManyWithoutQuestionNestedInputSchema: z.ZodType<Prisma.QuestionOptionUncheckedUpdateManyWithoutQuestionNestedInput> = z.object({
  create: z.union([ z.lazy(() => QuestionOptionCreateWithoutQuestionInputSchema),z.lazy(() => QuestionOptionCreateWithoutQuestionInputSchema).array(),z.lazy(() => QuestionOptionUncheckedCreateWithoutQuestionInputSchema),z.lazy(() => QuestionOptionUncheckedCreateWithoutQuestionInputSchema).array() ]).optional(),
  connectOrCreate: z.union([ z.lazy(() => QuestionOptionCreateOrConnectWithoutQuestionInputSchema),z.lazy(() => QuestionOptionCreateOrConnectWithoutQuestionInputSchema).array() ]).optional(),
  upsert: z.union([ z.lazy(() => QuestionOptionUpsertWithWhereUniqueWithoutQuestionInputSchema),z.lazy(() => QuestionOptionUpsertWithWhereUniqueWithoutQuestionInputSchema).array() ]).optional(),
  createMany: z.lazy(() => QuestionOptionCreateManyQuestionInputEnvelopeSchema).optional(),
  set: z.union([ z.lazy(() => QuestionOptionWhereUniqueInputSchema),z.lazy(() => QuestionOptionWhereUniqueInputSchema).array() ]).optional(),
  disconnect: z.union([ z.lazy(() => QuestionOptionWhereUniqueInputSchema),z.lazy(() => QuestionOptionWhereUniqueInputSchema).array() ]).optional(),
  delete: z.union([ z.lazy(() => QuestionOptionWhereUniqueInputSchema),z.lazy(() => QuestionOptionWhereUniqueInputSchema).array() ]).optional(),
  connect: z.union([ z.lazy(() => QuestionOptionWhereUniqueInputSchema),z.lazy(() => QuestionOptionWhereUniqueInputSchema).array() ]).optional(),
  update: z.union([ z.lazy(() => QuestionOptionUpdateWithWhereUniqueWithoutQuestionInputSchema),z.lazy(() => QuestionOptionUpdateWithWhereUniqueWithoutQuestionInputSchema).array() ]).optional(),
  updateMany: z.union([ z.lazy(() => QuestionOptionUpdateManyWithWhereWithoutQuestionInputSchema),z.lazy(() => QuestionOptionUpdateManyWithWhereWithoutQuestionInputSchema).array() ]).optional(),
  deleteMany: z.union([ z.lazy(() => QuestionOptionScalarWhereInputSchema),z.lazy(() => QuestionOptionScalarWhereInputSchema).array() ]).optional(),
}).strict();

export const ForecastUncheckedUpdateManyWithoutQuestionNestedInputSchema: z.ZodType<Prisma.ForecastUncheckedUpdateManyWithoutQuestionNestedInput> = z.object({
  create: z.union([ z.lazy(() => ForecastCreateWithoutQuestionInputSchema),z.lazy(() => ForecastCreateWithoutQuestionInputSchema).array(),z.lazy(() => ForecastUncheckedCreateWithoutQuestionInputSchema),z.lazy(() => ForecastUncheckedCreateWithoutQuestionInputSchema).array() ]).optional(),
  connectOrCreate: z.union([ z.lazy(() => ForecastCreateOrConnectWithoutQuestionInputSchema),z.lazy(() => ForecastCreateOrConnectWithoutQuestionInputSchema).array() ]).optional(),
  upsert: z.union([ z.lazy(() => ForecastUpsertWithWhereUniqueWithoutQuestionInputSchema),z.lazy(() => ForecastUpsertWithWhereUniqueWithoutQuestionInputSchema).array() ]).optional(),
  createMany: z.lazy(() => ForecastCreateManyQuestionInputEnvelopeSchema).optional(),
  set: z.union([ z.lazy(() => ForecastWhereUniqueInputSchema),z.lazy(() => ForecastWhereUniqueInputSchema).array() ]).optional(),
  disconnect: z.union([ z.lazy(() => ForecastWhereUniqueInputSchema),z.lazy(() => ForecastWhereUniqueInputSchema).array() ]).optional(),
  delete: z.union([ z.lazy(() => ForecastWhereUniqueInputSchema),z.lazy(() => ForecastWhereUniqueInputSchema).array() ]).optional(),
  connect: z.union([ z.lazy(() => ForecastWhereUniqueInputSchema),z.lazy(() => ForecastWhereUniqueInputSchema).array() ]).optional(),
  update: z.union([ z.lazy(() => ForecastUpdateWithWhereUniqueWithoutQuestionInputSchema),z.lazy(() => ForecastUpdateWithWhereUniqueWithoutQuestionInputSchema).array() ]).optional(),
  updateMany: z.union([ z.lazy(() => ForecastUpdateManyWithWhereWithoutQuestionInputSchema),z.lazy(() => ForecastUpdateManyWithWhereWithoutQuestionInputSchema).array() ]).optional(),
  deleteMany: z.union([ z.lazy(() => ForecastScalarWhereInputSchema),z.lazy(() => ForecastScalarWhereInputSchema).array() ]).optional(),
}).strict();

export const PingSlackMessageUncheckedUpdateManyWithoutQuestionNestedInputSchema: z.ZodType<Prisma.PingSlackMessageUncheckedUpdateManyWithoutQuestionNestedInput> = z.object({
  create: z.union([ z.lazy(() => PingSlackMessageCreateWithoutQuestionInputSchema),z.lazy(() => PingSlackMessageCreateWithoutQuestionInputSchema).array(),z.lazy(() => PingSlackMessageUncheckedCreateWithoutQuestionInputSchema),z.lazy(() => PingSlackMessageUncheckedCreateWithoutQuestionInputSchema).array() ]).optional(),
  connectOrCreate: z.union([ z.lazy(() => PingSlackMessageCreateOrConnectWithoutQuestionInputSchema),z.lazy(() => PingSlackMessageCreateOrConnectWithoutQuestionInputSchema).array() ]).optional(),
  upsert: z.union([ z.lazy(() => PingSlackMessageUpsertWithWhereUniqueWithoutQuestionInputSchema),z.lazy(() => PingSlackMessageUpsertWithWhereUniqueWithoutQuestionInputSchema).array() ]).optional(),
  createMany: z.lazy(() => PingSlackMessageCreateManyQuestionInputEnvelopeSchema).optional(),
  set: z.union([ z.lazy(() => PingSlackMessageWhereUniqueInputSchema),z.lazy(() => PingSlackMessageWhereUniqueInputSchema).array() ]).optional(),
  disconnect: z.union([ z.lazy(() => PingSlackMessageWhereUniqueInputSchema),z.lazy(() => PingSlackMessageWhereUniqueInputSchema).array() ]).optional(),
  delete: z.union([ z.lazy(() => PingSlackMessageWhereUniqueInputSchema),z.lazy(() => PingSlackMessageWhereUniqueInputSchema).array() ]).optional(),
  connect: z.union([ z.lazy(() => PingSlackMessageWhereUniqueInputSchema),z.lazy(() => PingSlackMessageWhereUniqueInputSchema).array() ]).optional(),
  update: z.union([ z.lazy(() => PingSlackMessageUpdateWithWhereUniqueWithoutQuestionInputSchema),z.lazy(() => PingSlackMessageUpdateWithWhereUniqueWithoutQuestionInputSchema).array() ]).optional(),
  updateMany: z.union([ z.lazy(() => PingSlackMessageUpdateManyWithWhereWithoutQuestionInputSchema),z.lazy(() => PingSlackMessageUpdateManyWithWhereWithoutQuestionInputSchema).array() ]).optional(),
  deleteMany: z.union([ z.lazy(() => PingSlackMessageScalarWhereInputSchema),z.lazy(() => PingSlackMessageScalarWhereInputSchema).array() ]).optional(),
}).strict();

export const UserUncheckedUpdateManyWithoutQuestionsSharedWithNestedInputSchema: z.ZodType<Prisma.UserUncheckedUpdateManyWithoutQuestionsSharedWithNestedInput> = z.object({
  create: z.union([ z.lazy(() => UserCreateWithoutQuestionsSharedWithInputSchema),z.lazy(() => UserCreateWithoutQuestionsSharedWithInputSchema).array(),z.lazy(() => UserUncheckedCreateWithoutQuestionsSharedWithInputSchema),z.lazy(() => UserUncheckedCreateWithoutQuestionsSharedWithInputSchema).array() ]).optional(),
  connectOrCreate: z.union([ z.lazy(() => UserCreateOrConnectWithoutQuestionsSharedWithInputSchema),z.lazy(() => UserCreateOrConnectWithoutQuestionsSharedWithInputSchema).array() ]).optional(),
  upsert: z.union([ z.lazy(() => UserUpsertWithWhereUniqueWithoutQuestionsSharedWithInputSchema),z.lazy(() => UserUpsertWithWhereUniqueWithoutQuestionsSharedWithInputSchema).array() ]).optional(),
  set: z.union([ z.lazy(() => UserWhereUniqueInputSchema),z.lazy(() => UserWhereUniqueInputSchema).array() ]).optional(),
  disconnect: z.union([ z.lazy(() => UserWhereUniqueInputSchema),z.lazy(() => UserWhereUniqueInputSchema).array() ]).optional(),
  delete: z.union([ z.lazy(() => UserWhereUniqueInputSchema),z.lazy(() => UserWhereUniqueInputSchema).array() ]).optional(),
  connect: z.union([ z.lazy(() => UserWhereUniqueInputSchema),z.lazy(() => UserWhereUniqueInputSchema).array() ]).optional(),
  update: z.union([ z.lazy(() => UserUpdateWithWhereUniqueWithoutQuestionsSharedWithInputSchema),z.lazy(() => UserUpdateWithWhereUniqueWithoutQuestionsSharedWithInputSchema).array() ]).optional(),
  updateMany: z.union([ z.lazy(() => UserUpdateManyWithWhereWithoutQuestionsSharedWithInputSchema),z.lazy(() => UserUpdateManyWithWhereWithoutQuestionsSharedWithInputSchema).array() ]).optional(),
  deleteMany: z.union([ z.lazy(() => UserScalarWhereInputSchema),z.lazy(() => UserScalarWhereInputSchema).array() ]).optional(),
}).strict();

export const UserListUncheckedUpdateManyWithoutQuestionsNestedInputSchema: z.ZodType<Prisma.UserListUncheckedUpdateManyWithoutQuestionsNestedInput> = z.object({
  create: z.union([ z.lazy(() => UserListCreateWithoutQuestionsInputSchema),z.lazy(() => UserListCreateWithoutQuestionsInputSchema).array(),z.lazy(() => UserListUncheckedCreateWithoutQuestionsInputSchema),z.lazy(() => UserListUncheckedCreateWithoutQuestionsInputSchema).array() ]).optional(),
  connectOrCreate: z.union([ z.lazy(() => UserListCreateOrConnectWithoutQuestionsInputSchema),z.lazy(() => UserListCreateOrConnectWithoutQuestionsInputSchema).array() ]).optional(),
  upsert: z.union([ z.lazy(() => UserListUpsertWithWhereUniqueWithoutQuestionsInputSchema),z.lazy(() => UserListUpsertWithWhereUniqueWithoutQuestionsInputSchema).array() ]).optional(),
  set: z.union([ z.lazy(() => UserListWhereUniqueInputSchema),z.lazy(() => UserListWhereUniqueInputSchema).array() ]).optional(),
  disconnect: z.union([ z.lazy(() => UserListWhereUniqueInputSchema),z.lazy(() => UserListWhereUniqueInputSchema).array() ]).optional(),
  delete: z.union([ z.lazy(() => UserListWhereUniqueInputSchema),z.lazy(() => UserListWhereUniqueInputSchema).array() ]).optional(),
  connect: z.union([ z.lazy(() => UserListWhereUniqueInputSchema),z.lazy(() => UserListWhereUniqueInputSchema).array() ]).optional(),
  update: z.union([ z.lazy(() => UserListUpdateWithWhereUniqueWithoutQuestionsInputSchema),z.lazy(() => UserListUpdateWithWhereUniqueWithoutQuestionsInputSchema).array() ]).optional(),
  updateMany: z.union([ z.lazy(() => UserListUpdateManyWithWhereWithoutQuestionsInputSchema),z.lazy(() => UserListUpdateManyWithWhereWithoutQuestionsInputSchema).array() ]).optional(),
  deleteMany: z.union([ z.lazy(() => UserListScalarWhereInputSchema),z.lazy(() => UserListScalarWhereInputSchema).array() ]).optional(),
}).strict();

export const QuestionScoreUncheckedUpdateManyWithoutQuestionNestedInputSchema: z.ZodType<Prisma.QuestionScoreUncheckedUpdateManyWithoutQuestionNestedInput> = z.object({
  create: z.union([ z.lazy(() => QuestionScoreCreateWithoutQuestionInputSchema),z.lazy(() => QuestionScoreCreateWithoutQuestionInputSchema).array(),z.lazy(() => QuestionScoreUncheckedCreateWithoutQuestionInputSchema),z.lazy(() => QuestionScoreUncheckedCreateWithoutQuestionInputSchema).array() ]).optional(),
  connectOrCreate: z.union([ z.lazy(() => QuestionScoreCreateOrConnectWithoutQuestionInputSchema),z.lazy(() => QuestionScoreCreateOrConnectWithoutQuestionInputSchema).array() ]).optional(),
  upsert: z.union([ z.lazy(() => QuestionScoreUpsertWithWhereUniqueWithoutQuestionInputSchema),z.lazy(() => QuestionScoreUpsertWithWhereUniqueWithoutQuestionInputSchema).array() ]).optional(),
  createMany: z.lazy(() => QuestionScoreCreateManyQuestionInputEnvelopeSchema).optional(),
  set: z.union([ z.lazy(() => QuestionScoreWhereUniqueInputSchema),z.lazy(() => QuestionScoreWhereUniqueInputSchema).array() ]).optional(),
  disconnect: z.union([ z.lazy(() => QuestionScoreWhereUniqueInputSchema),z.lazy(() => QuestionScoreWhereUniqueInputSchema).array() ]).optional(),
  delete: z.union([ z.lazy(() => QuestionScoreWhereUniqueInputSchema),z.lazy(() => QuestionScoreWhereUniqueInputSchema).array() ]).optional(),
  connect: z.union([ z.lazy(() => QuestionScoreWhereUniqueInputSchema),z.lazy(() => QuestionScoreWhereUniqueInputSchema).array() ]).optional(),
  update: z.union([ z.lazy(() => QuestionScoreUpdateWithWhereUniqueWithoutQuestionInputSchema),z.lazy(() => QuestionScoreUpdateWithWhereUniqueWithoutQuestionInputSchema).array() ]).optional(),
  updateMany: z.union([ z.lazy(() => QuestionScoreUpdateManyWithWhereWithoutQuestionInputSchema),z.lazy(() => QuestionScoreUpdateManyWithWhereWithoutQuestionInputSchema).array() ]).optional(),
  deleteMany: z.union([ z.lazy(() => QuestionScoreScalarWhereInputSchema),z.lazy(() => QuestionScoreScalarWhereInputSchema).array() ]).optional(),
}).strict();

export const QuestionSlackMessageUncheckedUpdateManyWithoutQuestionNestedInputSchema: z.ZodType<Prisma.QuestionSlackMessageUncheckedUpdateManyWithoutQuestionNestedInput> = z.object({
  create: z.union([ z.lazy(() => QuestionSlackMessageCreateWithoutQuestionInputSchema),z.lazy(() => QuestionSlackMessageCreateWithoutQuestionInputSchema).array(),z.lazy(() => QuestionSlackMessageUncheckedCreateWithoutQuestionInputSchema),z.lazy(() => QuestionSlackMessageUncheckedCreateWithoutQuestionInputSchema).array() ]).optional(),
  connectOrCreate: z.union([ z.lazy(() => QuestionSlackMessageCreateOrConnectWithoutQuestionInputSchema),z.lazy(() => QuestionSlackMessageCreateOrConnectWithoutQuestionInputSchema).array() ]).optional(),
  upsert: z.union([ z.lazy(() => QuestionSlackMessageUpsertWithWhereUniqueWithoutQuestionInputSchema),z.lazy(() => QuestionSlackMessageUpsertWithWhereUniqueWithoutQuestionInputSchema).array() ]).optional(),
  createMany: z.lazy(() => QuestionSlackMessageCreateManyQuestionInputEnvelopeSchema).optional(),
  set: z.union([ z.lazy(() => QuestionSlackMessageWhereUniqueInputSchema),z.lazy(() => QuestionSlackMessageWhereUniqueInputSchema).array() ]).optional(),
  disconnect: z.union([ z.lazy(() => QuestionSlackMessageWhereUniqueInputSchema),z.lazy(() => QuestionSlackMessageWhereUniqueInputSchema).array() ]).optional(),
  delete: z.union([ z.lazy(() => QuestionSlackMessageWhereUniqueInputSchema),z.lazy(() => QuestionSlackMessageWhereUniqueInputSchema).array() ]).optional(),
  connect: z.union([ z.lazy(() => QuestionSlackMessageWhereUniqueInputSchema),z.lazy(() => QuestionSlackMessageWhereUniqueInputSchema).array() ]).optional(),
  update: z.union([ z.lazy(() => QuestionSlackMessageUpdateWithWhereUniqueWithoutQuestionInputSchema),z.lazy(() => QuestionSlackMessageUpdateWithWhereUniqueWithoutQuestionInputSchema).array() ]).optional(),
  updateMany: z.union([ z.lazy(() => QuestionSlackMessageUpdateManyWithWhereWithoutQuestionInputSchema),z.lazy(() => QuestionSlackMessageUpdateManyWithWhereWithoutQuestionInputSchema).array() ]).optional(),
  deleteMany: z.union([ z.lazy(() => QuestionSlackMessageScalarWhereInputSchema),z.lazy(() => QuestionSlackMessageScalarWhereInputSchema).array() ]).optional(),
}).strict();

export const ResolutionSlackMessageUncheckedUpdateManyWithoutQuestionNestedInputSchema: z.ZodType<Prisma.ResolutionSlackMessageUncheckedUpdateManyWithoutQuestionNestedInput> = z.object({
  create: z.union([ z.lazy(() => ResolutionSlackMessageCreateWithoutQuestionInputSchema),z.lazy(() => ResolutionSlackMessageCreateWithoutQuestionInputSchema).array(),z.lazy(() => ResolutionSlackMessageUncheckedCreateWithoutQuestionInputSchema),z.lazy(() => ResolutionSlackMessageUncheckedCreateWithoutQuestionInputSchema).array() ]).optional(),
  connectOrCreate: z.union([ z.lazy(() => ResolutionSlackMessageCreateOrConnectWithoutQuestionInputSchema),z.lazy(() => ResolutionSlackMessageCreateOrConnectWithoutQuestionInputSchema).array() ]).optional(),
  upsert: z.union([ z.lazy(() => ResolutionSlackMessageUpsertWithWhereUniqueWithoutQuestionInputSchema),z.lazy(() => ResolutionSlackMessageUpsertWithWhereUniqueWithoutQuestionInputSchema).array() ]).optional(),
  createMany: z.lazy(() => ResolutionSlackMessageCreateManyQuestionInputEnvelopeSchema).optional(),
  set: z.union([ z.lazy(() => ResolutionSlackMessageWhereUniqueInputSchema),z.lazy(() => ResolutionSlackMessageWhereUniqueInputSchema).array() ]).optional(),
  disconnect: z.union([ z.lazy(() => ResolutionSlackMessageWhereUniqueInputSchema),z.lazy(() => ResolutionSlackMessageWhereUniqueInputSchema).array() ]).optional(),
  delete: z.union([ z.lazy(() => ResolutionSlackMessageWhereUniqueInputSchema),z.lazy(() => ResolutionSlackMessageWhereUniqueInputSchema).array() ]).optional(),
  connect: z.union([ z.lazy(() => ResolutionSlackMessageWhereUniqueInputSchema),z.lazy(() => ResolutionSlackMessageWhereUniqueInputSchema).array() ]).optional(),
  update: z.union([ z.lazy(() => ResolutionSlackMessageUpdateWithWhereUniqueWithoutQuestionInputSchema),z.lazy(() => ResolutionSlackMessageUpdateWithWhereUniqueWithoutQuestionInputSchema).array() ]).optional(),
  updateMany: z.union([ z.lazy(() => ResolutionSlackMessageUpdateManyWithWhereWithoutQuestionInputSchema),z.lazy(() => ResolutionSlackMessageUpdateManyWithWhereWithoutQuestionInputSchema).array() ]).optional(),
  deleteMany: z.union([ z.lazy(() => ResolutionSlackMessageScalarWhereInputSchema),z.lazy(() => ResolutionSlackMessageScalarWhereInputSchema).array() ]).optional(),
}).strict();

export const CommentUncheckedUpdateManyWithoutQuestionNestedInputSchema: z.ZodType<Prisma.CommentUncheckedUpdateManyWithoutQuestionNestedInput> = z.object({
  create: z.union([ z.lazy(() => CommentCreateWithoutQuestionInputSchema),z.lazy(() => CommentCreateWithoutQuestionInputSchema).array(),z.lazy(() => CommentUncheckedCreateWithoutQuestionInputSchema),z.lazy(() => CommentUncheckedCreateWithoutQuestionInputSchema).array() ]).optional(),
  connectOrCreate: z.union([ z.lazy(() => CommentCreateOrConnectWithoutQuestionInputSchema),z.lazy(() => CommentCreateOrConnectWithoutQuestionInputSchema).array() ]).optional(),
  upsert: z.union([ z.lazy(() => CommentUpsertWithWhereUniqueWithoutQuestionInputSchema),z.lazy(() => CommentUpsertWithWhereUniqueWithoutQuestionInputSchema).array() ]).optional(),
  createMany: z.lazy(() => CommentCreateManyQuestionInputEnvelopeSchema).optional(),
  set: z.union([ z.lazy(() => CommentWhereUniqueInputSchema),z.lazy(() => CommentWhereUniqueInputSchema).array() ]).optional(),
  disconnect: z.union([ z.lazy(() => CommentWhereUniqueInputSchema),z.lazy(() => CommentWhereUniqueInputSchema).array() ]).optional(),
  delete: z.union([ z.lazy(() => CommentWhereUniqueInputSchema),z.lazy(() => CommentWhereUniqueInputSchema).array() ]).optional(),
  connect: z.union([ z.lazy(() => CommentWhereUniqueInputSchema),z.lazy(() => CommentWhereUniqueInputSchema).array() ]).optional(),
  update: z.union([ z.lazy(() => CommentUpdateWithWhereUniqueWithoutQuestionInputSchema),z.lazy(() => CommentUpdateWithWhereUniqueWithoutQuestionInputSchema).array() ]).optional(),
  updateMany: z.union([ z.lazy(() => CommentUpdateManyWithWhereWithoutQuestionInputSchema),z.lazy(() => CommentUpdateManyWithWhereWithoutQuestionInputSchema).array() ]).optional(),
  deleteMany: z.union([ z.lazy(() => CommentScalarWhereInputSchema),z.lazy(() => CommentScalarWhereInputSchema).array() ]).optional(),
}).strict();

export const TagUncheckedUpdateManyWithoutQuestionsNestedInputSchema: z.ZodType<Prisma.TagUncheckedUpdateManyWithoutQuestionsNestedInput> = z.object({
  create: z.union([ z.lazy(() => TagCreateWithoutQuestionsInputSchema),z.lazy(() => TagCreateWithoutQuestionsInputSchema).array(),z.lazy(() => TagUncheckedCreateWithoutQuestionsInputSchema),z.lazy(() => TagUncheckedCreateWithoutQuestionsInputSchema).array() ]).optional(),
  connectOrCreate: z.union([ z.lazy(() => TagCreateOrConnectWithoutQuestionsInputSchema),z.lazy(() => TagCreateOrConnectWithoutQuestionsInputSchema).array() ]).optional(),
  upsert: z.union([ z.lazy(() => TagUpsertWithWhereUniqueWithoutQuestionsInputSchema),z.lazy(() => TagUpsertWithWhereUniqueWithoutQuestionsInputSchema).array() ]).optional(),
  set: z.union([ z.lazy(() => TagWhereUniqueInputSchema),z.lazy(() => TagWhereUniqueInputSchema).array() ]).optional(),
  disconnect: z.union([ z.lazy(() => TagWhereUniqueInputSchema),z.lazy(() => TagWhereUniqueInputSchema).array() ]).optional(),
  delete: z.union([ z.lazy(() => TagWhereUniqueInputSchema),z.lazy(() => TagWhereUniqueInputSchema).array() ]).optional(),
  connect: z.union([ z.lazy(() => TagWhereUniqueInputSchema),z.lazy(() => TagWhereUniqueInputSchema).array() ]).optional(),
  update: z.union([ z.lazy(() => TagUpdateWithWhereUniqueWithoutQuestionsInputSchema),z.lazy(() => TagUpdateWithWhereUniqueWithoutQuestionsInputSchema).array() ]).optional(),
  updateMany: z.union([ z.lazy(() => TagUpdateManyWithWhereWithoutQuestionsInputSchema),z.lazy(() => TagUpdateManyWithWhereWithoutQuestionsInputSchema).array() ]).optional(),
  deleteMany: z.union([ z.lazy(() => TagScalarWhereInputSchema),z.lazy(() => TagScalarWhereInputSchema).array() ]).optional(),
}).strict();

export const TournamentUncheckedUpdateManyWithoutQuestionsNestedInputSchema: z.ZodType<Prisma.TournamentUncheckedUpdateManyWithoutQuestionsNestedInput> = z.object({
  create: z.union([ z.lazy(() => TournamentCreateWithoutQuestionsInputSchema),z.lazy(() => TournamentCreateWithoutQuestionsInputSchema).array(),z.lazy(() => TournamentUncheckedCreateWithoutQuestionsInputSchema),z.lazy(() => TournamentUncheckedCreateWithoutQuestionsInputSchema).array() ]).optional(),
  connectOrCreate: z.union([ z.lazy(() => TournamentCreateOrConnectWithoutQuestionsInputSchema),z.lazy(() => TournamentCreateOrConnectWithoutQuestionsInputSchema).array() ]).optional(),
  upsert: z.union([ z.lazy(() => TournamentUpsertWithWhereUniqueWithoutQuestionsInputSchema),z.lazy(() => TournamentUpsertWithWhereUniqueWithoutQuestionsInputSchema).array() ]).optional(),
  set: z.union([ z.lazy(() => TournamentWhereUniqueInputSchema),z.lazy(() => TournamentWhereUniqueInputSchema).array() ]).optional(),
  disconnect: z.union([ z.lazy(() => TournamentWhereUniqueInputSchema),z.lazy(() => TournamentWhereUniqueInputSchema).array() ]).optional(),
  delete: z.union([ z.lazy(() => TournamentWhereUniqueInputSchema),z.lazy(() => TournamentWhereUniqueInputSchema).array() ]).optional(),
  connect: z.union([ z.lazy(() => TournamentWhereUniqueInputSchema),z.lazy(() => TournamentWhereUniqueInputSchema).array() ]).optional(),
  update: z.union([ z.lazy(() => TournamentUpdateWithWhereUniqueWithoutQuestionsInputSchema),z.lazy(() => TournamentUpdateWithWhereUniqueWithoutQuestionsInputSchema).array() ]).optional(),
  updateMany: z.union([ z.lazy(() => TournamentUpdateManyWithWhereWithoutQuestionsInputSchema),z.lazy(() => TournamentUpdateManyWithWhereWithoutQuestionsInputSchema).array() ]).optional(),
  deleteMany: z.union([ z.lazy(() => TournamentScalarWhereInputSchema),z.lazy(() => TournamentScalarWhereInputSchema).array() ]).optional(),
}).strict();

export const NotificationUncheckedUpdateManyWithoutQuestionNestedInputSchema: z.ZodType<Prisma.NotificationUncheckedUpdateManyWithoutQuestionNestedInput> = z.object({
  create: z.union([ z.lazy(() => NotificationCreateWithoutQuestionInputSchema),z.lazy(() => NotificationCreateWithoutQuestionInputSchema).array(),z.lazy(() => NotificationUncheckedCreateWithoutQuestionInputSchema),z.lazy(() => NotificationUncheckedCreateWithoutQuestionInputSchema).array() ]).optional(),
  connectOrCreate: z.union([ z.lazy(() => NotificationCreateOrConnectWithoutQuestionInputSchema),z.lazy(() => NotificationCreateOrConnectWithoutQuestionInputSchema).array() ]).optional(),
  upsert: z.union([ z.lazy(() => NotificationUpsertWithWhereUniqueWithoutQuestionInputSchema),z.lazy(() => NotificationUpsertWithWhereUniqueWithoutQuestionInputSchema).array() ]).optional(),
  createMany: z.lazy(() => NotificationCreateManyQuestionInputEnvelopeSchema).optional(),
  set: z.union([ z.lazy(() => NotificationWhereUniqueInputSchema),z.lazy(() => NotificationWhereUniqueInputSchema).array() ]).optional(),
  disconnect: z.union([ z.lazy(() => NotificationWhereUniqueInputSchema),z.lazy(() => NotificationWhereUniqueInputSchema).array() ]).optional(),
  delete: z.union([ z.lazy(() => NotificationWhereUniqueInputSchema),z.lazy(() => NotificationWhereUniqueInputSchema).array() ]).optional(),
  connect: z.union([ z.lazy(() => NotificationWhereUniqueInputSchema),z.lazy(() => NotificationWhereUniqueInputSchema).array() ]).optional(),
  update: z.union([ z.lazy(() => NotificationUpdateWithWhereUniqueWithoutQuestionInputSchema),z.lazy(() => NotificationUpdateWithWhereUniqueWithoutQuestionInputSchema).array() ]).optional(),
  updateMany: z.union([ z.lazy(() => NotificationUpdateManyWithWhereWithoutQuestionInputSchema),z.lazy(() => NotificationUpdateManyWithWhereWithoutQuestionInputSchema).array() ]).optional(),
  deleteMany: z.union([ z.lazy(() => NotificationScalarWhereInputSchema),z.lazy(() => NotificationScalarWhereInputSchema).array() ]).optional(),
}).strict();

export const UserCreateNestedOneWithoutTagsInputSchema: z.ZodType<Prisma.UserCreateNestedOneWithoutTagsInput> = z.object({
  create: z.union([ z.lazy(() => UserCreateWithoutTagsInputSchema),z.lazy(() => UserUncheckedCreateWithoutTagsInputSchema) ]).optional(),
  connectOrCreate: z.lazy(() => UserCreateOrConnectWithoutTagsInputSchema).optional(),
  connect: z.lazy(() => UserWhereUniqueInputSchema).optional()
}).strict();

export const QuestionCreateNestedManyWithoutTagsInputSchema: z.ZodType<Prisma.QuestionCreateNestedManyWithoutTagsInput> = z.object({
  create: z.union([ z.lazy(() => QuestionCreateWithoutTagsInputSchema),z.lazy(() => QuestionCreateWithoutTagsInputSchema).array(),z.lazy(() => QuestionUncheckedCreateWithoutTagsInputSchema),z.lazy(() => QuestionUncheckedCreateWithoutTagsInputSchema).array() ]).optional(),
  connectOrCreate: z.union([ z.lazy(() => QuestionCreateOrConnectWithoutTagsInputSchema),z.lazy(() => QuestionCreateOrConnectWithoutTagsInputSchema).array() ]).optional(),
  connect: z.union([ z.lazy(() => QuestionWhereUniqueInputSchema),z.lazy(() => QuestionWhereUniqueInputSchema).array() ]).optional(),
}).strict();

export const QuestionUncheckedCreateNestedManyWithoutTagsInputSchema: z.ZodType<Prisma.QuestionUncheckedCreateNestedManyWithoutTagsInput> = z.object({
  create: z.union([ z.lazy(() => QuestionCreateWithoutTagsInputSchema),z.lazy(() => QuestionCreateWithoutTagsInputSchema).array(),z.lazy(() => QuestionUncheckedCreateWithoutTagsInputSchema),z.lazy(() => QuestionUncheckedCreateWithoutTagsInputSchema).array() ]).optional(),
  connectOrCreate: z.union([ z.lazy(() => QuestionCreateOrConnectWithoutTagsInputSchema),z.lazy(() => QuestionCreateOrConnectWithoutTagsInputSchema).array() ]).optional(),
  connect: z.union([ z.lazy(() => QuestionWhereUniqueInputSchema),z.lazy(() => QuestionWhereUniqueInputSchema).array() ]).optional(),
}).strict();

export const UserUpdateOneRequiredWithoutTagsNestedInputSchema: z.ZodType<Prisma.UserUpdateOneRequiredWithoutTagsNestedInput> = z.object({
  create: z.union([ z.lazy(() => UserCreateWithoutTagsInputSchema),z.lazy(() => UserUncheckedCreateWithoutTagsInputSchema) ]).optional(),
  connectOrCreate: z.lazy(() => UserCreateOrConnectWithoutTagsInputSchema).optional(),
  upsert: z.lazy(() => UserUpsertWithoutTagsInputSchema).optional(),
  connect: z.lazy(() => UserWhereUniqueInputSchema).optional(),
  update: z.union([ z.lazy(() => UserUpdateToOneWithWhereWithoutTagsInputSchema),z.lazy(() => UserUpdateWithoutTagsInputSchema),z.lazy(() => UserUncheckedUpdateWithoutTagsInputSchema) ]).optional(),
}).strict();

export const QuestionUpdateManyWithoutTagsNestedInputSchema: z.ZodType<Prisma.QuestionUpdateManyWithoutTagsNestedInput> = z.object({
  create: z.union([ z.lazy(() => QuestionCreateWithoutTagsInputSchema),z.lazy(() => QuestionCreateWithoutTagsInputSchema).array(),z.lazy(() => QuestionUncheckedCreateWithoutTagsInputSchema),z.lazy(() => QuestionUncheckedCreateWithoutTagsInputSchema).array() ]).optional(),
  connectOrCreate: z.union([ z.lazy(() => QuestionCreateOrConnectWithoutTagsInputSchema),z.lazy(() => QuestionCreateOrConnectWithoutTagsInputSchema).array() ]).optional(),
  upsert: z.union([ z.lazy(() => QuestionUpsertWithWhereUniqueWithoutTagsInputSchema),z.lazy(() => QuestionUpsertWithWhereUniqueWithoutTagsInputSchema).array() ]).optional(),
  set: z.union([ z.lazy(() => QuestionWhereUniqueInputSchema),z.lazy(() => QuestionWhereUniqueInputSchema).array() ]).optional(),
  disconnect: z.union([ z.lazy(() => QuestionWhereUniqueInputSchema),z.lazy(() => QuestionWhereUniqueInputSchema).array() ]).optional(),
  delete: z.union([ z.lazy(() => QuestionWhereUniqueInputSchema),z.lazy(() => QuestionWhereUniqueInputSchema).array() ]).optional(),
  connect: z.union([ z.lazy(() => QuestionWhereUniqueInputSchema),z.lazy(() => QuestionWhereUniqueInputSchema).array() ]).optional(),
  update: z.union([ z.lazy(() => QuestionUpdateWithWhereUniqueWithoutTagsInputSchema),z.lazy(() => QuestionUpdateWithWhereUniqueWithoutTagsInputSchema).array() ]).optional(),
  updateMany: z.union([ z.lazy(() => QuestionUpdateManyWithWhereWithoutTagsInputSchema),z.lazy(() => QuestionUpdateManyWithWhereWithoutTagsInputSchema).array() ]).optional(),
  deleteMany: z.union([ z.lazy(() => QuestionScalarWhereInputSchema),z.lazy(() => QuestionScalarWhereInputSchema).array() ]).optional(),
}).strict();

export const QuestionUncheckedUpdateManyWithoutTagsNestedInputSchema: z.ZodType<Prisma.QuestionUncheckedUpdateManyWithoutTagsNestedInput> = z.object({
  create: z.union([ z.lazy(() => QuestionCreateWithoutTagsInputSchema),z.lazy(() => QuestionCreateWithoutTagsInputSchema).array(),z.lazy(() => QuestionUncheckedCreateWithoutTagsInputSchema),z.lazy(() => QuestionUncheckedCreateWithoutTagsInputSchema).array() ]).optional(),
  connectOrCreate: z.union([ z.lazy(() => QuestionCreateOrConnectWithoutTagsInputSchema),z.lazy(() => QuestionCreateOrConnectWithoutTagsInputSchema).array() ]).optional(),
  upsert: z.union([ z.lazy(() => QuestionUpsertWithWhereUniqueWithoutTagsInputSchema),z.lazy(() => QuestionUpsertWithWhereUniqueWithoutTagsInputSchema).array() ]).optional(),
  set: z.union([ z.lazy(() => QuestionWhereUniqueInputSchema),z.lazy(() => QuestionWhereUniqueInputSchema).array() ]).optional(),
  disconnect: z.union([ z.lazy(() => QuestionWhereUniqueInputSchema),z.lazy(() => QuestionWhereUniqueInputSchema).array() ]).optional(),
  delete: z.union([ z.lazy(() => QuestionWhereUniqueInputSchema),z.lazy(() => QuestionWhereUniqueInputSchema).array() ]).optional(),
  connect: z.union([ z.lazy(() => QuestionWhereUniqueInputSchema),z.lazy(() => QuestionWhereUniqueInputSchema).array() ]).optional(),
  update: z.union([ z.lazy(() => QuestionUpdateWithWhereUniqueWithoutTagsInputSchema),z.lazy(() => QuestionUpdateWithWhereUniqueWithoutTagsInputSchema).array() ]).optional(),
  updateMany: z.union([ z.lazy(() => QuestionUpdateManyWithWhereWithoutTagsInputSchema),z.lazy(() => QuestionUpdateManyWithWhereWithoutTagsInputSchema).array() ]).optional(),
  deleteMany: z.union([ z.lazy(() => QuestionScalarWhereInputSchema),z.lazy(() => QuestionScalarWhereInputSchema).array() ]).optional(),
}).strict();

export const SlackMessageCreateNestedOneWithoutResolutionSlackMessageInputSchema: z.ZodType<Prisma.SlackMessageCreateNestedOneWithoutResolutionSlackMessageInput> = z.object({
  create: z.union([ z.lazy(() => SlackMessageCreateWithoutResolutionSlackMessageInputSchema),z.lazy(() => SlackMessageUncheckedCreateWithoutResolutionSlackMessageInputSchema) ]).optional(),
  connectOrCreate: z.lazy(() => SlackMessageCreateOrConnectWithoutResolutionSlackMessageInputSchema).optional(),
  connect: z.lazy(() => SlackMessageWhereUniqueInputSchema).optional()
}).strict();

export const ProfileCreateNestedOneWithoutResolutionMessagesInputSchema: z.ZodType<Prisma.ProfileCreateNestedOneWithoutResolutionMessagesInput> = z.object({
  create: z.union([ z.lazy(() => ProfileCreateWithoutResolutionMessagesInputSchema),z.lazy(() => ProfileUncheckedCreateWithoutResolutionMessagesInputSchema) ]).optional(),
  connectOrCreate: z.lazy(() => ProfileCreateOrConnectWithoutResolutionMessagesInputSchema).optional(),
  connect: z.lazy(() => ProfileWhereUniqueInputSchema).optional()
}).strict();

export const QuestionCreateNestedOneWithoutResolutionMessagesInputSchema: z.ZodType<Prisma.QuestionCreateNestedOneWithoutResolutionMessagesInput> = z.object({
  create: z.union([ z.lazy(() => QuestionCreateWithoutResolutionMessagesInputSchema),z.lazy(() => QuestionUncheckedCreateWithoutResolutionMessagesInputSchema) ]).optional(),
  connectOrCreate: z.lazy(() => QuestionCreateOrConnectWithoutResolutionMessagesInputSchema).optional(),
  connect: z.lazy(() => QuestionWhereUniqueInputSchema).optional()
}).strict();

export const SlackMessageUpdateOneRequiredWithoutResolutionSlackMessageNestedInputSchema: z.ZodType<Prisma.SlackMessageUpdateOneRequiredWithoutResolutionSlackMessageNestedInput> = z.object({
  create: z.union([ z.lazy(() => SlackMessageCreateWithoutResolutionSlackMessageInputSchema),z.lazy(() => SlackMessageUncheckedCreateWithoutResolutionSlackMessageInputSchema) ]).optional(),
  connectOrCreate: z.lazy(() => SlackMessageCreateOrConnectWithoutResolutionSlackMessageInputSchema).optional(),
  upsert: z.lazy(() => SlackMessageUpsertWithoutResolutionSlackMessageInputSchema).optional(),
  connect: z.lazy(() => SlackMessageWhereUniqueInputSchema).optional(),
  update: z.union([ z.lazy(() => SlackMessageUpdateToOneWithWhereWithoutResolutionSlackMessageInputSchema),z.lazy(() => SlackMessageUpdateWithoutResolutionSlackMessageInputSchema),z.lazy(() => SlackMessageUncheckedUpdateWithoutResolutionSlackMessageInputSchema) ]).optional(),
}).strict();

export const ProfileUpdateOneWithoutResolutionMessagesNestedInputSchema: z.ZodType<Prisma.ProfileUpdateOneWithoutResolutionMessagesNestedInput> = z.object({
  create: z.union([ z.lazy(() => ProfileCreateWithoutResolutionMessagesInputSchema),z.lazy(() => ProfileUncheckedCreateWithoutResolutionMessagesInputSchema) ]).optional(),
  connectOrCreate: z.lazy(() => ProfileCreateOrConnectWithoutResolutionMessagesInputSchema).optional(),
  upsert: z.lazy(() => ProfileUpsertWithoutResolutionMessagesInputSchema).optional(),
  disconnect: z.union([ z.boolean(),z.lazy(() => ProfileWhereInputSchema) ]).optional(),
  delete: z.union([ z.boolean(),z.lazy(() => ProfileWhereInputSchema) ]).optional(),
  connect: z.lazy(() => ProfileWhereUniqueInputSchema).optional(),
  update: z.union([ z.lazy(() => ProfileUpdateToOneWithWhereWithoutResolutionMessagesInputSchema),z.lazy(() => ProfileUpdateWithoutResolutionMessagesInputSchema),z.lazy(() => ProfileUncheckedUpdateWithoutResolutionMessagesInputSchema) ]).optional(),
}).strict();

export const QuestionUpdateOneRequiredWithoutResolutionMessagesNestedInputSchema: z.ZodType<Prisma.QuestionUpdateOneRequiredWithoutResolutionMessagesNestedInput> = z.object({
  create: z.union([ z.lazy(() => QuestionCreateWithoutResolutionMessagesInputSchema),z.lazy(() => QuestionUncheckedCreateWithoutResolutionMessagesInputSchema) ]).optional(),
  connectOrCreate: z.lazy(() => QuestionCreateOrConnectWithoutResolutionMessagesInputSchema).optional(),
  upsert: z.lazy(() => QuestionUpsertWithoutResolutionMessagesInputSchema).optional(),
  connect: z.lazy(() => QuestionWhereUniqueInputSchema).optional(),
  update: z.union([ z.lazy(() => QuestionUpdateToOneWithWhereWithoutResolutionMessagesInputSchema),z.lazy(() => QuestionUpdateWithoutResolutionMessagesInputSchema),z.lazy(() => QuestionUncheckedUpdateWithoutResolutionMessagesInputSchema) ]).optional(),
}).strict();

export const SlackMessageCreateNestedOneWithoutPingSlackMessageInputSchema: z.ZodType<Prisma.SlackMessageCreateNestedOneWithoutPingSlackMessageInput> = z.object({
  create: z.union([ z.lazy(() => SlackMessageCreateWithoutPingSlackMessageInputSchema),z.lazy(() => SlackMessageUncheckedCreateWithoutPingSlackMessageInputSchema) ]).optional(),
  connectOrCreate: z.lazy(() => SlackMessageCreateOrConnectWithoutPingSlackMessageInputSchema).optional(),
  connect: z.lazy(() => SlackMessageWhereUniqueInputSchema).optional()
}).strict();

export const QuestionCreateNestedOneWithoutPingResolveMessagesInputSchema: z.ZodType<Prisma.QuestionCreateNestedOneWithoutPingResolveMessagesInput> = z.object({
  create: z.union([ z.lazy(() => QuestionCreateWithoutPingResolveMessagesInputSchema),z.lazy(() => QuestionUncheckedCreateWithoutPingResolveMessagesInputSchema) ]).optional(),
  connectOrCreate: z.lazy(() => QuestionCreateOrConnectWithoutPingResolveMessagesInputSchema).optional(),
  connect: z.lazy(() => QuestionWhereUniqueInputSchema).optional()
}).strict();

export const SlackMessageUpdateOneRequiredWithoutPingSlackMessageNestedInputSchema: z.ZodType<Prisma.SlackMessageUpdateOneRequiredWithoutPingSlackMessageNestedInput> = z.object({
  create: z.union([ z.lazy(() => SlackMessageCreateWithoutPingSlackMessageInputSchema),z.lazy(() => SlackMessageUncheckedCreateWithoutPingSlackMessageInputSchema) ]).optional(),
  connectOrCreate: z.lazy(() => SlackMessageCreateOrConnectWithoutPingSlackMessageInputSchema).optional(),
  upsert: z.lazy(() => SlackMessageUpsertWithoutPingSlackMessageInputSchema).optional(),
  connect: z.lazy(() => SlackMessageWhereUniqueInputSchema).optional(),
  update: z.union([ z.lazy(() => SlackMessageUpdateToOneWithWhereWithoutPingSlackMessageInputSchema),z.lazy(() => SlackMessageUpdateWithoutPingSlackMessageInputSchema),z.lazy(() => SlackMessageUncheckedUpdateWithoutPingSlackMessageInputSchema) ]).optional(),
}).strict();

export const QuestionUpdateOneRequiredWithoutPingResolveMessagesNestedInputSchema: z.ZodType<Prisma.QuestionUpdateOneRequiredWithoutPingResolveMessagesNestedInput> = z.object({
  create: z.union([ z.lazy(() => QuestionCreateWithoutPingResolveMessagesInputSchema),z.lazy(() => QuestionUncheckedCreateWithoutPingResolveMessagesInputSchema) ]).optional(),
  connectOrCreate: z.lazy(() => QuestionCreateOrConnectWithoutPingResolveMessagesInputSchema).optional(),
  upsert: z.lazy(() => QuestionUpsertWithoutPingResolveMessagesInputSchema).optional(),
  connect: z.lazy(() => QuestionWhereUniqueInputSchema).optional(),
  update: z.union([ z.lazy(() => QuestionUpdateToOneWithWhereWithoutPingResolveMessagesInputSchema),z.lazy(() => QuestionUpdateWithoutPingResolveMessagesInputSchema),z.lazy(() => QuestionUncheckedUpdateWithoutPingResolveMessagesInputSchema) ]).optional(),
}).strict();

export const SlackMessageCreateNestedOneWithoutQuestionSlackMessageInputSchema: z.ZodType<Prisma.SlackMessageCreateNestedOneWithoutQuestionSlackMessageInput> = z.object({
  create: z.union([ z.lazy(() => SlackMessageCreateWithoutQuestionSlackMessageInputSchema),z.lazy(() => SlackMessageUncheckedCreateWithoutQuestionSlackMessageInputSchema) ]).optional(),
  connectOrCreate: z.lazy(() => SlackMessageCreateOrConnectWithoutQuestionSlackMessageInputSchema).optional(),
  connect: z.lazy(() => SlackMessageWhereUniqueInputSchema).optional()
}).strict();

export const QuestionCreateNestedOneWithoutQuestionMessagesInputSchema: z.ZodType<Prisma.QuestionCreateNestedOneWithoutQuestionMessagesInput> = z.object({
  create: z.union([ z.lazy(() => QuestionCreateWithoutQuestionMessagesInputSchema),z.lazy(() => QuestionUncheckedCreateWithoutQuestionMessagesInputSchema) ]).optional(),
  connectOrCreate: z.lazy(() => QuestionCreateOrConnectWithoutQuestionMessagesInputSchema).optional(),
  connect: z.lazy(() => QuestionWhereUniqueInputSchema).optional()
}).strict();

export const SlackMessageUpdateOneRequiredWithoutQuestionSlackMessageNestedInputSchema: z.ZodType<Prisma.SlackMessageUpdateOneRequiredWithoutQuestionSlackMessageNestedInput> = z.object({
  create: z.union([ z.lazy(() => SlackMessageCreateWithoutQuestionSlackMessageInputSchema),z.lazy(() => SlackMessageUncheckedCreateWithoutQuestionSlackMessageInputSchema) ]).optional(),
  connectOrCreate: z.lazy(() => SlackMessageCreateOrConnectWithoutQuestionSlackMessageInputSchema).optional(),
  upsert: z.lazy(() => SlackMessageUpsertWithoutQuestionSlackMessageInputSchema).optional(),
  connect: z.lazy(() => SlackMessageWhereUniqueInputSchema).optional(),
  update: z.union([ z.lazy(() => SlackMessageUpdateToOneWithWhereWithoutQuestionSlackMessageInputSchema),z.lazy(() => SlackMessageUpdateWithoutQuestionSlackMessageInputSchema),z.lazy(() => SlackMessageUncheckedUpdateWithoutQuestionSlackMessageInputSchema) ]).optional(),
}).strict();

export const QuestionUpdateOneRequiredWithoutQuestionMessagesNestedInputSchema: z.ZodType<Prisma.QuestionUpdateOneRequiredWithoutQuestionMessagesNestedInput> = z.object({
  create: z.union([ z.lazy(() => QuestionCreateWithoutQuestionMessagesInputSchema),z.lazy(() => QuestionUncheckedCreateWithoutQuestionMessagesInputSchema) ]).optional(),
  connectOrCreate: z.lazy(() => QuestionCreateOrConnectWithoutQuestionMessagesInputSchema).optional(),
  upsert: z.lazy(() => QuestionUpsertWithoutQuestionMessagesInputSchema).optional(),
  connect: z.lazy(() => QuestionWhereUniqueInputSchema).optional(),
  update: z.union([ z.lazy(() => QuestionUpdateToOneWithWhereWithoutQuestionMessagesInputSchema),z.lazy(() => QuestionUpdateWithoutQuestionMessagesInputSchema),z.lazy(() => QuestionUncheckedUpdateWithoutQuestionMessagesInputSchema) ]).optional(),
}).strict();

export const PingSlackMessageCreateNestedOneWithoutMessageInputSchema: z.ZodType<Prisma.PingSlackMessageCreateNestedOneWithoutMessageInput> = z.object({
  create: z.union([ z.lazy(() => PingSlackMessageCreateWithoutMessageInputSchema),z.lazy(() => PingSlackMessageUncheckedCreateWithoutMessageInputSchema) ]).optional(),
  connectOrCreate: z.lazy(() => PingSlackMessageCreateOrConnectWithoutMessageInputSchema).optional(),
  connect: z.lazy(() => PingSlackMessageWhereUniqueInputSchema).optional()
}).strict();

export const QuestionSlackMessageCreateNestedOneWithoutMessageInputSchema: z.ZodType<Prisma.QuestionSlackMessageCreateNestedOneWithoutMessageInput> = z.object({
  create: z.union([ z.lazy(() => QuestionSlackMessageCreateWithoutMessageInputSchema),z.lazy(() => QuestionSlackMessageUncheckedCreateWithoutMessageInputSchema) ]).optional(),
  connectOrCreate: z.lazy(() => QuestionSlackMessageCreateOrConnectWithoutMessageInputSchema).optional(),
  connect: z.lazy(() => QuestionSlackMessageWhereUniqueInputSchema).optional()
}).strict();

export const ResolutionSlackMessageCreateNestedOneWithoutMessageInputSchema: z.ZodType<Prisma.ResolutionSlackMessageCreateNestedOneWithoutMessageInput> = z.object({
  create: z.union([ z.lazy(() => ResolutionSlackMessageCreateWithoutMessageInputSchema),z.lazy(() => ResolutionSlackMessageUncheckedCreateWithoutMessageInputSchema) ]).optional(),
  connectOrCreate: z.lazy(() => ResolutionSlackMessageCreateOrConnectWithoutMessageInputSchema).optional(),
  connect: z.lazy(() => ResolutionSlackMessageWhereUniqueInputSchema).optional()
}).strict();

export const PingSlackMessageUncheckedCreateNestedOneWithoutMessageInputSchema: z.ZodType<Prisma.PingSlackMessageUncheckedCreateNestedOneWithoutMessageInput> = z.object({
  create: z.union([ z.lazy(() => PingSlackMessageCreateWithoutMessageInputSchema),z.lazy(() => PingSlackMessageUncheckedCreateWithoutMessageInputSchema) ]).optional(),
  connectOrCreate: z.lazy(() => PingSlackMessageCreateOrConnectWithoutMessageInputSchema).optional(),
  connect: z.lazy(() => PingSlackMessageWhereUniqueInputSchema).optional()
}).strict();

export const QuestionSlackMessageUncheckedCreateNestedOneWithoutMessageInputSchema: z.ZodType<Prisma.QuestionSlackMessageUncheckedCreateNestedOneWithoutMessageInput> = z.object({
  create: z.union([ z.lazy(() => QuestionSlackMessageCreateWithoutMessageInputSchema),z.lazy(() => QuestionSlackMessageUncheckedCreateWithoutMessageInputSchema) ]).optional(),
  connectOrCreate: z.lazy(() => QuestionSlackMessageCreateOrConnectWithoutMessageInputSchema).optional(),
  connect: z.lazy(() => QuestionSlackMessageWhereUniqueInputSchema).optional()
}).strict();

export const ResolutionSlackMessageUncheckedCreateNestedOneWithoutMessageInputSchema: z.ZodType<Prisma.ResolutionSlackMessageUncheckedCreateNestedOneWithoutMessageInput> = z.object({
  create: z.union([ z.lazy(() => ResolutionSlackMessageCreateWithoutMessageInputSchema),z.lazy(() => ResolutionSlackMessageUncheckedCreateWithoutMessageInputSchema) ]).optional(),
  connectOrCreate: z.lazy(() => ResolutionSlackMessageCreateOrConnectWithoutMessageInputSchema).optional(),
  connect: z.lazy(() => ResolutionSlackMessageWhereUniqueInputSchema).optional()
}).strict();

export const PingSlackMessageUpdateOneWithoutMessageNestedInputSchema: z.ZodType<Prisma.PingSlackMessageUpdateOneWithoutMessageNestedInput> = z.object({
  create: z.union([ z.lazy(() => PingSlackMessageCreateWithoutMessageInputSchema),z.lazy(() => PingSlackMessageUncheckedCreateWithoutMessageInputSchema) ]).optional(),
  connectOrCreate: z.lazy(() => PingSlackMessageCreateOrConnectWithoutMessageInputSchema).optional(),
  upsert: z.lazy(() => PingSlackMessageUpsertWithoutMessageInputSchema).optional(),
  disconnect: z.union([ z.boolean(),z.lazy(() => PingSlackMessageWhereInputSchema) ]).optional(),
  delete: z.union([ z.boolean(),z.lazy(() => PingSlackMessageWhereInputSchema) ]).optional(),
  connect: z.lazy(() => PingSlackMessageWhereUniqueInputSchema).optional(),
  update: z.union([ z.lazy(() => PingSlackMessageUpdateToOneWithWhereWithoutMessageInputSchema),z.lazy(() => PingSlackMessageUpdateWithoutMessageInputSchema),z.lazy(() => PingSlackMessageUncheckedUpdateWithoutMessageInputSchema) ]).optional(),
}).strict();

export const QuestionSlackMessageUpdateOneWithoutMessageNestedInputSchema: z.ZodType<Prisma.QuestionSlackMessageUpdateOneWithoutMessageNestedInput> = z.object({
  create: z.union([ z.lazy(() => QuestionSlackMessageCreateWithoutMessageInputSchema),z.lazy(() => QuestionSlackMessageUncheckedCreateWithoutMessageInputSchema) ]).optional(),
  connectOrCreate: z.lazy(() => QuestionSlackMessageCreateOrConnectWithoutMessageInputSchema).optional(),
  upsert: z.lazy(() => QuestionSlackMessageUpsertWithoutMessageInputSchema).optional(),
  disconnect: z.union([ z.boolean(),z.lazy(() => QuestionSlackMessageWhereInputSchema) ]).optional(),
  delete: z.union([ z.boolean(),z.lazy(() => QuestionSlackMessageWhereInputSchema) ]).optional(),
  connect: z.lazy(() => QuestionSlackMessageWhereUniqueInputSchema).optional(),
  update: z.union([ z.lazy(() => QuestionSlackMessageUpdateToOneWithWhereWithoutMessageInputSchema),z.lazy(() => QuestionSlackMessageUpdateWithoutMessageInputSchema),z.lazy(() => QuestionSlackMessageUncheckedUpdateWithoutMessageInputSchema) ]).optional(),
}).strict();

export const ResolutionSlackMessageUpdateOneWithoutMessageNestedInputSchema: z.ZodType<Prisma.ResolutionSlackMessageUpdateOneWithoutMessageNestedInput> = z.object({
  create: z.union([ z.lazy(() => ResolutionSlackMessageCreateWithoutMessageInputSchema),z.lazy(() => ResolutionSlackMessageUncheckedCreateWithoutMessageInputSchema) ]).optional(),
  connectOrCreate: z.lazy(() => ResolutionSlackMessageCreateOrConnectWithoutMessageInputSchema).optional(),
  upsert: z.lazy(() => ResolutionSlackMessageUpsertWithoutMessageInputSchema).optional(),
  disconnect: z.union([ z.boolean(),z.lazy(() => ResolutionSlackMessageWhereInputSchema) ]).optional(),
  delete: z.union([ z.boolean(),z.lazy(() => ResolutionSlackMessageWhereInputSchema) ]).optional(),
  connect: z.lazy(() => ResolutionSlackMessageWhereUniqueInputSchema).optional(),
  update: z.union([ z.lazy(() => ResolutionSlackMessageUpdateToOneWithWhereWithoutMessageInputSchema),z.lazy(() => ResolutionSlackMessageUpdateWithoutMessageInputSchema),z.lazy(() => ResolutionSlackMessageUncheckedUpdateWithoutMessageInputSchema) ]).optional(),
}).strict();

export const PingSlackMessageUncheckedUpdateOneWithoutMessageNestedInputSchema: z.ZodType<Prisma.PingSlackMessageUncheckedUpdateOneWithoutMessageNestedInput> = z.object({
  create: z.union([ z.lazy(() => PingSlackMessageCreateWithoutMessageInputSchema),z.lazy(() => PingSlackMessageUncheckedCreateWithoutMessageInputSchema) ]).optional(),
  connectOrCreate: z.lazy(() => PingSlackMessageCreateOrConnectWithoutMessageInputSchema).optional(),
  upsert: z.lazy(() => PingSlackMessageUpsertWithoutMessageInputSchema).optional(),
  disconnect: z.union([ z.boolean(),z.lazy(() => PingSlackMessageWhereInputSchema) ]).optional(),
  delete: z.union([ z.boolean(),z.lazy(() => PingSlackMessageWhereInputSchema) ]).optional(),
  connect: z.lazy(() => PingSlackMessageWhereUniqueInputSchema).optional(),
  update: z.union([ z.lazy(() => PingSlackMessageUpdateToOneWithWhereWithoutMessageInputSchema),z.lazy(() => PingSlackMessageUpdateWithoutMessageInputSchema),z.lazy(() => PingSlackMessageUncheckedUpdateWithoutMessageInputSchema) ]).optional(),
}).strict();

export const QuestionSlackMessageUncheckedUpdateOneWithoutMessageNestedInputSchema: z.ZodType<Prisma.QuestionSlackMessageUncheckedUpdateOneWithoutMessageNestedInput> = z.object({
  create: z.union([ z.lazy(() => QuestionSlackMessageCreateWithoutMessageInputSchema),z.lazy(() => QuestionSlackMessageUncheckedCreateWithoutMessageInputSchema) ]).optional(),
  connectOrCreate: z.lazy(() => QuestionSlackMessageCreateOrConnectWithoutMessageInputSchema).optional(),
  upsert: z.lazy(() => QuestionSlackMessageUpsertWithoutMessageInputSchema).optional(),
  disconnect: z.union([ z.boolean(),z.lazy(() => QuestionSlackMessageWhereInputSchema) ]).optional(),
  delete: z.union([ z.boolean(),z.lazy(() => QuestionSlackMessageWhereInputSchema) ]).optional(),
  connect: z.lazy(() => QuestionSlackMessageWhereUniqueInputSchema).optional(),
  update: z.union([ z.lazy(() => QuestionSlackMessageUpdateToOneWithWhereWithoutMessageInputSchema),z.lazy(() => QuestionSlackMessageUpdateWithoutMessageInputSchema),z.lazy(() => QuestionSlackMessageUncheckedUpdateWithoutMessageInputSchema) ]).optional(),
}).strict();

export const ResolutionSlackMessageUncheckedUpdateOneWithoutMessageNestedInputSchema: z.ZodType<Prisma.ResolutionSlackMessageUncheckedUpdateOneWithoutMessageNestedInput> = z.object({
  create: z.union([ z.lazy(() => ResolutionSlackMessageCreateWithoutMessageInputSchema),z.lazy(() => ResolutionSlackMessageUncheckedCreateWithoutMessageInputSchema) ]).optional(),
  connectOrCreate: z.lazy(() => ResolutionSlackMessageCreateOrConnectWithoutMessageInputSchema).optional(),
  upsert: z.lazy(() => ResolutionSlackMessageUpsertWithoutMessageInputSchema).optional(),
  disconnect: z.union([ z.boolean(),z.lazy(() => ResolutionSlackMessageWhereInputSchema) ]).optional(),
  delete: z.union([ z.boolean(),z.lazy(() => ResolutionSlackMessageWhereInputSchema) ]).optional(),
  connect: z.lazy(() => ResolutionSlackMessageWhereUniqueInputSchema).optional(),
  update: z.union([ z.lazy(() => ResolutionSlackMessageUpdateToOneWithWhereWithoutMessageInputSchema),z.lazy(() => ResolutionSlackMessageUpdateWithoutMessageInputSchema),z.lazy(() => ResolutionSlackMessageUncheckedUpdateWithoutMessageInputSchema) ]).optional(),
}).strict();

export const ForecastCreateNestedManyWithoutUserInputSchema: z.ZodType<Prisma.ForecastCreateNestedManyWithoutUserInput> = z.object({
  create: z.union([ z.lazy(() => ForecastCreateWithoutUserInputSchema),z.lazy(() => ForecastCreateWithoutUserInputSchema).array(),z.lazy(() => ForecastUncheckedCreateWithoutUserInputSchema),z.lazy(() => ForecastUncheckedCreateWithoutUserInputSchema).array() ]).optional(),
  connectOrCreate: z.union([ z.lazy(() => ForecastCreateOrConnectWithoutUserInputSchema),z.lazy(() => ForecastCreateOrConnectWithoutUserInputSchema).array() ]).optional(),
  createMany: z.lazy(() => ForecastCreateManyUserInputEnvelopeSchema).optional(),
  connect: z.union([ z.lazy(() => ForecastWhereUniqueInputSchema),z.lazy(() => ForecastWhereUniqueInputSchema).array() ]).optional(),
}).strict();

export const ProfileCreateNestedManyWithoutUserInputSchema: z.ZodType<Prisma.ProfileCreateNestedManyWithoutUserInput> = z.object({
  create: z.union([ z.lazy(() => ProfileCreateWithoutUserInputSchema),z.lazy(() => ProfileCreateWithoutUserInputSchema).array(),z.lazy(() => ProfileUncheckedCreateWithoutUserInputSchema),z.lazy(() => ProfileUncheckedCreateWithoutUserInputSchema).array() ]).optional(),
  connectOrCreate: z.union([ z.lazy(() => ProfileCreateOrConnectWithoutUserInputSchema),z.lazy(() => ProfileCreateOrConnectWithoutUserInputSchema).array() ]).optional(),
  createMany: z.lazy(() => ProfileCreateManyUserInputEnvelopeSchema).optional(),
  connect: z.union([ z.lazy(() => ProfileWhereUniqueInputSchema),z.lazy(() => ProfileWhereUniqueInputSchema).array() ]).optional(),
}).strict();

export const QuestionCreateNestedManyWithoutUserInputSchema: z.ZodType<Prisma.QuestionCreateNestedManyWithoutUserInput> = z.object({
  create: z.union([ z.lazy(() => QuestionCreateWithoutUserInputSchema),z.lazy(() => QuestionCreateWithoutUserInputSchema).array(),z.lazy(() => QuestionUncheckedCreateWithoutUserInputSchema),z.lazy(() => QuestionUncheckedCreateWithoutUserInputSchema).array() ]).optional(),
  connectOrCreate: z.union([ z.lazy(() => QuestionCreateOrConnectWithoutUserInputSchema),z.lazy(() => QuestionCreateOrConnectWithoutUserInputSchema).array() ]).optional(),
  createMany: z.lazy(() => QuestionCreateManyUserInputEnvelopeSchema).optional(),
  connect: z.union([ z.lazy(() => QuestionWhereUniqueInputSchema),z.lazy(() => QuestionWhereUniqueInputSchema).array() ]).optional(),
}).strict();

export const QuestionScoreCreateNestedManyWithoutUserInputSchema: z.ZodType<Prisma.QuestionScoreCreateNestedManyWithoutUserInput> = z.object({
  create: z.union([ z.lazy(() => QuestionScoreCreateWithoutUserInputSchema),z.lazy(() => QuestionScoreCreateWithoutUserInputSchema).array(),z.lazy(() => QuestionScoreUncheckedCreateWithoutUserInputSchema),z.lazy(() => QuestionScoreUncheckedCreateWithoutUserInputSchema).array() ]).optional(),
  connectOrCreate: z.union([ z.lazy(() => QuestionScoreCreateOrConnectWithoutUserInputSchema),z.lazy(() => QuestionScoreCreateOrConnectWithoutUserInputSchema).array() ]).optional(),
  createMany: z.lazy(() => QuestionScoreCreateManyUserInputEnvelopeSchema).optional(),
  connect: z.union([ z.lazy(() => QuestionScoreWhereUniqueInputSchema),z.lazy(() => QuestionScoreWhereUniqueInputSchema).array() ]).optional(),
}).strict();

export const QuestionCreateNestedManyWithoutSharedWithInputSchema: z.ZodType<Prisma.QuestionCreateNestedManyWithoutSharedWithInput> = z.object({
  create: z.union([ z.lazy(() => QuestionCreateWithoutSharedWithInputSchema),z.lazy(() => QuestionCreateWithoutSharedWithInputSchema).array(),z.lazy(() => QuestionUncheckedCreateWithoutSharedWithInputSchema),z.lazy(() => QuestionUncheckedCreateWithoutSharedWithInputSchema).array() ]).optional(),
  connectOrCreate: z.union([ z.lazy(() => QuestionCreateOrConnectWithoutSharedWithInputSchema),z.lazy(() => QuestionCreateOrConnectWithoutSharedWithInputSchema).array() ]).optional(),
  connect: z.union([ z.lazy(() => QuestionWhereUniqueInputSchema),z.lazy(() => QuestionWhereUniqueInputSchema).array() ]).optional(),
}).strict();

export const CommentCreateNestedManyWithoutUserInputSchema: z.ZodType<Prisma.CommentCreateNestedManyWithoutUserInput> = z.object({
  create: z.union([ z.lazy(() => CommentCreateWithoutUserInputSchema),z.lazy(() => CommentCreateWithoutUserInputSchema).array(),z.lazy(() => CommentUncheckedCreateWithoutUserInputSchema),z.lazy(() => CommentUncheckedCreateWithoutUserInputSchema).array() ]).optional(),
  connectOrCreate: z.union([ z.lazy(() => CommentCreateOrConnectWithoutUserInputSchema),z.lazy(() => CommentCreateOrConnectWithoutUserInputSchema).array() ]).optional(),
  createMany: z.lazy(() => CommentCreateManyUserInputEnvelopeSchema).optional(),
  connect: z.union([ z.lazy(() => CommentWhereUniqueInputSchema),z.lazy(() => CommentWhereUniqueInputSchema).array() ]).optional(),
}).strict();

export const TargetCreateNestedOneWithoutUserInputSchema: z.ZodType<Prisma.TargetCreateNestedOneWithoutUserInput> = z.object({
  create: z.union([ z.lazy(() => TargetCreateWithoutUserInputSchema),z.lazy(() => TargetUncheckedCreateWithoutUserInputSchema) ]).optional(),
  connectOrCreate: z.lazy(() => TargetCreateOrConnectWithoutUserInputSchema).optional(),
  connect: z.lazy(() => TargetWhereUniqueInputSchema).optional()
}).strict();

export const UserListCreateNestedManyWithoutAuthorInputSchema: z.ZodType<Prisma.UserListCreateNestedManyWithoutAuthorInput> = z.object({
  create: z.union([ z.lazy(() => UserListCreateWithoutAuthorInputSchema),z.lazy(() => UserListCreateWithoutAuthorInputSchema).array(),z.lazy(() => UserListUncheckedCreateWithoutAuthorInputSchema),z.lazy(() => UserListUncheckedCreateWithoutAuthorInputSchema).array() ]).optional(),
  connectOrCreate: z.union([ z.lazy(() => UserListCreateOrConnectWithoutAuthorInputSchema),z.lazy(() => UserListCreateOrConnectWithoutAuthorInputSchema).array() ]).optional(),
  createMany: z.lazy(() => UserListCreateManyAuthorInputEnvelopeSchema).optional(),
  connect: z.union([ z.lazy(() => UserListWhereUniqueInputSchema),z.lazy(() => UserListWhereUniqueInputSchema).array() ]).optional(),
}).strict();

export const UserListCreateNestedManyWithoutUsersInputSchema: z.ZodType<Prisma.UserListCreateNestedManyWithoutUsersInput> = z.object({
  create: z.union([ z.lazy(() => UserListCreateWithoutUsersInputSchema),z.lazy(() => UserListCreateWithoutUsersInputSchema).array(),z.lazy(() => UserListUncheckedCreateWithoutUsersInputSchema),z.lazy(() => UserListUncheckedCreateWithoutUsersInputSchema).array() ]).optional(),
  connectOrCreate: z.union([ z.lazy(() => UserListCreateOrConnectWithoutUsersInputSchema),z.lazy(() => UserListCreateOrConnectWithoutUsersInputSchema).array() ]).optional(),
  connect: z.union([ z.lazy(() => UserListWhereUniqueInputSchema),z.lazy(() => UserListWhereUniqueInputSchema).array() ]).optional(),
}).strict();

export const TagCreateNestedManyWithoutUserInputSchema: z.ZodType<Prisma.TagCreateNestedManyWithoutUserInput> = z.object({
  create: z.union([ z.lazy(() => TagCreateWithoutUserInputSchema),z.lazy(() => TagCreateWithoutUserInputSchema).array(),z.lazy(() => TagUncheckedCreateWithoutUserInputSchema),z.lazy(() => TagUncheckedCreateWithoutUserInputSchema).array() ]).optional(),
  connectOrCreate: z.union([ z.lazy(() => TagCreateOrConnectWithoutUserInputSchema),z.lazy(() => TagCreateOrConnectWithoutUserInputSchema).array() ]).optional(),
  createMany: z.lazy(() => TagCreateManyUserInputEnvelopeSchema).optional(),
  connect: z.union([ z.lazy(() => TagWhereUniqueInputSchema),z.lazy(() => TagWhereUniqueInputSchema).array() ]).optional(),
}).strict();

export const TournamentCreateNestedManyWithoutAuthorInputSchema: z.ZodType<Prisma.TournamentCreateNestedManyWithoutAuthorInput> = z.object({
  create: z.union([ z.lazy(() => TournamentCreateWithoutAuthorInputSchema),z.lazy(() => TournamentCreateWithoutAuthorInputSchema).array(),z.lazy(() => TournamentUncheckedCreateWithoutAuthorInputSchema),z.lazy(() => TournamentUncheckedCreateWithoutAuthorInputSchema).array() ]).optional(),
  connectOrCreate: z.union([ z.lazy(() => TournamentCreateOrConnectWithoutAuthorInputSchema),z.lazy(() => TournamentCreateOrConnectWithoutAuthorInputSchema).array() ]).optional(),
  createMany: z.lazy(() => TournamentCreateManyAuthorInputEnvelopeSchema).optional(),
  connect: z.union([ z.lazy(() => TournamentWhereUniqueInputSchema),z.lazy(() => TournamentWhereUniqueInputSchema).array() ]).optional(),
}).strict();

export const NotificationCreateNestedManyWithoutUserInputSchema: z.ZodType<Prisma.NotificationCreateNestedManyWithoutUserInput> = z.object({
  create: z.union([ z.lazy(() => NotificationCreateWithoutUserInputSchema),z.lazy(() => NotificationCreateWithoutUserInputSchema).array(),z.lazy(() => NotificationUncheckedCreateWithoutUserInputSchema),z.lazy(() => NotificationUncheckedCreateWithoutUserInputSchema).array() ]).optional(),
  connectOrCreate: z.union([ z.lazy(() => NotificationCreateOrConnectWithoutUserInputSchema),z.lazy(() => NotificationCreateOrConnectWithoutUserInputSchema).array() ]).optional(),
  createMany: z.lazy(() => NotificationCreateManyUserInputEnvelopeSchema).optional(),
  connect: z.union([ z.lazy(() => NotificationWhereUniqueInputSchema),z.lazy(() => NotificationWhereUniqueInputSchema).array() ]).optional(),
}).strict();

export const QuestionOptionCreateNestedManyWithoutUserInputSchema: z.ZodType<Prisma.QuestionOptionCreateNestedManyWithoutUserInput> = z.object({
  create: z.union([ z.lazy(() => QuestionOptionCreateWithoutUserInputSchema),z.lazy(() => QuestionOptionCreateWithoutUserInputSchema).array(),z.lazy(() => QuestionOptionUncheckedCreateWithoutUserInputSchema),z.lazy(() => QuestionOptionUncheckedCreateWithoutUserInputSchema).array() ]).optional(),
  connectOrCreate: z.union([ z.lazy(() => QuestionOptionCreateOrConnectWithoutUserInputSchema),z.lazy(() => QuestionOptionCreateOrConnectWithoutUserInputSchema).array() ]).optional(),
  createMany: z.lazy(() => QuestionOptionCreateManyUserInputEnvelopeSchema).optional(),
  connect: z.union([ z.lazy(() => QuestionOptionWhereUniqueInputSchema),z.lazy(() => QuestionOptionWhereUniqueInputSchema).array() ]).optional(),
}).strict();

export const AccountCreateNestedManyWithoutUserInputSchema: z.ZodType<Prisma.AccountCreateNestedManyWithoutUserInput> = z.object({
  create: z.union([ z.lazy(() => AccountCreateWithoutUserInputSchema),z.lazy(() => AccountCreateWithoutUserInputSchema).array(),z.lazy(() => AccountUncheckedCreateWithoutUserInputSchema),z.lazy(() => AccountUncheckedCreateWithoutUserInputSchema).array() ]).optional(),
  connectOrCreate: z.union([ z.lazy(() => AccountCreateOrConnectWithoutUserInputSchema),z.lazy(() => AccountCreateOrConnectWithoutUserInputSchema).array() ]).optional(),
  createMany: z.lazy(() => AccountCreateManyUserInputEnvelopeSchema).optional(),
  connect: z.union([ z.lazy(() => AccountWhereUniqueInputSchema),z.lazy(() => AccountWhereUniqueInputSchema).array() ]).optional(),
}).strict();

export const ForecastUncheckedCreateNestedManyWithoutUserInputSchema: z.ZodType<Prisma.ForecastUncheckedCreateNestedManyWithoutUserInput> = z.object({
  create: z.union([ z.lazy(() => ForecastCreateWithoutUserInputSchema),z.lazy(() => ForecastCreateWithoutUserInputSchema).array(),z.lazy(() => ForecastUncheckedCreateWithoutUserInputSchema),z.lazy(() => ForecastUncheckedCreateWithoutUserInputSchema).array() ]).optional(),
  connectOrCreate: z.union([ z.lazy(() => ForecastCreateOrConnectWithoutUserInputSchema),z.lazy(() => ForecastCreateOrConnectWithoutUserInputSchema).array() ]).optional(),
  createMany: z.lazy(() => ForecastCreateManyUserInputEnvelopeSchema).optional(),
  connect: z.union([ z.lazy(() => ForecastWhereUniqueInputSchema),z.lazy(() => ForecastWhereUniqueInputSchema).array() ]).optional(),
}).strict();

export const ProfileUncheckedCreateNestedManyWithoutUserInputSchema: z.ZodType<Prisma.ProfileUncheckedCreateNestedManyWithoutUserInput> = z.object({
  create: z.union([ z.lazy(() => ProfileCreateWithoutUserInputSchema),z.lazy(() => ProfileCreateWithoutUserInputSchema).array(),z.lazy(() => ProfileUncheckedCreateWithoutUserInputSchema),z.lazy(() => ProfileUncheckedCreateWithoutUserInputSchema).array() ]).optional(),
  connectOrCreate: z.union([ z.lazy(() => ProfileCreateOrConnectWithoutUserInputSchema),z.lazy(() => ProfileCreateOrConnectWithoutUserInputSchema).array() ]).optional(),
  createMany: z.lazy(() => ProfileCreateManyUserInputEnvelopeSchema).optional(),
  connect: z.union([ z.lazy(() => ProfileWhereUniqueInputSchema),z.lazy(() => ProfileWhereUniqueInputSchema).array() ]).optional(),
}).strict();

export const QuestionUncheckedCreateNestedManyWithoutUserInputSchema: z.ZodType<Prisma.QuestionUncheckedCreateNestedManyWithoutUserInput> = z.object({
  create: z.union([ z.lazy(() => QuestionCreateWithoutUserInputSchema),z.lazy(() => QuestionCreateWithoutUserInputSchema).array(),z.lazy(() => QuestionUncheckedCreateWithoutUserInputSchema),z.lazy(() => QuestionUncheckedCreateWithoutUserInputSchema).array() ]).optional(),
  connectOrCreate: z.union([ z.lazy(() => QuestionCreateOrConnectWithoutUserInputSchema),z.lazy(() => QuestionCreateOrConnectWithoutUserInputSchema).array() ]).optional(),
  createMany: z.lazy(() => QuestionCreateManyUserInputEnvelopeSchema).optional(),
  connect: z.union([ z.lazy(() => QuestionWhereUniqueInputSchema),z.lazy(() => QuestionWhereUniqueInputSchema).array() ]).optional(),
}).strict();

export const QuestionScoreUncheckedCreateNestedManyWithoutUserInputSchema: z.ZodType<Prisma.QuestionScoreUncheckedCreateNestedManyWithoutUserInput> = z.object({
  create: z.union([ z.lazy(() => QuestionScoreCreateWithoutUserInputSchema),z.lazy(() => QuestionScoreCreateWithoutUserInputSchema).array(),z.lazy(() => QuestionScoreUncheckedCreateWithoutUserInputSchema),z.lazy(() => QuestionScoreUncheckedCreateWithoutUserInputSchema).array() ]).optional(),
  connectOrCreate: z.union([ z.lazy(() => QuestionScoreCreateOrConnectWithoutUserInputSchema),z.lazy(() => QuestionScoreCreateOrConnectWithoutUserInputSchema).array() ]).optional(),
  createMany: z.lazy(() => QuestionScoreCreateManyUserInputEnvelopeSchema).optional(),
  connect: z.union([ z.lazy(() => QuestionScoreWhereUniqueInputSchema),z.lazy(() => QuestionScoreWhereUniqueInputSchema).array() ]).optional(),
}).strict();

export const QuestionUncheckedCreateNestedManyWithoutSharedWithInputSchema: z.ZodType<Prisma.QuestionUncheckedCreateNestedManyWithoutSharedWithInput> = z.object({
  create: z.union([ z.lazy(() => QuestionCreateWithoutSharedWithInputSchema),z.lazy(() => QuestionCreateWithoutSharedWithInputSchema).array(),z.lazy(() => QuestionUncheckedCreateWithoutSharedWithInputSchema),z.lazy(() => QuestionUncheckedCreateWithoutSharedWithInputSchema).array() ]).optional(),
  connectOrCreate: z.union([ z.lazy(() => QuestionCreateOrConnectWithoutSharedWithInputSchema),z.lazy(() => QuestionCreateOrConnectWithoutSharedWithInputSchema).array() ]).optional(),
  connect: z.union([ z.lazy(() => QuestionWhereUniqueInputSchema),z.lazy(() => QuestionWhereUniqueInputSchema).array() ]).optional(),
}).strict();

export const CommentUncheckedCreateNestedManyWithoutUserInputSchema: z.ZodType<Prisma.CommentUncheckedCreateNestedManyWithoutUserInput> = z.object({
  create: z.union([ z.lazy(() => CommentCreateWithoutUserInputSchema),z.lazy(() => CommentCreateWithoutUserInputSchema).array(),z.lazy(() => CommentUncheckedCreateWithoutUserInputSchema),z.lazy(() => CommentUncheckedCreateWithoutUserInputSchema).array() ]).optional(),
  connectOrCreate: z.union([ z.lazy(() => CommentCreateOrConnectWithoutUserInputSchema),z.lazy(() => CommentCreateOrConnectWithoutUserInputSchema).array() ]).optional(),
  createMany: z.lazy(() => CommentCreateManyUserInputEnvelopeSchema).optional(),
  connect: z.union([ z.lazy(() => CommentWhereUniqueInputSchema),z.lazy(() => CommentWhereUniqueInputSchema).array() ]).optional(),
}).strict();

export const TargetUncheckedCreateNestedOneWithoutUserInputSchema: z.ZodType<Prisma.TargetUncheckedCreateNestedOneWithoutUserInput> = z.object({
  create: z.union([ z.lazy(() => TargetCreateWithoutUserInputSchema),z.lazy(() => TargetUncheckedCreateWithoutUserInputSchema) ]).optional(),
  connectOrCreate: z.lazy(() => TargetCreateOrConnectWithoutUserInputSchema).optional(),
  connect: z.lazy(() => TargetWhereUniqueInputSchema).optional()
}).strict();

export const UserListUncheckedCreateNestedManyWithoutAuthorInputSchema: z.ZodType<Prisma.UserListUncheckedCreateNestedManyWithoutAuthorInput> = z.object({
  create: z.union([ z.lazy(() => UserListCreateWithoutAuthorInputSchema),z.lazy(() => UserListCreateWithoutAuthorInputSchema).array(),z.lazy(() => UserListUncheckedCreateWithoutAuthorInputSchema),z.lazy(() => UserListUncheckedCreateWithoutAuthorInputSchema).array() ]).optional(),
  connectOrCreate: z.union([ z.lazy(() => UserListCreateOrConnectWithoutAuthorInputSchema),z.lazy(() => UserListCreateOrConnectWithoutAuthorInputSchema).array() ]).optional(),
  createMany: z.lazy(() => UserListCreateManyAuthorInputEnvelopeSchema).optional(),
  connect: z.union([ z.lazy(() => UserListWhereUniqueInputSchema),z.lazy(() => UserListWhereUniqueInputSchema).array() ]).optional(),
}).strict();

export const UserListUncheckedCreateNestedManyWithoutUsersInputSchema: z.ZodType<Prisma.UserListUncheckedCreateNestedManyWithoutUsersInput> = z.object({
  create: z.union([ z.lazy(() => UserListCreateWithoutUsersInputSchema),z.lazy(() => UserListCreateWithoutUsersInputSchema).array(),z.lazy(() => UserListUncheckedCreateWithoutUsersInputSchema),z.lazy(() => UserListUncheckedCreateWithoutUsersInputSchema).array() ]).optional(),
  connectOrCreate: z.union([ z.lazy(() => UserListCreateOrConnectWithoutUsersInputSchema),z.lazy(() => UserListCreateOrConnectWithoutUsersInputSchema).array() ]).optional(),
  connect: z.union([ z.lazy(() => UserListWhereUniqueInputSchema),z.lazy(() => UserListWhereUniqueInputSchema).array() ]).optional(),
}).strict();

export const TagUncheckedCreateNestedManyWithoutUserInputSchema: z.ZodType<Prisma.TagUncheckedCreateNestedManyWithoutUserInput> = z.object({
  create: z.union([ z.lazy(() => TagCreateWithoutUserInputSchema),z.lazy(() => TagCreateWithoutUserInputSchema).array(),z.lazy(() => TagUncheckedCreateWithoutUserInputSchema),z.lazy(() => TagUncheckedCreateWithoutUserInputSchema).array() ]).optional(),
  connectOrCreate: z.union([ z.lazy(() => TagCreateOrConnectWithoutUserInputSchema),z.lazy(() => TagCreateOrConnectWithoutUserInputSchema).array() ]).optional(),
  createMany: z.lazy(() => TagCreateManyUserInputEnvelopeSchema).optional(),
  connect: z.union([ z.lazy(() => TagWhereUniqueInputSchema),z.lazy(() => TagWhereUniqueInputSchema).array() ]).optional(),
}).strict();

export const TournamentUncheckedCreateNestedManyWithoutAuthorInputSchema: z.ZodType<Prisma.TournamentUncheckedCreateNestedManyWithoutAuthorInput> = z.object({
  create: z.union([ z.lazy(() => TournamentCreateWithoutAuthorInputSchema),z.lazy(() => TournamentCreateWithoutAuthorInputSchema).array(),z.lazy(() => TournamentUncheckedCreateWithoutAuthorInputSchema),z.lazy(() => TournamentUncheckedCreateWithoutAuthorInputSchema).array() ]).optional(),
  connectOrCreate: z.union([ z.lazy(() => TournamentCreateOrConnectWithoutAuthorInputSchema),z.lazy(() => TournamentCreateOrConnectWithoutAuthorInputSchema).array() ]).optional(),
  createMany: z.lazy(() => TournamentCreateManyAuthorInputEnvelopeSchema).optional(),
  connect: z.union([ z.lazy(() => TournamentWhereUniqueInputSchema),z.lazy(() => TournamentWhereUniqueInputSchema).array() ]).optional(),
}).strict();

export const NotificationUncheckedCreateNestedManyWithoutUserInputSchema: z.ZodType<Prisma.NotificationUncheckedCreateNestedManyWithoutUserInput> = z.object({
  create: z.union([ z.lazy(() => NotificationCreateWithoutUserInputSchema),z.lazy(() => NotificationCreateWithoutUserInputSchema).array(),z.lazy(() => NotificationUncheckedCreateWithoutUserInputSchema),z.lazy(() => NotificationUncheckedCreateWithoutUserInputSchema).array() ]).optional(),
  connectOrCreate: z.union([ z.lazy(() => NotificationCreateOrConnectWithoutUserInputSchema),z.lazy(() => NotificationCreateOrConnectWithoutUserInputSchema).array() ]).optional(),
  createMany: z.lazy(() => NotificationCreateManyUserInputEnvelopeSchema).optional(),
  connect: z.union([ z.lazy(() => NotificationWhereUniqueInputSchema),z.lazy(() => NotificationWhereUniqueInputSchema).array() ]).optional(),
}).strict();

export const QuestionOptionUncheckedCreateNestedManyWithoutUserInputSchema: z.ZodType<Prisma.QuestionOptionUncheckedCreateNestedManyWithoutUserInput> = z.object({
  create: z.union([ z.lazy(() => QuestionOptionCreateWithoutUserInputSchema),z.lazy(() => QuestionOptionCreateWithoutUserInputSchema).array(),z.lazy(() => QuestionOptionUncheckedCreateWithoutUserInputSchema),z.lazy(() => QuestionOptionUncheckedCreateWithoutUserInputSchema).array() ]).optional(),
  connectOrCreate: z.union([ z.lazy(() => QuestionOptionCreateOrConnectWithoutUserInputSchema),z.lazy(() => QuestionOptionCreateOrConnectWithoutUserInputSchema).array() ]).optional(),
  createMany: z.lazy(() => QuestionOptionCreateManyUserInputEnvelopeSchema).optional(),
  connect: z.union([ z.lazy(() => QuestionOptionWhereUniqueInputSchema),z.lazy(() => QuestionOptionWhereUniqueInputSchema).array() ]).optional(),
}).strict();

export const AccountUncheckedCreateNestedManyWithoutUserInputSchema: z.ZodType<Prisma.AccountUncheckedCreateNestedManyWithoutUserInput> = z.object({
  create: z.union([ z.lazy(() => AccountCreateWithoutUserInputSchema),z.lazy(() => AccountCreateWithoutUserInputSchema).array(),z.lazy(() => AccountUncheckedCreateWithoutUserInputSchema),z.lazy(() => AccountUncheckedCreateWithoutUserInputSchema).array() ]).optional(),
  connectOrCreate: z.union([ z.lazy(() => AccountCreateOrConnectWithoutUserInputSchema),z.lazy(() => AccountCreateOrConnectWithoutUserInputSchema).array() ]).optional(),
  createMany: z.lazy(() => AccountCreateManyUserInputEnvelopeSchema).optional(),
  connect: z.union([ z.lazy(() => AccountWhereUniqueInputSchema),z.lazy(() => AccountWhereUniqueInputSchema).array() ]).optional(),
}).strict();

export const ForecastUpdateManyWithoutUserNestedInputSchema: z.ZodType<Prisma.ForecastUpdateManyWithoutUserNestedInput> = z.object({
  create: z.union([ z.lazy(() => ForecastCreateWithoutUserInputSchema),z.lazy(() => ForecastCreateWithoutUserInputSchema).array(),z.lazy(() => ForecastUncheckedCreateWithoutUserInputSchema),z.lazy(() => ForecastUncheckedCreateWithoutUserInputSchema).array() ]).optional(),
  connectOrCreate: z.union([ z.lazy(() => ForecastCreateOrConnectWithoutUserInputSchema),z.lazy(() => ForecastCreateOrConnectWithoutUserInputSchema).array() ]).optional(),
  upsert: z.union([ z.lazy(() => ForecastUpsertWithWhereUniqueWithoutUserInputSchema),z.lazy(() => ForecastUpsertWithWhereUniqueWithoutUserInputSchema).array() ]).optional(),
  createMany: z.lazy(() => ForecastCreateManyUserInputEnvelopeSchema).optional(),
  set: z.union([ z.lazy(() => ForecastWhereUniqueInputSchema),z.lazy(() => ForecastWhereUniqueInputSchema).array() ]).optional(),
  disconnect: z.union([ z.lazy(() => ForecastWhereUniqueInputSchema),z.lazy(() => ForecastWhereUniqueInputSchema).array() ]).optional(),
  delete: z.union([ z.lazy(() => ForecastWhereUniqueInputSchema),z.lazy(() => ForecastWhereUniqueInputSchema).array() ]).optional(),
  connect: z.union([ z.lazy(() => ForecastWhereUniqueInputSchema),z.lazy(() => ForecastWhereUniqueInputSchema).array() ]).optional(),
  update: z.union([ z.lazy(() => ForecastUpdateWithWhereUniqueWithoutUserInputSchema),z.lazy(() => ForecastUpdateWithWhereUniqueWithoutUserInputSchema).array() ]).optional(),
  updateMany: z.union([ z.lazy(() => ForecastUpdateManyWithWhereWithoutUserInputSchema),z.lazy(() => ForecastUpdateManyWithWhereWithoutUserInputSchema).array() ]).optional(),
  deleteMany: z.union([ z.lazy(() => ForecastScalarWhereInputSchema),z.lazy(() => ForecastScalarWhereInputSchema).array() ]).optional(),
}).strict();

export const ProfileUpdateManyWithoutUserNestedInputSchema: z.ZodType<Prisma.ProfileUpdateManyWithoutUserNestedInput> = z.object({
  create: z.union([ z.lazy(() => ProfileCreateWithoutUserInputSchema),z.lazy(() => ProfileCreateWithoutUserInputSchema).array(),z.lazy(() => ProfileUncheckedCreateWithoutUserInputSchema),z.lazy(() => ProfileUncheckedCreateWithoutUserInputSchema).array() ]).optional(),
  connectOrCreate: z.union([ z.lazy(() => ProfileCreateOrConnectWithoutUserInputSchema),z.lazy(() => ProfileCreateOrConnectWithoutUserInputSchema).array() ]).optional(),
  upsert: z.union([ z.lazy(() => ProfileUpsertWithWhereUniqueWithoutUserInputSchema),z.lazy(() => ProfileUpsertWithWhereUniqueWithoutUserInputSchema).array() ]).optional(),
  createMany: z.lazy(() => ProfileCreateManyUserInputEnvelopeSchema).optional(),
  set: z.union([ z.lazy(() => ProfileWhereUniqueInputSchema),z.lazy(() => ProfileWhereUniqueInputSchema).array() ]).optional(),
  disconnect: z.union([ z.lazy(() => ProfileWhereUniqueInputSchema),z.lazy(() => ProfileWhereUniqueInputSchema).array() ]).optional(),
  delete: z.union([ z.lazy(() => ProfileWhereUniqueInputSchema),z.lazy(() => ProfileWhereUniqueInputSchema).array() ]).optional(),
  connect: z.union([ z.lazy(() => ProfileWhereUniqueInputSchema),z.lazy(() => ProfileWhereUniqueInputSchema).array() ]).optional(),
  update: z.union([ z.lazy(() => ProfileUpdateWithWhereUniqueWithoutUserInputSchema),z.lazy(() => ProfileUpdateWithWhereUniqueWithoutUserInputSchema).array() ]).optional(),
  updateMany: z.union([ z.lazy(() => ProfileUpdateManyWithWhereWithoutUserInputSchema),z.lazy(() => ProfileUpdateManyWithWhereWithoutUserInputSchema).array() ]).optional(),
  deleteMany: z.union([ z.lazy(() => ProfileScalarWhereInputSchema),z.lazy(() => ProfileScalarWhereInputSchema).array() ]).optional(),
}).strict();

export const QuestionUpdateManyWithoutUserNestedInputSchema: z.ZodType<Prisma.QuestionUpdateManyWithoutUserNestedInput> = z.object({
  create: z.union([ z.lazy(() => QuestionCreateWithoutUserInputSchema),z.lazy(() => QuestionCreateWithoutUserInputSchema).array(),z.lazy(() => QuestionUncheckedCreateWithoutUserInputSchema),z.lazy(() => QuestionUncheckedCreateWithoutUserInputSchema).array() ]).optional(),
  connectOrCreate: z.union([ z.lazy(() => QuestionCreateOrConnectWithoutUserInputSchema),z.lazy(() => QuestionCreateOrConnectWithoutUserInputSchema).array() ]).optional(),
  upsert: z.union([ z.lazy(() => QuestionUpsertWithWhereUniqueWithoutUserInputSchema),z.lazy(() => QuestionUpsertWithWhereUniqueWithoutUserInputSchema).array() ]).optional(),
  createMany: z.lazy(() => QuestionCreateManyUserInputEnvelopeSchema).optional(),
  set: z.union([ z.lazy(() => QuestionWhereUniqueInputSchema),z.lazy(() => QuestionWhereUniqueInputSchema).array() ]).optional(),
  disconnect: z.union([ z.lazy(() => QuestionWhereUniqueInputSchema),z.lazy(() => QuestionWhereUniqueInputSchema).array() ]).optional(),
  delete: z.union([ z.lazy(() => QuestionWhereUniqueInputSchema),z.lazy(() => QuestionWhereUniqueInputSchema).array() ]).optional(),
  connect: z.union([ z.lazy(() => QuestionWhereUniqueInputSchema),z.lazy(() => QuestionWhereUniqueInputSchema).array() ]).optional(),
  update: z.union([ z.lazy(() => QuestionUpdateWithWhereUniqueWithoutUserInputSchema),z.lazy(() => QuestionUpdateWithWhereUniqueWithoutUserInputSchema).array() ]).optional(),
  updateMany: z.union([ z.lazy(() => QuestionUpdateManyWithWhereWithoutUserInputSchema),z.lazy(() => QuestionUpdateManyWithWhereWithoutUserInputSchema).array() ]).optional(),
  deleteMany: z.union([ z.lazy(() => QuestionScalarWhereInputSchema),z.lazy(() => QuestionScalarWhereInputSchema).array() ]).optional(),
}).strict();

export const QuestionScoreUpdateManyWithoutUserNestedInputSchema: z.ZodType<Prisma.QuestionScoreUpdateManyWithoutUserNestedInput> = z.object({
  create: z.union([ z.lazy(() => QuestionScoreCreateWithoutUserInputSchema),z.lazy(() => QuestionScoreCreateWithoutUserInputSchema).array(),z.lazy(() => QuestionScoreUncheckedCreateWithoutUserInputSchema),z.lazy(() => QuestionScoreUncheckedCreateWithoutUserInputSchema).array() ]).optional(),
  connectOrCreate: z.union([ z.lazy(() => QuestionScoreCreateOrConnectWithoutUserInputSchema),z.lazy(() => QuestionScoreCreateOrConnectWithoutUserInputSchema).array() ]).optional(),
  upsert: z.union([ z.lazy(() => QuestionScoreUpsertWithWhereUniqueWithoutUserInputSchema),z.lazy(() => QuestionScoreUpsertWithWhereUniqueWithoutUserInputSchema).array() ]).optional(),
  createMany: z.lazy(() => QuestionScoreCreateManyUserInputEnvelopeSchema).optional(),
  set: z.union([ z.lazy(() => QuestionScoreWhereUniqueInputSchema),z.lazy(() => QuestionScoreWhereUniqueInputSchema).array() ]).optional(),
  disconnect: z.union([ z.lazy(() => QuestionScoreWhereUniqueInputSchema),z.lazy(() => QuestionScoreWhereUniqueInputSchema).array() ]).optional(),
  delete: z.union([ z.lazy(() => QuestionScoreWhereUniqueInputSchema),z.lazy(() => QuestionScoreWhereUniqueInputSchema).array() ]).optional(),
  connect: z.union([ z.lazy(() => QuestionScoreWhereUniqueInputSchema),z.lazy(() => QuestionScoreWhereUniqueInputSchema).array() ]).optional(),
  update: z.union([ z.lazy(() => QuestionScoreUpdateWithWhereUniqueWithoutUserInputSchema),z.lazy(() => QuestionScoreUpdateWithWhereUniqueWithoutUserInputSchema).array() ]).optional(),
  updateMany: z.union([ z.lazy(() => QuestionScoreUpdateManyWithWhereWithoutUserInputSchema),z.lazy(() => QuestionScoreUpdateManyWithWhereWithoutUserInputSchema).array() ]).optional(),
  deleteMany: z.union([ z.lazy(() => QuestionScoreScalarWhereInputSchema),z.lazy(() => QuestionScoreScalarWhereInputSchema).array() ]).optional(),
}).strict();

export const QuestionUpdateManyWithoutSharedWithNestedInputSchema: z.ZodType<Prisma.QuestionUpdateManyWithoutSharedWithNestedInput> = z.object({
  create: z.union([ z.lazy(() => QuestionCreateWithoutSharedWithInputSchema),z.lazy(() => QuestionCreateWithoutSharedWithInputSchema).array(),z.lazy(() => QuestionUncheckedCreateWithoutSharedWithInputSchema),z.lazy(() => QuestionUncheckedCreateWithoutSharedWithInputSchema).array() ]).optional(),
  connectOrCreate: z.union([ z.lazy(() => QuestionCreateOrConnectWithoutSharedWithInputSchema),z.lazy(() => QuestionCreateOrConnectWithoutSharedWithInputSchema).array() ]).optional(),
  upsert: z.union([ z.lazy(() => QuestionUpsertWithWhereUniqueWithoutSharedWithInputSchema),z.lazy(() => QuestionUpsertWithWhereUniqueWithoutSharedWithInputSchema).array() ]).optional(),
  set: z.union([ z.lazy(() => QuestionWhereUniqueInputSchema),z.lazy(() => QuestionWhereUniqueInputSchema).array() ]).optional(),
  disconnect: z.union([ z.lazy(() => QuestionWhereUniqueInputSchema),z.lazy(() => QuestionWhereUniqueInputSchema).array() ]).optional(),
  delete: z.union([ z.lazy(() => QuestionWhereUniqueInputSchema),z.lazy(() => QuestionWhereUniqueInputSchema).array() ]).optional(),
  connect: z.union([ z.lazy(() => QuestionWhereUniqueInputSchema),z.lazy(() => QuestionWhereUniqueInputSchema).array() ]).optional(),
  update: z.union([ z.lazy(() => QuestionUpdateWithWhereUniqueWithoutSharedWithInputSchema),z.lazy(() => QuestionUpdateWithWhereUniqueWithoutSharedWithInputSchema).array() ]).optional(),
  updateMany: z.union([ z.lazy(() => QuestionUpdateManyWithWhereWithoutSharedWithInputSchema),z.lazy(() => QuestionUpdateManyWithWhereWithoutSharedWithInputSchema).array() ]).optional(),
  deleteMany: z.union([ z.lazy(() => QuestionScalarWhereInputSchema),z.lazy(() => QuestionScalarWhereInputSchema).array() ]).optional(),
}).strict();

export const CommentUpdateManyWithoutUserNestedInputSchema: z.ZodType<Prisma.CommentUpdateManyWithoutUserNestedInput> = z.object({
  create: z.union([ z.lazy(() => CommentCreateWithoutUserInputSchema),z.lazy(() => CommentCreateWithoutUserInputSchema).array(),z.lazy(() => CommentUncheckedCreateWithoutUserInputSchema),z.lazy(() => CommentUncheckedCreateWithoutUserInputSchema).array() ]).optional(),
  connectOrCreate: z.union([ z.lazy(() => CommentCreateOrConnectWithoutUserInputSchema),z.lazy(() => CommentCreateOrConnectWithoutUserInputSchema).array() ]).optional(),
  upsert: z.union([ z.lazy(() => CommentUpsertWithWhereUniqueWithoutUserInputSchema),z.lazy(() => CommentUpsertWithWhereUniqueWithoutUserInputSchema).array() ]).optional(),
  createMany: z.lazy(() => CommentCreateManyUserInputEnvelopeSchema).optional(),
  set: z.union([ z.lazy(() => CommentWhereUniqueInputSchema),z.lazy(() => CommentWhereUniqueInputSchema).array() ]).optional(),
  disconnect: z.union([ z.lazy(() => CommentWhereUniqueInputSchema),z.lazy(() => CommentWhereUniqueInputSchema).array() ]).optional(),
  delete: z.union([ z.lazy(() => CommentWhereUniqueInputSchema),z.lazy(() => CommentWhereUniqueInputSchema).array() ]).optional(),
  connect: z.union([ z.lazy(() => CommentWhereUniqueInputSchema),z.lazy(() => CommentWhereUniqueInputSchema).array() ]).optional(),
  update: z.union([ z.lazy(() => CommentUpdateWithWhereUniqueWithoutUserInputSchema),z.lazy(() => CommentUpdateWithWhereUniqueWithoutUserInputSchema).array() ]).optional(),
  updateMany: z.union([ z.lazy(() => CommentUpdateManyWithWhereWithoutUserInputSchema),z.lazy(() => CommentUpdateManyWithWhereWithoutUserInputSchema).array() ]).optional(),
  deleteMany: z.union([ z.lazy(() => CommentScalarWhereInputSchema),z.lazy(() => CommentScalarWhereInputSchema).array() ]).optional(),
}).strict();

export const TargetUpdateOneWithoutUserNestedInputSchema: z.ZodType<Prisma.TargetUpdateOneWithoutUserNestedInput> = z.object({
  create: z.union([ z.lazy(() => TargetCreateWithoutUserInputSchema),z.lazy(() => TargetUncheckedCreateWithoutUserInputSchema) ]).optional(),
  connectOrCreate: z.lazy(() => TargetCreateOrConnectWithoutUserInputSchema).optional(),
  upsert: z.lazy(() => TargetUpsertWithoutUserInputSchema).optional(),
  disconnect: z.union([ z.boolean(),z.lazy(() => TargetWhereInputSchema) ]).optional(),
  delete: z.union([ z.boolean(),z.lazy(() => TargetWhereInputSchema) ]).optional(),
  connect: z.lazy(() => TargetWhereUniqueInputSchema).optional(),
  update: z.union([ z.lazy(() => TargetUpdateToOneWithWhereWithoutUserInputSchema),z.lazy(() => TargetUpdateWithoutUserInputSchema),z.lazy(() => TargetUncheckedUpdateWithoutUserInputSchema) ]).optional(),
}).strict();

export const UserListUpdateManyWithoutAuthorNestedInputSchema: z.ZodType<Prisma.UserListUpdateManyWithoutAuthorNestedInput> = z.object({
  create: z.union([ z.lazy(() => UserListCreateWithoutAuthorInputSchema),z.lazy(() => UserListCreateWithoutAuthorInputSchema).array(),z.lazy(() => UserListUncheckedCreateWithoutAuthorInputSchema),z.lazy(() => UserListUncheckedCreateWithoutAuthorInputSchema).array() ]).optional(),
  connectOrCreate: z.union([ z.lazy(() => UserListCreateOrConnectWithoutAuthorInputSchema),z.lazy(() => UserListCreateOrConnectWithoutAuthorInputSchema).array() ]).optional(),
  upsert: z.union([ z.lazy(() => UserListUpsertWithWhereUniqueWithoutAuthorInputSchema),z.lazy(() => UserListUpsertWithWhereUniqueWithoutAuthorInputSchema).array() ]).optional(),
  createMany: z.lazy(() => UserListCreateManyAuthorInputEnvelopeSchema).optional(),
  set: z.union([ z.lazy(() => UserListWhereUniqueInputSchema),z.lazy(() => UserListWhereUniqueInputSchema).array() ]).optional(),
  disconnect: z.union([ z.lazy(() => UserListWhereUniqueInputSchema),z.lazy(() => UserListWhereUniqueInputSchema).array() ]).optional(),
  delete: z.union([ z.lazy(() => UserListWhereUniqueInputSchema),z.lazy(() => UserListWhereUniqueInputSchema).array() ]).optional(),
  connect: z.union([ z.lazy(() => UserListWhereUniqueInputSchema),z.lazy(() => UserListWhereUniqueInputSchema).array() ]).optional(),
  update: z.union([ z.lazy(() => UserListUpdateWithWhereUniqueWithoutAuthorInputSchema),z.lazy(() => UserListUpdateWithWhereUniqueWithoutAuthorInputSchema).array() ]).optional(),
  updateMany: z.union([ z.lazy(() => UserListUpdateManyWithWhereWithoutAuthorInputSchema),z.lazy(() => UserListUpdateManyWithWhereWithoutAuthorInputSchema).array() ]).optional(),
  deleteMany: z.union([ z.lazy(() => UserListScalarWhereInputSchema),z.lazy(() => UserListScalarWhereInputSchema).array() ]).optional(),
}).strict();

export const UserListUpdateManyWithoutUsersNestedInputSchema: z.ZodType<Prisma.UserListUpdateManyWithoutUsersNestedInput> = z.object({
  create: z.union([ z.lazy(() => UserListCreateWithoutUsersInputSchema),z.lazy(() => UserListCreateWithoutUsersInputSchema).array(),z.lazy(() => UserListUncheckedCreateWithoutUsersInputSchema),z.lazy(() => UserListUncheckedCreateWithoutUsersInputSchema).array() ]).optional(),
  connectOrCreate: z.union([ z.lazy(() => UserListCreateOrConnectWithoutUsersInputSchema),z.lazy(() => UserListCreateOrConnectWithoutUsersInputSchema).array() ]).optional(),
  upsert: z.union([ z.lazy(() => UserListUpsertWithWhereUniqueWithoutUsersInputSchema),z.lazy(() => UserListUpsertWithWhereUniqueWithoutUsersInputSchema).array() ]).optional(),
  set: z.union([ z.lazy(() => UserListWhereUniqueInputSchema),z.lazy(() => UserListWhereUniqueInputSchema).array() ]).optional(),
  disconnect: z.union([ z.lazy(() => UserListWhereUniqueInputSchema),z.lazy(() => UserListWhereUniqueInputSchema).array() ]).optional(),
  delete: z.union([ z.lazy(() => UserListWhereUniqueInputSchema),z.lazy(() => UserListWhereUniqueInputSchema).array() ]).optional(),
  connect: z.union([ z.lazy(() => UserListWhereUniqueInputSchema),z.lazy(() => UserListWhereUniqueInputSchema).array() ]).optional(),
  update: z.union([ z.lazy(() => UserListUpdateWithWhereUniqueWithoutUsersInputSchema),z.lazy(() => UserListUpdateWithWhereUniqueWithoutUsersInputSchema).array() ]).optional(),
  updateMany: z.union([ z.lazy(() => UserListUpdateManyWithWhereWithoutUsersInputSchema),z.lazy(() => UserListUpdateManyWithWhereWithoutUsersInputSchema).array() ]).optional(),
  deleteMany: z.union([ z.lazy(() => UserListScalarWhereInputSchema),z.lazy(() => UserListScalarWhereInputSchema).array() ]).optional(),
}).strict();

export const TagUpdateManyWithoutUserNestedInputSchema: z.ZodType<Prisma.TagUpdateManyWithoutUserNestedInput> = z.object({
  create: z.union([ z.lazy(() => TagCreateWithoutUserInputSchema),z.lazy(() => TagCreateWithoutUserInputSchema).array(),z.lazy(() => TagUncheckedCreateWithoutUserInputSchema),z.lazy(() => TagUncheckedCreateWithoutUserInputSchema).array() ]).optional(),
  connectOrCreate: z.union([ z.lazy(() => TagCreateOrConnectWithoutUserInputSchema),z.lazy(() => TagCreateOrConnectWithoutUserInputSchema).array() ]).optional(),
  upsert: z.union([ z.lazy(() => TagUpsertWithWhereUniqueWithoutUserInputSchema),z.lazy(() => TagUpsertWithWhereUniqueWithoutUserInputSchema).array() ]).optional(),
  createMany: z.lazy(() => TagCreateManyUserInputEnvelopeSchema).optional(),
  set: z.union([ z.lazy(() => TagWhereUniqueInputSchema),z.lazy(() => TagWhereUniqueInputSchema).array() ]).optional(),
  disconnect: z.union([ z.lazy(() => TagWhereUniqueInputSchema),z.lazy(() => TagWhereUniqueInputSchema).array() ]).optional(),
  delete: z.union([ z.lazy(() => TagWhereUniqueInputSchema),z.lazy(() => TagWhereUniqueInputSchema).array() ]).optional(),
  connect: z.union([ z.lazy(() => TagWhereUniqueInputSchema),z.lazy(() => TagWhereUniqueInputSchema).array() ]).optional(),
  update: z.union([ z.lazy(() => TagUpdateWithWhereUniqueWithoutUserInputSchema),z.lazy(() => TagUpdateWithWhereUniqueWithoutUserInputSchema).array() ]).optional(),
  updateMany: z.union([ z.lazy(() => TagUpdateManyWithWhereWithoutUserInputSchema),z.lazy(() => TagUpdateManyWithWhereWithoutUserInputSchema).array() ]).optional(),
  deleteMany: z.union([ z.lazy(() => TagScalarWhereInputSchema),z.lazy(() => TagScalarWhereInputSchema).array() ]).optional(),
}).strict();

export const TournamentUpdateManyWithoutAuthorNestedInputSchema: z.ZodType<Prisma.TournamentUpdateManyWithoutAuthorNestedInput> = z.object({
  create: z.union([ z.lazy(() => TournamentCreateWithoutAuthorInputSchema),z.lazy(() => TournamentCreateWithoutAuthorInputSchema).array(),z.lazy(() => TournamentUncheckedCreateWithoutAuthorInputSchema),z.lazy(() => TournamentUncheckedCreateWithoutAuthorInputSchema).array() ]).optional(),
  connectOrCreate: z.union([ z.lazy(() => TournamentCreateOrConnectWithoutAuthorInputSchema),z.lazy(() => TournamentCreateOrConnectWithoutAuthorInputSchema).array() ]).optional(),
  upsert: z.union([ z.lazy(() => TournamentUpsertWithWhereUniqueWithoutAuthorInputSchema),z.lazy(() => TournamentUpsertWithWhereUniqueWithoutAuthorInputSchema).array() ]).optional(),
  createMany: z.lazy(() => TournamentCreateManyAuthorInputEnvelopeSchema).optional(),
  set: z.union([ z.lazy(() => TournamentWhereUniqueInputSchema),z.lazy(() => TournamentWhereUniqueInputSchema).array() ]).optional(),
  disconnect: z.union([ z.lazy(() => TournamentWhereUniqueInputSchema),z.lazy(() => TournamentWhereUniqueInputSchema).array() ]).optional(),
  delete: z.union([ z.lazy(() => TournamentWhereUniqueInputSchema),z.lazy(() => TournamentWhereUniqueInputSchema).array() ]).optional(),
  connect: z.union([ z.lazy(() => TournamentWhereUniqueInputSchema),z.lazy(() => TournamentWhereUniqueInputSchema).array() ]).optional(),
  update: z.union([ z.lazy(() => TournamentUpdateWithWhereUniqueWithoutAuthorInputSchema),z.lazy(() => TournamentUpdateWithWhereUniqueWithoutAuthorInputSchema).array() ]).optional(),
  updateMany: z.union([ z.lazy(() => TournamentUpdateManyWithWhereWithoutAuthorInputSchema),z.lazy(() => TournamentUpdateManyWithWhereWithoutAuthorInputSchema).array() ]).optional(),
  deleteMany: z.union([ z.lazy(() => TournamentScalarWhereInputSchema),z.lazy(() => TournamentScalarWhereInputSchema).array() ]).optional(),
}).strict();

export const NotificationUpdateManyWithoutUserNestedInputSchema: z.ZodType<Prisma.NotificationUpdateManyWithoutUserNestedInput> = z.object({
  create: z.union([ z.lazy(() => NotificationCreateWithoutUserInputSchema),z.lazy(() => NotificationCreateWithoutUserInputSchema).array(),z.lazy(() => NotificationUncheckedCreateWithoutUserInputSchema),z.lazy(() => NotificationUncheckedCreateWithoutUserInputSchema).array() ]).optional(),
  connectOrCreate: z.union([ z.lazy(() => NotificationCreateOrConnectWithoutUserInputSchema),z.lazy(() => NotificationCreateOrConnectWithoutUserInputSchema).array() ]).optional(),
  upsert: z.union([ z.lazy(() => NotificationUpsertWithWhereUniqueWithoutUserInputSchema),z.lazy(() => NotificationUpsertWithWhereUniqueWithoutUserInputSchema).array() ]).optional(),
  createMany: z.lazy(() => NotificationCreateManyUserInputEnvelopeSchema).optional(),
  set: z.union([ z.lazy(() => NotificationWhereUniqueInputSchema),z.lazy(() => NotificationWhereUniqueInputSchema).array() ]).optional(),
  disconnect: z.union([ z.lazy(() => NotificationWhereUniqueInputSchema),z.lazy(() => NotificationWhereUniqueInputSchema).array() ]).optional(),
  delete: z.union([ z.lazy(() => NotificationWhereUniqueInputSchema),z.lazy(() => NotificationWhereUniqueInputSchema).array() ]).optional(),
  connect: z.union([ z.lazy(() => NotificationWhereUniqueInputSchema),z.lazy(() => NotificationWhereUniqueInputSchema).array() ]).optional(),
  update: z.union([ z.lazy(() => NotificationUpdateWithWhereUniqueWithoutUserInputSchema),z.lazy(() => NotificationUpdateWithWhereUniqueWithoutUserInputSchema).array() ]).optional(),
  updateMany: z.union([ z.lazy(() => NotificationUpdateManyWithWhereWithoutUserInputSchema),z.lazy(() => NotificationUpdateManyWithWhereWithoutUserInputSchema).array() ]).optional(),
  deleteMany: z.union([ z.lazy(() => NotificationScalarWhereInputSchema),z.lazy(() => NotificationScalarWhereInputSchema).array() ]).optional(),
}).strict();

export const QuestionOptionUpdateManyWithoutUserNestedInputSchema: z.ZodType<Prisma.QuestionOptionUpdateManyWithoutUserNestedInput> = z.object({
  create: z.union([ z.lazy(() => QuestionOptionCreateWithoutUserInputSchema),z.lazy(() => QuestionOptionCreateWithoutUserInputSchema).array(),z.lazy(() => QuestionOptionUncheckedCreateWithoutUserInputSchema),z.lazy(() => QuestionOptionUncheckedCreateWithoutUserInputSchema).array() ]).optional(),
  connectOrCreate: z.union([ z.lazy(() => QuestionOptionCreateOrConnectWithoutUserInputSchema),z.lazy(() => QuestionOptionCreateOrConnectWithoutUserInputSchema).array() ]).optional(),
  upsert: z.union([ z.lazy(() => QuestionOptionUpsertWithWhereUniqueWithoutUserInputSchema),z.lazy(() => QuestionOptionUpsertWithWhereUniqueWithoutUserInputSchema).array() ]).optional(),
  createMany: z.lazy(() => QuestionOptionCreateManyUserInputEnvelopeSchema).optional(),
  set: z.union([ z.lazy(() => QuestionOptionWhereUniqueInputSchema),z.lazy(() => QuestionOptionWhereUniqueInputSchema).array() ]).optional(),
  disconnect: z.union([ z.lazy(() => QuestionOptionWhereUniqueInputSchema),z.lazy(() => QuestionOptionWhereUniqueInputSchema).array() ]).optional(),
  delete: z.union([ z.lazy(() => QuestionOptionWhereUniqueInputSchema),z.lazy(() => QuestionOptionWhereUniqueInputSchema).array() ]).optional(),
  connect: z.union([ z.lazy(() => QuestionOptionWhereUniqueInputSchema),z.lazy(() => QuestionOptionWhereUniqueInputSchema).array() ]).optional(),
  update: z.union([ z.lazy(() => QuestionOptionUpdateWithWhereUniqueWithoutUserInputSchema),z.lazy(() => QuestionOptionUpdateWithWhereUniqueWithoutUserInputSchema).array() ]).optional(),
  updateMany: z.union([ z.lazy(() => QuestionOptionUpdateManyWithWhereWithoutUserInputSchema),z.lazy(() => QuestionOptionUpdateManyWithWhereWithoutUserInputSchema).array() ]).optional(),
  deleteMany: z.union([ z.lazy(() => QuestionOptionScalarWhereInputSchema),z.lazy(() => QuestionOptionScalarWhereInputSchema).array() ]).optional(),
}).strict();

export const AccountUpdateManyWithoutUserNestedInputSchema: z.ZodType<Prisma.AccountUpdateManyWithoutUserNestedInput> = z.object({
  create: z.union([ z.lazy(() => AccountCreateWithoutUserInputSchema),z.lazy(() => AccountCreateWithoutUserInputSchema).array(),z.lazy(() => AccountUncheckedCreateWithoutUserInputSchema),z.lazy(() => AccountUncheckedCreateWithoutUserInputSchema).array() ]).optional(),
  connectOrCreate: z.union([ z.lazy(() => AccountCreateOrConnectWithoutUserInputSchema),z.lazy(() => AccountCreateOrConnectWithoutUserInputSchema).array() ]).optional(),
  upsert: z.union([ z.lazy(() => AccountUpsertWithWhereUniqueWithoutUserInputSchema),z.lazy(() => AccountUpsertWithWhereUniqueWithoutUserInputSchema).array() ]).optional(),
  createMany: z.lazy(() => AccountCreateManyUserInputEnvelopeSchema).optional(),
  set: z.union([ z.lazy(() => AccountWhereUniqueInputSchema),z.lazy(() => AccountWhereUniqueInputSchema).array() ]).optional(),
  disconnect: z.union([ z.lazy(() => AccountWhereUniqueInputSchema),z.lazy(() => AccountWhereUniqueInputSchema).array() ]).optional(),
  delete: z.union([ z.lazy(() => AccountWhereUniqueInputSchema),z.lazy(() => AccountWhereUniqueInputSchema).array() ]).optional(),
  connect: z.union([ z.lazy(() => AccountWhereUniqueInputSchema),z.lazy(() => AccountWhereUniqueInputSchema).array() ]).optional(),
  update: z.union([ z.lazy(() => AccountUpdateWithWhereUniqueWithoutUserInputSchema),z.lazy(() => AccountUpdateWithWhereUniqueWithoutUserInputSchema).array() ]).optional(),
  updateMany: z.union([ z.lazy(() => AccountUpdateManyWithWhereWithoutUserInputSchema),z.lazy(() => AccountUpdateManyWithWhereWithoutUserInputSchema).array() ]).optional(),
  deleteMany: z.union([ z.lazy(() => AccountScalarWhereInputSchema),z.lazy(() => AccountScalarWhereInputSchema).array() ]).optional(),
}).strict();

export const ForecastUncheckedUpdateManyWithoutUserNestedInputSchema: z.ZodType<Prisma.ForecastUncheckedUpdateManyWithoutUserNestedInput> = z.object({
  create: z.union([ z.lazy(() => ForecastCreateWithoutUserInputSchema),z.lazy(() => ForecastCreateWithoutUserInputSchema).array(),z.lazy(() => ForecastUncheckedCreateWithoutUserInputSchema),z.lazy(() => ForecastUncheckedCreateWithoutUserInputSchema).array() ]).optional(),
  connectOrCreate: z.union([ z.lazy(() => ForecastCreateOrConnectWithoutUserInputSchema),z.lazy(() => ForecastCreateOrConnectWithoutUserInputSchema).array() ]).optional(),
  upsert: z.union([ z.lazy(() => ForecastUpsertWithWhereUniqueWithoutUserInputSchema),z.lazy(() => ForecastUpsertWithWhereUniqueWithoutUserInputSchema).array() ]).optional(),
  createMany: z.lazy(() => ForecastCreateManyUserInputEnvelopeSchema).optional(),
  set: z.union([ z.lazy(() => ForecastWhereUniqueInputSchema),z.lazy(() => ForecastWhereUniqueInputSchema).array() ]).optional(),
  disconnect: z.union([ z.lazy(() => ForecastWhereUniqueInputSchema),z.lazy(() => ForecastWhereUniqueInputSchema).array() ]).optional(),
  delete: z.union([ z.lazy(() => ForecastWhereUniqueInputSchema),z.lazy(() => ForecastWhereUniqueInputSchema).array() ]).optional(),
  connect: z.union([ z.lazy(() => ForecastWhereUniqueInputSchema),z.lazy(() => ForecastWhereUniqueInputSchema).array() ]).optional(),
  update: z.union([ z.lazy(() => ForecastUpdateWithWhereUniqueWithoutUserInputSchema),z.lazy(() => ForecastUpdateWithWhereUniqueWithoutUserInputSchema).array() ]).optional(),
  updateMany: z.union([ z.lazy(() => ForecastUpdateManyWithWhereWithoutUserInputSchema),z.lazy(() => ForecastUpdateManyWithWhereWithoutUserInputSchema).array() ]).optional(),
  deleteMany: z.union([ z.lazy(() => ForecastScalarWhereInputSchema),z.lazy(() => ForecastScalarWhereInputSchema).array() ]).optional(),
}).strict();

export const ProfileUncheckedUpdateManyWithoutUserNestedInputSchema: z.ZodType<Prisma.ProfileUncheckedUpdateManyWithoutUserNestedInput> = z.object({
  create: z.union([ z.lazy(() => ProfileCreateWithoutUserInputSchema),z.lazy(() => ProfileCreateWithoutUserInputSchema).array(),z.lazy(() => ProfileUncheckedCreateWithoutUserInputSchema),z.lazy(() => ProfileUncheckedCreateWithoutUserInputSchema).array() ]).optional(),
  connectOrCreate: z.union([ z.lazy(() => ProfileCreateOrConnectWithoutUserInputSchema),z.lazy(() => ProfileCreateOrConnectWithoutUserInputSchema).array() ]).optional(),
  upsert: z.union([ z.lazy(() => ProfileUpsertWithWhereUniqueWithoutUserInputSchema),z.lazy(() => ProfileUpsertWithWhereUniqueWithoutUserInputSchema).array() ]).optional(),
  createMany: z.lazy(() => ProfileCreateManyUserInputEnvelopeSchema).optional(),
  set: z.union([ z.lazy(() => ProfileWhereUniqueInputSchema),z.lazy(() => ProfileWhereUniqueInputSchema).array() ]).optional(),
  disconnect: z.union([ z.lazy(() => ProfileWhereUniqueInputSchema),z.lazy(() => ProfileWhereUniqueInputSchema).array() ]).optional(),
  delete: z.union([ z.lazy(() => ProfileWhereUniqueInputSchema),z.lazy(() => ProfileWhereUniqueInputSchema).array() ]).optional(),
  connect: z.union([ z.lazy(() => ProfileWhereUniqueInputSchema),z.lazy(() => ProfileWhereUniqueInputSchema).array() ]).optional(),
  update: z.union([ z.lazy(() => ProfileUpdateWithWhereUniqueWithoutUserInputSchema),z.lazy(() => ProfileUpdateWithWhereUniqueWithoutUserInputSchema).array() ]).optional(),
  updateMany: z.union([ z.lazy(() => ProfileUpdateManyWithWhereWithoutUserInputSchema),z.lazy(() => ProfileUpdateManyWithWhereWithoutUserInputSchema).array() ]).optional(),
  deleteMany: z.union([ z.lazy(() => ProfileScalarWhereInputSchema),z.lazy(() => ProfileScalarWhereInputSchema).array() ]).optional(),
}).strict();

export const QuestionUncheckedUpdateManyWithoutUserNestedInputSchema: z.ZodType<Prisma.QuestionUncheckedUpdateManyWithoutUserNestedInput> = z.object({
  create: z.union([ z.lazy(() => QuestionCreateWithoutUserInputSchema),z.lazy(() => QuestionCreateWithoutUserInputSchema).array(),z.lazy(() => QuestionUncheckedCreateWithoutUserInputSchema),z.lazy(() => QuestionUncheckedCreateWithoutUserInputSchema).array() ]).optional(),
  connectOrCreate: z.union([ z.lazy(() => QuestionCreateOrConnectWithoutUserInputSchema),z.lazy(() => QuestionCreateOrConnectWithoutUserInputSchema).array() ]).optional(),
  upsert: z.union([ z.lazy(() => QuestionUpsertWithWhereUniqueWithoutUserInputSchema),z.lazy(() => QuestionUpsertWithWhereUniqueWithoutUserInputSchema).array() ]).optional(),
  createMany: z.lazy(() => QuestionCreateManyUserInputEnvelopeSchema).optional(),
  set: z.union([ z.lazy(() => QuestionWhereUniqueInputSchema),z.lazy(() => QuestionWhereUniqueInputSchema).array() ]).optional(),
  disconnect: z.union([ z.lazy(() => QuestionWhereUniqueInputSchema),z.lazy(() => QuestionWhereUniqueInputSchema).array() ]).optional(),
  delete: z.union([ z.lazy(() => QuestionWhereUniqueInputSchema),z.lazy(() => QuestionWhereUniqueInputSchema).array() ]).optional(),
  connect: z.union([ z.lazy(() => QuestionWhereUniqueInputSchema),z.lazy(() => QuestionWhereUniqueInputSchema).array() ]).optional(),
  update: z.union([ z.lazy(() => QuestionUpdateWithWhereUniqueWithoutUserInputSchema),z.lazy(() => QuestionUpdateWithWhereUniqueWithoutUserInputSchema).array() ]).optional(),
  updateMany: z.union([ z.lazy(() => QuestionUpdateManyWithWhereWithoutUserInputSchema),z.lazy(() => QuestionUpdateManyWithWhereWithoutUserInputSchema).array() ]).optional(),
  deleteMany: z.union([ z.lazy(() => QuestionScalarWhereInputSchema),z.lazy(() => QuestionScalarWhereInputSchema).array() ]).optional(),
}).strict();

export const QuestionScoreUncheckedUpdateManyWithoutUserNestedInputSchema: z.ZodType<Prisma.QuestionScoreUncheckedUpdateManyWithoutUserNestedInput> = z.object({
  create: z.union([ z.lazy(() => QuestionScoreCreateWithoutUserInputSchema),z.lazy(() => QuestionScoreCreateWithoutUserInputSchema).array(),z.lazy(() => QuestionScoreUncheckedCreateWithoutUserInputSchema),z.lazy(() => QuestionScoreUncheckedCreateWithoutUserInputSchema).array() ]).optional(),
  connectOrCreate: z.union([ z.lazy(() => QuestionScoreCreateOrConnectWithoutUserInputSchema),z.lazy(() => QuestionScoreCreateOrConnectWithoutUserInputSchema).array() ]).optional(),
  upsert: z.union([ z.lazy(() => QuestionScoreUpsertWithWhereUniqueWithoutUserInputSchema),z.lazy(() => QuestionScoreUpsertWithWhereUniqueWithoutUserInputSchema).array() ]).optional(),
  createMany: z.lazy(() => QuestionScoreCreateManyUserInputEnvelopeSchema).optional(),
  set: z.union([ z.lazy(() => QuestionScoreWhereUniqueInputSchema),z.lazy(() => QuestionScoreWhereUniqueInputSchema).array() ]).optional(),
  disconnect: z.union([ z.lazy(() => QuestionScoreWhereUniqueInputSchema),z.lazy(() => QuestionScoreWhereUniqueInputSchema).array() ]).optional(),
  delete: z.union([ z.lazy(() => QuestionScoreWhereUniqueInputSchema),z.lazy(() => QuestionScoreWhereUniqueInputSchema).array() ]).optional(),
  connect: z.union([ z.lazy(() => QuestionScoreWhereUniqueInputSchema),z.lazy(() => QuestionScoreWhereUniqueInputSchema).array() ]).optional(),
  update: z.union([ z.lazy(() => QuestionScoreUpdateWithWhereUniqueWithoutUserInputSchema),z.lazy(() => QuestionScoreUpdateWithWhereUniqueWithoutUserInputSchema).array() ]).optional(),
  updateMany: z.union([ z.lazy(() => QuestionScoreUpdateManyWithWhereWithoutUserInputSchema),z.lazy(() => QuestionScoreUpdateManyWithWhereWithoutUserInputSchema).array() ]).optional(),
  deleteMany: z.union([ z.lazy(() => QuestionScoreScalarWhereInputSchema),z.lazy(() => QuestionScoreScalarWhereInputSchema).array() ]).optional(),
}).strict();

export const QuestionUncheckedUpdateManyWithoutSharedWithNestedInputSchema: z.ZodType<Prisma.QuestionUncheckedUpdateManyWithoutSharedWithNestedInput> = z.object({
  create: z.union([ z.lazy(() => QuestionCreateWithoutSharedWithInputSchema),z.lazy(() => QuestionCreateWithoutSharedWithInputSchema).array(),z.lazy(() => QuestionUncheckedCreateWithoutSharedWithInputSchema),z.lazy(() => QuestionUncheckedCreateWithoutSharedWithInputSchema).array() ]).optional(),
  connectOrCreate: z.union([ z.lazy(() => QuestionCreateOrConnectWithoutSharedWithInputSchema),z.lazy(() => QuestionCreateOrConnectWithoutSharedWithInputSchema).array() ]).optional(),
  upsert: z.union([ z.lazy(() => QuestionUpsertWithWhereUniqueWithoutSharedWithInputSchema),z.lazy(() => QuestionUpsertWithWhereUniqueWithoutSharedWithInputSchema).array() ]).optional(),
  set: z.union([ z.lazy(() => QuestionWhereUniqueInputSchema),z.lazy(() => QuestionWhereUniqueInputSchema).array() ]).optional(),
  disconnect: z.union([ z.lazy(() => QuestionWhereUniqueInputSchema),z.lazy(() => QuestionWhereUniqueInputSchema).array() ]).optional(),
  delete: z.union([ z.lazy(() => QuestionWhereUniqueInputSchema),z.lazy(() => QuestionWhereUniqueInputSchema).array() ]).optional(),
  connect: z.union([ z.lazy(() => QuestionWhereUniqueInputSchema),z.lazy(() => QuestionWhereUniqueInputSchema).array() ]).optional(),
  update: z.union([ z.lazy(() => QuestionUpdateWithWhereUniqueWithoutSharedWithInputSchema),z.lazy(() => QuestionUpdateWithWhereUniqueWithoutSharedWithInputSchema).array() ]).optional(),
  updateMany: z.union([ z.lazy(() => QuestionUpdateManyWithWhereWithoutSharedWithInputSchema),z.lazy(() => QuestionUpdateManyWithWhereWithoutSharedWithInputSchema).array() ]).optional(),
  deleteMany: z.union([ z.lazy(() => QuestionScalarWhereInputSchema),z.lazy(() => QuestionScalarWhereInputSchema).array() ]).optional(),
}).strict();

export const CommentUncheckedUpdateManyWithoutUserNestedInputSchema: z.ZodType<Prisma.CommentUncheckedUpdateManyWithoutUserNestedInput> = z.object({
  create: z.union([ z.lazy(() => CommentCreateWithoutUserInputSchema),z.lazy(() => CommentCreateWithoutUserInputSchema).array(),z.lazy(() => CommentUncheckedCreateWithoutUserInputSchema),z.lazy(() => CommentUncheckedCreateWithoutUserInputSchema).array() ]).optional(),
  connectOrCreate: z.union([ z.lazy(() => CommentCreateOrConnectWithoutUserInputSchema),z.lazy(() => CommentCreateOrConnectWithoutUserInputSchema).array() ]).optional(),
  upsert: z.union([ z.lazy(() => CommentUpsertWithWhereUniqueWithoutUserInputSchema),z.lazy(() => CommentUpsertWithWhereUniqueWithoutUserInputSchema).array() ]).optional(),
  createMany: z.lazy(() => CommentCreateManyUserInputEnvelopeSchema).optional(),
  set: z.union([ z.lazy(() => CommentWhereUniqueInputSchema),z.lazy(() => CommentWhereUniqueInputSchema).array() ]).optional(),
  disconnect: z.union([ z.lazy(() => CommentWhereUniqueInputSchema),z.lazy(() => CommentWhereUniqueInputSchema).array() ]).optional(),
  delete: z.union([ z.lazy(() => CommentWhereUniqueInputSchema),z.lazy(() => CommentWhereUniqueInputSchema).array() ]).optional(),
  connect: z.union([ z.lazy(() => CommentWhereUniqueInputSchema),z.lazy(() => CommentWhereUniqueInputSchema).array() ]).optional(),
  update: z.union([ z.lazy(() => CommentUpdateWithWhereUniqueWithoutUserInputSchema),z.lazy(() => CommentUpdateWithWhereUniqueWithoutUserInputSchema).array() ]).optional(),
  updateMany: z.union([ z.lazy(() => CommentUpdateManyWithWhereWithoutUserInputSchema),z.lazy(() => CommentUpdateManyWithWhereWithoutUserInputSchema).array() ]).optional(),
  deleteMany: z.union([ z.lazy(() => CommentScalarWhereInputSchema),z.lazy(() => CommentScalarWhereInputSchema).array() ]).optional(),
}).strict();

export const TargetUncheckedUpdateOneWithoutUserNestedInputSchema: z.ZodType<Prisma.TargetUncheckedUpdateOneWithoutUserNestedInput> = z.object({
  create: z.union([ z.lazy(() => TargetCreateWithoutUserInputSchema),z.lazy(() => TargetUncheckedCreateWithoutUserInputSchema) ]).optional(),
  connectOrCreate: z.lazy(() => TargetCreateOrConnectWithoutUserInputSchema).optional(),
  upsert: z.lazy(() => TargetUpsertWithoutUserInputSchema).optional(),
  disconnect: z.union([ z.boolean(),z.lazy(() => TargetWhereInputSchema) ]).optional(),
  delete: z.union([ z.boolean(),z.lazy(() => TargetWhereInputSchema) ]).optional(),
  connect: z.lazy(() => TargetWhereUniqueInputSchema).optional(),
  update: z.union([ z.lazy(() => TargetUpdateToOneWithWhereWithoutUserInputSchema),z.lazy(() => TargetUpdateWithoutUserInputSchema),z.lazy(() => TargetUncheckedUpdateWithoutUserInputSchema) ]).optional(),
}).strict();

export const UserListUncheckedUpdateManyWithoutAuthorNestedInputSchema: z.ZodType<Prisma.UserListUncheckedUpdateManyWithoutAuthorNestedInput> = z.object({
  create: z.union([ z.lazy(() => UserListCreateWithoutAuthorInputSchema),z.lazy(() => UserListCreateWithoutAuthorInputSchema).array(),z.lazy(() => UserListUncheckedCreateWithoutAuthorInputSchema),z.lazy(() => UserListUncheckedCreateWithoutAuthorInputSchema).array() ]).optional(),
  connectOrCreate: z.union([ z.lazy(() => UserListCreateOrConnectWithoutAuthorInputSchema),z.lazy(() => UserListCreateOrConnectWithoutAuthorInputSchema).array() ]).optional(),
  upsert: z.union([ z.lazy(() => UserListUpsertWithWhereUniqueWithoutAuthorInputSchema),z.lazy(() => UserListUpsertWithWhereUniqueWithoutAuthorInputSchema).array() ]).optional(),
  createMany: z.lazy(() => UserListCreateManyAuthorInputEnvelopeSchema).optional(),
  set: z.union([ z.lazy(() => UserListWhereUniqueInputSchema),z.lazy(() => UserListWhereUniqueInputSchema).array() ]).optional(),
  disconnect: z.union([ z.lazy(() => UserListWhereUniqueInputSchema),z.lazy(() => UserListWhereUniqueInputSchema).array() ]).optional(),
  delete: z.union([ z.lazy(() => UserListWhereUniqueInputSchema),z.lazy(() => UserListWhereUniqueInputSchema).array() ]).optional(),
  connect: z.union([ z.lazy(() => UserListWhereUniqueInputSchema),z.lazy(() => UserListWhereUniqueInputSchema).array() ]).optional(),
  update: z.union([ z.lazy(() => UserListUpdateWithWhereUniqueWithoutAuthorInputSchema),z.lazy(() => UserListUpdateWithWhereUniqueWithoutAuthorInputSchema).array() ]).optional(),
  updateMany: z.union([ z.lazy(() => UserListUpdateManyWithWhereWithoutAuthorInputSchema),z.lazy(() => UserListUpdateManyWithWhereWithoutAuthorInputSchema).array() ]).optional(),
  deleteMany: z.union([ z.lazy(() => UserListScalarWhereInputSchema),z.lazy(() => UserListScalarWhereInputSchema).array() ]).optional(),
}).strict();

export const UserListUncheckedUpdateManyWithoutUsersNestedInputSchema: z.ZodType<Prisma.UserListUncheckedUpdateManyWithoutUsersNestedInput> = z.object({
  create: z.union([ z.lazy(() => UserListCreateWithoutUsersInputSchema),z.lazy(() => UserListCreateWithoutUsersInputSchema).array(),z.lazy(() => UserListUncheckedCreateWithoutUsersInputSchema),z.lazy(() => UserListUncheckedCreateWithoutUsersInputSchema).array() ]).optional(),
  connectOrCreate: z.union([ z.lazy(() => UserListCreateOrConnectWithoutUsersInputSchema),z.lazy(() => UserListCreateOrConnectWithoutUsersInputSchema).array() ]).optional(),
  upsert: z.union([ z.lazy(() => UserListUpsertWithWhereUniqueWithoutUsersInputSchema),z.lazy(() => UserListUpsertWithWhereUniqueWithoutUsersInputSchema).array() ]).optional(),
  set: z.union([ z.lazy(() => UserListWhereUniqueInputSchema),z.lazy(() => UserListWhereUniqueInputSchema).array() ]).optional(),
  disconnect: z.union([ z.lazy(() => UserListWhereUniqueInputSchema),z.lazy(() => UserListWhereUniqueInputSchema).array() ]).optional(),
  delete: z.union([ z.lazy(() => UserListWhereUniqueInputSchema),z.lazy(() => UserListWhereUniqueInputSchema).array() ]).optional(),
  connect: z.union([ z.lazy(() => UserListWhereUniqueInputSchema),z.lazy(() => UserListWhereUniqueInputSchema).array() ]).optional(),
  update: z.union([ z.lazy(() => UserListUpdateWithWhereUniqueWithoutUsersInputSchema),z.lazy(() => UserListUpdateWithWhereUniqueWithoutUsersInputSchema).array() ]).optional(),
  updateMany: z.union([ z.lazy(() => UserListUpdateManyWithWhereWithoutUsersInputSchema),z.lazy(() => UserListUpdateManyWithWhereWithoutUsersInputSchema).array() ]).optional(),
  deleteMany: z.union([ z.lazy(() => UserListScalarWhereInputSchema),z.lazy(() => UserListScalarWhereInputSchema).array() ]).optional(),
}).strict();

export const TagUncheckedUpdateManyWithoutUserNestedInputSchema: z.ZodType<Prisma.TagUncheckedUpdateManyWithoutUserNestedInput> = z.object({
  create: z.union([ z.lazy(() => TagCreateWithoutUserInputSchema),z.lazy(() => TagCreateWithoutUserInputSchema).array(),z.lazy(() => TagUncheckedCreateWithoutUserInputSchema),z.lazy(() => TagUncheckedCreateWithoutUserInputSchema).array() ]).optional(),
  connectOrCreate: z.union([ z.lazy(() => TagCreateOrConnectWithoutUserInputSchema),z.lazy(() => TagCreateOrConnectWithoutUserInputSchema).array() ]).optional(),
  upsert: z.union([ z.lazy(() => TagUpsertWithWhereUniqueWithoutUserInputSchema),z.lazy(() => TagUpsertWithWhereUniqueWithoutUserInputSchema).array() ]).optional(),
  createMany: z.lazy(() => TagCreateManyUserInputEnvelopeSchema).optional(),
  set: z.union([ z.lazy(() => TagWhereUniqueInputSchema),z.lazy(() => TagWhereUniqueInputSchema).array() ]).optional(),
  disconnect: z.union([ z.lazy(() => TagWhereUniqueInputSchema),z.lazy(() => TagWhereUniqueInputSchema).array() ]).optional(),
  delete: z.union([ z.lazy(() => TagWhereUniqueInputSchema),z.lazy(() => TagWhereUniqueInputSchema).array() ]).optional(),
  connect: z.union([ z.lazy(() => TagWhereUniqueInputSchema),z.lazy(() => TagWhereUniqueInputSchema).array() ]).optional(),
  update: z.union([ z.lazy(() => TagUpdateWithWhereUniqueWithoutUserInputSchema),z.lazy(() => TagUpdateWithWhereUniqueWithoutUserInputSchema).array() ]).optional(),
  updateMany: z.union([ z.lazy(() => TagUpdateManyWithWhereWithoutUserInputSchema),z.lazy(() => TagUpdateManyWithWhereWithoutUserInputSchema).array() ]).optional(),
  deleteMany: z.union([ z.lazy(() => TagScalarWhereInputSchema),z.lazy(() => TagScalarWhereInputSchema).array() ]).optional(),
}).strict();

export const TournamentUncheckedUpdateManyWithoutAuthorNestedInputSchema: z.ZodType<Prisma.TournamentUncheckedUpdateManyWithoutAuthorNestedInput> = z.object({
  create: z.union([ z.lazy(() => TournamentCreateWithoutAuthorInputSchema),z.lazy(() => TournamentCreateWithoutAuthorInputSchema).array(),z.lazy(() => TournamentUncheckedCreateWithoutAuthorInputSchema),z.lazy(() => TournamentUncheckedCreateWithoutAuthorInputSchema).array() ]).optional(),
  connectOrCreate: z.union([ z.lazy(() => TournamentCreateOrConnectWithoutAuthorInputSchema),z.lazy(() => TournamentCreateOrConnectWithoutAuthorInputSchema).array() ]).optional(),
  upsert: z.union([ z.lazy(() => TournamentUpsertWithWhereUniqueWithoutAuthorInputSchema),z.lazy(() => TournamentUpsertWithWhereUniqueWithoutAuthorInputSchema).array() ]).optional(),
  createMany: z.lazy(() => TournamentCreateManyAuthorInputEnvelopeSchema).optional(),
  set: z.union([ z.lazy(() => TournamentWhereUniqueInputSchema),z.lazy(() => TournamentWhereUniqueInputSchema).array() ]).optional(),
  disconnect: z.union([ z.lazy(() => TournamentWhereUniqueInputSchema),z.lazy(() => TournamentWhereUniqueInputSchema).array() ]).optional(),
  delete: z.union([ z.lazy(() => TournamentWhereUniqueInputSchema),z.lazy(() => TournamentWhereUniqueInputSchema).array() ]).optional(),
  connect: z.union([ z.lazy(() => TournamentWhereUniqueInputSchema),z.lazy(() => TournamentWhereUniqueInputSchema).array() ]).optional(),
  update: z.union([ z.lazy(() => TournamentUpdateWithWhereUniqueWithoutAuthorInputSchema),z.lazy(() => TournamentUpdateWithWhereUniqueWithoutAuthorInputSchema).array() ]).optional(),
  updateMany: z.union([ z.lazy(() => TournamentUpdateManyWithWhereWithoutAuthorInputSchema),z.lazy(() => TournamentUpdateManyWithWhereWithoutAuthorInputSchema).array() ]).optional(),
  deleteMany: z.union([ z.lazy(() => TournamentScalarWhereInputSchema),z.lazy(() => TournamentScalarWhereInputSchema).array() ]).optional(),
}).strict();

export const NotificationUncheckedUpdateManyWithoutUserNestedInputSchema: z.ZodType<Prisma.NotificationUncheckedUpdateManyWithoutUserNestedInput> = z.object({
  create: z.union([ z.lazy(() => NotificationCreateWithoutUserInputSchema),z.lazy(() => NotificationCreateWithoutUserInputSchema).array(),z.lazy(() => NotificationUncheckedCreateWithoutUserInputSchema),z.lazy(() => NotificationUncheckedCreateWithoutUserInputSchema).array() ]).optional(),
  connectOrCreate: z.union([ z.lazy(() => NotificationCreateOrConnectWithoutUserInputSchema),z.lazy(() => NotificationCreateOrConnectWithoutUserInputSchema).array() ]).optional(),
  upsert: z.union([ z.lazy(() => NotificationUpsertWithWhereUniqueWithoutUserInputSchema),z.lazy(() => NotificationUpsertWithWhereUniqueWithoutUserInputSchema).array() ]).optional(),
  createMany: z.lazy(() => NotificationCreateManyUserInputEnvelopeSchema).optional(),
  set: z.union([ z.lazy(() => NotificationWhereUniqueInputSchema),z.lazy(() => NotificationWhereUniqueInputSchema).array() ]).optional(),
  disconnect: z.union([ z.lazy(() => NotificationWhereUniqueInputSchema),z.lazy(() => NotificationWhereUniqueInputSchema).array() ]).optional(),
  delete: z.union([ z.lazy(() => NotificationWhereUniqueInputSchema),z.lazy(() => NotificationWhereUniqueInputSchema).array() ]).optional(),
  connect: z.union([ z.lazy(() => NotificationWhereUniqueInputSchema),z.lazy(() => NotificationWhereUniqueInputSchema).array() ]).optional(),
  update: z.union([ z.lazy(() => NotificationUpdateWithWhereUniqueWithoutUserInputSchema),z.lazy(() => NotificationUpdateWithWhereUniqueWithoutUserInputSchema).array() ]).optional(),
  updateMany: z.union([ z.lazy(() => NotificationUpdateManyWithWhereWithoutUserInputSchema),z.lazy(() => NotificationUpdateManyWithWhereWithoutUserInputSchema).array() ]).optional(),
  deleteMany: z.union([ z.lazy(() => NotificationScalarWhereInputSchema),z.lazy(() => NotificationScalarWhereInputSchema).array() ]).optional(),
}).strict();

export const QuestionOptionUncheckedUpdateManyWithoutUserNestedInputSchema: z.ZodType<Prisma.QuestionOptionUncheckedUpdateManyWithoutUserNestedInput> = z.object({
  create: z.union([ z.lazy(() => QuestionOptionCreateWithoutUserInputSchema),z.lazy(() => QuestionOptionCreateWithoutUserInputSchema).array(),z.lazy(() => QuestionOptionUncheckedCreateWithoutUserInputSchema),z.lazy(() => QuestionOptionUncheckedCreateWithoutUserInputSchema).array() ]).optional(),
  connectOrCreate: z.union([ z.lazy(() => QuestionOptionCreateOrConnectWithoutUserInputSchema),z.lazy(() => QuestionOptionCreateOrConnectWithoutUserInputSchema).array() ]).optional(),
  upsert: z.union([ z.lazy(() => QuestionOptionUpsertWithWhereUniqueWithoutUserInputSchema),z.lazy(() => QuestionOptionUpsertWithWhereUniqueWithoutUserInputSchema).array() ]).optional(),
  createMany: z.lazy(() => QuestionOptionCreateManyUserInputEnvelopeSchema).optional(),
  set: z.union([ z.lazy(() => QuestionOptionWhereUniqueInputSchema),z.lazy(() => QuestionOptionWhereUniqueInputSchema).array() ]).optional(),
  disconnect: z.union([ z.lazy(() => QuestionOptionWhereUniqueInputSchema),z.lazy(() => QuestionOptionWhereUniqueInputSchema).array() ]).optional(),
  delete: z.union([ z.lazy(() => QuestionOptionWhereUniqueInputSchema),z.lazy(() => QuestionOptionWhereUniqueInputSchema).array() ]).optional(),
  connect: z.union([ z.lazy(() => QuestionOptionWhereUniqueInputSchema),z.lazy(() => QuestionOptionWhereUniqueInputSchema).array() ]).optional(),
  update: z.union([ z.lazy(() => QuestionOptionUpdateWithWhereUniqueWithoutUserInputSchema),z.lazy(() => QuestionOptionUpdateWithWhereUniqueWithoutUserInputSchema).array() ]).optional(),
  updateMany: z.union([ z.lazy(() => QuestionOptionUpdateManyWithWhereWithoutUserInputSchema),z.lazy(() => QuestionOptionUpdateManyWithWhereWithoutUserInputSchema).array() ]).optional(),
  deleteMany: z.union([ z.lazy(() => QuestionOptionScalarWhereInputSchema),z.lazy(() => QuestionOptionScalarWhereInputSchema).array() ]).optional(),
}).strict();

export const AccountUncheckedUpdateManyWithoutUserNestedInputSchema: z.ZodType<Prisma.AccountUncheckedUpdateManyWithoutUserNestedInput> = z.object({
  create: z.union([ z.lazy(() => AccountCreateWithoutUserInputSchema),z.lazy(() => AccountCreateWithoutUserInputSchema).array(),z.lazy(() => AccountUncheckedCreateWithoutUserInputSchema),z.lazy(() => AccountUncheckedCreateWithoutUserInputSchema).array() ]).optional(),
  connectOrCreate: z.union([ z.lazy(() => AccountCreateOrConnectWithoutUserInputSchema),z.lazy(() => AccountCreateOrConnectWithoutUserInputSchema).array() ]).optional(),
  upsert: z.union([ z.lazy(() => AccountUpsertWithWhereUniqueWithoutUserInputSchema),z.lazy(() => AccountUpsertWithWhereUniqueWithoutUserInputSchema).array() ]).optional(),
  createMany: z.lazy(() => AccountCreateManyUserInputEnvelopeSchema).optional(),
  set: z.union([ z.lazy(() => AccountWhereUniqueInputSchema),z.lazy(() => AccountWhereUniqueInputSchema).array() ]).optional(),
  disconnect: z.union([ z.lazy(() => AccountWhereUniqueInputSchema),z.lazy(() => AccountWhereUniqueInputSchema).array() ]).optional(),
  delete: z.union([ z.lazy(() => AccountWhereUniqueInputSchema),z.lazy(() => AccountWhereUniqueInputSchema).array() ]).optional(),
  connect: z.union([ z.lazy(() => AccountWhereUniqueInputSchema),z.lazy(() => AccountWhereUniqueInputSchema).array() ]).optional(),
  update: z.union([ z.lazy(() => AccountUpdateWithWhereUniqueWithoutUserInputSchema),z.lazy(() => AccountUpdateWithWhereUniqueWithoutUserInputSchema).array() ]).optional(),
  updateMany: z.union([ z.lazy(() => AccountUpdateManyWithWhereWithoutUserInputSchema),z.lazy(() => AccountUpdateManyWithWhereWithoutUserInputSchema).array() ]).optional(),
  deleteMany: z.union([ z.lazy(() => AccountScalarWhereInputSchema),z.lazy(() => AccountScalarWhereInputSchema).array() ]).optional(),
}).strict();

export const ForecastCreateNestedManyWithoutProfileInputSchema: z.ZodType<Prisma.ForecastCreateNestedManyWithoutProfileInput> = z.object({
  create: z.union([ z.lazy(() => ForecastCreateWithoutProfileInputSchema),z.lazy(() => ForecastCreateWithoutProfileInputSchema).array(),z.lazy(() => ForecastUncheckedCreateWithoutProfileInputSchema),z.lazy(() => ForecastUncheckedCreateWithoutProfileInputSchema).array() ]).optional(),
  connectOrCreate: z.union([ z.lazy(() => ForecastCreateOrConnectWithoutProfileInputSchema),z.lazy(() => ForecastCreateOrConnectWithoutProfileInputSchema).array() ]).optional(),
  createMany: z.lazy(() => ForecastCreateManyProfileInputEnvelopeSchema).optional(),
  connect: z.union([ z.lazy(() => ForecastWhereUniqueInputSchema),z.lazy(() => ForecastWhereUniqueInputSchema).array() ]).optional(),
}).strict();

export const UserCreateNestedOneWithoutProfilesInputSchema: z.ZodType<Prisma.UserCreateNestedOneWithoutProfilesInput> = z.object({
  create: z.union([ z.lazy(() => UserCreateWithoutProfilesInputSchema),z.lazy(() => UserUncheckedCreateWithoutProfilesInputSchema) ]).optional(),
  connectOrCreate: z.lazy(() => UserCreateOrConnectWithoutProfilesInputSchema).optional(),
  connect: z.lazy(() => UserWhereUniqueInputSchema).optional()
}).strict();

export const QuestionCreateNestedManyWithoutProfileInputSchema: z.ZodType<Prisma.QuestionCreateNestedManyWithoutProfileInput> = z.object({
  create: z.union([ z.lazy(() => QuestionCreateWithoutProfileInputSchema),z.lazy(() => QuestionCreateWithoutProfileInputSchema).array(),z.lazy(() => QuestionUncheckedCreateWithoutProfileInputSchema),z.lazy(() => QuestionUncheckedCreateWithoutProfileInputSchema).array() ]).optional(),
  connectOrCreate: z.union([ z.lazy(() => QuestionCreateOrConnectWithoutProfileInputSchema),z.lazy(() => QuestionCreateOrConnectWithoutProfileInputSchema).array() ]).optional(),
  createMany: z.lazy(() => QuestionCreateManyProfileInputEnvelopeSchema).optional(),
  connect: z.union([ z.lazy(() => QuestionWhereUniqueInputSchema),z.lazy(() => QuestionWhereUniqueInputSchema).array() ]).optional(),
}).strict();

export const ResolutionSlackMessageCreateNestedManyWithoutProfileInputSchema: z.ZodType<Prisma.ResolutionSlackMessageCreateNestedManyWithoutProfileInput> = z.object({
  create: z.union([ z.lazy(() => ResolutionSlackMessageCreateWithoutProfileInputSchema),z.lazy(() => ResolutionSlackMessageCreateWithoutProfileInputSchema).array(),z.lazy(() => ResolutionSlackMessageUncheckedCreateWithoutProfileInputSchema),z.lazy(() => ResolutionSlackMessageUncheckedCreateWithoutProfileInputSchema).array() ]).optional(),
  connectOrCreate: z.union([ z.lazy(() => ResolutionSlackMessageCreateOrConnectWithoutProfileInputSchema),z.lazy(() => ResolutionSlackMessageCreateOrConnectWithoutProfileInputSchema).array() ]).optional(),
  createMany: z.lazy(() => ResolutionSlackMessageCreateManyProfileInputEnvelopeSchema).optional(),
  connect: z.union([ z.lazy(() => ResolutionSlackMessageWhereUniqueInputSchema),z.lazy(() => ResolutionSlackMessageWhereUniqueInputSchema).array() ]).optional(),
}).strict();

export const TargetCreateNestedOneWithoutProfileInputSchema: z.ZodType<Prisma.TargetCreateNestedOneWithoutProfileInput> = z.object({
  create: z.union([ z.lazy(() => TargetCreateWithoutProfileInputSchema),z.lazy(() => TargetUncheckedCreateWithoutProfileInputSchema) ]).optional(),
  connectOrCreate: z.lazy(() => TargetCreateOrConnectWithoutProfileInputSchema).optional(),
  connect: z.lazy(() => TargetWhereUniqueInputSchema).optional()
}).strict();

export const ForecastUncheckedCreateNestedManyWithoutProfileInputSchema: z.ZodType<Prisma.ForecastUncheckedCreateNestedManyWithoutProfileInput> = z.object({
  create: z.union([ z.lazy(() => ForecastCreateWithoutProfileInputSchema),z.lazy(() => ForecastCreateWithoutProfileInputSchema).array(),z.lazy(() => ForecastUncheckedCreateWithoutProfileInputSchema),z.lazy(() => ForecastUncheckedCreateWithoutProfileInputSchema).array() ]).optional(),
  connectOrCreate: z.union([ z.lazy(() => ForecastCreateOrConnectWithoutProfileInputSchema),z.lazy(() => ForecastCreateOrConnectWithoutProfileInputSchema).array() ]).optional(),
  createMany: z.lazy(() => ForecastCreateManyProfileInputEnvelopeSchema).optional(),
  connect: z.union([ z.lazy(() => ForecastWhereUniqueInputSchema),z.lazy(() => ForecastWhereUniqueInputSchema).array() ]).optional(),
}).strict();

export const QuestionUncheckedCreateNestedManyWithoutProfileInputSchema: z.ZodType<Prisma.QuestionUncheckedCreateNestedManyWithoutProfileInput> = z.object({
  create: z.union([ z.lazy(() => QuestionCreateWithoutProfileInputSchema),z.lazy(() => QuestionCreateWithoutProfileInputSchema).array(),z.lazy(() => QuestionUncheckedCreateWithoutProfileInputSchema),z.lazy(() => QuestionUncheckedCreateWithoutProfileInputSchema).array() ]).optional(),
  connectOrCreate: z.union([ z.lazy(() => QuestionCreateOrConnectWithoutProfileInputSchema),z.lazy(() => QuestionCreateOrConnectWithoutProfileInputSchema).array() ]).optional(),
  createMany: z.lazy(() => QuestionCreateManyProfileInputEnvelopeSchema).optional(),
  connect: z.union([ z.lazy(() => QuestionWhereUniqueInputSchema),z.lazy(() => QuestionWhereUniqueInputSchema).array() ]).optional(),
}).strict();

export const ResolutionSlackMessageUncheckedCreateNestedManyWithoutProfileInputSchema: z.ZodType<Prisma.ResolutionSlackMessageUncheckedCreateNestedManyWithoutProfileInput> = z.object({
  create: z.union([ z.lazy(() => ResolutionSlackMessageCreateWithoutProfileInputSchema),z.lazy(() => ResolutionSlackMessageCreateWithoutProfileInputSchema).array(),z.lazy(() => ResolutionSlackMessageUncheckedCreateWithoutProfileInputSchema),z.lazy(() => ResolutionSlackMessageUncheckedCreateWithoutProfileInputSchema).array() ]).optional(),
  connectOrCreate: z.union([ z.lazy(() => ResolutionSlackMessageCreateOrConnectWithoutProfileInputSchema),z.lazy(() => ResolutionSlackMessageCreateOrConnectWithoutProfileInputSchema).array() ]).optional(),
  createMany: z.lazy(() => ResolutionSlackMessageCreateManyProfileInputEnvelopeSchema).optional(),
  connect: z.union([ z.lazy(() => ResolutionSlackMessageWhereUniqueInputSchema),z.lazy(() => ResolutionSlackMessageWhereUniqueInputSchema).array() ]).optional(),
}).strict();

export const TargetUncheckedCreateNestedOneWithoutProfileInputSchema: z.ZodType<Prisma.TargetUncheckedCreateNestedOneWithoutProfileInput> = z.object({
  create: z.union([ z.lazy(() => TargetCreateWithoutProfileInputSchema),z.lazy(() => TargetUncheckedCreateWithoutProfileInputSchema) ]).optional(),
  connectOrCreate: z.lazy(() => TargetCreateOrConnectWithoutProfileInputSchema).optional(),
  connect: z.lazy(() => TargetWhereUniqueInputSchema).optional()
}).strict();

export const ForecastUpdateManyWithoutProfileNestedInputSchema: z.ZodType<Prisma.ForecastUpdateManyWithoutProfileNestedInput> = z.object({
  create: z.union([ z.lazy(() => ForecastCreateWithoutProfileInputSchema),z.lazy(() => ForecastCreateWithoutProfileInputSchema).array(),z.lazy(() => ForecastUncheckedCreateWithoutProfileInputSchema),z.lazy(() => ForecastUncheckedCreateWithoutProfileInputSchema).array() ]).optional(),
  connectOrCreate: z.union([ z.lazy(() => ForecastCreateOrConnectWithoutProfileInputSchema),z.lazy(() => ForecastCreateOrConnectWithoutProfileInputSchema).array() ]).optional(),
  upsert: z.union([ z.lazy(() => ForecastUpsertWithWhereUniqueWithoutProfileInputSchema),z.lazy(() => ForecastUpsertWithWhereUniqueWithoutProfileInputSchema).array() ]).optional(),
  createMany: z.lazy(() => ForecastCreateManyProfileInputEnvelopeSchema).optional(),
  set: z.union([ z.lazy(() => ForecastWhereUniqueInputSchema),z.lazy(() => ForecastWhereUniqueInputSchema).array() ]).optional(),
  disconnect: z.union([ z.lazy(() => ForecastWhereUniqueInputSchema),z.lazy(() => ForecastWhereUniqueInputSchema).array() ]).optional(),
  delete: z.union([ z.lazy(() => ForecastWhereUniqueInputSchema),z.lazy(() => ForecastWhereUniqueInputSchema).array() ]).optional(),
  connect: z.union([ z.lazy(() => ForecastWhereUniqueInputSchema),z.lazy(() => ForecastWhereUniqueInputSchema).array() ]).optional(),
  update: z.union([ z.lazy(() => ForecastUpdateWithWhereUniqueWithoutProfileInputSchema),z.lazy(() => ForecastUpdateWithWhereUniqueWithoutProfileInputSchema).array() ]).optional(),
  updateMany: z.union([ z.lazy(() => ForecastUpdateManyWithWhereWithoutProfileInputSchema),z.lazy(() => ForecastUpdateManyWithWhereWithoutProfileInputSchema).array() ]).optional(),
  deleteMany: z.union([ z.lazy(() => ForecastScalarWhereInputSchema),z.lazy(() => ForecastScalarWhereInputSchema).array() ]).optional(),
}).strict();

export const UserUpdateOneRequiredWithoutProfilesNestedInputSchema: z.ZodType<Prisma.UserUpdateOneRequiredWithoutProfilesNestedInput> = z.object({
  create: z.union([ z.lazy(() => UserCreateWithoutProfilesInputSchema),z.lazy(() => UserUncheckedCreateWithoutProfilesInputSchema) ]).optional(),
  connectOrCreate: z.lazy(() => UserCreateOrConnectWithoutProfilesInputSchema).optional(),
  upsert: z.lazy(() => UserUpsertWithoutProfilesInputSchema).optional(),
  connect: z.lazy(() => UserWhereUniqueInputSchema).optional(),
  update: z.union([ z.lazy(() => UserUpdateToOneWithWhereWithoutProfilesInputSchema),z.lazy(() => UserUpdateWithoutProfilesInputSchema),z.lazy(() => UserUncheckedUpdateWithoutProfilesInputSchema) ]).optional(),
}).strict();

export const QuestionUpdateManyWithoutProfileNestedInputSchema: z.ZodType<Prisma.QuestionUpdateManyWithoutProfileNestedInput> = z.object({
  create: z.union([ z.lazy(() => QuestionCreateWithoutProfileInputSchema),z.lazy(() => QuestionCreateWithoutProfileInputSchema).array(),z.lazy(() => QuestionUncheckedCreateWithoutProfileInputSchema),z.lazy(() => QuestionUncheckedCreateWithoutProfileInputSchema).array() ]).optional(),
  connectOrCreate: z.union([ z.lazy(() => QuestionCreateOrConnectWithoutProfileInputSchema),z.lazy(() => QuestionCreateOrConnectWithoutProfileInputSchema).array() ]).optional(),
  upsert: z.union([ z.lazy(() => QuestionUpsertWithWhereUniqueWithoutProfileInputSchema),z.lazy(() => QuestionUpsertWithWhereUniqueWithoutProfileInputSchema).array() ]).optional(),
  createMany: z.lazy(() => QuestionCreateManyProfileInputEnvelopeSchema).optional(),
  set: z.union([ z.lazy(() => QuestionWhereUniqueInputSchema),z.lazy(() => QuestionWhereUniqueInputSchema).array() ]).optional(),
  disconnect: z.union([ z.lazy(() => QuestionWhereUniqueInputSchema),z.lazy(() => QuestionWhereUniqueInputSchema).array() ]).optional(),
  delete: z.union([ z.lazy(() => QuestionWhereUniqueInputSchema),z.lazy(() => QuestionWhereUniqueInputSchema).array() ]).optional(),
  connect: z.union([ z.lazy(() => QuestionWhereUniqueInputSchema),z.lazy(() => QuestionWhereUniqueInputSchema).array() ]).optional(),
  update: z.union([ z.lazy(() => QuestionUpdateWithWhereUniqueWithoutProfileInputSchema),z.lazy(() => QuestionUpdateWithWhereUniqueWithoutProfileInputSchema).array() ]).optional(),
  updateMany: z.union([ z.lazy(() => QuestionUpdateManyWithWhereWithoutProfileInputSchema),z.lazy(() => QuestionUpdateManyWithWhereWithoutProfileInputSchema).array() ]).optional(),
  deleteMany: z.union([ z.lazy(() => QuestionScalarWhereInputSchema),z.lazy(() => QuestionScalarWhereInputSchema).array() ]).optional(),
}).strict();

export const ResolutionSlackMessageUpdateManyWithoutProfileNestedInputSchema: z.ZodType<Prisma.ResolutionSlackMessageUpdateManyWithoutProfileNestedInput> = z.object({
  create: z.union([ z.lazy(() => ResolutionSlackMessageCreateWithoutProfileInputSchema),z.lazy(() => ResolutionSlackMessageCreateWithoutProfileInputSchema).array(),z.lazy(() => ResolutionSlackMessageUncheckedCreateWithoutProfileInputSchema),z.lazy(() => ResolutionSlackMessageUncheckedCreateWithoutProfileInputSchema).array() ]).optional(),
  connectOrCreate: z.union([ z.lazy(() => ResolutionSlackMessageCreateOrConnectWithoutProfileInputSchema),z.lazy(() => ResolutionSlackMessageCreateOrConnectWithoutProfileInputSchema).array() ]).optional(),
  upsert: z.union([ z.lazy(() => ResolutionSlackMessageUpsertWithWhereUniqueWithoutProfileInputSchema),z.lazy(() => ResolutionSlackMessageUpsertWithWhereUniqueWithoutProfileInputSchema).array() ]).optional(),
  createMany: z.lazy(() => ResolutionSlackMessageCreateManyProfileInputEnvelopeSchema).optional(),
  set: z.union([ z.lazy(() => ResolutionSlackMessageWhereUniqueInputSchema),z.lazy(() => ResolutionSlackMessageWhereUniqueInputSchema).array() ]).optional(),
  disconnect: z.union([ z.lazy(() => ResolutionSlackMessageWhereUniqueInputSchema),z.lazy(() => ResolutionSlackMessageWhereUniqueInputSchema).array() ]).optional(),
  delete: z.union([ z.lazy(() => ResolutionSlackMessageWhereUniqueInputSchema),z.lazy(() => ResolutionSlackMessageWhereUniqueInputSchema).array() ]).optional(),
  connect: z.union([ z.lazy(() => ResolutionSlackMessageWhereUniqueInputSchema),z.lazy(() => ResolutionSlackMessageWhereUniqueInputSchema).array() ]).optional(),
  update: z.union([ z.lazy(() => ResolutionSlackMessageUpdateWithWhereUniqueWithoutProfileInputSchema),z.lazy(() => ResolutionSlackMessageUpdateWithWhereUniqueWithoutProfileInputSchema).array() ]).optional(),
  updateMany: z.union([ z.lazy(() => ResolutionSlackMessageUpdateManyWithWhereWithoutProfileInputSchema),z.lazy(() => ResolutionSlackMessageUpdateManyWithWhereWithoutProfileInputSchema).array() ]).optional(),
  deleteMany: z.union([ z.lazy(() => ResolutionSlackMessageScalarWhereInputSchema),z.lazy(() => ResolutionSlackMessageScalarWhereInputSchema).array() ]).optional(),
}).strict();

export const TargetUpdateOneWithoutProfileNestedInputSchema: z.ZodType<Prisma.TargetUpdateOneWithoutProfileNestedInput> = z.object({
  create: z.union([ z.lazy(() => TargetCreateWithoutProfileInputSchema),z.lazy(() => TargetUncheckedCreateWithoutProfileInputSchema) ]).optional(),
  connectOrCreate: z.lazy(() => TargetCreateOrConnectWithoutProfileInputSchema).optional(),
  upsert: z.lazy(() => TargetUpsertWithoutProfileInputSchema).optional(),
  disconnect: z.union([ z.boolean(),z.lazy(() => TargetWhereInputSchema) ]).optional(),
  delete: z.union([ z.boolean(),z.lazy(() => TargetWhereInputSchema) ]).optional(),
  connect: z.lazy(() => TargetWhereUniqueInputSchema).optional(),
  update: z.union([ z.lazy(() => TargetUpdateToOneWithWhereWithoutProfileInputSchema),z.lazy(() => TargetUpdateWithoutProfileInputSchema),z.lazy(() => TargetUncheckedUpdateWithoutProfileInputSchema) ]).optional(),
}).strict();

export const ForecastUncheckedUpdateManyWithoutProfileNestedInputSchema: z.ZodType<Prisma.ForecastUncheckedUpdateManyWithoutProfileNestedInput> = z.object({
  create: z.union([ z.lazy(() => ForecastCreateWithoutProfileInputSchema),z.lazy(() => ForecastCreateWithoutProfileInputSchema).array(),z.lazy(() => ForecastUncheckedCreateWithoutProfileInputSchema),z.lazy(() => ForecastUncheckedCreateWithoutProfileInputSchema).array() ]).optional(),
  connectOrCreate: z.union([ z.lazy(() => ForecastCreateOrConnectWithoutProfileInputSchema),z.lazy(() => ForecastCreateOrConnectWithoutProfileInputSchema).array() ]).optional(),
  upsert: z.union([ z.lazy(() => ForecastUpsertWithWhereUniqueWithoutProfileInputSchema),z.lazy(() => ForecastUpsertWithWhereUniqueWithoutProfileInputSchema).array() ]).optional(),
  createMany: z.lazy(() => ForecastCreateManyProfileInputEnvelopeSchema).optional(),
  set: z.union([ z.lazy(() => ForecastWhereUniqueInputSchema),z.lazy(() => ForecastWhereUniqueInputSchema).array() ]).optional(),
  disconnect: z.union([ z.lazy(() => ForecastWhereUniqueInputSchema),z.lazy(() => ForecastWhereUniqueInputSchema).array() ]).optional(),
  delete: z.union([ z.lazy(() => ForecastWhereUniqueInputSchema),z.lazy(() => ForecastWhereUniqueInputSchema).array() ]).optional(),
  connect: z.union([ z.lazy(() => ForecastWhereUniqueInputSchema),z.lazy(() => ForecastWhereUniqueInputSchema).array() ]).optional(),
  update: z.union([ z.lazy(() => ForecastUpdateWithWhereUniqueWithoutProfileInputSchema),z.lazy(() => ForecastUpdateWithWhereUniqueWithoutProfileInputSchema).array() ]).optional(),
  updateMany: z.union([ z.lazy(() => ForecastUpdateManyWithWhereWithoutProfileInputSchema),z.lazy(() => ForecastUpdateManyWithWhereWithoutProfileInputSchema).array() ]).optional(),
  deleteMany: z.union([ z.lazy(() => ForecastScalarWhereInputSchema),z.lazy(() => ForecastScalarWhereInputSchema).array() ]).optional(),
}).strict();

export const QuestionUncheckedUpdateManyWithoutProfileNestedInputSchema: z.ZodType<Prisma.QuestionUncheckedUpdateManyWithoutProfileNestedInput> = z.object({
  create: z.union([ z.lazy(() => QuestionCreateWithoutProfileInputSchema),z.lazy(() => QuestionCreateWithoutProfileInputSchema).array(),z.lazy(() => QuestionUncheckedCreateWithoutProfileInputSchema),z.lazy(() => QuestionUncheckedCreateWithoutProfileInputSchema).array() ]).optional(),
  connectOrCreate: z.union([ z.lazy(() => QuestionCreateOrConnectWithoutProfileInputSchema),z.lazy(() => QuestionCreateOrConnectWithoutProfileInputSchema).array() ]).optional(),
  upsert: z.union([ z.lazy(() => QuestionUpsertWithWhereUniqueWithoutProfileInputSchema),z.lazy(() => QuestionUpsertWithWhereUniqueWithoutProfileInputSchema).array() ]).optional(),
  createMany: z.lazy(() => QuestionCreateManyProfileInputEnvelopeSchema).optional(),
  set: z.union([ z.lazy(() => QuestionWhereUniqueInputSchema),z.lazy(() => QuestionWhereUniqueInputSchema).array() ]).optional(),
  disconnect: z.union([ z.lazy(() => QuestionWhereUniqueInputSchema),z.lazy(() => QuestionWhereUniqueInputSchema).array() ]).optional(),
  delete: z.union([ z.lazy(() => QuestionWhereUniqueInputSchema),z.lazy(() => QuestionWhereUniqueInputSchema).array() ]).optional(),
  connect: z.union([ z.lazy(() => QuestionWhereUniqueInputSchema),z.lazy(() => QuestionWhereUniqueInputSchema).array() ]).optional(),
  update: z.union([ z.lazy(() => QuestionUpdateWithWhereUniqueWithoutProfileInputSchema),z.lazy(() => QuestionUpdateWithWhereUniqueWithoutProfileInputSchema).array() ]).optional(),
  updateMany: z.union([ z.lazy(() => QuestionUpdateManyWithWhereWithoutProfileInputSchema),z.lazy(() => QuestionUpdateManyWithWhereWithoutProfileInputSchema).array() ]).optional(),
  deleteMany: z.union([ z.lazy(() => QuestionScalarWhereInputSchema),z.lazy(() => QuestionScalarWhereInputSchema).array() ]).optional(),
}).strict();

export const ResolutionSlackMessageUncheckedUpdateManyWithoutProfileNestedInputSchema: z.ZodType<Prisma.ResolutionSlackMessageUncheckedUpdateManyWithoutProfileNestedInput> = z.object({
  create: z.union([ z.lazy(() => ResolutionSlackMessageCreateWithoutProfileInputSchema),z.lazy(() => ResolutionSlackMessageCreateWithoutProfileInputSchema).array(),z.lazy(() => ResolutionSlackMessageUncheckedCreateWithoutProfileInputSchema),z.lazy(() => ResolutionSlackMessageUncheckedCreateWithoutProfileInputSchema).array() ]).optional(),
  connectOrCreate: z.union([ z.lazy(() => ResolutionSlackMessageCreateOrConnectWithoutProfileInputSchema),z.lazy(() => ResolutionSlackMessageCreateOrConnectWithoutProfileInputSchema).array() ]).optional(),
  upsert: z.union([ z.lazy(() => ResolutionSlackMessageUpsertWithWhereUniqueWithoutProfileInputSchema),z.lazy(() => ResolutionSlackMessageUpsertWithWhereUniqueWithoutProfileInputSchema).array() ]).optional(),
  createMany: z.lazy(() => ResolutionSlackMessageCreateManyProfileInputEnvelopeSchema).optional(),
  set: z.union([ z.lazy(() => ResolutionSlackMessageWhereUniqueInputSchema),z.lazy(() => ResolutionSlackMessageWhereUniqueInputSchema).array() ]).optional(),
  disconnect: z.union([ z.lazy(() => ResolutionSlackMessageWhereUniqueInputSchema),z.lazy(() => ResolutionSlackMessageWhereUniqueInputSchema).array() ]).optional(),
  delete: z.union([ z.lazy(() => ResolutionSlackMessageWhereUniqueInputSchema),z.lazy(() => ResolutionSlackMessageWhereUniqueInputSchema).array() ]).optional(),
  connect: z.union([ z.lazy(() => ResolutionSlackMessageWhereUniqueInputSchema),z.lazy(() => ResolutionSlackMessageWhereUniqueInputSchema).array() ]).optional(),
  update: z.union([ z.lazy(() => ResolutionSlackMessageUpdateWithWhereUniqueWithoutProfileInputSchema),z.lazy(() => ResolutionSlackMessageUpdateWithWhereUniqueWithoutProfileInputSchema).array() ]).optional(),
  updateMany: z.union([ z.lazy(() => ResolutionSlackMessageUpdateManyWithWhereWithoutProfileInputSchema),z.lazy(() => ResolutionSlackMessageUpdateManyWithWhereWithoutProfileInputSchema).array() ]).optional(),
  deleteMany: z.union([ z.lazy(() => ResolutionSlackMessageScalarWhereInputSchema),z.lazy(() => ResolutionSlackMessageScalarWhereInputSchema).array() ]).optional(),
}).strict();

export const TargetUncheckedUpdateOneWithoutProfileNestedInputSchema: z.ZodType<Prisma.TargetUncheckedUpdateOneWithoutProfileNestedInput> = z.object({
  create: z.union([ z.lazy(() => TargetCreateWithoutProfileInputSchema),z.lazy(() => TargetUncheckedCreateWithoutProfileInputSchema) ]).optional(),
  connectOrCreate: z.lazy(() => TargetCreateOrConnectWithoutProfileInputSchema).optional(),
  upsert: z.lazy(() => TargetUpsertWithoutProfileInputSchema).optional(),
  disconnect: z.union([ z.boolean(),z.lazy(() => TargetWhereInputSchema) ]).optional(),
  delete: z.union([ z.boolean(),z.lazy(() => TargetWhereInputSchema) ]).optional(),
  connect: z.lazy(() => TargetWhereUniqueInputSchema).optional(),
  update: z.union([ z.lazy(() => TargetUpdateToOneWithWhereWithoutProfileInputSchema),z.lazy(() => TargetUpdateWithoutProfileInputSchema),z.lazy(() => TargetUncheckedUpdateWithoutProfileInputSchema) ]).optional(),
}).strict();

export const EnumGroupTypeFieldUpdateOperationsInputSchema: z.ZodType<Prisma.EnumGroupTypeFieldUpdateOperationsInput> = z.object({
  set: z.lazy(() => GroupTypeSchema).optional()
}).strict();

export const UserCreateNestedOneWithoutTargetInputSchema: z.ZodType<Prisma.UserCreateNestedOneWithoutTargetInput> = z.object({
  create: z.union([ z.lazy(() => UserCreateWithoutTargetInputSchema),z.lazy(() => UserUncheckedCreateWithoutTargetInputSchema) ]).optional(),
  connectOrCreate: z.lazy(() => UserCreateOrConnectWithoutTargetInputSchema).optional(),
  connect: z.lazy(() => UserWhereUniqueInputSchema).optional()
}).strict();

export const ProfileCreateNestedOneWithoutTargetInputSchema: z.ZodType<Prisma.ProfileCreateNestedOneWithoutTargetInput> = z.object({
  create: z.union([ z.lazy(() => ProfileCreateWithoutTargetInputSchema),z.lazy(() => ProfileUncheckedCreateWithoutTargetInputSchema) ]).optional(),
  connectOrCreate: z.lazy(() => ProfileCreateOrConnectWithoutTargetInputSchema).optional(),
  connect: z.lazy(() => ProfileWhereUniqueInputSchema).optional()
}).strict();

export const EnumTargetTypeFieldUpdateOperationsInputSchema: z.ZodType<Prisma.EnumTargetTypeFieldUpdateOperationsInput> = z.object({
  set: z.lazy(() => TargetTypeSchema).optional()
}).strict();

export const EnumDayOfTheWeekFieldUpdateOperationsInputSchema: z.ZodType<Prisma.EnumDayOfTheWeekFieldUpdateOperationsInput> = z.object({
  set: z.lazy(() => DayOfTheWeekSchema).optional()
}).strict();

export const UserUpdateOneRequiredWithoutTargetNestedInputSchema: z.ZodType<Prisma.UserUpdateOneRequiredWithoutTargetNestedInput> = z.object({
  create: z.union([ z.lazy(() => UserCreateWithoutTargetInputSchema),z.lazy(() => UserUncheckedCreateWithoutTargetInputSchema) ]).optional(),
  connectOrCreate: z.lazy(() => UserCreateOrConnectWithoutTargetInputSchema).optional(),
  upsert: z.lazy(() => UserUpsertWithoutTargetInputSchema).optional(),
  connect: z.lazy(() => UserWhereUniqueInputSchema).optional(),
  update: z.union([ z.lazy(() => UserUpdateToOneWithWhereWithoutTargetInputSchema),z.lazy(() => UserUpdateWithoutTargetInputSchema),z.lazy(() => UserUncheckedUpdateWithoutTargetInputSchema) ]).optional(),
}).strict();

export const ProfileUpdateOneWithoutTargetNestedInputSchema: z.ZodType<Prisma.ProfileUpdateOneWithoutTargetNestedInput> = z.object({
  create: z.union([ z.lazy(() => ProfileCreateWithoutTargetInputSchema),z.lazy(() => ProfileUncheckedCreateWithoutTargetInputSchema) ]).optional(),
  connectOrCreate: z.lazy(() => ProfileCreateOrConnectWithoutTargetInputSchema).optional(),
  upsert: z.lazy(() => ProfileUpsertWithoutTargetInputSchema).optional(),
  disconnect: z.union([ z.boolean(),z.lazy(() => ProfileWhereInputSchema) ]).optional(),
  delete: z.union([ z.boolean(),z.lazy(() => ProfileWhereInputSchema) ]).optional(),
  connect: z.lazy(() => ProfileWhereUniqueInputSchema).optional(),
  update: z.union([ z.lazy(() => ProfileUpdateToOneWithWhereWithoutTargetInputSchema),z.lazy(() => ProfileUpdateWithoutTargetInputSchema),z.lazy(() => ProfileUncheckedUpdateWithoutTargetInputSchema) ]).optional(),
}).strict();

export const UserCreateNestedOneWithoutAccountsInputSchema: z.ZodType<Prisma.UserCreateNestedOneWithoutAccountsInput> = z.object({
  create: z.union([ z.lazy(() => UserCreateWithoutAccountsInputSchema),z.lazy(() => UserUncheckedCreateWithoutAccountsInputSchema) ]).optional(),
  connectOrCreate: z.lazy(() => UserCreateOrConnectWithoutAccountsInputSchema).optional(),
  connect: z.lazy(() => UserWhereUniqueInputSchema).optional()
}).strict();

export const UserUpdateOneRequiredWithoutAccountsNestedInputSchema: z.ZodType<Prisma.UserUpdateOneRequiredWithoutAccountsNestedInput> = z.object({
  create: z.union([ z.lazy(() => UserCreateWithoutAccountsInputSchema),z.lazy(() => UserUncheckedCreateWithoutAccountsInputSchema) ]).optional(),
  connectOrCreate: z.lazy(() => UserCreateOrConnectWithoutAccountsInputSchema).optional(),
  upsert: z.lazy(() => UserUpsertWithoutAccountsInputSchema).optional(),
  connect: z.lazy(() => UserWhereUniqueInputSchema).optional(),
  update: z.union([ z.lazy(() => UserUpdateToOneWithWhereWithoutAccountsInputSchema),z.lazy(() => UserUpdateWithoutAccountsInputSchema),z.lazy(() => UserUncheckedUpdateWithoutAccountsInputSchema) ]).optional(),
}).strict();

export const QuestionCreateNestedOneWithoutCommentsInputSchema: z.ZodType<Prisma.QuestionCreateNestedOneWithoutCommentsInput> = z.object({
  create: z.union([ z.lazy(() => QuestionCreateWithoutCommentsInputSchema),z.lazy(() => QuestionUncheckedCreateWithoutCommentsInputSchema) ]).optional(),
  connectOrCreate: z.lazy(() => QuestionCreateOrConnectWithoutCommentsInputSchema).optional(),
  connect: z.lazy(() => QuestionWhereUniqueInputSchema).optional()
}).strict();

export const UserCreateNestedOneWithoutCommentsInputSchema: z.ZodType<Prisma.UserCreateNestedOneWithoutCommentsInput> = z.object({
  create: z.union([ z.lazy(() => UserCreateWithoutCommentsInputSchema),z.lazy(() => UserUncheckedCreateWithoutCommentsInputSchema) ]).optional(),
  connectOrCreate: z.lazy(() => UserCreateOrConnectWithoutCommentsInputSchema).optional(),
  connect: z.lazy(() => UserWhereUniqueInputSchema).optional()
}).strict();

export const QuestionUpdateOneRequiredWithoutCommentsNestedInputSchema: z.ZodType<Prisma.QuestionUpdateOneRequiredWithoutCommentsNestedInput> = z.object({
  create: z.union([ z.lazy(() => QuestionCreateWithoutCommentsInputSchema),z.lazy(() => QuestionUncheckedCreateWithoutCommentsInputSchema) ]).optional(),
  connectOrCreate: z.lazy(() => QuestionCreateOrConnectWithoutCommentsInputSchema).optional(),
  upsert: z.lazy(() => QuestionUpsertWithoutCommentsInputSchema).optional(),
  connect: z.lazy(() => QuestionWhereUniqueInputSchema).optional(),
  update: z.union([ z.lazy(() => QuestionUpdateToOneWithWhereWithoutCommentsInputSchema),z.lazy(() => QuestionUpdateWithoutCommentsInputSchema),z.lazy(() => QuestionUncheckedUpdateWithoutCommentsInputSchema) ]).optional(),
}).strict();

export const UserUpdateOneRequiredWithoutCommentsNestedInputSchema: z.ZodType<Prisma.UserUpdateOneRequiredWithoutCommentsNestedInput> = z.object({
  create: z.union([ z.lazy(() => UserCreateWithoutCommentsInputSchema),z.lazy(() => UserUncheckedCreateWithoutCommentsInputSchema) ]).optional(),
  connectOrCreate: z.lazy(() => UserCreateOrConnectWithoutCommentsInputSchema).optional(),
  upsert: z.lazy(() => UserUpsertWithoutCommentsInputSchema).optional(),
  connect: z.lazy(() => UserWhereUniqueInputSchema).optional(),
  update: z.union([ z.lazy(() => UserUpdateToOneWithWhereWithoutCommentsInputSchema),z.lazy(() => UserUpdateWithoutCommentsInputSchema),z.lazy(() => UserUncheckedUpdateWithoutCommentsInputSchema) ]).optional(),
}).strict();

export const UserListCreateemailDomainsInputSchema: z.ZodType<Prisma.UserListCreateemailDomainsInput> = z.object({
  set: z.string().array()
}).strict();

export const UserCreateNestedOneWithoutAuthorOfListsInputSchema: z.ZodType<Prisma.UserCreateNestedOneWithoutAuthorOfListsInput> = z.object({
  create: z.union([ z.lazy(() => UserCreateWithoutAuthorOfListsInputSchema),z.lazy(() => UserUncheckedCreateWithoutAuthorOfListsInputSchema) ]).optional(),
  connectOrCreate: z.lazy(() => UserCreateOrConnectWithoutAuthorOfListsInputSchema).optional(),
  connect: z.lazy(() => UserWhereUniqueInputSchema).optional()
}).strict();

export const UserCreateNestedManyWithoutMemberOfListsInputSchema: z.ZodType<Prisma.UserCreateNestedManyWithoutMemberOfListsInput> = z.object({
  create: z.union([ z.lazy(() => UserCreateWithoutMemberOfListsInputSchema),z.lazy(() => UserCreateWithoutMemberOfListsInputSchema).array(),z.lazy(() => UserUncheckedCreateWithoutMemberOfListsInputSchema),z.lazy(() => UserUncheckedCreateWithoutMemberOfListsInputSchema).array() ]).optional(),
  connectOrCreate: z.union([ z.lazy(() => UserCreateOrConnectWithoutMemberOfListsInputSchema),z.lazy(() => UserCreateOrConnectWithoutMemberOfListsInputSchema).array() ]).optional(),
  connect: z.union([ z.lazy(() => UserWhereUniqueInputSchema),z.lazy(() => UserWhereUniqueInputSchema).array() ]).optional(),
}).strict();

export const QuestionCreateNestedManyWithoutSharedWithListsInputSchema: z.ZodType<Prisma.QuestionCreateNestedManyWithoutSharedWithListsInput> = z.object({
  create: z.union([ z.lazy(() => QuestionCreateWithoutSharedWithListsInputSchema),z.lazy(() => QuestionCreateWithoutSharedWithListsInputSchema).array(),z.lazy(() => QuestionUncheckedCreateWithoutSharedWithListsInputSchema),z.lazy(() => QuestionUncheckedCreateWithoutSharedWithListsInputSchema).array() ]).optional(),
  connectOrCreate: z.union([ z.lazy(() => QuestionCreateOrConnectWithoutSharedWithListsInputSchema),z.lazy(() => QuestionCreateOrConnectWithoutSharedWithListsInputSchema).array() ]).optional(),
  connect: z.union([ z.lazy(() => QuestionWhereUniqueInputSchema),z.lazy(() => QuestionWhereUniqueInputSchema).array() ]).optional(),
}).strict();

export const TournamentCreateNestedManyWithoutUserListInputSchema: z.ZodType<Prisma.TournamentCreateNestedManyWithoutUserListInput> = z.object({
  create: z.union([ z.lazy(() => TournamentCreateWithoutUserListInputSchema),z.lazy(() => TournamentCreateWithoutUserListInputSchema).array(),z.lazy(() => TournamentUncheckedCreateWithoutUserListInputSchema),z.lazy(() => TournamentUncheckedCreateWithoutUserListInputSchema).array() ]).optional(),
  connectOrCreate: z.union([ z.lazy(() => TournamentCreateOrConnectWithoutUserListInputSchema),z.lazy(() => TournamentCreateOrConnectWithoutUserListInputSchema).array() ]).optional(),
  createMany: z.lazy(() => TournamentCreateManyUserListInputEnvelopeSchema).optional(),
  connect: z.union([ z.lazy(() => TournamentWhereUniqueInputSchema),z.lazy(() => TournamentWhereUniqueInputSchema).array() ]).optional(),
}).strict();

export const UserUncheckedCreateNestedManyWithoutMemberOfListsInputSchema: z.ZodType<Prisma.UserUncheckedCreateNestedManyWithoutMemberOfListsInput> = z.object({
  create: z.union([ z.lazy(() => UserCreateWithoutMemberOfListsInputSchema),z.lazy(() => UserCreateWithoutMemberOfListsInputSchema).array(),z.lazy(() => UserUncheckedCreateWithoutMemberOfListsInputSchema),z.lazy(() => UserUncheckedCreateWithoutMemberOfListsInputSchema).array() ]).optional(),
  connectOrCreate: z.union([ z.lazy(() => UserCreateOrConnectWithoutMemberOfListsInputSchema),z.lazy(() => UserCreateOrConnectWithoutMemberOfListsInputSchema).array() ]).optional(),
  connect: z.union([ z.lazy(() => UserWhereUniqueInputSchema),z.lazy(() => UserWhereUniqueInputSchema).array() ]).optional(),
}).strict();

export const QuestionUncheckedCreateNestedManyWithoutSharedWithListsInputSchema: z.ZodType<Prisma.QuestionUncheckedCreateNestedManyWithoutSharedWithListsInput> = z.object({
  create: z.union([ z.lazy(() => QuestionCreateWithoutSharedWithListsInputSchema),z.lazy(() => QuestionCreateWithoutSharedWithListsInputSchema).array(),z.lazy(() => QuestionUncheckedCreateWithoutSharedWithListsInputSchema),z.lazy(() => QuestionUncheckedCreateWithoutSharedWithListsInputSchema).array() ]).optional(),
  connectOrCreate: z.union([ z.lazy(() => QuestionCreateOrConnectWithoutSharedWithListsInputSchema),z.lazy(() => QuestionCreateOrConnectWithoutSharedWithListsInputSchema).array() ]).optional(),
  connect: z.union([ z.lazy(() => QuestionWhereUniqueInputSchema),z.lazy(() => QuestionWhereUniqueInputSchema).array() ]).optional(),
}).strict();

export const TournamentUncheckedCreateNestedManyWithoutUserListInputSchema: z.ZodType<Prisma.TournamentUncheckedCreateNestedManyWithoutUserListInput> = z.object({
  create: z.union([ z.lazy(() => TournamentCreateWithoutUserListInputSchema),z.lazy(() => TournamentCreateWithoutUserListInputSchema).array(),z.lazy(() => TournamentUncheckedCreateWithoutUserListInputSchema),z.lazy(() => TournamentUncheckedCreateWithoutUserListInputSchema).array() ]).optional(),
  connectOrCreate: z.union([ z.lazy(() => TournamentCreateOrConnectWithoutUserListInputSchema),z.lazy(() => TournamentCreateOrConnectWithoutUserListInputSchema).array() ]).optional(),
  createMany: z.lazy(() => TournamentCreateManyUserListInputEnvelopeSchema).optional(),
  connect: z.union([ z.lazy(() => TournamentWhereUniqueInputSchema),z.lazy(() => TournamentWhereUniqueInputSchema).array() ]).optional(),
}).strict();

export const UserListUpdateemailDomainsInputSchema: z.ZodType<Prisma.UserListUpdateemailDomainsInput> = z.object({
  set: z.string().array().optional(),
  push: z.union([ z.string(),z.string().array() ]).optional(),
}).strict();

export const UserUpdateOneRequiredWithoutAuthorOfListsNestedInputSchema: z.ZodType<Prisma.UserUpdateOneRequiredWithoutAuthorOfListsNestedInput> = z.object({
  create: z.union([ z.lazy(() => UserCreateWithoutAuthorOfListsInputSchema),z.lazy(() => UserUncheckedCreateWithoutAuthorOfListsInputSchema) ]).optional(),
  connectOrCreate: z.lazy(() => UserCreateOrConnectWithoutAuthorOfListsInputSchema).optional(),
  upsert: z.lazy(() => UserUpsertWithoutAuthorOfListsInputSchema).optional(),
  connect: z.lazy(() => UserWhereUniqueInputSchema).optional(),
  update: z.union([ z.lazy(() => UserUpdateToOneWithWhereWithoutAuthorOfListsInputSchema),z.lazy(() => UserUpdateWithoutAuthorOfListsInputSchema),z.lazy(() => UserUncheckedUpdateWithoutAuthorOfListsInputSchema) ]).optional(),
}).strict();

export const UserUpdateManyWithoutMemberOfListsNestedInputSchema: z.ZodType<Prisma.UserUpdateManyWithoutMemberOfListsNestedInput> = z.object({
  create: z.union([ z.lazy(() => UserCreateWithoutMemberOfListsInputSchema),z.lazy(() => UserCreateWithoutMemberOfListsInputSchema).array(),z.lazy(() => UserUncheckedCreateWithoutMemberOfListsInputSchema),z.lazy(() => UserUncheckedCreateWithoutMemberOfListsInputSchema).array() ]).optional(),
  connectOrCreate: z.union([ z.lazy(() => UserCreateOrConnectWithoutMemberOfListsInputSchema),z.lazy(() => UserCreateOrConnectWithoutMemberOfListsInputSchema).array() ]).optional(),
  upsert: z.union([ z.lazy(() => UserUpsertWithWhereUniqueWithoutMemberOfListsInputSchema),z.lazy(() => UserUpsertWithWhereUniqueWithoutMemberOfListsInputSchema).array() ]).optional(),
  set: z.union([ z.lazy(() => UserWhereUniqueInputSchema),z.lazy(() => UserWhereUniqueInputSchema).array() ]).optional(),
  disconnect: z.union([ z.lazy(() => UserWhereUniqueInputSchema),z.lazy(() => UserWhereUniqueInputSchema).array() ]).optional(),
  delete: z.union([ z.lazy(() => UserWhereUniqueInputSchema),z.lazy(() => UserWhereUniqueInputSchema).array() ]).optional(),
  connect: z.union([ z.lazy(() => UserWhereUniqueInputSchema),z.lazy(() => UserWhereUniqueInputSchema).array() ]).optional(),
  update: z.union([ z.lazy(() => UserUpdateWithWhereUniqueWithoutMemberOfListsInputSchema),z.lazy(() => UserUpdateWithWhereUniqueWithoutMemberOfListsInputSchema).array() ]).optional(),
  updateMany: z.union([ z.lazy(() => UserUpdateManyWithWhereWithoutMemberOfListsInputSchema),z.lazy(() => UserUpdateManyWithWhereWithoutMemberOfListsInputSchema).array() ]).optional(),
  deleteMany: z.union([ z.lazy(() => UserScalarWhereInputSchema),z.lazy(() => UserScalarWhereInputSchema).array() ]).optional(),
}).strict();

export const QuestionUpdateManyWithoutSharedWithListsNestedInputSchema: z.ZodType<Prisma.QuestionUpdateManyWithoutSharedWithListsNestedInput> = z.object({
  create: z.union([ z.lazy(() => QuestionCreateWithoutSharedWithListsInputSchema),z.lazy(() => QuestionCreateWithoutSharedWithListsInputSchema).array(),z.lazy(() => QuestionUncheckedCreateWithoutSharedWithListsInputSchema),z.lazy(() => QuestionUncheckedCreateWithoutSharedWithListsInputSchema).array() ]).optional(),
  connectOrCreate: z.union([ z.lazy(() => QuestionCreateOrConnectWithoutSharedWithListsInputSchema),z.lazy(() => QuestionCreateOrConnectWithoutSharedWithListsInputSchema).array() ]).optional(),
  upsert: z.union([ z.lazy(() => QuestionUpsertWithWhereUniqueWithoutSharedWithListsInputSchema),z.lazy(() => QuestionUpsertWithWhereUniqueWithoutSharedWithListsInputSchema).array() ]).optional(),
  set: z.union([ z.lazy(() => QuestionWhereUniqueInputSchema),z.lazy(() => QuestionWhereUniqueInputSchema).array() ]).optional(),
  disconnect: z.union([ z.lazy(() => QuestionWhereUniqueInputSchema),z.lazy(() => QuestionWhereUniqueInputSchema).array() ]).optional(),
  delete: z.union([ z.lazy(() => QuestionWhereUniqueInputSchema),z.lazy(() => QuestionWhereUniqueInputSchema).array() ]).optional(),
  connect: z.union([ z.lazy(() => QuestionWhereUniqueInputSchema),z.lazy(() => QuestionWhereUniqueInputSchema).array() ]).optional(),
  update: z.union([ z.lazy(() => QuestionUpdateWithWhereUniqueWithoutSharedWithListsInputSchema),z.lazy(() => QuestionUpdateWithWhereUniqueWithoutSharedWithListsInputSchema).array() ]).optional(),
  updateMany: z.union([ z.lazy(() => QuestionUpdateManyWithWhereWithoutSharedWithListsInputSchema),z.lazy(() => QuestionUpdateManyWithWhereWithoutSharedWithListsInputSchema).array() ]).optional(),
  deleteMany: z.union([ z.lazy(() => QuestionScalarWhereInputSchema),z.lazy(() => QuestionScalarWhereInputSchema).array() ]).optional(),
}).strict();

export const TournamentUpdateManyWithoutUserListNestedInputSchema: z.ZodType<Prisma.TournamentUpdateManyWithoutUserListNestedInput> = z.object({
  create: z.union([ z.lazy(() => TournamentCreateWithoutUserListInputSchema),z.lazy(() => TournamentCreateWithoutUserListInputSchema).array(),z.lazy(() => TournamentUncheckedCreateWithoutUserListInputSchema),z.lazy(() => TournamentUncheckedCreateWithoutUserListInputSchema).array() ]).optional(),
  connectOrCreate: z.union([ z.lazy(() => TournamentCreateOrConnectWithoutUserListInputSchema),z.lazy(() => TournamentCreateOrConnectWithoutUserListInputSchema).array() ]).optional(),
  upsert: z.union([ z.lazy(() => TournamentUpsertWithWhereUniqueWithoutUserListInputSchema),z.lazy(() => TournamentUpsertWithWhereUniqueWithoutUserListInputSchema).array() ]).optional(),
  createMany: z.lazy(() => TournamentCreateManyUserListInputEnvelopeSchema).optional(),
  set: z.union([ z.lazy(() => TournamentWhereUniqueInputSchema),z.lazy(() => TournamentWhereUniqueInputSchema).array() ]).optional(),
  disconnect: z.union([ z.lazy(() => TournamentWhereUniqueInputSchema),z.lazy(() => TournamentWhereUniqueInputSchema).array() ]).optional(),
  delete: z.union([ z.lazy(() => TournamentWhereUniqueInputSchema),z.lazy(() => TournamentWhereUniqueInputSchema).array() ]).optional(),
  connect: z.union([ z.lazy(() => TournamentWhereUniqueInputSchema),z.lazy(() => TournamentWhereUniqueInputSchema).array() ]).optional(),
  update: z.union([ z.lazy(() => TournamentUpdateWithWhereUniqueWithoutUserListInputSchema),z.lazy(() => TournamentUpdateWithWhereUniqueWithoutUserListInputSchema).array() ]).optional(),
  updateMany: z.union([ z.lazy(() => TournamentUpdateManyWithWhereWithoutUserListInputSchema),z.lazy(() => TournamentUpdateManyWithWhereWithoutUserListInputSchema).array() ]).optional(),
  deleteMany: z.union([ z.lazy(() => TournamentScalarWhereInputSchema),z.lazy(() => TournamentScalarWhereInputSchema).array() ]).optional(),
}).strict();

export const UserUncheckedUpdateManyWithoutMemberOfListsNestedInputSchema: z.ZodType<Prisma.UserUncheckedUpdateManyWithoutMemberOfListsNestedInput> = z.object({
  create: z.union([ z.lazy(() => UserCreateWithoutMemberOfListsInputSchema),z.lazy(() => UserCreateWithoutMemberOfListsInputSchema).array(),z.lazy(() => UserUncheckedCreateWithoutMemberOfListsInputSchema),z.lazy(() => UserUncheckedCreateWithoutMemberOfListsInputSchema).array() ]).optional(),
  connectOrCreate: z.union([ z.lazy(() => UserCreateOrConnectWithoutMemberOfListsInputSchema),z.lazy(() => UserCreateOrConnectWithoutMemberOfListsInputSchema).array() ]).optional(),
  upsert: z.union([ z.lazy(() => UserUpsertWithWhereUniqueWithoutMemberOfListsInputSchema),z.lazy(() => UserUpsertWithWhereUniqueWithoutMemberOfListsInputSchema).array() ]).optional(),
  set: z.union([ z.lazy(() => UserWhereUniqueInputSchema),z.lazy(() => UserWhereUniqueInputSchema).array() ]).optional(),
  disconnect: z.union([ z.lazy(() => UserWhereUniqueInputSchema),z.lazy(() => UserWhereUniqueInputSchema).array() ]).optional(),
  delete: z.union([ z.lazy(() => UserWhereUniqueInputSchema),z.lazy(() => UserWhereUniqueInputSchema).array() ]).optional(),
  connect: z.union([ z.lazy(() => UserWhereUniqueInputSchema),z.lazy(() => UserWhereUniqueInputSchema).array() ]).optional(),
  update: z.union([ z.lazy(() => UserUpdateWithWhereUniqueWithoutMemberOfListsInputSchema),z.lazy(() => UserUpdateWithWhereUniqueWithoutMemberOfListsInputSchema).array() ]).optional(),
  updateMany: z.union([ z.lazy(() => UserUpdateManyWithWhereWithoutMemberOfListsInputSchema),z.lazy(() => UserUpdateManyWithWhereWithoutMemberOfListsInputSchema).array() ]).optional(),
  deleteMany: z.union([ z.lazy(() => UserScalarWhereInputSchema),z.lazy(() => UserScalarWhereInputSchema).array() ]).optional(),
}).strict();

export const QuestionUncheckedUpdateManyWithoutSharedWithListsNestedInputSchema: z.ZodType<Prisma.QuestionUncheckedUpdateManyWithoutSharedWithListsNestedInput> = z.object({
  create: z.union([ z.lazy(() => QuestionCreateWithoutSharedWithListsInputSchema),z.lazy(() => QuestionCreateWithoutSharedWithListsInputSchema).array(),z.lazy(() => QuestionUncheckedCreateWithoutSharedWithListsInputSchema),z.lazy(() => QuestionUncheckedCreateWithoutSharedWithListsInputSchema).array() ]).optional(),
  connectOrCreate: z.union([ z.lazy(() => QuestionCreateOrConnectWithoutSharedWithListsInputSchema),z.lazy(() => QuestionCreateOrConnectWithoutSharedWithListsInputSchema).array() ]).optional(),
  upsert: z.union([ z.lazy(() => QuestionUpsertWithWhereUniqueWithoutSharedWithListsInputSchema),z.lazy(() => QuestionUpsertWithWhereUniqueWithoutSharedWithListsInputSchema).array() ]).optional(),
  set: z.union([ z.lazy(() => QuestionWhereUniqueInputSchema),z.lazy(() => QuestionWhereUniqueInputSchema).array() ]).optional(),
  disconnect: z.union([ z.lazy(() => QuestionWhereUniqueInputSchema),z.lazy(() => QuestionWhereUniqueInputSchema).array() ]).optional(),
  delete: z.union([ z.lazy(() => QuestionWhereUniqueInputSchema),z.lazy(() => QuestionWhereUniqueInputSchema).array() ]).optional(),
  connect: z.union([ z.lazy(() => QuestionWhereUniqueInputSchema),z.lazy(() => QuestionWhereUniqueInputSchema).array() ]).optional(),
  update: z.union([ z.lazy(() => QuestionUpdateWithWhereUniqueWithoutSharedWithListsInputSchema),z.lazy(() => QuestionUpdateWithWhereUniqueWithoutSharedWithListsInputSchema).array() ]).optional(),
  updateMany: z.union([ z.lazy(() => QuestionUpdateManyWithWhereWithoutSharedWithListsInputSchema),z.lazy(() => QuestionUpdateManyWithWhereWithoutSharedWithListsInputSchema).array() ]).optional(),
  deleteMany: z.union([ z.lazy(() => QuestionScalarWhereInputSchema),z.lazy(() => QuestionScalarWhereInputSchema).array() ]).optional(),
}).strict();

export const TournamentUncheckedUpdateManyWithoutUserListNestedInputSchema: z.ZodType<Prisma.TournamentUncheckedUpdateManyWithoutUserListNestedInput> = z.object({
  create: z.union([ z.lazy(() => TournamentCreateWithoutUserListInputSchema),z.lazy(() => TournamentCreateWithoutUserListInputSchema).array(),z.lazy(() => TournamentUncheckedCreateWithoutUserListInputSchema),z.lazy(() => TournamentUncheckedCreateWithoutUserListInputSchema).array() ]).optional(),
  connectOrCreate: z.union([ z.lazy(() => TournamentCreateOrConnectWithoutUserListInputSchema),z.lazy(() => TournamentCreateOrConnectWithoutUserListInputSchema).array() ]).optional(),
  upsert: z.union([ z.lazy(() => TournamentUpsertWithWhereUniqueWithoutUserListInputSchema),z.lazy(() => TournamentUpsertWithWhereUniqueWithoutUserListInputSchema).array() ]).optional(),
  createMany: z.lazy(() => TournamentCreateManyUserListInputEnvelopeSchema).optional(),
  set: z.union([ z.lazy(() => TournamentWhereUniqueInputSchema),z.lazy(() => TournamentWhereUniqueInputSchema).array() ]).optional(),
  disconnect: z.union([ z.lazy(() => TournamentWhereUniqueInputSchema),z.lazy(() => TournamentWhereUniqueInputSchema).array() ]).optional(),
  delete: z.union([ z.lazy(() => TournamentWhereUniqueInputSchema),z.lazy(() => TournamentWhereUniqueInputSchema).array() ]).optional(),
  connect: z.union([ z.lazy(() => TournamentWhereUniqueInputSchema),z.lazy(() => TournamentWhereUniqueInputSchema).array() ]).optional(),
  update: z.union([ z.lazy(() => TournamentUpdateWithWhereUniqueWithoutUserListInputSchema),z.lazy(() => TournamentUpdateWithWhereUniqueWithoutUserListInputSchema).array() ]).optional(),
  updateMany: z.union([ z.lazy(() => TournamentUpdateManyWithWhereWithoutUserListInputSchema),z.lazy(() => TournamentUpdateManyWithWhereWithoutUserListInputSchema).array() ]).optional(),
  deleteMany: z.union([ z.lazy(() => TournamentScalarWhereInputSchema),z.lazy(() => TournamentScalarWhereInputSchema).array() ]).optional(),
}).strict();

export const QuestionCreateNestedManyWithoutTournamentsInputSchema: z.ZodType<Prisma.QuestionCreateNestedManyWithoutTournamentsInput> = z.object({
  create: z.union([ z.lazy(() => QuestionCreateWithoutTournamentsInputSchema),z.lazy(() => QuestionCreateWithoutTournamentsInputSchema).array(),z.lazy(() => QuestionUncheckedCreateWithoutTournamentsInputSchema),z.lazy(() => QuestionUncheckedCreateWithoutTournamentsInputSchema).array() ]).optional(),
  connectOrCreate: z.union([ z.lazy(() => QuestionCreateOrConnectWithoutTournamentsInputSchema),z.lazy(() => QuestionCreateOrConnectWithoutTournamentsInputSchema).array() ]).optional(),
  connect: z.union([ z.lazy(() => QuestionWhereUniqueInputSchema),z.lazy(() => QuestionWhereUniqueInputSchema).array() ]).optional(),
}).strict();

export const UserCreateNestedOneWithoutTournamentsInputSchema: z.ZodType<Prisma.UserCreateNestedOneWithoutTournamentsInput> = z.object({
  create: z.union([ z.lazy(() => UserCreateWithoutTournamentsInputSchema),z.lazy(() => UserUncheckedCreateWithoutTournamentsInputSchema) ]).optional(),
  connectOrCreate: z.lazy(() => UserCreateOrConnectWithoutTournamentsInputSchema).optional(),
  connect: z.lazy(() => UserWhereUniqueInputSchema).optional()
}).strict();

export const UserListCreateNestedOneWithoutTournamentsInputSchema: z.ZodType<Prisma.UserListCreateNestedOneWithoutTournamentsInput> = z.object({
  create: z.union([ z.lazy(() => UserListCreateWithoutTournamentsInputSchema),z.lazy(() => UserListUncheckedCreateWithoutTournamentsInputSchema) ]).optional(),
  connectOrCreate: z.lazy(() => UserListCreateOrConnectWithoutTournamentsInputSchema).optional(),
  connect: z.lazy(() => UserListWhereUniqueInputSchema).optional()
}).strict();

export const QuestionUncheckedCreateNestedManyWithoutTournamentsInputSchema: z.ZodType<Prisma.QuestionUncheckedCreateNestedManyWithoutTournamentsInput> = z.object({
  create: z.union([ z.lazy(() => QuestionCreateWithoutTournamentsInputSchema),z.lazy(() => QuestionCreateWithoutTournamentsInputSchema).array(),z.lazy(() => QuestionUncheckedCreateWithoutTournamentsInputSchema),z.lazy(() => QuestionUncheckedCreateWithoutTournamentsInputSchema).array() ]).optional(),
  connectOrCreate: z.union([ z.lazy(() => QuestionCreateOrConnectWithoutTournamentsInputSchema),z.lazy(() => QuestionCreateOrConnectWithoutTournamentsInputSchema).array() ]).optional(),
  connect: z.union([ z.lazy(() => QuestionWhereUniqueInputSchema),z.lazy(() => QuestionWhereUniqueInputSchema).array() ]).optional(),
}).strict();

export const QuestionUpdateManyWithoutTournamentsNestedInputSchema: z.ZodType<Prisma.QuestionUpdateManyWithoutTournamentsNestedInput> = z.object({
  create: z.union([ z.lazy(() => QuestionCreateWithoutTournamentsInputSchema),z.lazy(() => QuestionCreateWithoutTournamentsInputSchema).array(),z.lazy(() => QuestionUncheckedCreateWithoutTournamentsInputSchema),z.lazy(() => QuestionUncheckedCreateWithoutTournamentsInputSchema).array() ]).optional(),
  connectOrCreate: z.union([ z.lazy(() => QuestionCreateOrConnectWithoutTournamentsInputSchema),z.lazy(() => QuestionCreateOrConnectWithoutTournamentsInputSchema).array() ]).optional(),
  upsert: z.union([ z.lazy(() => QuestionUpsertWithWhereUniqueWithoutTournamentsInputSchema),z.lazy(() => QuestionUpsertWithWhereUniqueWithoutTournamentsInputSchema).array() ]).optional(),
  set: z.union([ z.lazy(() => QuestionWhereUniqueInputSchema),z.lazy(() => QuestionWhereUniqueInputSchema).array() ]).optional(),
  disconnect: z.union([ z.lazy(() => QuestionWhereUniqueInputSchema),z.lazy(() => QuestionWhereUniqueInputSchema).array() ]).optional(),
  delete: z.union([ z.lazy(() => QuestionWhereUniqueInputSchema),z.lazy(() => QuestionWhereUniqueInputSchema).array() ]).optional(),
  connect: z.union([ z.lazy(() => QuestionWhereUniqueInputSchema),z.lazy(() => QuestionWhereUniqueInputSchema).array() ]).optional(),
  update: z.union([ z.lazy(() => QuestionUpdateWithWhereUniqueWithoutTournamentsInputSchema),z.lazy(() => QuestionUpdateWithWhereUniqueWithoutTournamentsInputSchema).array() ]).optional(),
  updateMany: z.union([ z.lazy(() => QuestionUpdateManyWithWhereWithoutTournamentsInputSchema),z.lazy(() => QuestionUpdateManyWithWhereWithoutTournamentsInputSchema).array() ]).optional(),
  deleteMany: z.union([ z.lazy(() => QuestionScalarWhereInputSchema),z.lazy(() => QuestionScalarWhereInputSchema).array() ]).optional(),
}).strict();

export const UserUpdateOneRequiredWithoutTournamentsNestedInputSchema: z.ZodType<Prisma.UserUpdateOneRequiredWithoutTournamentsNestedInput> = z.object({
  create: z.union([ z.lazy(() => UserCreateWithoutTournamentsInputSchema),z.lazy(() => UserUncheckedCreateWithoutTournamentsInputSchema) ]).optional(),
  connectOrCreate: z.lazy(() => UserCreateOrConnectWithoutTournamentsInputSchema).optional(),
  upsert: z.lazy(() => UserUpsertWithoutTournamentsInputSchema).optional(),
  connect: z.lazy(() => UserWhereUniqueInputSchema).optional(),
  update: z.union([ z.lazy(() => UserUpdateToOneWithWhereWithoutTournamentsInputSchema),z.lazy(() => UserUpdateWithoutTournamentsInputSchema),z.lazy(() => UserUncheckedUpdateWithoutTournamentsInputSchema) ]).optional(),
}).strict();

export const UserListUpdateOneWithoutTournamentsNestedInputSchema: z.ZodType<Prisma.UserListUpdateOneWithoutTournamentsNestedInput> = z.object({
  create: z.union([ z.lazy(() => UserListCreateWithoutTournamentsInputSchema),z.lazy(() => UserListUncheckedCreateWithoutTournamentsInputSchema) ]).optional(),
  connectOrCreate: z.lazy(() => UserListCreateOrConnectWithoutTournamentsInputSchema).optional(),
  upsert: z.lazy(() => UserListUpsertWithoutTournamentsInputSchema).optional(),
  disconnect: z.union([ z.boolean(),z.lazy(() => UserListWhereInputSchema) ]).optional(),
  delete: z.union([ z.boolean(),z.lazy(() => UserListWhereInputSchema) ]).optional(),
  connect: z.lazy(() => UserListWhereUniqueInputSchema).optional(),
  update: z.union([ z.lazy(() => UserListUpdateToOneWithWhereWithoutTournamentsInputSchema),z.lazy(() => UserListUpdateWithoutTournamentsInputSchema),z.lazy(() => UserListUncheckedUpdateWithoutTournamentsInputSchema) ]).optional(),
}).strict();

export const QuestionUncheckedUpdateManyWithoutTournamentsNestedInputSchema: z.ZodType<Prisma.QuestionUncheckedUpdateManyWithoutTournamentsNestedInput> = z.object({
  create: z.union([ z.lazy(() => QuestionCreateWithoutTournamentsInputSchema),z.lazy(() => QuestionCreateWithoutTournamentsInputSchema).array(),z.lazy(() => QuestionUncheckedCreateWithoutTournamentsInputSchema),z.lazy(() => QuestionUncheckedCreateWithoutTournamentsInputSchema).array() ]).optional(),
  connectOrCreate: z.union([ z.lazy(() => QuestionCreateOrConnectWithoutTournamentsInputSchema),z.lazy(() => QuestionCreateOrConnectWithoutTournamentsInputSchema).array() ]).optional(),
  upsert: z.union([ z.lazy(() => QuestionUpsertWithWhereUniqueWithoutTournamentsInputSchema),z.lazy(() => QuestionUpsertWithWhereUniqueWithoutTournamentsInputSchema).array() ]).optional(),
  set: z.union([ z.lazy(() => QuestionWhereUniqueInputSchema),z.lazy(() => QuestionWhereUniqueInputSchema).array() ]).optional(),
  disconnect: z.union([ z.lazy(() => QuestionWhereUniqueInputSchema),z.lazy(() => QuestionWhereUniqueInputSchema).array() ]).optional(),
  delete: z.union([ z.lazy(() => QuestionWhereUniqueInputSchema),z.lazy(() => QuestionWhereUniqueInputSchema).array() ]).optional(),
  connect: z.union([ z.lazy(() => QuestionWhereUniqueInputSchema),z.lazy(() => QuestionWhereUniqueInputSchema).array() ]).optional(),
  update: z.union([ z.lazy(() => QuestionUpdateWithWhereUniqueWithoutTournamentsInputSchema),z.lazy(() => QuestionUpdateWithWhereUniqueWithoutTournamentsInputSchema).array() ]).optional(),
  updateMany: z.union([ z.lazy(() => QuestionUpdateManyWithWhereWithoutTournamentsInputSchema),z.lazy(() => QuestionUpdateManyWithWhereWithoutTournamentsInputSchema).array() ]).optional(),
  deleteMany: z.union([ z.lazy(() => QuestionScalarWhereInputSchema),z.lazy(() => QuestionScalarWhereInputSchema).array() ]).optional(),
}).strict();

export const NotificationCreatetagsInputSchema: z.ZodType<Prisma.NotificationCreatetagsInput> = z.object({
  set: z.string().array()
}).strict();

export const UserCreateNestedOneWithoutNotificationsInputSchema: z.ZodType<Prisma.UserCreateNestedOneWithoutNotificationsInput> = z.object({
  create: z.union([ z.lazy(() => UserCreateWithoutNotificationsInputSchema),z.lazy(() => UserUncheckedCreateWithoutNotificationsInputSchema) ]).optional(),
  connectOrCreate: z.lazy(() => UserCreateOrConnectWithoutNotificationsInputSchema).optional(),
  connect: z.lazy(() => UserWhereUniqueInputSchema).optional()
}).strict();

export const QuestionCreateNestedOneWithoutNotificationsInputSchema: z.ZodType<Prisma.QuestionCreateNestedOneWithoutNotificationsInput> = z.object({
  create: z.union([ z.lazy(() => QuestionCreateWithoutNotificationsInputSchema),z.lazy(() => QuestionUncheckedCreateWithoutNotificationsInputSchema) ]).optional(),
  connectOrCreate: z.lazy(() => QuestionCreateOrConnectWithoutNotificationsInputSchema).optional(),
  connect: z.lazy(() => QuestionWhereUniqueInputSchema).optional()
}).strict();

export const NotificationUpdatetagsInputSchema: z.ZodType<Prisma.NotificationUpdatetagsInput> = z.object({
  set: z.string().array().optional(),
  push: z.union([ z.string(),z.string().array() ]).optional(),
}).strict();

export const UserUpdateOneRequiredWithoutNotificationsNestedInputSchema: z.ZodType<Prisma.UserUpdateOneRequiredWithoutNotificationsNestedInput> = z.object({
  create: z.union([ z.lazy(() => UserCreateWithoutNotificationsInputSchema),z.lazy(() => UserUncheckedCreateWithoutNotificationsInputSchema) ]).optional(),
  connectOrCreate: z.lazy(() => UserCreateOrConnectWithoutNotificationsInputSchema).optional(),
  upsert: z.lazy(() => UserUpsertWithoutNotificationsInputSchema).optional(),
  connect: z.lazy(() => UserWhereUniqueInputSchema).optional(),
  update: z.union([ z.lazy(() => UserUpdateToOneWithWhereWithoutNotificationsInputSchema),z.lazy(() => UserUpdateWithoutNotificationsInputSchema),z.lazy(() => UserUncheckedUpdateWithoutNotificationsInputSchema) ]).optional(),
}).strict();

export const QuestionUpdateOneWithoutNotificationsNestedInputSchema: z.ZodType<Prisma.QuestionUpdateOneWithoutNotificationsNestedInput> = z.object({
  create: z.union([ z.lazy(() => QuestionCreateWithoutNotificationsInputSchema),z.lazy(() => QuestionUncheckedCreateWithoutNotificationsInputSchema) ]).optional(),
  connectOrCreate: z.lazy(() => QuestionCreateOrConnectWithoutNotificationsInputSchema).optional(),
  upsert: z.lazy(() => QuestionUpsertWithoutNotificationsInputSchema).optional(),
  disconnect: z.union([ z.boolean(),z.lazy(() => QuestionWhereInputSchema) ]).optional(),
  delete: z.union([ z.boolean(),z.lazy(() => QuestionWhereInputSchema) ]).optional(),
  connect: z.lazy(() => QuestionWhereUniqueInputSchema).optional(),
  update: z.union([ z.lazy(() => QuestionUpdateToOneWithWhereWithoutNotificationsInputSchema),z.lazy(() => QuestionUpdateWithoutNotificationsInputSchema),z.lazy(() => QuestionUncheckedUpdateWithoutNotificationsInputSchema) ]).optional(),
}).strict();

export const NestedStringFilterSchema: z.ZodType<Prisma.NestedStringFilter> = z.object({
  equals: z.string().optional(),
  in: z.string().array().optional(),
  notIn: z.string().array().optional(),
  lt: z.string().optional(),
  lte: z.string().optional(),
  gt: z.string().optional(),
  gte: z.string().optional(),
  contains: z.string().optional(),
  startsWith: z.string().optional(),
  endsWith: z.string().optional(),
  search: z.string().optional(),
  not: z.union([ z.string(),z.lazy(() => NestedStringFilterSchema) ]).optional(),
}).strict();

export const NestedDateTimeFilterSchema: z.ZodType<Prisma.NestedDateTimeFilter> = z.object({
  equals: z.coerce.date().optional(),
  in: z.coerce.date().array().optional(),
  notIn: z.coerce.date().array().optional(),
  lt: z.coerce.date().optional(),
  lte: z.coerce.date().optional(),
  gt: z.coerce.date().optional(),
  gte: z.coerce.date().optional(),
  not: z.union([ z.coerce.date(),z.lazy(() => NestedDateTimeFilterSchema) ]).optional(),
}).strict();

export const NestedStringWithAggregatesFilterSchema: z.ZodType<Prisma.NestedStringWithAggregatesFilter> = z.object({
  equals: z.string().optional(),
  in: z.string().array().optional(),
  notIn: z.string().array().optional(),
  lt: z.string().optional(),
  lte: z.string().optional(),
  gt: z.string().optional(),
  gte: z.string().optional(),
  contains: z.string().optional(),
  startsWith: z.string().optional(),
  endsWith: z.string().optional(),
  search: z.string().optional(),
  not: z.union([ z.string(),z.lazy(() => NestedStringWithAggregatesFilterSchema) ]).optional(),
  _count: z.lazy(() => NestedIntFilterSchema).optional(),
  _min: z.lazy(() => NestedStringFilterSchema).optional(),
  _max: z.lazy(() => NestedStringFilterSchema).optional()
}).strict();

export const NestedIntFilterSchema: z.ZodType<Prisma.NestedIntFilter> = z.object({
  equals: z.number().optional(),
  in: z.number().array().optional(),
  notIn: z.number().array().optional(),
  lt: z.number().optional(),
  lte: z.number().optional(),
  gt: z.number().optional(),
  gte: z.number().optional(),
  not: z.union([ z.number(),z.lazy(() => NestedIntFilterSchema) ]).optional(),
}).strict();

export const NestedDateTimeWithAggregatesFilterSchema: z.ZodType<Prisma.NestedDateTimeWithAggregatesFilter> = z.object({
  equals: z.coerce.date().optional(),
  in: z.coerce.date().array().optional(),
  notIn: z.coerce.date().array().optional(),
  lt: z.coerce.date().optional(),
  lte: z.coerce.date().optional(),
  gt: z.coerce.date().optional(),
  gte: z.coerce.date().optional(),
  not: z.union([ z.coerce.date(),z.lazy(() => NestedDateTimeWithAggregatesFilterSchema) ]).optional(),
  _count: z.lazy(() => NestedIntFilterSchema).optional(),
  _min: z.lazy(() => NestedDateTimeFilterSchema).optional(),
  _max: z.lazy(() => NestedDateTimeFilterSchema).optional()
}).strict();

export const NestedStringNullableFilterSchema: z.ZodType<Prisma.NestedStringNullableFilter> = z.object({
  equals: z.string().optional().nullable(),
  in: z.string().array().optional().nullable(),
  notIn: z.string().array().optional().nullable(),
  lt: z.string().optional(),
  lte: z.string().optional(),
  gt: z.string().optional(),
  gte: z.string().optional(),
  contains: z.string().optional(),
  startsWith: z.string().optional(),
  endsWith: z.string().optional(),
  search: z.string().optional(),
  not: z.union([ z.string(),z.lazy(() => NestedStringNullableFilterSchema) ]).optional().nullable(),
}).strict();

export const NestedDecimalFilterSchema: z.ZodType<Prisma.NestedDecimalFilter> = z.object({
  equals: z.union([z.number(),z.string(),z.instanceof(Decimal),z.instanceof(Prisma.Decimal),DecimalJsLikeSchema,]).refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' }).optional(),
  in: z.union([z.number().array(),z.string().array(),z.instanceof(Decimal).array(),z.instanceof(Prisma.Decimal).array(),DecimalJsLikeSchema.array(),]).refine((v) => Array.isArray(v) && (v as any[]).every((v) => isValidDecimalInput(v)), { message: 'Must be a Decimal' }).optional(),
  notIn: z.union([z.number().array(),z.string().array(),z.instanceof(Decimal).array(),z.instanceof(Prisma.Decimal).array(),DecimalJsLikeSchema.array(),]).refine((v) => Array.isArray(v) && (v as any[]).every((v) => isValidDecimalInput(v)), { message: 'Must be a Decimal' }).optional(),
  lt: z.union([z.number(),z.string(),z.instanceof(Decimal),z.instanceof(Prisma.Decimal),DecimalJsLikeSchema,]).refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' }).optional(),
  lte: z.union([z.number(),z.string(),z.instanceof(Decimal),z.instanceof(Prisma.Decimal),DecimalJsLikeSchema,]).refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' }).optional(),
  gt: z.union([z.number(),z.string(),z.instanceof(Decimal),z.instanceof(Prisma.Decimal),DecimalJsLikeSchema,]).refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' }).optional(),
  gte: z.union([z.number(),z.string(),z.instanceof(Decimal),z.instanceof(Prisma.Decimal),DecimalJsLikeSchema,]).refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' }).optional(),
  not: z.union([ z.union([z.number(),z.string(),z.instanceof(Decimal),z.instanceof(Prisma.Decimal),DecimalJsLikeSchema,]).refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' }),z.lazy(() => NestedDecimalFilterSchema) ]).optional(),
}).strict();

export const NestedIntNullableFilterSchema: z.ZodType<Prisma.NestedIntNullableFilter> = z.object({
  equals: z.number().optional().nullable(),
  in: z.number().array().optional().nullable(),
  notIn: z.number().array().optional().nullable(),
  lt: z.number().optional(),
  lte: z.number().optional(),
  gt: z.number().optional(),
  gte: z.number().optional(),
  not: z.union([ z.number(),z.lazy(() => NestedIntNullableFilterSchema) ]).optional().nullable(),
}).strict();

export const NestedIntWithAggregatesFilterSchema: z.ZodType<Prisma.NestedIntWithAggregatesFilter> = z.object({
  equals: z.number().optional(),
  in: z.number().array().optional(),
  notIn: z.number().array().optional(),
  lt: z.number().optional(),
  lte: z.number().optional(),
  gt: z.number().optional(),
  gte: z.number().optional(),
  not: z.union([ z.number(),z.lazy(() => NestedIntWithAggregatesFilterSchema) ]).optional(),
  _count: z.lazy(() => NestedIntFilterSchema).optional(),
  _avg: z.lazy(() => NestedFloatFilterSchema).optional(),
  _sum: z.lazy(() => NestedIntFilterSchema).optional(),
  _min: z.lazy(() => NestedIntFilterSchema).optional(),
  _max: z.lazy(() => NestedIntFilterSchema).optional()
}).strict();

export const NestedFloatFilterSchema: z.ZodType<Prisma.NestedFloatFilter> = z.object({
  equals: z.number().optional(),
  in: z.number().array().optional(),
  notIn: z.number().array().optional(),
  lt: z.number().optional(),
  lte: z.number().optional(),
  gt: z.number().optional(),
  gte: z.number().optional(),
  not: z.union([ z.number(),z.lazy(() => NestedFloatFilterSchema) ]).optional(),
}).strict();

export const NestedStringNullableWithAggregatesFilterSchema: z.ZodType<Prisma.NestedStringNullableWithAggregatesFilter> = z.object({
  equals: z.string().optional().nullable(),
  in: z.string().array().optional().nullable(),
  notIn: z.string().array().optional().nullable(),
  lt: z.string().optional(),
  lte: z.string().optional(),
  gt: z.string().optional(),
  gte: z.string().optional(),
  contains: z.string().optional(),
  startsWith: z.string().optional(),
  endsWith: z.string().optional(),
  search: z.string().optional(),
  not: z.union([ z.string(),z.lazy(() => NestedStringNullableWithAggregatesFilterSchema) ]).optional().nullable(),
  _count: z.lazy(() => NestedIntNullableFilterSchema).optional(),
  _min: z.lazy(() => NestedStringNullableFilterSchema).optional(),
  _max: z.lazy(() => NestedStringNullableFilterSchema).optional()
}).strict();

export const NestedDecimalWithAggregatesFilterSchema: z.ZodType<Prisma.NestedDecimalWithAggregatesFilter> = z.object({
  equals: z.union([z.number(),z.string(),z.instanceof(Decimal),z.instanceof(Prisma.Decimal),DecimalJsLikeSchema,]).refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' }).optional(),
  in: z.union([z.number().array(),z.string().array(),z.instanceof(Decimal).array(),z.instanceof(Prisma.Decimal).array(),DecimalJsLikeSchema.array(),]).refine((v) => Array.isArray(v) && (v as any[]).every((v) => isValidDecimalInput(v)), { message: 'Must be a Decimal' }).optional(),
  notIn: z.union([z.number().array(),z.string().array(),z.instanceof(Decimal).array(),z.instanceof(Prisma.Decimal).array(),DecimalJsLikeSchema.array(),]).refine((v) => Array.isArray(v) && (v as any[]).every((v) => isValidDecimalInput(v)), { message: 'Must be a Decimal' }).optional(),
  lt: z.union([z.number(),z.string(),z.instanceof(Decimal),z.instanceof(Prisma.Decimal),DecimalJsLikeSchema,]).refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' }).optional(),
  lte: z.union([z.number(),z.string(),z.instanceof(Decimal),z.instanceof(Prisma.Decimal),DecimalJsLikeSchema,]).refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' }).optional(),
  gt: z.union([z.number(),z.string(),z.instanceof(Decimal),z.instanceof(Prisma.Decimal),DecimalJsLikeSchema,]).refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' }).optional(),
  gte: z.union([z.number(),z.string(),z.instanceof(Decimal),z.instanceof(Prisma.Decimal),DecimalJsLikeSchema,]).refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' }).optional(),
  not: z.union([ z.union([z.number(),z.string(),z.instanceof(Decimal),z.instanceof(Prisma.Decimal),DecimalJsLikeSchema,]).refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' }),z.lazy(() => NestedDecimalWithAggregatesFilterSchema) ]).optional(),
  _count: z.lazy(() => NestedIntFilterSchema).optional(),
  _avg: z.lazy(() => NestedDecimalFilterSchema).optional(),
  _sum: z.lazy(() => NestedDecimalFilterSchema).optional(),
  _min: z.lazy(() => NestedDecimalFilterSchema).optional(),
  _max: z.lazy(() => NestedDecimalFilterSchema).optional()
}).strict();

export const NestedIntNullableWithAggregatesFilterSchema: z.ZodType<Prisma.NestedIntNullableWithAggregatesFilter> = z.object({
  equals: z.number().optional().nullable(),
  in: z.number().array().optional().nullable(),
  notIn: z.number().array().optional().nullable(),
  lt: z.number().optional(),
  lte: z.number().optional(),
  gt: z.number().optional(),
  gte: z.number().optional(),
  not: z.union([ z.number(),z.lazy(() => NestedIntNullableWithAggregatesFilterSchema) ]).optional().nullable(),
  _count: z.lazy(() => NestedIntNullableFilterSchema).optional(),
  _avg: z.lazy(() => NestedFloatNullableFilterSchema).optional(),
  _sum: z.lazy(() => NestedIntNullableFilterSchema).optional(),
  _min: z.lazy(() => NestedIntNullableFilterSchema).optional(),
  _max: z.lazy(() => NestedIntNullableFilterSchema).optional()
}).strict();

export const NestedFloatNullableFilterSchema: z.ZodType<Prisma.NestedFloatNullableFilter> = z.object({
  equals: z.number().optional().nullable(),
  in: z.number().array().optional().nullable(),
  notIn: z.number().array().optional().nullable(),
  lt: z.number().optional(),
  lte: z.number().optional(),
  gt: z.number().optional(),
  gte: z.number().optional(),
  not: z.union([ z.number(),z.lazy(() => NestedFloatNullableFilterSchema) ]).optional().nullable(),
}).strict();

export const NestedDecimalNullableFilterSchema: z.ZodType<Prisma.NestedDecimalNullableFilter> = z.object({
  equals: z.union([z.number(),z.string(),z.instanceof(Decimal),z.instanceof(Prisma.Decimal),DecimalJsLikeSchema,]).refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' }).optional().nullable(),
  in: z.union([z.number().array(),z.string().array(),z.instanceof(Decimal).array(),z.instanceof(Prisma.Decimal).array(),DecimalJsLikeSchema.array(),]).refine((v) => Array.isArray(v) && (v as any[]).every((v) => isValidDecimalInput(v)), { message: 'Must be a Decimal' }).optional().nullable(),
  notIn: z.union([z.number().array(),z.string().array(),z.instanceof(Decimal).array(),z.instanceof(Prisma.Decimal).array(),DecimalJsLikeSchema.array(),]).refine((v) => Array.isArray(v) && (v as any[]).every((v) => isValidDecimalInput(v)), { message: 'Must be a Decimal' }).optional().nullable(),
  lt: z.union([z.number(),z.string(),z.instanceof(Decimal),z.instanceof(Prisma.Decimal),DecimalJsLikeSchema,]).refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' }).optional(),
  lte: z.union([z.number(),z.string(),z.instanceof(Decimal),z.instanceof(Prisma.Decimal),DecimalJsLikeSchema,]).refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' }).optional(),
  gt: z.union([z.number(),z.string(),z.instanceof(Decimal),z.instanceof(Prisma.Decimal),DecimalJsLikeSchema,]).refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' }).optional(),
  gte: z.union([z.number(),z.string(),z.instanceof(Decimal),z.instanceof(Prisma.Decimal),DecimalJsLikeSchema,]).refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' }).optional(),
  not: z.union([ z.union([z.number(),z.string(),z.instanceof(Decimal),z.instanceof(Prisma.Decimal),DecimalJsLikeSchema,]).refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' }),z.lazy(() => NestedDecimalNullableFilterSchema) ]).optional().nullable(),
}).strict();

export const NestedDecimalNullableWithAggregatesFilterSchema: z.ZodType<Prisma.NestedDecimalNullableWithAggregatesFilter> = z.object({
  equals: z.union([z.number(),z.string(),z.instanceof(Decimal),z.instanceof(Prisma.Decimal),DecimalJsLikeSchema,]).refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' }).optional().nullable(),
  in: z.union([z.number().array(),z.string().array(),z.instanceof(Decimal).array(),z.instanceof(Prisma.Decimal).array(),DecimalJsLikeSchema.array(),]).refine((v) => Array.isArray(v) && (v as any[]).every((v) => isValidDecimalInput(v)), { message: 'Must be a Decimal' }).optional().nullable(),
  notIn: z.union([z.number().array(),z.string().array(),z.instanceof(Decimal).array(),z.instanceof(Prisma.Decimal).array(),DecimalJsLikeSchema.array(),]).refine((v) => Array.isArray(v) && (v as any[]).every((v) => isValidDecimalInput(v)), { message: 'Must be a Decimal' }).optional().nullable(),
  lt: z.union([z.number(),z.string(),z.instanceof(Decimal),z.instanceof(Prisma.Decimal),DecimalJsLikeSchema,]).refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' }).optional(),
  lte: z.union([z.number(),z.string(),z.instanceof(Decimal),z.instanceof(Prisma.Decimal),DecimalJsLikeSchema,]).refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' }).optional(),
  gt: z.union([z.number(),z.string(),z.instanceof(Decimal),z.instanceof(Prisma.Decimal),DecimalJsLikeSchema,]).refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' }).optional(),
  gte: z.union([z.number(),z.string(),z.instanceof(Decimal),z.instanceof(Prisma.Decimal),DecimalJsLikeSchema,]).refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' }).optional(),
  not: z.union([ z.union([z.number(),z.string(),z.instanceof(Decimal),z.instanceof(Prisma.Decimal),DecimalJsLikeSchema,]).refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' }),z.lazy(() => NestedDecimalNullableWithAggregatesFilterSchema) ]).optional().nullable(),
  _count: z.lazy(() => NestedIntNullableFilterSchema).optional(),
  _avg: z.lazy(() => NestedDecimalNullableFilterSchema).optional(),
  _sum: z.lazy(() => NestedDecimalNullableFilterSchema).optional(),
  _min: z.lazy(() => NestedDecimalNullableFilterSchema).optional(),
  _max: z.lazy(() => NestedDecimalNullableFilterSchema).optional()
}).strict();

export const NestedEnumResolutionNullableFilterSchema: z.ZodType<Prisma.NestedEnumResolutionNullableFilter> = z.object({
  equals: z.lazy(() => ResolutionSchema).optional().nullable(),
  in: z.lazy(() => ResolutionSchema).array().optional().nullable(),
  notIn: z.lazy(() => ResolutionSchema).array().optional().nullable(),
  not: z.union([ z.lazy(() => ResolutionSchema),z.lazy(() => NestedEnumResolutionNullableFilterSchema) ]).optional().nullable(),
}).strict();

export const NestedDateTimeNullableFilterSchema: z.ZodType<Prisma.NestedDateTimeNullableFilter> = z.object({
  equals: z.coerce.date().optional().nullable(),
  in: z.coerce.date().array().optional().nullable(),
  notIn: z.coerce.date().array().optional().nullable(),
  lt: z.coerce.date().optional(),
  lte: z.coerce.date().optional(),
  gt: z.coerce.date().optional(),
  gte: z.coerce.date().optional(),
  not: z.union([ z.coerce.date(),z.lazy(() => NestedDateTimeNullableFilterSchema) ]).optional().nullable(),
}).strict();

export const NestedEnumResolutionNullableWithAggregatesFilterSchema: z.ZodType<Prisma.NestedEnumResolutionNullableWithAggregatesFilter> = z.object({
  equals: z.lazy(() => ResolutionSchema).optional().nullable(),
  in: z.lazy(() => ResolutionSchema).array().optional().nullable(),
  notIn: z.lazy(() => ResolutionSchema).array().optional().nullable(),
  not: z.union([ z.lazy(() => ResolutionSchema),z.lazy(() => NestedEnumResolutionNullableWithAggregatesFilterSchema) ]).optional().nullable(),
  _count: z.lazy(() => NestedIntNullableFilterSchema).optional(),
  _min: z.lazy(() => NestedEnumResolutionNullableFilterSchema).optional(),
  _max: z.lazy(() => NestedEnumResolutionNullableFilterSchema).optional()
}).strict();

export const NestedDateTimeNullableWithAggregatesFilterSchema: z.ZodType<Prisma.NestedDateTimeNullableWithAggregatesFilter> = z.object({
  equals: z.coerce.date().optional().nullable(),
  in: z.coerce.date().array().optional().nullable(),
  notIn: z.coerce.date().array().optional().nullable(),
  lt: z.coerce.date().optional(),
  lte: z.coerce.date().optional(),
  gt: z.coerce.date().optional(),
  gte: z.coerce.date().optional(),
  not: z.union([ z.coerce.date(),z.lazy(() => NestedDateTimeNullableWithAggregatesFilterSchema) ]).optional().nullable(),
  _count: z.lazy(() => NestedIntNullableFilterSchema).optional(),
  _min: z.lazy(() => NestedDateTimeNullableFilterSchema).optional(),
  _max: z.lazy(() => NestedDateTimeNullableFilterSchema).optional()
}).strict();

export const NestedEnumQuestionTypeFilterSchema: z.ZodType<Prisma.NestedEnumQuestionTypeFilter> = z.object({
  equals: z.lazy(() => QuestionTypeSchema).optional(),
  in: z.lazy(() => QuestionTypeSchema).array().optional(),
  notIn: z.lazy(() => QuestionTypeSchema).array().optional(),
  not: z.union([ z.lazy(() => QuestionTypeSchema),z.lazy(() => NestedEnumQuestionTypeFilterSchema) ]).optional(),
}).strict();

export const NestedBoolFilterSchema: z.ZodType<Prisma.NestedBoolFilter> = z.object({
  equals: z.boolean().optional(),
  not: z.union([ z.boolean(),z.lazy(() => NestedBoolFilterSchema) ]).optional(),
}).strict();

export const NestedBoolNullableFilterSchema: z.ZodType<Prisma.NestedBoolNullableFilter> = z.object({
  equals: z.boolean().optional().nullable(),
  not: z.union([ z.boolean(),z.lazy(() => NestedBoolNullableFilterSchema) ]).optional().nullable(),
}).strict();

export const NestedEnumQuestionTypeWithAggregatesFilterSchema: z.ZodType<Prisma.NestedEnumQuestionTypeWithAggregatesFilter> = z.object({
  equals: z.lazy(() => QuestionTypeSchema).optional(),
  in: z.lazy(() => QuestionTypeSchema).array().optional(),
  notIn: z.lazy(() => QuestionTypeSchema).array().optional(),
  not: z.union([ z.lazy(() => QuestionTypeSchema),z.lazy(() => NestedEnumQuestionTypeWithAggregatesFilterSchema) ]).optional(),
  _count: z.lazy(() => NestedIntFilterSchema).optional(),
  _min: z.lazy(() => NestedEnumQuestionTypeFilterSchema).optional(),
  _max: z.lazy(() => NestedEnumQuestionTypeFilterSchema).optional()
}).strict();

export const NestedBoolWithAggregatesFilterSchema: z.ZodType<Prisma.NestedBoolWithAggregatesFilter> = z.object({
  equals: z.boolean().optional(),
  not: z.union([ z.boolean(),z.lazy(() => NestedBoolWithAggregatesFilterSchema) ]).optional(),
  _count: z.lazy(() => NestedIntFilterSchema).optional(),
  _min: z.lazy(() => NestedBoolFilterSchema).optional(),
  _max: z.lazy(() => NestedBoolFilterSchema).optional()
}).strict();

export const NestedBoolNullableWithAggregatesFilterSchema: z.ZodType<Prisma.NestedBoolNullableWithAggregatesFilter> = z.object({
  equals: z.boolean().optional().nullable(),
  not: z.union([ z.boolean(),z.lazy(() => NestedBoolNullableWithAggregatesFilterSchema) ]).optional().nullable(),
  _count: z.lazy(() => NestedIntNullableFilterSchema).optional(),
  _min: z.lazy(() => NestedBoolNullableFilterSchema).optional(),
  _max: z.lazy(() => NestedBoolNullableFilterSchema).optional()
}).strict();

export const NestedEnumGroupTypeFilterSchema: z.ZodType<Prisma.NestedEnumGroupTypeFilter> = z.object({
  equals: z.lazy(() => GroupTypeSchema).optional(),
  in: z.lazy(() => GroupTypeSchema).array().optional(),
  notIn: z.lazy(() => GroupTypeSchema).array().optional(),
  not: z.union([ z.lazy(() => GroupTypeSchema),z.lazy(() => NestedEnumGroupTypeFilterSchema) ]).optional(),
}).strict();

export const NestedEnumGroupTypeWithAggregatesFilterSchema: z.ZodType<Prisma.NestedEnumGroupTypeWithAggregatesFilter> = z.object({
  equals: z.lazy(() => GroupTypeSchema).optional(),
  in: z.lazy(() => GroupTypeSchema).array().optional(),
  notIn: z.lazy(() => GroupTypeSchema).array().optional(),
  not: z.union([ z.lazy(() => GroupTypeSchema),z.lazy(() => NestedEnumGroupTypeWithAggregatesFilterSchema) ]).optional(),
  _count: z.lazy(() => NestedIntFilterSchema).optional(),
  _min: z.lazy(() => NestedEnumGroupTypeFilterSchema).optional(),
  _max: z.lazy(() => NestedEnumGroupTypeFilterSchema).optional()
}).strict();

export const NestedEnumTargetTypeFilterSchema: z.ZodType<Prisma.NestedEnumTargetTypeFilter> = z.object({
  equals: z.lazy(() => TargetTypeSchema).optional(),
  in: z.lazy(() => TargetTypeSchema).array().optional(),
  notIn: z.lazy(() => TargetTypeSchema).array().optional(),
  not: z.union([ z.lazy(() => TargetTypeSchema),z.lazy(() => NestedEnumTargetTypeFilterSchema) ]).optional(),
}).strict();

export const NestedEnumDayOfTheWeekFilterSchema: z.ZodType<Prisma.NestedEnumDayOfTheWeekFilter> = z.object({
  equals: z.lazy(() => DayOfTheWeekSchema).optional(),
  in: z.lazy(() => DayOfTheWeekSchema).array().optional(),
  notIn: z.lazy(() => DayOfTheWeekSchema).array().optional(),
  not: z.union([ z.lazy(() => DayOfTheWeekSchema),z.lazy(() => NestedEnumDayOfTheWeekFilterSchema) ]).optional(),
}).strict();

export const NestedEnumTargetTypeWithAggregatesFilterSchema: z.ZodType<Prisma.NestedEnumTargetTypeWithAggregatesFilter> = z.object({
  equals: z.lazy(() => TargetTypeSchema).optional(),
  in: z.lazy(() => TargetTypeSchema).array().optional(),
  notIn: z.lazy(() => TargetTypeSchema).array().optional(),
  not: z.union([ z.lazy(() => TargetTypeSchema),z.lazy(() => NestedEnumTargetTypeWithAggregatesFilterSchema) ]).optional(),
  _count: z.lazy(() => NestedIntFilterSchema).optional(),
  _min: z.lazy(() => NestedEnumTargetTypeFilterSchema).optional(),
  _max: z.lazy(() => NestedEnumTargetTypeFilterSchema).optional()
}).strict();

export const NestedEnumDayOfTheWeekWithAggregatesFilterSchema: z.ZodType<Prisma.NestedEnumDayOfTheWeekWithAggregatesFilter> = z.object({
  equals: z.lazy(() => DayOfTheWeekSchema).optional(),
  in: z.lazy(() => DayOfTheWeekSchema).array().optional(),
  notIn: z.lazy(() => DayOfTheWeekSchema).array().optional(),
  not: z.union([ z.lazy(() => DayOfTheWeekSchema),z.lazy(() => NestedEnumDayOfTheWeekWithAggregatesFilterSchema) ]).optional(),
  _count: z.lazy(() => NestedIntFilterSchema).optional(),
  _min: z.lazy(() => NestedEnumDayOfTheWeekFilterSchema).optional(),
  _max: z.lazy(() => NestedEnumDayOfTheWeekFilterSchema).optional()
}).strict();

export const QuestionOptionCreateWithoutForecastsInputSchema: z.ZodType<Prisma.QuestionOptionCreateWithoutForecastsInput> = z.object({
  id: z.string().cuid().optional(),
  text: z.string(),
  resolution: z.lazy(() => ResolutionSchema).optional().nullable(),
  createdAt: z.coerce.date().optional(),
  resolvedAt: z.coerce.date().optional().nullable(),
  question: z.lazy(() => QuestionCreateNestedOneWithoutOptionsInputSchema),
  user: z.lazy(() => UserCreateNestedOneWithoutQuestionOptionsInputSchema),
  questionScores: z.lazy(() => QuestionScoreCreateNestedManyWithoutQuestionOptionInputSchema).optional()
}).strict();

export const QuestionOptionUncheckedCreateWithoutForecastsInputSchema: z.ZodType<Prisma.QuestionOptionUncheckedCreateWithoutForecastsInput> = z.object({
  id: z.string().cuid().optional(),
  questionId: z.string(),
  text: z.string(),
  resolution: z.lazy(() => ResolutionSchema).optional().nullable(),
  createdAt: z.coerce.date().optional(),
  userId: z.string(),
  resolvedAt: z.coerce.date().optional().nullable(),
  questionScores: z.lazy(() => QuestionScoreUncheckedCreateNestedManyWithoutQuestionOptionInputSchema).optional()
}).strict();

export const QuestionOptionCreateOrConnectWithoutForecastsInputSchema: z.ZodType<Prisma.QuestionOptionCreateOrConnectWithoutForecastsInput> = z.object({
  where: z.lazy(() => QuestionOptionWhereUniqueInputSchema),
  create: z.union([ z.lazy(() => QuestionOptionCreateWithoutForecastsInputSchema),z.lazy(() => QuestionOptionUncheckedCreateWithoutForecastsInputSchema) ]),
}).strict();

export const ProfileCreateWithoutForecastsInputSchema: z.ZodType<Prisma.ProfileCreateWithoutForecastsInput> = z.object({
  createdAt: z.coerce.date().optional(),
  slackId: z.string().optional().nullable(),
  slackTeamId: z.string().optional().nullable(),
  user: z.lazy(() => UserCreateNestedOneWithoutProfilesInputSchema),
  questions: z.lazy(() => QuestionCreateNestedManyWithoutProfileInputSchema).optional(),
  resolutionMessages: z.lazy(() => ResolutionSlackMessageCreateNestedManyWithoutProfileInputSchema).optional(),
  target: z.lazy(() => TargetCreateNestedOneWithoutProfileInputSchema).optional()
}).strict();

export const ProfileUncheckedCreateWithoutForecastsInputSchema: z.ZodType<Prisma.ProfileUncheckedCreateWithoutForecastsInput> = z.object({
  id: z.number().int().optional(),
  createdAt: z.coerce.date().optional(),
  slackId: z.string().optional().nullable(),
  slackTeamId: z.string().optional().nullable(),
  userId: z.string(),
  questions: z.lazy(() => QuestionUncheckedCreateNestedManyWithoutProfileInputSchema).optional(),
  resolutionMessages: z.lazy(() => ResolutionSlackMessageUncheckedCreateNestedManyWithoutProfileInputSchema).optional(),
  target: z.lazy(() => TargetUncheckedCreateNestedOneWithoutProfileInputSchema).optional()
}).strict();

export const ProfileCreateOrConnectWithoutForecastsInputSchema: z.ZodType<Prisma.ProfileCreateOrConnectWithoutForecastsInput> = z.object({
  where: z.lazy(() => ProfileWhereUniqueInputSchema),
  create: z.union([ z.lazy(() => ProfileCreateWithoutForecastsInputSchema),z.lazy(() => ProfileUncheckedCreateWithoutForecastsInputSchema) ]),
}).strict();

export const QuestionCreateWithoutForecastsInputSchema: z.ZodType<Prisma.QuestionCreateWithoutForecastsInput> = z.object({
  id: z.string().cuid().optional(),
  createdAt: z.coerce.date().optional(),
  comment: z.string().optional().nullable(),
  title: z.string(),
  type: z.lazy(() => QuestionTypeSchema).optional(),
  resolveBy: z.coerce.date(),
  resolved: z.boolean().optional(),
  pingedForResolution: z.boolean().optional(),
  resolution: z.lazy(() => ResolutionSchema).optional().nullable(),
  resolvedAt: z.coerce.date().optional().nullable(),
  notes: z.string().optional().nullable(),
  hideForecastsUntil: z.coerce.date().optional().nullable(),
  hideForecastsUntilPrediction: z.boolean().optional().nullable(),
  sharedPublicly: z.boolean().optional(),
  unlisted: z.boolean().optional(),
  exclusiveAnswers: z.boolean().optional().nullable(),
  options: z.lazy(() => QuestionOptionCreateNestedManyWithoutQuestionInputSchema).optional(),
  pingResolveMessages: z.lazy(() => PingSlackMessageCreateNestedManyWithoutQuestionInputSchema).optional(),
  profile: z.lazy(() => ProfileCreateNestedOneWithoutQuestionsInputSchema).optional(),
  user: z.lazy(() => UserCreateNestedOneWithoutQuestionsInputSchema),
  sharedWith: z.lazy(() => UserCreateNestedManyWithoutQuestionsSharedWithInputSchema).optional(),
  sharedWithLists: z.lazy(() => UserListCreateNestedManyWithoutQuestionsInputSchema).optional(),
  questionScores: z.lazy(() => QuestionScoreCreateNestedManyWithoutQuestionInputSchema).optional(),
  questionMessages: z.lazy(() => QuestionSlackMessageCreateNestedManyWithoutQuestionInputSchema).optional(),
  resolutionMessages: z.lazy(() => ResolutionSlackMessageCreateNestedManyWithoutQuestionInputSchema).optional(),
  comments: z.lazy(() => CommentCreateNestedManyWithoutQuestionInputSchema).optional(),
  tags: z.lazy(() => TagCreateNestedManyWithoutQuestionsInputSchema).optional(),
  tournaments: z.lazy(() => TournamentCreateNestedManyWithoutQuestionsInputSchema).optional(),
  notifications: z.lazy(() => NotificationCreateNestedManyWithoutQuestionInputSchema).optional()
}).strict();

export const QuestionUncheckedCreateWithoutForecastsInputSchema: z.ZodType<Prisma.QuestionUncheckedCreateWithoutForecastsInput> = z.object({
  id: z.string().cuid().optional(),
  createdAt: z.coerce.date().optional(),
  comment: z.string().optional().nullable(),
  profileId: z.number().int().optional().nullable(),
  title: z.string(),
  type: z.lazy(() => QuestionTypeSchema).optional(),
  resolveBy: z.coerce.date(),
  resolved: z.boolean().optional(),
  pingedForResolution: z.boolean().optional(),
  resolution: z.lazy(() => ResolutionSchema).optional().nullable(),
  resolvedAt: z.coerce.date().optional().nullable(),
  notes: z.string().optional().nullable(),
  hideForecastsUntil: z.coerce.date().optional().nullable(),
  hideForecastsUntilPrediction: z.boolean().optional().nullable(),
  userId: z.string(),
  sharedPublicly: z.boolean().optional(),
  unlisted: z.boolean().optional(),
  exclusiveAnswers: z.boolean().optional().nullable(),
  options: z.lazy(() => QuestionOptionUncheckedCreateNestedManyWithoutQuestionInputSchema).optional(),
  pingResolveMessages: z.lazy(() => PingSlackMessageUncheckedCreateNestedManyWithoutQuestionInputSchema).optional(),
  sharedWith: z.lazy(() => UserUncheckedCreateNestedManyWithoutQuestionsSharedWithInputSchema).optional(),
  sharedWithLists: z.lazy(() => UserListUncheckedCreateNestedManyWithoutQuestionsInputSchema).optional(),
  questionScores: z.lazy(() => QuestionScoreUncheckedCreateNestedManyWithoutQuestionInputSchema).optional(),
  questionMessages: z.lazy(() => QuestionSlackMessageUncheckedCreateNestedManyWithoutQuestionInputSchema).optional(),
  resolutionMessages: z.lazy(() => ResolutionSlackMessageUncheckedCreateNestedManyWithoutQuestionInputSchema).optional(),
  comments: z.lazy(() => CommentUncheckedCreateNestedManyWithoutQuestionInputSchema).optional(),
  tags: z.lazy(() => TagUncheckedCreateNestedManyWithoutQuestionsInputSchema).optional(),
  tournaments: z.lazy(() => TournamentUncheckedCreateNestedManyWithoutQuestionsInputSchema).optional(),
  notifications: z.lazy(() => NotificationUncheckedCreateNestedManyWithoutQuestionInputSchema).optional()
}).strict();

export const QuestionCreateOrConnectWithoutForecastsInputSchema: z.ZodType<Prisma.QuestionCreateOrConnectWithoutForecastsInput> = z.object({
  where: z.lazy(() => QuestionWhereUniqueInputSchema),
  create: z.union([ z.lazy(() => QuestionCreateWithoutForecastsInputSchema),z.lazy(() => QuestionUncheckedCreateWithoutForecastsInputSchema) ]),
}).strict();

export const UserCreateWithoutForecastsInputSchema: z.ZodType<Prisma.UserCreateWithoutForecastsInput> = z.object({
  id: z.string().cuid().optional(),
  name: z.string().optional().nullable(),
  createdAt: z.coerce.date().optional(),
  email: z.string(),
  image: z.string().optional().nullable(),
  staleReminder: z.boolean().optional(),
  unsubscribedFromEmailsAt: z.coerce.date().optional().nullable(),
  apiKey: z.string().optional().nullable(),
  discordUserId: z.string().optional().nullable(),
  emailVerified: z.coerce.date().optional().nullable(),
  profiles: z.lazy(() => ProfileCreateNestedManyWithoutUserInputSchema).optional(),
  questions: z.lazy(() => QuestionCreateNestedManyWithoutUserInputSchema).optional(),
  questionScores: z.lazy(() => QuestionScoreCreateNestedManyWithoutUserInputSchema).optional(),
  questionsSharedWith: z.lazy(() => QuestionCreateNestedManyWithoutSharedWithInputSchema).optional(),
  comments: z.lazy(() => CommentCreateNestedManyWithoutUserInputSchema).optional(),
  target: z.lazy(() => TargetCreateNestedOneWithoutUserInputSchema).optional(),
  authorOfLists: z.lazy(() => UserListCreateNestedManyWithoutAuthorInputSchema).optional(),
  memberOfLists: z.lazy(() => UserListCreateNestedManyWithoutUsersInputSchema).optional(),
  tags: z.lazy(() => TagCreateNestedManyWithoutUserInputSchema).optional(),
  tournaments: z.lazy(() => TournamentCreateNestedManyWithoutAuthorInputSchema).optional(),
  notifications: z.lazy(() => NotificationCreateNestedManyWithoutUserInputSchema).optional(),
  questionOptions: z.lazy(() => QuestionOptionCreateNestedManyWithoutUserInputSchema).optional(),
  accounts: z.lazy(() => AccountCreateNestedManyWithoutUserInputSchema).optional()
}).strict();

export const UserUncheckedCreateWithoutForecastsInputSchema: z.ZodType<Prisma.UserUncheckedCreateWithoutForecastsInput> = z.object({
  id: z.string().cuid().optional(),
  name: z.string().optional().nullable(),
  createdAt: z.coerce.date().optional(),
  email: z.string(),
  image: z.string().optional().nullable(),
  staleReminder: z.boolean().optional(),
  unsubscribedFromEmailsAt: z.coerce.date().optional().nullable(),
  apiKey: z.string().optional().nullable(),
  discordUserId: z.string().optional().nullable(),
  emailVerified: z.coerce.date().optional().nullable(),
  profiles: z.lazy(() => ProfileUncheckedCreateNestedManyWithoutUserInputSchema).optional(),
  questions: z.lazy(() => QuestionUncheckedCreateNestedManyWithoutUserInputSchema).optional(),
  questionScores: z.lazy(() => QuestionScoreUncheckedCreateNestedManyWithoutUserInputSchema).optional(),
  questionsSharedWith: z.lazy(() => QuestionUncheckedCreateNestedManyWithoutSharedWithInputSchema).optional(),
  comments: z.lazy(() => CommentUncheckedCreateNestedManyWithoutUserInputSchema).optional(),
  target: z.lazy(() => TargetUncheckedCreateNestedOneWithoutUserInputSchema).optional(),
  authorOfLists: z.lazy(() => UserListUncheckedCreateNestedManyWithoutAuthorInputSchema).optional(),
  memberOfLists: z.lazy(() => UserListUncheckedCreateNestedManyWithoutUsersInputSchema).optional(),
  tags: z.lazy(() => TagUncheckedCreateNestedManyWithoutUserInputSchema).optional(),
  tournaments: z.lazy(() => TournamentUncheckedCreateNestedManyWithoutAuthorInputSchema).optional(),
  notifications: z.lazy(() => NotificationUncheckedCreateNestedManyWithoutUserInputSchema).optional(),
  questionOptions: z.lazy(() => QuestionOptionUncheckedCreateNestedManyWithoutUserInputSchema).optional(),
  accounts: z.lazy(() => AccountUncheckedCreateNestedManyWithoutUserInputSchema).optional()
}).strict();

export const UserCreateOrConnectWithoutForecastsInputSchema: z.ZodType<Prisma.UserCreateOrConnectWithoutForecastsInput> = z.object({
  where: z.lazy(() => UserWhereUniqueInputSchema),
  create: z.union([ z.lazy(() => UserCreateWithoutForecastsInputSchema),z.lazy(() => UserUncheckedCreateWithoutForecastsInputSchema) ]),
}).strict();

export const QuestionOptionUpsertWithoutForecastsInputSchema: z.ZodType<Prisma.QuestionOptionUpsertWithoutForecastsInput> = z.object({
  update: z.union([ z.lazy(() => QuestionOptionUpdateWithoutForecastsInputSchema),z.lazy(() => QuestionOptionUncheckedUpdateWithoutForecastsInputSchema) ]),
  create: z.union([ z.lazy(() => QuestionOptionCreateWithoutForecastsInputSchema),z.lazy(() => QuestionOptionUncheckedCreateWithoutForecastsInputSchema) ]),
  where: z.lazy(() => QuestionOptionWhereInputSchema).optional()
}).strict();

export const QuestionOptionUpdateToOneWithWhereWithoutForecastsInputSchema: z.ZodType<Prisma.QuestionOptionUpdateToOneWithWhereWithoutForecastsInput> = z.object({
  where: z.lazy(() => QuestionOptionWhereInputSchema).optional(),
  data: z.union([ z.lazy(() => QuestionOptionUpdateWithoutForecastsInputSchema),z.lazy(() => QuestionOptionUncheckedUpdateWithoutForecastsInputSchema) ]),
}).strict();

export const QuestionOptionUpdateWithoutForecastsInputSchema: z.ZodType<Prisma.QuestionOptionUpdateWithoutForecastsInput> = z.object({
  id: z.union([ z.string().cuid(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  text: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  resolution: z.union([ z.lazy(() => ResolutionSchema),z.lazy(() => NullableEnumResolutionFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  createdAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  resolvedAt: z.union([ z.coerce.date(),z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  question: z.lazy(() => QuestionUpdateOneRequiredWithoutOptionsNestedInputSchema).optional(),
  user: z.lazy(() => UserUpdateOneRequiredWithoutQuestionOptionsNestedInputSchema).optional(),
  questionScores: z.lazy(() => QuestionScoreUpdateManyWithoutQuestionOptionNestedInputSchema).optional()
}).strict();

export const QuestionOptionUncheckedUpdateWithoutForecastsInputSchema: z.ZodType<Prisma.QuestionOptionUncheckedUpdateWithoutForecastsInput> = z.object({
  id: z.union([ z.string().cuid(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  questionId: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  text: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  resolution: z.union([ z.lazy(() => ResolutionSchema),z.lazy(() => NullableEnumResolutionFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  createdAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  userId: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  resolvedAt: z.union([ z.coerce.date(),z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  questionScores: z.lazy(() => QuestionScoreUncheckedUpdateManyWithoutQuestionOptionNestedInputSchema).optional()
}).strict();

export const ProfileUpsertWithoutForecastsInputSchema: z.ZodType<Prisma.ProfileUpsertWithoutForecastsInput> = z.object({
  update: z.union([ z.lazy(() => ProfileUpdateWithoutForecastsInputSchema),z.lazy(() => ProfileUncheckedUpdateWithoutForecastsInputSchema) ]),
  create: z.union([ z.lazy(() => ProfileCreateWithoutForecastsInputSchema),z.lazy(() => ProfileUncheckedCreateWithoutForecastsInputSchema) ]),
  where: z.lazy(() => ProfileWhereInputSchema).optional()
}).strict();

export const ProfileUpdateToOneWithWhereWithoutForecastsInputSchema: z.ZodType<Prisma.ProfileUpdateToOneWithWhereWithoutForecastsInput> = z.object({
  where: z.lazy(() => ProfileWhereInputSchema).optional(),
  data: z.union([ z.lazy(() => ProfileUpdateWithoutForecastsInputSchema),z.lazy(() => ProfileUncheckedUpdateWithoutForecastsInputSchema) ]),
}).strict();

export const ProfileUpdateWithoutForecastsInputSchema: z.ZodType<Prisma.ProfileUpdateWithoutForecastsInput> = z.object({
  createdAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  slackId: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  slackTeamId: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  user: z.lazy(() => UserUpdateOneRequiredWithoutProfilesNestedInputSchema).optional(),
  questions: z.lazy(() => QuestionUpdateManyWithoutProfileNestedInputSchema).optional(),
  resolutionMessages: z.lazy(() => ResolutionSlackMessageUpdateManyWithoutProfileNestedInputSchema).optional(),
  target: z.lazy(() => TargetUpdateOneWithoutProfileNestedInputSchema).optional()
}).strict();

export const ProfileUncheckedUpdateWithoutForecastsInputSchema: z.ZodType<Prisma.ProfileUncheckedUpdateWithoutForecastsInput> = z.object({
  id: z.union([ z.number().int(),z.lazy(() => IntFieldUpdateOperationsInputSchema) ]).optional(),
  createdAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  slackId: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  slackTeamId: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  userId: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  questions: z.lazy(() => QuestionUncheckedUpdateManyWithoutProfileNestedInputSchema).optional(),
  resolutionMessages: z.lazy(() => ResolutionSlackMessageUncheckedUpdateManyWithoutProfileNestedInputSchema).optional(),
  target: z.lazy(() => TargetUncheckedUpdateOneWithoutProfileNestedInputSchema).optional()
}).strict();

export const QuestionUpsertWithoutForecastsInputSchema: z.ZodType<Prisma.QuestionUpsertWithoutForecastsInput> = z.object({
  update: z.union([ z.lazy(() => QuestionUpdateWithoutForecastsInputSchema),z.lazy(() => QuestionUncheckedUpdateWithoutForecastsInputSchema) ]),
  create: z.union([ z.lazy(() => QuestionCreateWithoutForecastsInputSchema),z.lazy(() => QuestionUncheckedCreateWithoutForecastsInputSchema) ]),
  where: z.lazy(() => QuestionWhereInputSchema).optional()
}).strict();

export const QuestionUpdateToOneWithWhereWithoutForecastsInputSchema: z.ZodType<Prisma.QuestionUpdateToOneWithWhereWithoutForecastsInput> = z.object({
  where: z.lazy(() => QuestionWhereInputSchema).optional(),
  data: z.union([ z.lazy(() => QuestionUpdateWithoutForecastsInputSchema),z.lazy(() => QuestionUncheckedUpdateWithoutForecastsInputSchema) ]),
}).strict();

export const QuestionUpdateWithoutForecastsInputSchema: z.ZodType<Prisma.QuestionUpdateWithoutForecastsInput> = z.object({
  id: z.union([ z.string().cuid(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  createdAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  comment: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  title: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  type: z.union([ z.lazy(() => QuestionTypeSchema),z.lazy(() => EnumQuestionTypeFieldUpdateOperationsInputSchema) ]).optional(),
  resolveBy: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  resolved: z.union([ z.boolean(),z.lazy(() => BoolFieldUpdateOperationsInputSchema) ]).optional(),
  pingedForResolution: z.union([ z.boolean(),z.lazy(() => BoolFieldUpdateOperationsInputSchema) ]).optional(),
  resolution: z.union([ z.lazy(() => ResolutionSchema),z.lazy(() => NullableEnumResolutionFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  resolvedAt: z.union([ z.coerce.date(),z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  notes: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  hideForecastsUntil: z.union([ z.coerce.date(),z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  hideForecastsUntilPrediction: z.union([ z.boolean(),z.lazy(() => NullableBoolFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  sharedPublicly: z.union([ z.boolean(),z.lazy(() => BoolFieldUpdateOperationsInputSchema) ]).optional(),
  unlisted: z.union([ z.boolean(),z.lazy(() => BoolFieldUpdateOperationsInputSchema) ]).optional(),
  exclusiveAnswers: z.union([ z.boolean(),z.lazy(() => NullableBoolFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  options: z.lazy(() => QuestionOptionUpdateManyWithoutQuestionNestedInputSchema).optional(),
  pingResolveMessages: z.lazy(() => PingSlackMessageUpdateManyWithoutQuestionNestedInputSchema).optional(),
  profile: z.lazy(() => ProfileUpdateOneWithoutQuestionsNestedInputSchema).optional(),
  user: z.lazy(() => UserUpdateOneRequiredWithoutQuestionsNestedInputSchema).optional(),
  sharedWith: z.lazy(() => UserUpdateManyWithoutQuestionsSharedWithNestedInputSchema).optional(),
  sharedWithLists: z.lazy(() => UserListUpdateManyWithoutQuestionsNestedInputSchema).optional(),
  questionScores: z.lazy(() => QuestionScoreUpdateManyWithoutQuestionNestedInputSchema).optional(),
  questionMessages: z.lazy(() => QuestionSlackMessageUpdateManyWithoutQuestionNestedInputSchema).optional(),
  resolutionMessages: z.lazy(() => ResolutionSlackMessageUpdateManyWithoutQuestionNestedInputSchema).optional(),
  comments: z.lazy(() => CommentUpdateManyWithoutQuestionNestedInputSchema).optional(),
  tags: z.lazy(() => TagUpdateManyWithoutQuestionsNestedInputSchema).optional(),
  tournaments: z.lazy(() => TournamentUpdateManyWithoutQuestionsNestedInputSchema).optional(),
  notifications: z.lazy(() => NotificationUpdateManyWithoutQuestionNestedInputSchema).optional()
}).strict();

export const QuestionUncheckedUpdateWithoutForecastsInputSchema: z.ZodType<Prisma.QuestionUncheckedUpdateWithoutForecastsInput> = z.object({
  id: z.union([ z.string().cuid(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  createdAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  comment: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  profileId: z.union([ z.number().int(),z.lazy(() => NullableIntFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  title: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  type: z.union([ z.lazy(() => QuestionTypeSchema),z.lazy(() => EnumQuestionTypeFieldUpdateOperationsInputSchema) ]).optional(),
  resolveBy: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  resolved: z.union([ z.boolean(),z.lazy(() => BoolFieldUpdateOperationsInputSchema) ]).optional(),
  pingedForResolution: z.union([ z.boolean(),z.lazy(() => BoolFieldUpdateOperationsInputSchema) ]).optional(),
  resolution: z.union([ z.lazy(() => ResolutionSchema),z.lazy(() => NullableEnumResolutionFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  resolvedAt: z.union([ z.coerce.date(),z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  notes: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  hideForecastsUntil: z.union([ z.coerce.date(),z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  hideForecastsUntilPrediction: z.union([ z.boolean(),z.lazy(() => NullableBoolFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  userId: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  sharedPublicly: z.union([ z.boolean(),z.lazy(() => BoolFieldUpdateOperationsInputSchema) ]).optional(),
  unlisted: z.union([ z.boolean(),z.lazy(() => BoolFieldUpdateOperationsInputSchema) ]).optional(),
  exclusiveAnswers: z.union([ z.boolean(),z.lazy(() => NullableBoolFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  options: z.lazy(() => QuestionOptionUncheckedUpdateManyWithoutQuestionNestedInputSchema).optional(),
  pingResolveMessages: z.lazy(() => PingSlackMessageUncheckedUpdateManyWithoutQuestionNestedInputSchema).optional(),
  sharedWith: z.lazy(() => UserUncheckedUpdateManyWithoutQuestionsSharedWithNestedInputSchema).optional(),
  sharedWithLists: z.lazy(() => UserListUncheckedUpdateManyWithoutQuestionsNestedInputSchema).optional(),
  questionScores: z.lazy(() => QuestionScoreUncheckedUpdateManyWithoutQuestionNestedInputSchema).optional(),
  questionMessages: z.lazy(() => QuestionSlackMessageUncheckedUpdateManyWithoutQuestionNestedInputSchema).optional(),
  resolutionMessages: z.lazy(() => ResolutionSlackMessageUncheckedUpdateManyWithoutQuestionNestedInputSchema).optional(),
  comments: z.lazy(() => CommentUncheckedUpdateManyWithoutQuestionNestedInputSchema).optional(),
  tags: z.lazy(() => TagUncheckedUpdateManyWithoutQuestionsNestedInputSchema).optional(),
  tournaments: z.lazy(() => TournamentUncheckedUpdateManyWithoutQuestionsNestedInputSchema).optional(),
  notifications: z.lazy(() => NotificationUncheckedUpdateManyWithoutQuestionNestedInputSchema).optional()
}).strict();

export const UserUpsertWithoutForecastsInputSchema: z.ZodType<Prisma.UserUpsertWithoutForecastsInput> = z.object({
  update: z.union([ z.lazy(() => UserUpdateWithoutForecastsInputSchema),z.lazy(() => UserUncheckedUpdateWithoutForecastsInputSchema) ]),
  create: z.union([ z.lazy(() => UserCreateWithoutForecastsInputSchema),z.lazy(() => UserUncheckedCreateWithoutForecastsInputSchema) ]),
  where: z.lazy(() => UserWhereInputSchema).optional()
}).strict();

export const UserUpdateToOneWithWhereWithoutForecastsInputSchema: z.ZodType<Prisma.UserUpdateToOneWithWhereWithoutForecastsInput> = z.object({
  where: z.lazy(() => UserWhereInputSchema).optional(),
  data: z.union([ z.lazy(() => UserUpdateWithoutForecastsInputSchema),z.lazy(() => UserUncheckedUpdateWithoutForecastsInputSchema) ]),
}).strict();

export const UserUpdateWithoutForecastsInputSchema: z.ZodType<Prisma.UserUpdateWithoutForecastsInput> = z.object({
  id: z.union([ z.string().cuid(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  name: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  createdAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  email: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  image: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  staleReminder: z.union([ z.boolean(),z.lazy(() => BoolFieldUpdateOperationsInputSchema) ]).optional(),
  unsubscribedFromEmailsAt: z.union([ z.coerce.date(),z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  apiKey: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  discordUserId: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  emailVerified: z.union([ z.coerce.date(),z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  profiles: z.lazy(() => ProfileUpdateManyWithoutUserNestedInputSchema).optional(),
  questions: z.lazy(() => QuestionUpdateManyWithoutUserNestedInputSchema).optional(),
  questionScores: z.lazy(() => QuestionScoreUpdateManyWithoutUserNestedInputSchema).optional(),
  questionsSharedWith: z.lazy(() => QuestionUpdateManyWithoutSharedWithNestedInputSchema).optional(),
  comments: z.lazy(() => CommentUpdateManyWithoutUserNestedInputSchema).optional(),
  target: z.lazy(() => TargetUpdateOneWithoutUserNestedInputSchema).optional(),
  authorOfLists: z.lazy(() => UserListUpdateManyWithoutAuthorNestedInputSchema).optional(),
  memberOfLists: z.lazy(() => UserListUpdateManyWithoutUsersNestedInputSchema).optional(),
  tags: z.lazy(() => TagUpdateManyWithoutUserNestedInputSchema).optional(),
  tournaments: z.lazy(() => TournamentUpdateManyWithoutAuthorNestedInputSchema).optional(),
  notifications: z.lazy(() => NotificationUpdateManyWithoutUserNestedInputSchema).optional(),
  questionOptions: z.lazy(() => QuestionOptionUpdateManyWithoutUserNestedInputSchema).optional(),
  accounts: z.lazy(() => AccountUpdateManyWithoutUserNestedInputSchema).optional()
}).strict();

export const UserUncheckedUpdateWithoutForecastsInputSchema: z.ZodType<Prisma.UserUncheckedUpdateWithoutForecastsInput> = z.object({
  id: z.union([ z.string().cuid(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  name: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  createdAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  email: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  image: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  staleReminder: z.union([ z.boolean(),z.lazy(() => BoolFieldUpdateOperationsInputSchema) ]).optional(),
  unsubscribedFromEmailsAt: z.union([ z.coerce.date(),z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  apiKey: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  discordUserId: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  emailVerified: z.union([ z.coerce.date(),z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  profiles: z.lazy(() => ProfileUncheckedUpdateManyWithoutUserNestedInputSchema).optional(),
  questions: z.lazy(() => QuestionUncheckedUpdateManyWithoutUserNestedInputSchema).optional(),
  questionScores: z.lazy(() => QuestionScoreUncheckedUpdateManyWithoutUserNestedInputSchema).optional(),
  questionsSharedWith: z.lazy(() => QuestionUncheckedUpdateManyWithoutSharedWithNestedInputSchema).optional(),
  comments: z.lazy(() => CommentUncheckedUpdateManyWithoutUserNestedInputSchema).optional(),
  target: z.lazy(() => TargetUncheckedUpdateOneWithoutUserNestedInputSchema).optional(),
  authorOfLists: z.lazy(() => UserListUncheckedUpdateManyWithoutAuthorNestedInputSchema).optional(),
  memberOfLists: z.lazy(() => UserListUncheckedUpdateManyWithoutUsersNestedInputSchema).optional(),
  tags: z.lazy(() => TagUncheckedUpdateManyWithoutUserNestedInputSchema).optional(),
  tournaments: z.lazy(() => TournamentUncheckedUpdateManyWithoutAuthorNestedInputSchema).optional(),
  notifications: z.lazy(() => NotificationUncheckedUpdateManyWithoutUserNestedInputSchema).optional(),
  questionOptions: z.lazy(() => QuestionOptionUncheckedUpdateManyWithoutUserNestedInputSchema).optional(),
  accounts: z.lazy(() => AccountUncheckedUpdateManyWithoutUserNestedInputSchema).optional()
}).strict();

export const QuestionCreateWithoutQuestionScoresInputSchema: z.ZodType<Prisma.QuestionCreateWithoutQuestionScoresInput> = z.object({
  id: z.string().cuid().optional(),
  createdAt: z.coerce.date().optional(),
  comment: z.string().optional().nullable(),
  title: z.string(),
  type: z.lazy(() => QuestionTypeSchema).optional(),
  resolveBy: z.coerce.date(),
  resolved: z.boolean().optional(),
  pingedForResolution: z.boolean().optional(),
  resolution: z.lazy(() => ResolutionSchema).optional().nullable(),
  resolvedAt: z.coerce.date().optional().nullable(),
  notes: z.string().optional().nullable(),
  hideForecastsUntil: z.coerce.date().optional().nullable(),
  hideForecastsUntilPrediction: z.boolean().optional().nullable(),
  sharedPublicly: z.boolean().optional(),
  unlisted: z.boolean().optional(),
  exclusiveAnswers: z.boolean().optional().nullable(),
  options: z.lazy(() => QuestionOptionCreateNestedManyWithoutQuestionInputSchema).optional(),
  forecasts: z.lazy(() => ForecastCreateNestedManyWithoutQuestionInputSchema).optional(),
  pingResolveMessages: z.lazy(() => PingSlackMessageCreateNestedManyWithoutQuestionInputSchema).optional(),
  profile: z.lazy(() => ProfileCreateNestedOneWithoutQuestionsInputSchema).optional(),
  user: z.lazy(() => UserCreateNestedOneWithoutQuestionsInputSchema),
  sharedWith: z.lazy(() => UserCreateNestedManyWithoutQuestionsSharedWithInputSchema).optional(),
  sharedWithLists: z.lazy(() => UserListCreateNestedManyWithoutQuestionsInputSchema).optional(),
  questionMessages: z.lazy(() => QuestionSlackMessageCreateNestedManyWithoutQuestionInputSchema).optional(),
  resolutionMessages: z.lazy(() => ResolutionSlackMessageCreateNestedManyWithoutQuestionInputSchema).optional(),
  comments: z.lazy(() => CommentCreateNestedManyWithoutQuestionInputSchema).optional(),
  tags: z.lazy(() => TagCreateNestedManyWithoutQuestionsInputSchema).optional(),
  tournaments: z.lazy(() => TournamentCreateNestedManyWithoutQuestionsInputSchema).optional(),
  notifications: z.lazy(() => NotificationCreateNestedManyWithoutQuestionInputSchema).optional()
}).strict();

export const QuestionUncheckedCreateWithoutQuestionScoresInputSchema: z.ZodType<Prisma.QuestionUncheckedCreateWithoutQuestionScoresInput> = z.object({
  id: z.string().cuid().optional(),
  createdAt: z.coerce.date().optional(),
  comment: z.string().optional().nullable(),
  profileId: z.number().int().optional().nullable(),
  title: z.string(),
  type: z.lazy(() => QuestionTypeSchema).optional(),
  resolveBy: z.coerce.date(),
  resolved: z.boolean().optional(),
  pingedForResolution: z.boolean().optional(),
  resolution: z.lazy(() => ResolutionSchema).optional().nullable(),
  resolvedAt: z.coerce.date().optional().nullable(),
  notes: z.string().optional().nullable(),
  hideForecastsUntil: z.coerce.date().optional().nullable(),
  hideForecastsUntilPrediction: z.boolean().optional().nullable(),
  userId: z.string(),
  sharedPublicly: z.boolean().optional(),
  unlisted: z.boolean().optional(),
  exclusiveAnswers: z.boolean().optional().nullable(),
  options: z.lazy(() => QuestionOptionUncheckedCreateNestedManyWithoutQuestionInputSchema).optional(),
  forecasts: z.lazy(() => ForecastUncheckedCreateNestedManyWithoutQuestionInputSchema).optional(),
  pingResolveMessages: z.lazy(() => PingSlackMessageUncheckedCreateNestedManyWithoutQuestionInputSchema).optional(),
  sharedWith: z.lazy(() => UserUncheckedCreateNestedManyWithoutQuestionsSharedWithInputSchema).optional(),
  sharedWithLists: z.lazy(() => UserListUncheckedCreateNestedManyWithoutQuestionsInputSchema).optional(),
  questionMessages: z.lazy(() => QuestionSlackMessageUncheckedCreateNestedManyWithoutQuestionInputSchema).optional(),
  resolutionMessages: z.lazy(() => ResolutionSlackMessageUncheckedCreateNestedManyWithoutQuestionInputSchema).optional(),
  comments: z.lazy(() => CommentUncheckedCreateNestedManyWithoutQuestionInputSchema).optional(),
  tags: z.lazy(() => TagUncheckedCreateNestedManyWithoutQuestionsInputSchema).optional(),
  tournaments: z.lazy(() => TournamentUncheckedCreateNestedManyWithoutQuestionsInputSchema).optional(),
  notifications: z.lazy(() => NotificationUncheckedCreateNestedManyWithoutQuestionInputSchema).optional()
}).strict();

export const QuestionCreateOrConnectWithoutQuestionScoresInputSchema: z.ZodType<Prisma.QuestionCreateOrConnectWithoutQuestionScoresInput> = z.object({
  where: z.lazy(() => QuestionWhereUniqueInputSchema),
  create: z.union([ z.lazy(() => QuestionCreateWithoutQuestionScoresInputSchema),z.lazy(() => QuestionUncheckedCreateWithoutQuestionScoresInputSchema) ]),
}).strict();

export const UserCreateWithoutQuestionScoresInputSchema: z.ZodType<Prisma.UserCreateWithoutQuestionScoresInput> = z.object({
  id: z.string().cuid().optional(),
  name: z.string().optional().nullable(),
  createdAt: z.coerce.date().optional(),
  email: z.string(),
  image: z.string().optional().nullable(),
  staleReminder: z.boolean().optional(),
  unsubscribedFromEmailsAt: z.coerce.date().optional().nullable(),
  apiKey: z.string().optional().nullable(),
  discordUserId: z.string().optional().nullable(),
  emailVerified: z.coerce.date().optional().nullable(),
  forecasts: z.lazy(() => ForecastCreateNestedManyWithoutUserInputSchema).optional(),
  profiles: z.lazy(() => ProfileCreateNestedManyWithoutUserInputSchema).optional(),
  questions: z.lazy(() => QuestionCreateNestedManyWithoutUserInputSchema).optional(),
  questionsSharedWith: z.lazy(() => QuestionCreateNestedManyWithoutSharedWithInputSchema).optional(),
  comments: z.lazy(() => CommentCreateNestedManyWithoutUserInputSchema).optional(),
  target: z.lazy(() => TargetCreateNestedOneWithoutUserInputSchema).optional(),
  authorOfLists: z.lazy(() => UserListCreateNestedManyWithoutAuthorInputSchema).optional(),
  memberOfLists: z.lazy(() => UserListCreateNestedManyWithoutUsersInputSchema).optional(),
  tags: z.lazy(() => TagCreateNestedManyWithoutUserInputSchema).optional(),
  tournaments: z.lazy(() => TournamentCreateNestedManyWithoutAuthorInputSchema).optional(),
  notifications: z.lazy(() => NotificationCreateNestedManyWithoutUserInputSchema).optional(),
  questionOptions: z.lazy(() => QuestionOptionCreateNestedManyWithoutUserInputSchema).optional(),
  accounts: z.lazy(() => AccountCreateNestedManyWithoutUserInputSchema).optional()
}).strict();

export const UserUncheckedCreateWithoutQuestionScoresInputSchema: z.ZodType<Prisma.UserUncheckedCreateWithoutQuestionScoresInput> = z.object({
  id: z.string().cuid().optional(),
  name: z.string().optional().nullable(),
  createdAt: z.coerce.date().optional(),
  email: z.string(),
  image: z.string().optional().nullable(),
  staleReminder: z.boolean().optional(),
  unsubscribedFromEmailsAt: z.coerce.date().optional().nullable(),
  apiKey: z.string().optional().nullable(),
  discordUserId: z.string().optional().nullable(),
  emailVerified: z.coerce.date().optional().nullable(),
  forecasts: z.lazy(() => ForecastUncheckedCreateNestedManyWithoutUserInputSchema).optional(),
  profiles: z.lazy(() => ProfileUncheckedCreateNestedManyWithoutUserInputSchema).optional(),
  questions: z.lazy(() => QuestionUncheckedCreateNestedManyWithoutUserInputSchema).optional(),
  questionsSharedWith: z.lazy(() => QuestionUncheckedCreateNestedManyWithoutSharedWithInputSchema).optional(),
  comments: z.lazy(() => CommentUncheckedCreateNestedManyWithoutUserInputSchema).optional(),
  target: z.lazy(() => TargetUncheckedCreateNestedOneWithoutUserInputSchema).optional(),
  authorOfLists: z.lazy(() => UserListUncheckedCreateNestedManyWithoutAuthorInputSchema).optional(),
  memberOfLists: z.lazy(() => UserListUncheckedCreateNestedManyWithoutUsersInputSchema).optional(),
  tags: z.lazy(() => TagUncheckedCreateNestedManyWithoutUserInputSchema).optional(),
  tournaments: z.lazy(() => TournamentUncheckedCreateNestedManyWithoutAuthorInputSchema).optional(),
  notifications: z.lazy(() => NotificationUncheckedCreateNestedManyWithoutUserInputSchema).optional(),
  questionOptions: z.lazy(() => QuestionOptionUncheckedCreateNestedManyWithoutUserInputSchema).optional(),
  accounts: z.lazy(() => AccountUncheckedCreateNestedManyWithoutUserInputSchema).optional()
}).strict();

export const UserCreateOrConnectWithoutQuestionScoresInputSchema: z.ZodType<Prisma.UserCreateOrConnectWithoutQuestionScoresInput> = z.object({
  where: z.lazy(() => UserWhereUniqueInputSchema),
  create: z.union([ z.lazy(() => UserCreateWithoutQuestionScoresInputSchema),z.lazy(() => UserUncheckedCreateWithoutQuestionScoresInputSchema) ]),
}).strict();

export const QuestionOptionCreateWithoutQuestionScoresInputSchema: z.ZodType<Prisma.QuestionOptionCreateWithoutQuestionScoresInput> = z.object({
  id: z.string().cuid().optional(),
  text: z.string(),
  resolution: z.lazy(() => ResolutionSchema).optional().nullable(),
  createdAt: z.coerce.date().optional(),
  resolvedAt: z.coerce.date().optional().nullable(),
  question: z.lazy(() => QuestionCreateNestedOneWithoutOptionsInputSchema),
  forecasts: z.lazy(() => ForecastCreateNestedManyWithoutOptionInputSchema).optional(),
  user: z.lazy(() => UserCreateNestedOneWithoutQuestionOptionsInputSchema)
}).strict();

export const QuestionOptionUncheckedCreateWithoutQuestionScoresInputSchema: z.ZodType<Prisma.QuestionOptionUncheckedCreateWithoutQuestionScoresInput> = z.object({
  id: z.string().cuid().optional(),
  questionId: z.string(),
  text: z.string(),
  resolution: z.lazy(() => ResolutionSchema).optional().nullable(),
  createdAt: z.coerce.date().optional(),
  userId: z.string(),
  resolvedAt: z.coerce.date().optional().nullable(),
  forecasts: z.lazy(() => ForecastUncheckedCreateNestedManyWithoutOptionInputSchema).optional()
}).strict();

export const QuestionOptionCreateOrConnectWithoutQuestionScoresInputSchema: z.ZodType<Prisma.QuestionOptionCreateOrConnectWithoutQuestionScoresInput> = z.object({
  where: z.lazy(() => QuestionOptionWhereUniqueInputSchema),
  create: z.union([ z.lazy(() => QuestionOptionCreateWithoutQuestionScoresInputSchema),z.lazy(() => QuestionOptionUncheckedCreateWithoutQuestionScoresInputSchema) ]),
}).strict();

export const QuestionUpsertWithoutQuestionScoresInputSchema: z.ZodType<Prisma.QuestionUpsertWithoutQuestionScoresInput> = z.object({
  update: z.union([ z.lazy(() => QuestionUpdateWithoutQuestionScoresInputSchema),z.lazy(() => QuestionUncheckedUpdateWithoutQuestionScoresInputSchema) ]),
  create: z.union([ z.lazy(() => QuestionCreateWithoutQuestionScoresInputSchema),z.lazy(() => QuestionUncheckedCreateWithoutQuestionScoresInputSchema) ]),
  where: z.lazy(() => QuestionWhereInputSchema).optional()
}).strict();

export const QuestionUpdateToOneWithWhereWithoutQuestionScoresInputSchema: z.ZodType<Prisma.QuestionUpdateToOneWithWhereWithoutQuestionScoresInput> = z.object({
  where: z.lazy(() => QuestionWhereInputSchema).optional(),
  data: z.union([ z.lazy(() => QuestionUpdateWithoutQuestionScoresInputSchema),z.lazy(() => QuestionUncheckedUpdateWithoutQuestionScoresInputSchema) ]),
}).strict();

export const QuestionUpdateWithoutQuestionScoresInputSchema: z.ZodType<Prisma.QuestionUpdateWithoutQuestionScoresInput> = z.object({
  id: z.union([ z.string().cuid(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  createdAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  comment: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  title: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  type: z.union([ z.lazy(() => QuestionTypeSchema),z.lazy(() => EnumQuestionTypeFieldUpdateOperationsInputSchema) ]).optional(),
  resolveBy: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  resolved: z.union([ z.boolean(),z.lazy(() => BoolFieldUpdateOperationsInputSchema) ]).optional(),
  pingedForResolution: z.union([ z.boolean(),z.lazy(() => BoolFieldUpdateOperationsInputSchema) ]).optional(),
  resolution: z.union([ z.lazy(() => ResolutionSchema),z.lazy(() => NullableEnumResolutionFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  resolvedAt: z.union([ z.coerce.date(),z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  notes: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  hideForecastsUntil: z.union([ z.coerce.date(),z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  hideForecastsUntilPrediction: z.union([ z.boolean(),z.lazy(() => NullableBoolFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  sharedPublicly: z.union([ z.boolean(),z.lazy(() => BoolFieldUpdateOperationsInputSchema) ]).optional(),
  unlisted: z.union([ z.boolean(),z.lazy(() => BoolFieldUpdateOperationsInputSchema) ]).optional(),
  exclusiveAnswers: z.union([ z.boolean(),z.lazy(() => NullableBoolFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  options: z.lazy(() => QuestionOptionUpdateManyWithoutQuestionNestedInputSchema).optional(),
  forecasts: z.lazy(() => ForecastUpdateManyWithoutQuestionNestedInputSchema).optional(),
  pingResolveMessages: z.lazy(() => PingSlackMessageUpdateManyWithoutQuestionNestedInputSchema).optional(),
  profile: z.lazy(() => ProfileUpdateOneWithoutQuestionsNestedInputSchema).optional(),
  user: z.lazy(() => UserUpdateOneRequiredWithoutQuestionsNestedInputSchema).optional(),
  sharedWith: z.lazy(() => UserUpdateManyWithoutQuestionsSharedWithNestedInputSchema).optional(),
  sharedWithLists: z.lazy(() => UserListUpdateManyWithoutQuestionsNestedInputSchema).optional(),
  questionMessages: z.lazy(() => QuestionSlackMessageUpdateManyWithoutQuestionNestedInputSchema).optional(),
  resolutionMessages: z.lazy(() => ResolutionSlackMessageUpdateManyWithoutQuestionNestedInputSchema).optional(),
  comments: z.lazy(() => CommentUpdateManyWithoutQuestionNestedInputSchema).optional(),
  tags: z.lazy(() => TagUpdateManyWithoutQuestionsNestedInputSchema).optional(),
  tournaments: z.lazy(() => TournamentUpdateManyWithoutQuestionsNestedInputSchema).optional(),
  notifications: z.lazy(() => NotificationUpdateManyWithoutQuestionNestedInputSchema).optional()
}).strict();

export const QuestionUncheckedUpdateWithoutQuestionScoresInputSchema: z.ZodType<Prisma.QuestionUncheckedUpdateWithoutQuestionScoresInput> = z.object({
  id: z.union([ z.string().cuid(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  createdAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  comment: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  profileId: z.union([ z.number().int(),z.lazy(() => NullableIntFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  title: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  type: z.union([ z.lazy(() => QuestionTypeSchema),z.lazy(() => EnumQuestionTypeFieldUpdateOperationsInputSchema) ]).optional(),
  resolveBy: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  resolved: z.union([ z.boolean(),z.lazy(() => BoolFieldUpdateOperationsInputSchema) ]).optional(),
  pingedForResolution: z.union([ z.boolean(),z.lazy(() => BoolFieldUpdateOperationsInputSchema) ]).optional(),
  resolution: z.union([ z.lazy(() => ResolutionSchema),z.lazy(() => NullableEnumResolutionFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  resolvedAt: z.union([ z.coerce.date(),z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  notes: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  hideForecastsUntil: z.union([ z.coerce.date(),z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  hideForecastsUntilPrediction: z.union([ z.boolean(),z.lazy(() => NullableBoolFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  userId: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  sharedPublicly: z.union([ z.boolean(),z.lazy(() => BoolFieldUpdateOperationsInputSchema) ]).optional(),
  unlisted: z.union([ z.boolean(),z.lazy(() => BoolFieldUpdateOperationsInputSchema) ]).optional(),
  exclusiveAnswers: z.union([ z.boolean(),z.lazy(() => NullableBoolFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  options: z.lazy(() => QuestionOptionUncheckedUpdateManyWithoutQuestionNestedInputSchema).optional(),
  forecasts: z.lazy(() => ForecastUncheckedUpdateManyWithoutQuestionNestedInputSchema).optional(),
  pingResolveMessages: z.lazy(() => PingSlackMessageUncheckedUpdateManyWithoutQuestionNestedInputSchema).optional(),
  sharedWith: z.lazy(() => UserUncheckedUpdateManyWithoutQuestionsSharedWithNestedInputSchema).optional(),
  sharedWithLists: z.lazy(() => UserListUncheckedUpdateManyWithoutQuestionsNestedInputSchema).optional(),
  questionMessages: z.lazy(() => QuestionSlackMessageUncheckedUpdateManyWithoutQuestionNestedInputSchema).optional(),
  resolutionMessages: z.lazy(() => ResolutionSlackMessageUncheckedUpdateManyWithoutQuestionNestedInputSchema).optional(),
  comments: z.lazy(() => CommentUncheckedUpdateManyWithoutQuestionNestedInputSchema).optional(),
  tags: z.lazy(() => TagUncheckedUpdateManyWithoutQuestionsNestedInputSchema).optional(),
  tournaments: z.lazy(() => TournamentUncheckedUpdateManyWithoutQuestionsNestedInputSchema).optional(),
  notifications: z.lazy(() => NotificationUncheckedUpdateManyWithoutQuestionNestedInputSchema).optional()
}).strict();

export const UserUpsertWithoutQuestionScoresInputSchema: z.ZodType<Prisma.UserUpsertWithoutQuestionScoresInput> = z.object({
  update: z.union([ z.lazy(() => UserUpdateWithoutQuestionScoresInputSchema),z.lazy(() => UserUncheckedUpdateWithoutQuestionScoresInputSchema) ]),
  create: z.union([ z.lazy(() => UserCreateWithoutQuestionScoresInputSchema),z.lazy(() => UserUncheckedCreateWithoutQuestionScoresInputSchema) ]),
  where: z.lazy(() => UserWhereInputSchema).optional()
}).strict();

export const UserUpdateToOneWithWhereWithoutQuestionScoresInputSchema: z.ZodType<Prisma.UserUpdateToOneWithWhereWithoutQuestionScoresInput> = z.object({
  where: z.lazy(() => UserWhereInputSchema).optional(),
  data: z.union([ z.lazy(() => UserUpdateWithoutQuestionScoresInputSchema),z.lazy(() => UserUncheckedUpdateWithoutQuestionScoresInputSchema) ]),
}).strict();

export const UserUpdateWithoutQuestionScoresInputSchema: z.ZodType<Prisma.UserUpdateWithoutQuestionScoresInput> = z.object({
  id: z.union([ z.string().cuid(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  name: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  createdAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  email: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  image: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  staleReminder: z.union([ z.boolean(),z.lazy(() => BoolFieldUpdateOperationsInputSchema) ]).optional(),
  unsubscribedFromEmailsAt: z.union([ z.coerce.date(),z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  apiKey: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  discordUserId: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  emailVerified: z.union([ z.coerce.date(),z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  forecasts: z.lazy(() => ForecastUpdateManyWithoutUserNestedInputSchema).optional(),
  profiles: z.lazy(() => ProfileUpdateManyWithoutUserNestedInputSchema).optional(),
  questions: z.lazy(() => QuestionUpdateManyWithoutUserNestedInputSchema).optional(),
  questionsSharedWith: z.lazy(() => QuestionUpdateManyWithoutSharedWithNestedInputSchema).optional(),
  comments: z.lazy(() => CommentUpdateManyWithoutUserNestedInputSchema).optional(),
  target: z.lazy(() => TargetUpdateOneWithoutUserNestedInputSchema).optional(),
  authorOfLists: z.lazy(() => UserListUpdateManyWithoutAuthorNestedInputSchema).optional(),
  memberOfLists: z.lazy(() => UserListUpdateManyWithoutUsersNestedInputSchema).optional(),
  tags: z.lazy(() => TagUpdateManyWithoutUserNestedInputSchema).optional(),
  tournaments: z.lazy(() => TournamentUpdateManyWithoutAuthorNestedInputSchema).optional(),
  notifications: z.lazy(() => NotificationUpdateManyWithoutUserNestedInputSchema).optional(),
  questionOptions: z.lazy(() => QuestionOptionUpdateManyWithoutUserNestedInputSchema).optional(),
  accounts: z.lazy(() => AccountUpdateManyWithoutUserNestedInputSchema).optional()
}).strict();

export const UserUncheckedUpdateWithoutQuestionScoresInputSchema: z.ZodType<Prisma.UserUncheckedUpdateWithoutQuestionScoresInput> = z.object({
  id: z.union([ z.string().cuid(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  name: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  createdAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  email: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  image: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  staleReminder: z.union([ z.boolean(),z.lazy(() => BoolFieldUpdateOperationsInputSchema) ]).optional(),
  unsubscribedFromEmailsAt: z.union([ z.coerce.date(),z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  apiKey: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  discordUserId: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  emailVerified: z.union([ z.coerce.date(),z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  forecasts: z.lazy(() => ForecastUncheckedUpdateManyWithoutUserNestedInputSchema).optional(),
  profiles: z.lazy(() => ProfileUncheckedUpdateManyWithoutUserNestedInputSchema).optional(),
  questions: z.lazy(() => QuestionUncheckedUpdateManyWithoutUserNestedInputSchema).optional(),
  questionsSharedWith: z.lazy(() => QuestionUncheckedUpdateManyWithoutSharedWithNestedInputSchema).optional(),
  comments: z.lazy(() => CommentUncheckedUpdateManyWithoutUserNestedInputSchema).optional(),
  target: z.lazy(() => TargetUncheckedUpdateOneWithoutUserNestedInputSchema).optional(),
  authorOfLists: z.lazy(() => UserListUncheckedUpdateManyWithoutAuthorNestedInputSchema).optional(),
  memberOfLists: z.lazy(() => UserListUncheckedUpdateManyWithoutUsersNestedInputSchema).optional(),
  tags: z.lazy(() => TagUncheckedUpdateManyWithoutUserNestedInputSchema).optional(),
  tournaments: z.lazy(() => TournamentUncheckedUpdateManyWithoutAuthorNestedInputSchema).optional(),
  notifications: z.lazy(() => NotificationUncheckedUpdateManyWithoutUserNestedInputSchema).optional(),
  questionOptions: z.lazy(() => QuestionOptionUncheckedUpdateManyWithoutUserNestedInputSchema).optional(),
  accounts: z.lazy(() => AccountUncheckedUpdateManyWithoutUserNestedInputSchema).optional()
}).strict();

export const QuestionOptionUpsertWithoutQuestionScoresInputSchema: z.ZodType<Prisma.QuestionOptionUpsertWithoutQuestionScoresInput> = z.object({
  update: z.union([ z.lazy(() => QuestionOptionUpdateWithoutQuestionScoresInputSchema),z.lazy(() => QuestionOptionUncheckedUpdateWithoutQuestionScoresInputSchema) ]),
  create: z.union([ z.lazy(() => QuestionOptionCreateWithoutQuestionScoresInputSchema),z.lazy(() => QuestionOptionUncheckedCreateWithoutQuestionScoresInputSchema) ]),
  where: z.lazy(() => QuestionOptionWhereInputSchema).optional()
}).strict();

export const QuestionOptionUpdateToOneWithWhereWithoutQuestionScoresInputSchema: z.ZodType<Prisma.QuestionOptionUpdateToOneWithWhereWithoutQuestionScoresInput> = z.object({
  where: z.lazy(() => QuestionOptionWhereInputSchema).optional(),
  data: z.union([ z.lazy(() => QuestionOptionUpdateWithoutQuestionScoresInputSchema),z.lazy(() => QuestionOptionUncheckedUpdateWithoutQuestionScoresInputSchema) ]),
}).strict();

export const QuestionOptionUpdateWithoutQuestionScoresInputSchema: z.ZodType<Prisma.QuestionOptionUpdateWithoutQuestionScoresInput> = z.object({
  id: z.union([ z.string().cuid(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  text: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  resolution: z.union([ z.lazy(() => ResolutionSchema),z.lazy(() => NullableEnumResolutionFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  createdAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  resolvedAt: z.union([ z.coerce.date(),z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  question: z.lazy(() => QuestionUpdateOneRequiredWithoutOptionsNestedInputSchema).optional(),
  forecasts: z.lazy(() => ForecastUpdateManyWithoutOptionNestedInputSchema).optional(),
  user: z.lazy(() => UserUpdateOneRequiredWithoutQuestionOptionsNestedInputSchema).optional()
}).strict();

export const QuestionOptionUncheckedUpdateWithoutQuestionScoresInputSchema: z.ZodType<Prisma.QuestionOptionUncheckedUpdateWithoutQuestionScoresInput> = z.object({
  id: z.union([ z.string().cuid(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  questionId: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  text: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  resolution: z.union([ z.lazy(() => ResolutionSchema),z.lazy(() => NullableEnumResolutionFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  createdAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  userId: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  resolvedAt: z.union([ z.coerce.date(),z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  forecasts: z.lazy(() => ForecastUncheckedUpdateManyWithoutOptionNestedInputSchema).optional()
}).strict();

export const QuestionCreateWithoutOptionsInputSchema: z.ZodType<Prisma.QuestionCreateWithoutOptionsInput> = z.object({
  id: z.string().cuid().optional(),
  createdAt: z.coerce.date().optional(),
  comment: z.string().optional().nullable(),
  title: z.string(),
  type: z.lazy(() => QuestionTypeSchema).optional(),
  resolveBy: z.coerce.date(),
  resolved: z.boolean().optional(),
  pingedForResolution: z.boolean().optional(),
  resolution: z.lazy(() => ResolutionSchema).optional().nullable(),
  resolvedAt: z.coerce.date().optional().nullable(),
  notes: z.string().optional().nullable(),
  hideForecastsUntil: z.coerce.date().optional().nullable(),
  hideForecastsUntilPrediction: z.boolean().optional().nullable(),
  sharedPublicly: z.boolean().optional(),
  unlisted: z.boolean().optional(),
  exclusiveAnswers: z.boolean().optional().nullable(),
  forecasts: z.lazy(() => ForecastCreateNestedManyWithoutQuestionInputSchema).optional(),
  pingResolveMessages: z.lazy(() => PingSlackMessageCreateNestedManyWithoutQuestionInputSchema).optional(),
  profile: z.lazy(() => ProfileCreateNestedOneWithoutQuestionsInputSchema).optional(),
  user: z.lazy(() => UserCreateNestedOneWithoutQuestionsInputSchema),
  sharedWith: z.lazy(() => UserCreateNestedManyWithoutQuestionsSharedWithInputSchema).optional(),
  sharedWithLists: z.lazy(() => UserListCreateNestedManyWithoutQuestionsInputSchema).optional(),
  questionScores: z.lazy(() => QuestionScoreCreateNestedManyWithoutQuestionInputSchema).optional(),
  questionMessages: z.lazy(() => QuestionSlackMessageCreateNestedManyWithoutQuestionInputSchema).optional(),
  resolutionMessages: z.lazy(() => ResolutionSlackMessageCreateNestedManyWithoutQuestionInputSchema).optional(),
  comments: z.lazy(() => CommentCreateNestedManyWithoutQuestionInputSchema).optional(),
  tags: z.lazy(() => TagCreateNestedManyWithoutQuestionsInputSchema).optional(),
  tournaments: z.lazy(() => TournamentCreateNestedManyWithoutQuestionsInputSchema).optional(),
  notifications: z.lazy(() => NotificationCreateNestedManyWithoutQuestionInputSchema).optional()
}).strict();

export const QuestionUncheckedCreateWithoutOptionsInputSchema: z.ZodType<Prisma.QuestionUncheckedCreateWithoutOptionsInput> = z.object({
  id: z.string().cuid().optional(),
  createdAt: z.coerce.date().optional(),
  comment: z.string().optional().nullable(),
  profileId: z.number().int().optional().nullable(),
  title: z.string(),
  type: z.lazy(() => QuestionTypeSchema).optional(),
  resolveBy: z.coerce.date(),
  resolved: z.boolean().optional(),
  pingedForResolution: z.boolean().optional(),
  resolution: z.lazy(() => ResolutionSchema).optional().nullable(),
  resolvedAt: z.coerce.date().optional().nullable(),
  notes: z.string().optional().nullable(),
  hideForecastsUntil: z.coerce.date().optional().nullable(),
  hideForecastsUntilPrediction: z.boolean().optional().nullable(),
  userId: z.string(),
  sharedPublicly: z.boolean().optional(),
  unlisted: z.boolean().optional(),
  exclusiveAnswers: z.boolean().optional().nullable(),
  forecasts: z.lazy(() => ForecastUncheckedCreateNestedManyWithoutQuestionInputSchema).optional(),
  pingResolveMessages: z.lazy(() => PingSlackMessageUncheckedCreateNestedManyWithoutQuestionInputSchema).optional(),
  sharedWith: z.lazy(() => UserUncheckedCreateNestedManyWithoutQuestionsSharedWithInputSchema).optional(),
  sharedWithLists: z.lazy(() => UserListUncheckedCreateNestedManyWithoutQuestionsInputSchema).optional(),
  questionScores: z.lazy(() => QuestionScoreUncheckedCreateNestedManyWithoutQuestionInputSchema).optional(),
  questionMessages: z.lazy(() => QuestionSlackMessageUncheckedCreateNestedManyWithoutQuestionInputSchema).optional(),
  resolutionMessages: z.lazy(() => ResolutionSlackMessageUncheckedCreateNestedManyWithoutQuestionInputSchema).optional(),
  comments: z.lazy(() => CommentUncheckedCreateNestedManyWithoutQuestionInputSchema).optional(),
  tags: z.lazy(() => TagUncheckedCreateNestedManyWithoutQuestionsInputSchema).optional(),
  tournaments: z.lazy(() => TournamentUncheckedCreateNestedManyWithoutQuestionsInputSchema).optional(),
  notifications: z.lazy(() => NotificationUncheckedCreateNestedManyWithoutQuestionInputSchema).optional()
}).strict();

export const QuestionCreateOrConnectWithoutOptionsInputSchema: z.ZodType<Prisma.QuestionCreateOrConnectWithoutOptionsInput> = z.object({
  where: z.lazy(() => QuestionWhereUniqueInputSchema),
  create: z.union([ z.lazy(() => QuestionCreateWithoutOptionsInputSchema),z.lazy(() => QuestionUncheckedCreateWithoutOptionsInputSchema) ]),
}).strict();

export const ForecastCreateWithoutOptionInputSchema: z.ZodType<Prisma.ForecastCreateWithoutOptionInput> = z.object({
  createdAt: z.coerce.date().optional(),
  comment: z.string().optional().nullable(),
  forecast: z.union([z.number(),z.string(),z.instanceof(Decimal),z.instanceof(Prisma.Decimal),DecimalJsLikeSchema,]).refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' }),
  profile: z.lazy(() => ProfileCreateNestedOneWithoutForecastsInputSchema).optional(),
  question: z.lazy(() => QuestionCreateNestedOneWithoutForecastsInputSchema),
  user: z.lazy(() => UserCreateNestedOneWithoutForecastsInputSchema)
}).strict();

export const ForecastUncheckedCreateWithoutOptionInputSchema: z.ZodType<Prisma.ForecastUncheckedCreateWithoutOptionInput> = z.object({
  id: z.number().int().optional(),
  createdAt: z.coerce.date().optional(),
  comment: z.string().optional().nullable(),
  forecast: z.union([z.number(),z.string(),z.instanceof(Decimal),z.instanceof(Prisma.Decimal),DecimalJsLikeSchema,]).refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' }),
  profileId: z.number().int().optional().nullable(),
  questionId: z.string(),
  userId: z.string()
}).strict();

export const ForecastCreateOrConnectWithoutOptionInputSchema: z.ZodType<Prisma.ForecastCreateOrConnectWithoutOptionInput> = z.object({
  where: z.lazy(() => ForecastWhereUniqueInputSchema),
  create: z.union([ z.lazy(() => ForecastCreateWithoutOptionInputSchema),z.lazy(() => ForecastUncheckedCreateWithoutOptionInputSchema) ]),
}).strict();

export const ForecastCreateManyOptionInputEnvelopeSchema: z.ZodType<Prisma.ForecastCreateManyOptionInputEnvelope> = z.object({
  data: z.union([ z.lazy(() => ForecastCreateManyOptionInputSchema),z.lazy(() => ForecastCreateManyOptionInputSchema).array() ]),
  skipDuplicates: z.boolean().optional()
}).strict();

export const UserCreateWithoutQuestionOptionsInputSchema: z.ZodType<Prisma.UserCreateWithoutQuestionOptionsInput> = z.object({
  id: z.string().cuid().optional(),
  name: z.string().optional().nullable(),
  createdAt: z.coerce.date().optional(),
  email: z.string(),
  image: z.string().optional().nullable(),
  staleReminder: z.boolean().optional(),
  unsubscribedFromEmailsAt: z.coerce.date().optional().nullable(),
  apiKey: z.string().optional().nullable(),
  discordUserId: z.string().optional().nullable(),
  emailVerified: z.coerce.date().optional().nullable(),
  forecasts: z.lazy(() => ForecastCreateNestedManyWithoutUserInputSchema).optional(),
  profiles: z.lazy(() => ProfileCreateNestedManyWithoutUserInputSchema).optional(),
  questions: z.lazy(() => QuestionCreateNestedManyWithoutUserInputSchema).optional(),
  questionScores: z.lazy(() => QuestionScoreCreateNestedManyWithoutUserInputSchema).optional(),
  questionsSharedWith: z.lazy(() => QuestionCreateNestedManyWithoutSharedWithInputSchema).optional(),
  comments: z.lazy(() => CommentCreateNestedManyWithoutUserInputSchema).optional(),
  target: z.lazy(() => TargetCreateNestedOneWithoutUserInputSchema).optional(),
  authorOfLists: z.lazy(() => UserListCreateNestedManyWithoutAuthorInputSchema).optional(),
  memberOfLists: z.lazy(() => UserListCreateNestedManyWithoutUsersInputSchema).optional(),
  tags: z.lazy(() => TagCreateNestedManyWithoutUserInputSchema).optional(),
  tournaments: z.lazy(() => TournamentCreateNestedManyWithoutAuthorInputSchema).optional(),
  notifications: z.lazy(() => NotificationCreateNestedManyWithoutUserInputSchema).optional(),
  accounts: z.lazy(() => AccountCreateNestedManyWithoutUserInputSchema).optional()
}).strict();

export const UserUncheckedCreateWithoutQuestionOptionsInputSchema: z.ZodType<Prisma.UserUncheckedCreateWithoutQuestionOptionsInput> = z.object({
  id: z.string().cuid().optional(),
  name: z.string().optional().nullable(),
  createdAt: z.coerce.date().optional(),
  email: z.string(),
  image: z.string().optional().nullable(),
  staleReminder: z.boolean().optional(),
  unsubscribedFromEmailsAt: z.coerce.date().optional().nullable(),
  apiKey: z.string().optional().nullable(),
  discordUserId: z.string().optional().nullable(),
  emailVerified: z.coerce.date().optional().nullable(),
  forecasts: z.lazy(() => ForecastUncheckedCreateNestedManyWithoutUserInputSchema).optional(),
  profiles: z.lazy(() => ProfileUncheckedCreateNestedManyWithoutUserInputSchema).optional(),
  questions: z.lazy(() => QuestionUncheckedCreateNestedManyWithoutUserInputSchema).optional(),
  questionScores: z.lazy(() => QuestionScoreUncheckedCreateNestedManyWithoutUserInputSchema).optional(),
  questionsSharedWith: z.lazy(() => QuestionUncheckedCreateNestedManyWithoutSharedWithInputSchema).optional(),
  comments: z.lazy(() => CommentUncheckedCreateNestedManyWithoutUserInputSchema).optional(),
  target: z.lazy(() => TargetUncheckedCreateNestedOneWithoutUserInputSchema).optional(),
  authorOfLists: z.lazy(() => UserListUncheckedCreateNestedManyWithoutAuthorInputSchema).optional(),
  memberOfLists: z.lazy(() => UserListUncheckedCreateNestedManyWithoutUsersInputSchema).optional(),
  tags: z.lazy(() => TagUncheckedCreateNestedManyWithoutUserInputSchema).optional(),
  tournaments: z.lazy(() => TournamentUncheckedCreateNestedManyWithoutAuthorInputSchema).optional(),
  notifications: z.lazy(() => NotificationUncheckedCreateNestedManyWithoutUserInputSchema).optional(),
  accounts: z.lazy(() => AccountUncheckedCreateNestedManyWithoutUserInputSchema).optional()
}).strict();

export const UserCreateOrConnectWithoutQuestionOptionsInputSchema: z.ZodType<Prisma.UserCreateOrConnectWithoutQuestionOptionsInput> = z.object({
  where: z.lazy(() => UserWhereUniqueInputSchema),
  create: z.union([ z.lazy(() => UserCreateWithoutQuestionOptionsInputSchema),z.lazy(() => UserUncheckedCreateWithoutQuestionOptionsInputSchema) ]),
}).strict();

export const QuestionScoreCreateWithoutQuestionOptionInputSchema: z.ZodType<Prisma.QuestionScoreCreateWithoutQuestionOptionInput> = z.object({
  createdAt: z.coerce.date().optional(),
  relativeScore: z.union([z.number(),z.string(),z.instanceof(Decimal),z.instanceof(Prisma.Decimal),DecimalJsLikeSchema,]).refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' }).optional().nullable(),
  userQuestionComboId: z.string(),
  absoluteScore: z.union([z.number(),z.string(),z.instanceof(Decimal),z.instanceof(Prisma.Decimal),DecimalJsLikeSchema,]).refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' }),
  rank: z.number().int(),
  question: z.lazy(() => QuestionCreateNestedOneWithoutQuestionScoresInputSchema),
  user: z.lazy(() => UserCreateNestedOneWithoutQuestionScoresInputSchema)
}).strict();

export const QuestionScoreUncheckedCreateWithoutQuestionOptionInputSchema: z.ZodType<Prisma.QuestionScoreUncheckedCreateWithoutQuestionOptionInput> = z.object({
  id: z.number().int().optional(),
  createdAt: z.coerce.date().optional(),
  relativeScore: z.union([z.number(),z.string(),z.instanceof(Decimal),z.instanceof(Prisma.Decimal),DecimalJsLikeSchema,]).refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' }).optional().nullable(),
  questionId: z.string(),
  userQuestionComboId: z.string(),
  absoluteScore: z.union([z.number(),z.string(),z.instanceof(Decimal),z.instanceof(Prisma.Decimal),DecimalJsLikeSchema,]).refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' }),
  rank: z.number().int(),
  userId: z.string()
}).strict();

export const QuestionScoreCreateOrConnectWithoutQuestionOptionInputSchema: z.ZodType<Prisma.QuestionScoreCreateOrConnectWithoutQuestionOptionInput> = z.object({
  where: z.lazy(() => QuestionScoreWhereUniqueInputSchema),
  create: z.union([ z.lazy(() => QuestionScoreCreateWithoutQuestionOptionInputSchema),z.lazy(() => QuestionScoreUncheckedCreateWithoutQuestionOptionInputSchema) ]),
}).strict();

export const QuestionScoreCreateManyQuestionOptionInputEnvelopeSchema: z.ZodType<Prisma.QuestionScoreCreateManyQuestionOptionInputEnvelope> = z.object({
  data: z.union([ z.lazy(() => QuestionScoreCreateManyQuestionOptionInputSchema),z.lazy(() => QuestionScoreCreateManyQuestionOptionInputSchema).array() ]),
  skipDuplicates: z.boolean().optional()
}).strict();

export const QuestionUpsertWithoutOptionsInputSchema: z.ZodType<Prisma.QuestionUpsertWithoutOptionsInput> = z.object({
  update: z.union([ z.lazy(() => QuestionUpdateWithoutOptionsInputSchema),z.lazy(() => QuestionUncheckedUpdateWithoutOptionsInputSchema) ]),
  create: z.union([ z.lazy(() => QuestionCreateWithoutOptionsInputSchema),z.lazy(() => QuestionUncheckedCreateWithoutOptionsInputSchema) ]),
  where: z.lazy(() => QuestionWhereInputSchema).optional()
}).strict();

export const QuestionUpdateToOneWithWhereWithoutOptionsInputSchema: z.ZodType<Prisma.QuestionUpdateToOneWithWhereWithoutOptionsInput> = z.object({
  where: z.lazy(() => QuestionWhereInputSchema).optional(),
  data: z.union([ z.lazy(() => QuestionUpdateWithoutOptionsInputSchema),z.lazy(() => QuestionUncheckedUpdateWithoutOptionsInputSchema) ]),
}).strict();

export const QuestionUpdateWithoutOptionsInputSchema: z.ZodType<Prisma.QuestionUpdateWithoutOptionsInput> = z.object({
  id: z.union([ z.string().cuid(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  createdAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  comment: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  title: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  type: z.union([ z.lazy(() => QuestionTypeSchema),z.lazy(() => EnumQuestionTypeFieldUpdateOperationsInputSchema) ]).optional(),
  resolveBy: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  resolved: z.union([ z.boolean(),z.lazy(() => BoolFieldUpdateOperationsInputSchema) ]).optional(),
  pingedForResolution: z.union([ z.boolean(),z.lazy(() => BoolFieldUpdateOperationsInputSchema) ]).optional(),
  resolution: z.union([ z.lazy(() => ResolutionSchema),z.lazy(() => NullableEnumResolutionFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  resolvedAt: z.union([ z.coerce.date(),z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  notes: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  hideForecastsUntil: z.union([ z.coerce.date(),z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  hideForecastsUntilPrediction: z.union([ z.boolean(),z.lazy(() => NullableBoolFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  sharedPublicly: z.union([ z.boolean(),z.lazy(() => BoolFieldUpdateOperationsInputSchema) ]).optional(),
  unlisted: z.union([ z.boolean(),z.lazy(() => BoolFieldUpdateOperationsInputSchema) ]).optional(),
  exclusiveAnswers: z.union([ z.boolean(),z.lazy(() => NullableBoolFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  forecasts: z.lazy(() => ForecastUpdateManyWithoutQuestionNestedInputSchema).optional(),
  pingResolveMessages: z.lazy(() => PingSlackMessageUpdateManyWithoutQuestionNestedInputSchema).optional(),
  profile: z.lazy(() => ProfileUpdateOneWithoutQuestionsNestedInputSchema).optional(),
  user: z.lazy(() => UserUpdateOneRequiredWithoutQuestionsNestedInputSchema).optional(),
  sharedWith: z.lazy(() => UserUpdateManyWithoutQuestionsSharedWithNestedInputSchema).optional(),
  sharedWithLists: z.lazy(() => UserListUpdateManyWithoutQuestionsNestedInputSchema).optional(),
  questionScores: z.lazy(() => QuestionScoreUpdateManyWithoutQuestionNestedInputSchema).optional(),
  questionMessages: z.lazy(() => QuestionSlackMessageUpdateManyWithoutQuestionNestedInputSchema).optional(),
  resolutionMessages: z.lazy(() => ResolutionSlackMessageUpdateManyWithoutQuestionNestedInputSchema).optional(),
  comments: z.lazy(() => CommentUpdateManyWithoutQuestionNestedInputSchema).optional(),
  tags: z.lazy(() => TagUpdateManyWithoutQuestionsNestedInputSchema).optional(),
  tournaments: z.lazy(() => TournamentUpdateManyWithoutQuestionsNestedInputSchema).optional(),
  notifications: z.lazy(() => NotificationUpdateManyWithoutQuestionNestedInputSchema).optional()
}).strict();

export const QuestionUncheckedUpdateWithoutOptionsInputSchema: z.ZodType<Prisma.QuestionUncheckedUpdateWithoutOptionsInput> = z.object({
  id: z.union([ z.string().cuid(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  createdAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  comment: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  profileId: z.union([ z.number().int(),z.lazy(() => NullableIntFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  title: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  type: z.union([ z.lazy(() => QuestionTypeSchema),z.lazy(() => EnumQuestionTypeFieldUpdateOperationsInputSchema) ]).optional(),
  resolveBy: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  resolved: z.union([ z.boolean(),z.lazy(() => BoolFieldUpdateOperationsInputSchema) ]).optional(),
  pingedForResolution: z.union([ z.boolean(),z.lazy(() => BoolFieldUpdateOperationsInputSchema) ]).optional(),
  resolution: z.union([ z.lazy(() => ResolutionSchema),z.lazy(() => NullableEnumResolutionFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  resolvedAt: z.union([ z.coerce.date(),z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  notes: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  hideForecastsUntil: z.union([ z.coerce.date(),z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  hideForecastsUntilPrediction: z.union([ z.boolean(),z.lazy(() => NullableBoolFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  userId: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  sharedPublicly: z.union([ z.boolean(),z.lazy(() => BoolFieldUpdateOperationsInputSchema) ]).optional(),
  unlisted: z.union([ z.boolean(),z.lazy(() => BoolFieldUpdateOperationsInputSchema) ]).optional(),
  exclusiveAnswers: z.union([ z.boolean(),z.lazy(() => NullableBoolFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  forecasts: z.lazy(() => ForecastUncheckedUpdateManyWithoutQuestionNestedInputSchema).optional(),
  pingResolveMessages: z.lazy(() => PingSlackMessageUncheckedUpdateManyWithoutQuestionNestedInputSchema).optional(),
  sharedWith: z.lazy(() => UserUncheckedUpdateManyWithoutQuestionsSharedWithNestedInputSchema).optional(),
  sharedWithLists: z.lazy(() => UserListUncheckedUpdateManyWithoutQuestionsNestedInputSchema).optional(),
  questionScores: z.lazy(() => QuestionScoreUncheckedUpdateManyWithoutQuestionNestedInputSchema).optional(),
  questionMessages: z.lazy(() => QuestionSlackMessageUncheckedUpdateManyWithoutQuestionNestedInputSchema).optional(),
  resolutionMessages: z.lazy(() => ResolutionSlackMessageUncheckedUpdateManyWithoutQuestionNestedInputSchema).optional(),
  comments: z.lazy(() => CommentUncheckedUpdateManyWithoutQuestionNestedInputSchema).optional(),
  tags: z.lazy(() => TagUncheckedUpdateManyWithoutQuestionsNestedInputSchema).optional(),
  tournaments: z.lazy(() => TournamentUncheckedUpdateManyWithoutQuestionsNestedInputSchema).optional(),
  notifications: z.lazy(() => NotificationUncheckedUpdateManyWithoutQuestionNestedInputSchema).optional()
}).strict();

export const ForecastUpsertWithWhereUniqueWithoutOptionInputSchema: z.ZodType<Prisma.ForecastUpsertWithWhereUniqueWithoutOptionInput> = z.object({
  where: z.lazy(() => ForecastWhereUniqueInputSchema),
  update: z.union([ z.lazy(() => ForecastUpdateWithoutOptionInputSchema),z.lazy(() => ForecastUncheckedUpdateWithoutOptionInputSchema) ]),
  create: z.union([ z.lazy(() => ForecastCreateWithoutOptionInputSchema),z.lazy(() => ForecastUncheckedCreateWithoutOptionInputSchema) ]),
}).strict();

export const ForecastUpdateWithWhereUniqueWithoutOptionInputSchema: z.ZodType<Prisma.ForecastUpdateWithWhereUniqueWithoutOptionInput> = z.object({
  where: z.lazy(() => ForecastWhereUniqueInputSchema),
  data: z.union([ z.lazy(() => ForecastUpdateWithoutOptionInputSchema),z.lazy(() => ForecastUncheckedUpdateWithoutOptionInputSchema) ]),
}).strict();

export const ForecastUpdateManyWithWhereWithoutOptionInputSchema: z.ZodType<Prisma.ForecastUpdateManyWithWhereWithoutOptionInput> = z.object({
  where: z.lazy(() => ForecastScalarWhereInputSchema),
  data: z.union([ z.lazy(() => ForecastUpdateManyMutationInputSchema),z.lazy(() => ForecastUncheckedUpdateManyWithoutOptionInputSchema) ]),
}).strict();

export const ForecastScalarWhereInputSchema: z.ZodType<Prisma.ForecastScalarWhereInput> = z.object({
  AND: z.union([ z.lazy(() => ForecastScalarWhereInputSchema),z.lazy(() => ForecastScalarWhereInputSchema).array() ]).optional(),
  OR: z.lazy(() => ForecastScalarWhereInputSchema).array().optional(),
  NOT: z.union([ z.lazy(() => ForecastScalarWhereInputSchema),z.lazy(() => ForecastScalarWhereInputSchema).array() ]).optional(),
  id: z.union([ z.lazy(() => IntFilterSchema),z.number() ]).optional(),
  createdAt: z.union([ z.lazy(() => DateTimeFilterSchema),z.coerce.date() ]).optional(),
  comment: z.union([ z.lazy(() => StringNullableFilterSchema),z.string() ]).optional().nullable(),
  forecast: z.union([ z.lazy(() => DecimalFilterSchema),z.union([z.number(),z.string(),z.instanceof(Decimal),z.instanceof(Prisma.Decimal),DecimalJsLikeSchema,]).refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' }) ]).optional(),
  profileId: z.union([ z.lazy(() => IntNullableFilterSchema),z.number() ]).optional().nullable(),
  questionId: z.union([ z.lazy(() => StringFilterSchema),z.string() ]).optional(),
  optionId: z.union([ z.lazy(() => StringNullableFilterSchema),z.string() ]).optional().nullable(),
  userId: z.union([ z.lazy(() => StringFilterSchema),z.string() ]).optional(),
}).strict();

export const UserUpsertWithoutQuestionOptionsInputSchema: z.ZodType<Prisma.UserUpsertWithoutQuestionOptionsInput> = z.object({
  update: z.union([ z.lazy(() => UserUpdateWithoutQuestionOptionsInputSchema),z.lazy(() => UserUncheckedUpdateWithoutQuestionOptionsInputSchema) ]),
  create: z.union([ z.lazy(() => UserCreateWithoutQuestionOptionsInputSchema),z.lazy(() => UserUncheckedCreateWithoutQuestionOptionsInputSchema) ]),
  where: z.lazy(() => UserWhereInputSchema).optional()
}).strict();

export const UserUpdateToOneWithWhereWithoutQuestionOptionsInputSchema: z.ZodType<Prisma.UserUpdateToOneWithWhereWithoutQuestionOptionsInput> = z.object({
  where: z.lazy(() => UserWhereInputSchema).optional(),
  data: z.union([ z.lazy(() => UserUpdateWithoutQuestionOptionsInputSchema),z.lazy(() => UserUncheckedUpdateWithoutQuestionOptionsInputSchema) ]),
}).strict();

export const UserUpdateWithoutQuestionOptionsInputSchema: z.ZodType<Prisma.UserUpdateWithoutQuestionOptionsInput> = z.object({
  id: z.union([ z.string().cuid(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  name: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  createdAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  email: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  image: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  staleReminder: z.union([ z.boolean(),z.lazy(() => BoolFieldUpdateOperationsInputSchema) ]).optional(),
  unsubscribedFromEmailsAt: z.union([ z.coerce.date(),z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  apiKey: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  discordUserId: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  emailVerified: z.union([ z.coerce.date(),z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  forecasts: z.lazy(() => ForecastUpdateManyWithoutUserNestedInputSchema).optional(),
  profiles: z.lazy(() => ProfileUpdateManyWithoutUserNestedInputSchema).optional(),
  questions: z.lazy(() => QuestionUpdateManyWithoutUserNestedInputSchema).optional(),
  questionScores: z.lazy(() => QuestionScoreUpdateManyWithoutUserNestedInputSchema).optional(),
  questionsSharedWith: z.lazy(() => QuestionUpdateManyWithoutSharedWithNestedInputSchema).optional(),
  comments: z.lazy(() => CommentUpdateManyWithoutUserNestedInputSchema).optional(),
  target: z.lazy(() => TargetUpdateOneWithoutUserNestedInputSchema).optional(),
  authorOfLists: z.lazy(() => UserListUpdateManyWithoutAuthorNestedInputSchema).optional(),
  memberOfLists: z.lazy(() => UserListUpdateManyWithoutUsersNestedInputSchema).optional(),
  tags: z.lazy(() => TagUpdateManyWithoutUserNestedInputSchema).optional(),
  tournaments: z.lazy(() => TournamentUpdateManyWithoutAuthorNestedInputSchema).optional(),
  notifications: z.lazy(() => NotificationUpdateManyWithoutUserNestedInputSchema).optional(),
  accounts: z.lazy(() => AccountUpdateManyWithoutUserNestedInputSchema).optional()
}).strict();

export const UserUncheckedUpdateWithoutQuestionOptionsInputSchema: z.ZodType<Prisma.UserUncheckedUpdateWithoutQuestionOptionsInput> = z.object({
  id: z.union([ z.string().cuid(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  name: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  createdAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  email: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  image: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  staleReminder: z.union([ z.boolean(),z.lazy(() => BoolFieldUpdateOperationsInputSchema) ]).optional(),
  unsubscribedFromEmailsAt: z.union([ z.coerce.date(),z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  apiKey: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  discordUserId: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  emailVerified: z.union([ z.coerce.date(),z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  forecasts: z.lazy(() => ForecastUncheckedUpdateManyWithoutUserNestedInputSchema).optional(),
  profiles: z.lazy(() => ProfileUncheckedUpdateManyWithoutUserNestedInputSchema).optional(),
  questions: z.lazy(() => QuestionUncheckedUpdateManyWithoutUserNestedInputSchema).optional(),
  questionScores: z.lazy(() => QuestionScoreUncheckedUpdateManyWithoutUserNestedInputSchema).optional(),
  questionsSharedWith: z.lazy(() => QuestionUncheckedUpdateManyWithoutSharedWithNestedInputSchema).optional(),
  comments: z.lazy(() => CommentUncheckedUpdateManyWithoutUserNestedInputSchema).optional(),
  target: z.lazy(() => TargetUncheckedUpdateOneWithoutUserNestedInputSchema).optional(),
  authorOfLists: z.lazy(() => UserListUncheckedUpdateManyWithoutAuthorNestedInputSchema).optional(),
  memberOfLists: z.lazy(() => UserListUncheckedUpdateManyWithoutUsersNestedInputSchema).optional(),
  tags: z.lazy(() => TagUncheckedUpdateManyWithoutUserNestedInputSchema).optional(),
  tournaments: z.lazy(() => TournamentUncheckedUpdateManyWithoutAuthorNestedInputSchema).optional(),
  notifications: z.lazy(() => NotificationUncheckedUpdateManyWithoutUserNestedInputSchema).optional(),
  accounts: z.lazy(() => AccountUncheckedUpdateManyWithoutUserNestedInputSchema).optional()
}).strict();

export const QuestionScoreUpsertWithWhereUniqueWithoutQuestionOptionInputSchema: z.ZodType<Prisma.QuestionScoreUpsertWithWhereUniqueWithoutQuestionOptionInput> = z.object({
  where: z.lazy(() => QuestionScoreWhereUniqueInputSchema),
  update: z.union([ z.lazy(() => QuestionScoreUpdateWithoutQuestionOptionInputSchema),z.lazy(() => QuestionScoreUncheckedUpdateWithoutQuestionOptionInputSchema) ]),
  create: z.union([ z.lazy(() => QuestionScoreCreateWithoutQuestionOptionInputSchema),z.lazy(() => QuestionScoreUncheckedCreateWithoutQuestionOptionInputSchema) ]),
}).strict();

export const QuestionScoreUpdateWithWhereUniqueWithoutQuestionOptionInputSchema: z.ZodType<Prisma.QuestionScoreUpdateWithWhereUniqueWithoutQuestionOptionInput> = z.object({
  where: z.lazy(() => QuestionScoreWhereUniqueInputSchema),
  data: z.union([ z.lazy(() => QuestionScoreUpdateWithoutQuestionOptionInputSchema),z.lazy(() => QuestionScoreUncheckedUpdateWithoutQuestionOptionInputSchema) ]),
}).strict();

export const QuestionScoreUpdateManyWithWhereWithoutQuestionOptionInputSchema: z.ZodType<Prisma.QuestionScoreUpdateManyWithWhereWithoutQuestionOptionInput> = z.object({
  where: z.lazy(() => QuestionScoreScalarWhereInputSchema),
  data: z.union([ z.lazy(() => QuestionScoreUpdateManyMutationInputSchema),z.lazy(() => QuestionScoreUncheckedUpdateManyWithoutQuestionOptionInputSchema) ]),
}).strict();

export const QuestionScoreScalarWhereInputSchema: z.ZodType<Prisma.QuestionScoreScalarWhereInput> = z.object({
  AND: z.union([ z.lazy(() => QuestionScoreScalarWhereInputSchema),z.lazy(() => QuestionScoreScalarWhereInputSchema).array() ]).optional(),
  OR: z.lazy(() => QuestionScoreScalarWhereInputSchema).array().optional(),
  NOT: z.union([ z.lazy(() => QuestionScoreScalarWhereInputSchema),z.lazy(() => QuestionScoreScalarWhereInputSchema).array() ]).optional(),
  id: z.union([ z.lazy(() => IntFilterSchema),z.number() ]).optional(),
  createdAt: z.union([ z.lazy(() => DateTimeFilterSchema),z.coerce.date() ]).optional(),
  relativeScore: z.union([ z.lazy(() => DecimalNullableFilterSchema),z.union([z.number(),z.string(),z.instanceof(Decimal),z.instanceof(Prisma.Decimal),DecimalJsLikeSchema,]).refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' }) ]).optional().nullable(),
  questionId: z.union([ z.lazy(() => StringFilterSchema),z.string() ]).optional(),
  userQuestionComboId: z.union([ z.lazy(() => StringFilterSchema),z.string() ]).optional(),
  absoluteScore: z.union([ z.lazy(() => DecimalFilterSchema),z.union([z.number(),z.string(),z.instanceof(Decimal),z.instanceof(Prisma.Decimal),DecimalJsLikeSchema,]).refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' }) ]).optional(),
  rank: z.union([ z.lazy(() => IntFilterSchema),z.number() ]).optional(),
  userId: z.union([ z.lazy(() => StringFilterSchema),z.string() ]).optional(),
  questionOptionId: z.union([ z.lazy(() => StringNullableFilterSchema),z.string() ]).optional().nullable(),
}).strict();

export const QuestionOptionCreateWithoutQuestionInputSchema: z.ZodType<Prisma.QuestionOptionCreateWithoutQuestionInput> = z.object({
  id: z.string().cuid().optional(),
  text: z.string(),
  resolution: z.lazy(() => ResolutionSchema).optional().nullable(),
  createdAt: z.coerce.date().optional(),
  resolvedAt: z.coerce.date().optional().nullable(),
  forecasts: z.lazy(() => ForecastCreateNestedManyWithoutOptionInputSchema).optional(),
  user: z.lazy(() => UserCreateNestedOneWithoutQuestionOptionsInputSchema),
  questionScores: z.lazy(() => QuestionScoreCreateNestedManyWithoutQuestionOptionInputSchema).optional()
}).strict();

export const QuestionOptionUncheckedCreateWithoutQuestionInputSchema: z.ZodType<Prisma.QuestionOptionUncheckedCreateWithoutQuestionInput> = z.object({
  id: z.string().cuid().optional(),
  text: z.string(),
  resolution: z.lazy(() => ResolutionSchema).optional().nullable(),
  createdAt: z.coerce.date().optional(),
  userId: z.string(),
  resolvedAt: z.coerce.date().optional().nullable(),
  forecasts: z.lazy(() => ForecastUncheckedCreateNestedManyWithoutOptionInputSchema).optional(),
  questionScores: z.lazy(() => QuestionScoreUncheckedCreateNestedManyWithoutQuestionOptionInputSchema).optional()
}).strict();

export const QuestionOptionCreateOrConnectWithoutQuestionInputSchema: z.ZodType<Prisma.QuestionOptionCreateOrConnectWithoutQuestionInput> = z.object({
  where: z.lazy(() => QuestionOptionWhereUniqueInputSchema),
  create: z.union([ z.lazy(() => QuestionOptionCreateWithoutQuestionInputSchema),z.lazy(() => QuestionOptionUncheckedCreateWithoutQuestionInputSchema) ]),
}).strict();

export const QuestionOptionCreateManyQuestionInputEnvelopeSchema: z.ZodType<Prisma.QuestionOptionCreateManyQuestionInputEnvelope> = z.object({
  data: z.union([ z.lazy(() => QuestionOptionCreateManyQuestionInputSchema),z.lazy(() => QuestionOptionCreateManyQuestionInputSchema).array() ]),
  skipDuplicates: z.boolean().optional()
}).strict();

export const ForecastCreateWithoutQuestionInputSchema: z.ZodType<Prisma.ForecastCreateWithoutQuestionInput> = z.object({
  createdAt: z.coerce.date().optional(),
  comment: z.string().optional().nullable(),
  forecast: z.union([z.number(),z.string(),z.instanceof(Decimal),z.instanceof(Prisma.Decimal),DecimalJsLikeSchema,]).refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' }),
  option: z.lazy(() => QuestionOptionCreateNestedOneWithoutForecastsInputSchema).optional(),
  profile: z.lazy(() => ProfileCreateNestedOneWithoutForecastsInputSchema).optional(),
  user: z.lazy(() => UserCreateNestedOneWithoutForecastsInputSchema)
}).strict();

export const ForecastUncheckedCreateWithoutQuestionInputSchema: z.ZodType<Prisma.ForecastUncheckedCreateWithoutQuestionInput> = z.object({
  id: z.number().int().optional(),
  createdAt: z.coerce.date().optional(),
  comment: z.string().optional().nullable(),
  forecast: z.union([z.number(),z.string(),z.instanceof(Decimal),z.instanceof(Prisma.Decimal),DecimalJsLikeSchema,]).refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' }),
  profileId: z.number().int().optional().nullable(),
  optionId: z.string().optional().nullable(),
  userId: z.string()
}).strict();

export const ForecastCreateOrConnectWithoutQuestionInputSchema: z.ZodType<Prisma.ForecastCreateOrConnectWithoutQuestionInput> = z.object({
  where: z.lazy(() => ForecastWhereUniqueInputSchema),
  create: z.union([ z.lazy(() => ForecastCreateWithoutQuestionInputSchema),z.lazy(() => ForecastUncheckedCreateWithoutQuestionInputSchema) ]),
}).strict();

export const ForecastCreateManyQuestionInputEnvelopeSchema: z.ZodType<Prisma.ForecastCreateManyQuestionInputEnvelope> = z.object({
  data: z.union([ z.lazy(() => ForecastCreateManyQuestionInputSchema),z.lazy(() => ForecastCreateManyQuestionInputSchema).array() ]),
  skipDuplicates: z.boolean().optional()
}).strict();

export const PingSlackMessageCreateWithoutQuestionInputSchema: z.ZodType<Prisma.PingSlackMessageCreateWithoutQuestionInput> = z.object({
  message: z.lazy(() => SlackMessageCreateNestedOneWithoutPingSlackMessageInputSchema)
}).strict();

export const PingSlackMessageUncheckedCreateWithoutQuestionInputSchema: z.ZodType<Prisma.PingSlackMessageUncheckedCreateWithoutQuestionInput> = z.object({
  id: z.number().int().optional(),
  detailsId: z.number().int()
}).strict();

export const PingSlackMessageCreateOrConnectWithoutQuestionInputSchema: z.ZodType<Prisma.PingSlackMessageCreateOrConnectWithoutQuestionInput> = z.object({
  where: z.lazy(() => PingSlackMessageWhereUniqueInputSchema),
  create: z.union([ z.lazy(() => PingSlackMessageCreateWithoutQuestionInputSchema),z.lazy(() => PingSlackMessageUncheckedCreateWithoutQuestionInputSchema) ]),
}).strict();

export const PingSlackMessageCreateManyQuestionInputEnvelopeSchema: z.ZodType<Prisma.PingSlackMessageCreateManyQuestionInputEnvelope> = z.object({
  data: z.union([ z.lazy(() => PingSlackMessageCreateManyQuestionInputSchema),z.lazy(() => PingSlackMessageCreateManyQuestionInputSchema).array() ]),
  skipDuplicates: z.boolean().optional()
}).strict();

export const ProfileCreateWithoutQuestionsInputSchema: z.ZodType<Prisma.ProfileCreateWithoutQuestionsInput> = z.object({
  createdAt: z.coerce.date().optional(),
  slackId: z.string().optional().nullable(),
  slackTeamId: z.string().optional().nullable(),
  forecasts: z.lazy(() => ForecastCreateNestedManyWithoutProfileInputSchema).optional(),
  user: z.lazy(() => UserCreateNestedOneWithoutProfilesInputSchema),
  resolutionMessages: z.lazy(() => ResolutionSlackMessageCreateNestedManyWithoutProfileInputSchema).optional(),
  target: z.lazy(() => TargetCreateNestedOneWithoutProfileInputSchema).optional()
}).strict();

export const ProfileUncheckedCreateWithoutQuestionsInputSchema: z.ZodType<Prisma.ProfileUncheckedCreateWithoutQuestionsInput> = z.object({
  id: z.number().int().optional(),
  createdAt: z.coerce.date().optional(),
  slackId: z.string().optional().nullable(),
  slackTeamId: z.string().optional().nullable(),
  userId: z.string(),
  forecasts: z.lazy(() => ForecastUncheckedCreateNestedManyWithoutProfileInputSchema).optional(),
  resolutionMessages: z.lazy(() => ResolutionSlackMessageUncheckedCreateNestedManyWithoutProfileInputSchema).optional(),
  target: z.lazy(() => TargetUncheckedCreateNestedOneWithoutProfileInputSchema).optional()
}).strict();

export const ProfileCreateOrConnectWithoutQuestionsInputSchema: z.ZodType<Prisma.ProfileCreateOrConnectWithoutQuestionsInput> = z.object({
  where: z.lazy(() => ProfileWhereUniqueInputSchema),
  create: z.union([ z.lazy(() => ProfileCreateWithoutQuestionsInputSchema),z.lazy(() => ProfileUncheckedCreateWithoutQuestionsInputSchema) ]),
}).strict();

export const UserCreateWithoutQuestionsInputSchema: z.ZodType<Prisma.UserCreateWithoutQuestionsInput> = z.object({
  id: z.string().cuid().optional(),
  name: z.string().optional().nullable(),
  createdAt: z.coerce.date().optional(),
  email: z.string(),
  image: z.string().optional().nullable(),
  staleReminder: z.boolean().optional(),
  unsubscribedFromEmailsAt: z.coerce.date().optional().nullable(),
  apiKey: z.string().optional().nullable(),
  discordUserId: z.string().optional().nullable(),
  emailVerified: z.coerce.date().optional().nullable(),
  forecasts: z.lazy(() => ForecastCreateNestedManyWithoutUserInputSchema).optional(),
  profiles: z.lazy(() => ProfileCreateNestedManyWithoutUserInputSchema).optional(),
  questionScores: z.lazy(() => QuestionScoreCreateNestedManyWithoutUserInputSchema).optional(),
  questionsSharedWith: z.lazy(() => QuestionCreateNestedManyWithoutSharedWithInputSchema).optional(),
  comments: z.lazy(() => CommentCreateNestedManyWithoutUserInputSchema).optional(),
  target: z.lazy(() => TargetCreateNestedOneWithoutUserInputSchema).optional(),
  authorOfLists: z.lazy(() => UserListCreateNestedManyWithoutAuthorInputSchema).optional(),
  memberOfLists: z.lazy(() => UserListCreateNestedManyWithoutUsersInputSchema).optional(),
  tags: z.lazy(() => TagCreateNestedManyWithoutUserInputSchema).optional(),
  tournaments: z.lazy(() => TournamentCreateNestedManyWithoutAuthorInputSchema).optional(),
  notifications: z.lazy(() => NotificationCreateNestedManyWithoutUserInputSchema).optional(),
  questionOptions: z.lazy(() => QuestionOptionCreateNestedManyWithoutUserInputSchema).optional(),
  accounts: z.lazy(() => AccountCreateNestedManyWithoutUserInputSchema).optional()
}).strict();

export const UserUncheckedCreateWithoutQuestionsInputSchema: z.ZodType<Prisma.UserUncheckedCreateWithoutQuestionsInput> = z.object({
  id: z.string().cuid().optional(),
  name: z.string().optional().nullable(),
  createdAt: z.coerce.date().optional(),
  email: z.string(),
  image: z.string().optional().nullable(),
  staleReminder: z.boolean().optional(),
  unsubscribedFromEmailsAt: z.coerce.date().optional().nullable(),
  apiKey: z.string().optional().nullable(),
  discordUserId: z.string().optional().nullable(),
  emailVerified: z.coerce.date().optional().nullable(),
  forecasts: z.lazy(() => ForecastUncheckedCreateNestedManyWithoutUserInputSchema).optional(),
  profiles: z.lazy(() => ProfileUncheckedCreateNestedManyWithoutUserInputSchema).optional(),
  questionScores: z.lazy(() => QuestionScoreUncheckedCreateNestedManyWithoutUserInputSchema).optional(),
  questionsSharedWith: z.lazy(() => QuestionUncheckedCreateNestedManyWithoutSharedWithInputSchema).optional(),
  comments: z.lazy(() => CommentUncheckedCreateNestedManyWithoutUserInputSchema).optional(),
  target: z.lazy(() => TargetUncheckedCreateNestedOneWithoutUserInputSchema).optional(),
  authorOfLists: z.lazy(() => UserListUncheckedCreateNestedManyWithoutAuthorInputSchema).optional(),
  memberOfLists: z.lazy(() => UserListUncheckedCreateNestedManyWithoutUsersInputSchema).optional(),
  tags: z.lazy(() => TagUncheckedCreateNestedManyWithoutUserInputSchema).optional(),
  tournaments: z.lazy(() => TournamentUncheckedCreateNestedManyWithoutAuthorInputSchema).optional(),
  notifications: z.lazy(() => NotificationUncheckedCreateNestedManyWithoutUserInputSchema).optional(),
  questionOptions: z.lazy(() => QuestionOptionUncheckedCreateNestedManyWithoutUserInputSchema).optional(),
  accounts: z.lazy(() => AccountUncheckedCreateNestedManyWithoutUserInputSchema).optional()
}).strict();

export const UserCreateOrConnectWithoutQuestionsInputSchema: z.ZodType<Prisma.UserCreateOrConnectWithoutQuestionsInput> = z.object({
  where: z.lazy(() => UserWhereUniqueInputSchema),
  create: z.union([ z.lazy(() => UserCreateWithoutQuestionsInputSchema),z.lazy(() => UserUncheckedCreateWithoutQuestionsInputSchema) ]),
}).strict();

export const UserCreateWithoutQuestionsSharedWithInputSchema: z.ZodType<Prisma.UserCreateWithoutQuestionsSharedWithInput> = z.object({
  id: z.string().cuid().optional(),
  name: z.string().optional().nullable(),
  createdAt: z.coerce.date().optional(),
  email: z.string(),
  image: z.string().optional().nullable(),
  staleReminder: z.boolean().optional(),
  unsubscribedFromEmailsAt: z.coerce.date().optional().nullable(),
  apiKey: z.string().optional().nullable(),
  discordUserId: z.string().optional().nullable(),
  emailVerified: z.coerce.date().optional().nullable(),
  forecasts: z.lazy(() => ForecastCreateNestedManyWithoutUserInputSchema).optional(),
  profiles: z.lazy(() => ProfileCreateNestedManyWithoutUserInputSchema).optional(),
  questions: z.lazy(() => QuestionCreateNestedManyWithoutUserInputSchema).optional(),
  questionScores: z.lazy(() => QuestionScoreCreateNestedManyWithoutUserInputSchema).optional(),
  comments: z.lazy(() => CommentCreateNestedManyWithoutUserInputSchema).optional(),
  target: z.lazy(() => TargetCreateNestedOneWithoutUserInputSchema).optional(),
  authorOfLists: z.lazy(() => UserListCreateNestedManyWithoutAuthorInputSchema).optional(),
  memberOfLists: z.lazy(() => UserListCreateNestedManyWithoutUsersInputSchema).optional(),
  tags: z.lazy(() => TagCreateNestedManyWithoutUserInputSchema).optional(),
  tournaments: z.lazy(() => TournamentCreateNestedManyWithoutAuthorInputSchema).optional(),
  notifications: z.lazy(() => NotificationCreateNestedManyWithoutUserInputSchema).optional(),
  questionOptions: z.lazy(() => QuestionOptionCreateNestedManyWithoutUserInputSchema).optional(),
  accounts: z.lazy(() => AccountCreateNestedManyWithoutUserInputSchema).optional()
}).strict();

export const UserUncheckedCreateWithoutQuestionsSharedWithInputSchema: z.ZodType<Prisma.UserUncheckedCreateWithoutQuestionsSharedWithInput> = z.object({
  id: z.string().cuid().optional(),
  name: z.string().optional().nullable(),
  createdAt: z.coerce.date().optional(),
  email: z.string(),
  image: z.string().optional().nullable(),
  staleReminder: z.boolean().optional(),
  unsubscribedFromEmailsAt: z.coerce.date().optional().nullable(),
  apiKey: z.string().optional().nullable(),
  discordUserId: z.string().optional().nullable(),
  emailVerified: z.coerce.date().optional().nullable(),
  forecasts: z.lazy(() => ForecastUncheckedCreateNestedManyWithoutUserInputSchema).optional(),
  profiles: z.lazy(() => ProfileUncheckedCreateNestedManyWithoutUserInputSchema).optional(),
  questions: z.lazy(() => QuestionUncheckedCreateNestedManyWithoutUserInputSchema).optional(),
  questionScores: z.lazy(() => QuestionScoreUncheckedCreateNestedManyWithoutUserInputSchema).optional(),
  comments: z.lazy(() => CommentUncheckedCreateNestedManyWithoutUserInputSchema).optional(),
  target: z.lazy(() => TargetUncheckedCreateNestedOneWithoutUserInputSchema).optional(),
  authorOfLists: z.lazy(() => UserListUncheckedCreateNestedManyWithoutAuthorInputSchema).optional(),
  memberOfLists: z.lazy(() => UserListUncheckedCreateNestedManyWithoutUsersInputSchema).optional(),
  tags: z.lazy(() => TagUncheckedCreateNestedManyWithoutUserInputSchema).optional(),
  tournaments: z.lazy(() => TournamentUncheckedCreateNestedManyWithoutAuthorInputSchema).optional(),
  notifications: z.lazy(() => NotificationUncheckedCreateNestedManyWithoutUserInputSchema).optional(),
  questionOptions: z.lazy(() => QuestionOptionUncheckedCreateNestedManyWithoutUserInputSchema).optional(),
  accounts: z.lazy(() => AccountUncheckedCreateNestedManyWithoutUserInputSchema).optional()
}).strict();

export const UserCreateOrConnectWithoutQuestionsSharedWithInputSchema: z.ZodType<Prisma.UserCreateOrConnectWithoutQuestionsSharedWithInput> = z.object({
  where: z.lazy(() => UserWhereUniqueInputSchema),
  create: z.union([ z.lazy(() => UserCreateWithoutQuestionsSharedWithInputSchema),z.lazy(() => UserUncheckedCreateWithoutQuestionsSharedWithInputSchema) ]),
}).strict();

export const UserListCreateWithoutQuestionsInputSchema: z.ZodType<Prisma.UserListCreateWithoutQuestionsInput> = z.object({
  id: z.string().cuid().optional(),
  createdAt: z.coerce.date().optional(),
  inviteId: z.string().cuid().optional().nullable(),
  name: z.string(),
  emailDomains: z.union([ z.lazy(() => UserListCreateemailDomainsInputSchema),z.string().array() ]).optional(),
  syncToSlackTeamId: z.string().optional().nullable(),
  syncToSlackChannelId: z.string().optional().nullable(),
  author: z.lazy(() => UserCreateNestedOneWithoutAuthorOfListsInputSchema),
  users: z.lazy(() => UserCreateNestedManyWithoutMemberOfListsInputSchema).optional(),
  tournaments: z.lazy(() => TournamentCreateNestedManyWithoutUserListInputSchema).optional()
}).strict();

export const UserListUncheckedCreateWithoutQuestionsInputSchema: z.ZodType<Prisma.UserListUncheckedCreateWithoutQuestionsInput> = z.object({
  id: z.string().cuid().optional(),
  createdAt: z.coerce.date().optional(),
  inviteId: z.string().cuid().optional().nullable(),
  name: z.string(),
  emailDomains: z.union([ z.lazy(() => UserListCreateemailDomainsInputSchema),z.string().array() ]).optional(),
  syncToSlackTeamId: z.string().optional().nullable(),
  syncToSlackChannelId: z.string().optional().nullable(),
  authorId: z.string(),
  users: z.lazy(() => UserUncheckedCreateNestedManyWithoutMemberOfListsInputSchema).optional(),
  tournaments: z.lazy(() => TournamentUncheckedCreateNestedManyWithoutUserListInputSchema).optional()
}).strict();

export const UserListCreateOrConnectWithoutQuestionsInputSchema: z.ZodType<Prisma.UserListCreateOrConnectWithoutQuestionsInput> = z.object({
  where: z.lazy(() => UserListWhereUniqueInputSchema),
  create: z.union([ z.lazy(() => UserListCreateWithoutQuestionsInputSchema),z.lazy(() => UserListUncheckedCreateWithoutQuestionsInputSchema) ]),
}).strict();

export const QuestionScoreCreateWithoutQuestionInputSchema: z.ZodType<Prisma.QuestionScoreCreateWithoutQuestionInput> = z.object({
  createdAt: z.coerce.date().optional(),
  relativeScore: z.union([z.number(),z.string(),z.instanceof(Decimal),z.instanceof(Prisma.Decimal),DecimalJsLikeSchema,]).refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' }).optional().nullable(),
  userQuestionComboId: z.string(),
  absoluteScore: z.union([z.number(),z.string(),z.instanceof(Decimal),z.instanceof(Prisma.Decimal),DecimalJsLikeSchema,]).refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' }),
  rank: z.number().int(),
  user: z.lazy(() => UserCreateNestedOneWithoutQuestionScoresInputSchema),
  QuestionOption: z.lazy(() => QuestionOptionCreateNestedOneWithoutQuestionScoresInputSchema).optional()
}).strict();

export const QuestionScoreUncheckedCreateWithoutQuestionInputSchema: z.ZodType<Prisma.QuestionScoreUncheckedCreateWithoutQuestionInput> = z.object({
  id: z.number().int().optional(),
  createdAt: z.coerce.date().optional(),
  relativeScore: z.union([z.number(),z.string(),z.instanceof(Decimal),z.instanceof(Prisma.Decimal),DecimalJsLikeSchema,]).refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' }).optional().nullable(),
  userQuestionComboId: z.string(),
  absoluteScore: z.union([z.number(),z.string(),z.instanceof(Decimal),z.instanceof(Prisma.Decimal),DecimalJsLikeSchema,]).refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' }),
  rank: z.number().int(),
  userId: z.string(),
  questionOptionId: z.string().optional().nullable()
}).strict();

export const QuestionScoreCreateOrConnectWithoutQuestionInputSchema: z.ZodType<Prisma.QuestionScoreCreateOrConnectWithoutQuestionInput> = z.object({
  where: z.lazy(() => QuestionScoreWhereUniqueInputSchema),
  create: z.union([ z.lazy(() => QuestionScoreCreateWithoutQuestionInputSchema),z.lazy(() => QuestionScoreUncheckedCreateWithoutQuestionInputSchema) ]),
}).strict();

export const QuestionScoreCreateManyQuestionInputEnvelopeSchema: z.ZodType<Prisma.QuestionScoreCreateManyQuestionInputEnvelope> = z.object({
  data: z.union([ z.lazy(() => QuestionScoreCreateManyQuestionInputSchema),z.lazy(() => QuestionScoreCreateManyQuestionInputSchema).array() ]),
  skipDuplicates: z.boolean().optional()
}).strict();

export const QuestionSlackMessageCreateWithoutQuestionInputSchema: z.ZodType<Prisma.QuestionSlackMessageCreateWithoutQuestionInput> = z.object({
  updatedAt: z.coerce.date().optional(),
  message: z.lazy(() => SlackMessageCreateNestedOneWithoutQuestionSlackMessageInputSchema)
}).strict();

export const QuestionSlackMessageUncheckedCreateWithoutQuestionInputSchema: z.ZodType<Prisma.QuestionSlackMessageUncheckedCreateWithoutQuestionInput> = z.object({
  id: z.number().int().optional(),
  detailsId: z.number().int(),
  updatedAt: z.coerce.date().optional()
}).strict();

export const QuestionSlackMessageCreateOrConnectWithoutQuestionInputSchema: z.ZodType<Prisma.QuestionSlackMessageCreateOrConnectWithoutQuestionInput> = z.object({
  where: z.lazy(() => QuestionSlackMessageWhereUniqueInputSchema),
  create: z.union([ z.lazy(() => QuestionSlackMessageCreateWithoutQuestionInputSchema),z.lazy(() => QuestionSlackMessageUncheckedCreateWithoutQuestionInputSchema) ]),
}).strict();

export const QuestionSlackMessageCreateManyQuestionInputEnvelopeSchema: z.ZodType<Prisma.QuestionSlackMessageCreateManyQuestionInputEnvelope> = z.object({
  data: z.union([ z.lazy(() => QuestionSlackMessageCreateManyQuestionInputSchema),z.lazy(() => QuestionSlackMessageCreateManyQuestionInputSchema).array() ]),
  skipDuplicates: z.boolean().optional()
}).strict();

export const ResolutionSlackMessageCreateWithoutQuestionInputSchema: z.ZodType<Prisma.ResolutionSlackMessageCreateWithoutQuestionInput> = z.object({
  message: z.lazy(() => SlackMessageCreateNestedOneWithoutResolutionSlackMessageInputSchema),
  profile: z.lazy(() => ProfileCreateNestedOneWithoutResolutionMessagesInputSchema).optional()
}).strict();

export const ResolutionSlackMessageUncheckedCreateWithoutQuestionInputSchema: z.ZodType<Prisma.ResolutionSlackMessageUncheckedCreateWithoutQuestionInput> = z.object({
  id: z.number().int().optional(),
  detailsId: z.number().int(),
  profileId: z.number().int().optional().nullable()
}).strict();

export const ResolutionSlackMessageCreateOrConnectWithoutQuestionInputSchema: z.ZodType<Prisma.ResolutionSlackMessageCreateOrConnectWithoutQuestionInput> = z.object({
  where: z.lazy(() => ResolutionSlackMessageWhereUniqueInputSchema),
  create: z.union([ z.lazy(() => ResolutionSlackMessageCreateWithoutQuestionInputSchema),z.lazy(() => ResolutionSlackMessageUncheckedCreateWithoutQuestionInputSchema) ]),
}).strict();

export const ResolutionSlackMessageCreateManyQuestionInputEnvelopeSchema: z.ZodType<Prisma.ResolutionSlackMessageCreateManyQuestionInputEnvelope> = z.object({
  data: z.union([ z.lazy(() => ResolutionSlackMessageCreateManyQuestionInputSchema),z.lazy(() => ResolutionSlackMessageCreateManyQuestionInputSchema).array() ]),
  skipDuplicates: z.boolean().optional()
}).strict();

export const CommentCreateWithoutQuestionInputSchema: z.ZodType<Prisma.CommentCreateWithoutQuestionInput> = z.object({
  createdAt: z.coerce.date().optional(),
  comment: z.string(),
  user: z.lazy(() => UserCreateNestedOneWithoutCommentsInputSchema)
}).strict();

export const CommentUncheckedCreateWithoutQuestionInputSchema: z.ZodType<Prisma.CommentUncheckedCreateWithoutQuestionInput> = z.object({
  id: z.number().int().optional(),
  createdAt: z.coerce.date().optional(),
  comment: z.string(),
  userId: z.string()
}).strict();

export const CommentCreateOrConnectWithoutQuestionInputSchema: z.ZodType<Prisma.CommentCreateOrConnectWithoutQuestionInput> = z.object({
  where: z.lazy(() => CommentWhereUniqueInputSchema),
  create: z.union([ z.lazy(() => CommentCreateWithoutQuestionInputSchema),z.lazy(() => CommentUncheckedCreateWithoutQuestionInputSchema) ]),
}).strict();

export const CommentCreateManyQuestionInputEnvelopeSchema: z.ZodType<Prisma.CommentCreateManyQuestionInputEnvelope> = z.object({
  data: z.union([ z.lazy(() => CommentCreateManyQuestionInputSchema),z.lazy(() => CommentCreateManyQuestionInputSchema).array() ]),
  skipDuplicates: z.boolean().optional()
}).strict();

export const TagCreateWithoutQuestionsInputSchema: z.ZodType<Prisma.TagCreateWithoutQuestionsInput> = z.object({
  id: z.string().cuid().optional(),
  createdAt: z.coerce.date().optional(),
  name: z.string(),
  user: z.lazy(() => UserCreateNestedOneWithoutTagsInputSchema)
}).strict();

export const TagUncheckedCreateWithoutQuestionsInputSchema: z.ZodType<Prisma.TagUncheckedCreateWithoutQuestionsInput> = z.object({
  id: z.string().cuid().optional(),
  createdAt: z.coerce.date().optional(),
  name: z.string(),
  userId: z.string()
}).strict();

export const TagCreateOrConnectWithoutQuestionsInputSchema: z.ZodType<Prisma.TagCreateOrConnectWithoutQuestionsInput> = z.object({
  where: z.lazy(() => TagWhereUniqueInputSchema),
  create: z.union([ z.lazy(() => TagCreateWithoutQuestionsInputSchema),z.lazy(() => TagUncheckedCreateWithoutQuestionsInputSchema) ]),
}).strict();

export const TournamentCreateWithoutQuestionsInputSchema: z.ZodType<Prisma.TournamentCreateWithoutQuestionsInput> = z.object({
  id: z.string().cuid().optional(),
  createdAt: z.coerce.date().optional(),
  name: z.string(),
  description: z.string().optional().nullable(),
  sharedPublicly: z.boolean().optional(),
  unlisted: z.boolean().optional(),
  anyoneInListCanEdit: z.boolean().optional(),
  showLeaderboard: z.boolean().optional(),
  predictYourYear: z.number().int().optional().nullable(),
  syncToSlackTeamId: z.string().optional().nullable(),
  syncToSlackChannelId: z.string().optional().nullable(),
  author: z.lazy(() => UserCreateNestedOneWithoutTournamentsInputSchema),
  userList: z.lazy(() => UserListCreateNestedOneWithoutTournamentsInputSchema).optional()
}).strict();

export const TournamentUncheckedCreateWithoutQuestionsInputSchema: z.ZodType<Prisma.TournamentUncheckedCreateWithoutQuestionsInput> = z.object({
  id: z.string().cuid().optional(),
  createdAt: z.coerce.date().optional(),
  name: z.string(),
  description: z.string().optional().nullable(),
  authorId: z.string(),
  sharedPublicly: z.boolean().optional(),
  unlisted: z.boolean().optional(),
  userListId: z.string().optional().nullable(),
  anyoneInListCanEdit: z.boolean().optional(),
  showLeaderboard: z.boolean().optional(),
  predictYourYear: z.number().int().optional().nullable(),
  syncToSlackTeamId: z.string().optional().nullable(),
  syncToSlackChannelId: z.string().optional().nullable()
}).strict();

export const TournamentCreateOrConnectWithoutQuestionsInputSchema: z.ZodType<Prisma.TournamentCreateOrConnectWithoutQuestionsInput> = z.object({
  where: z.lazy(() => TournamentWhereUniqueInputSchema),
  create: z.union([ z.lazy(() => TournamentCreateWithoutQuestionsInputSchema),z.lazy(() => TournamentUncheckedCreateWithoutQuestionsInputSchema) ]),
}).strict();

export const NotificationCreateWithoutQuestionInputSchema: z.ZodType<Prisma.NotificationCreateWithoutQuestionInput> = z.object({
  id: z.string().cuid().optional(),
  createdAt: z.coerce.date().optional(),
  emailSentAt: z.coerce.date().optional().nullable(),
  title: z.string(),
  content: z.string(),
  url: z.string().optional().nullable(),
  tags: z.union([ z.lazy(() => NotificationCreatetagsInputSchema),z.string().array() ]).optional(),
  read: z.boolean().optional(),
  user: z.lazy(() => UserCreateNestedOneWithoutNotificationsInputSchema)
}).strict();

export const NotificationUncheckedCreateWithoutQuestionInputSchema: z.ZodType<Prisma.NotificationUncheckedCreateWithoutQuestionInput> = z.object({
  id: z.string().cuid().optional(),
  createdAt: z.coerce.date().optional(),
  emailSentAt: z.coerce.date().optional().nullable(),
  title: z.string(),
  content: z.string(),
  url: z.string().optional().nullable(),
  tags: z.union([ z.lazy(() => NotificationCreatetagsInputSchema),z.string().array() ]).optional(),
  read: z.boolean().optional(),
  userId: z.string()
}).strict();

export const NotificationCreateOrConnectWithoutQuestionInputSchema: z.ZodType<Prisma.NotificationCreateOrConnectWithoutQuestionInput> = z.object({
  where: z.lazy(() => NotificationWhereUniqueInputSchema),
  create: z.union([ z.lazy(() => NotificationCreateWithoutQuestionInputSchema),z.lazy(() => NotificationUncheckedCreateWithoutQuestionInputSchema) ]),
}).strict();

export const NotificationCreateManyQuestionInputEnvelopeSchema: z.ZodType<Prisma.NotificationCreateManyQuestionInputEnvelope> = z.object({
  data: z.union([ z.lazy(() => NotificationCreateManyQuestionInputSchema),z.lazy(() => NotificationCreateManyQuestionInputSchema).array() ]),
  skipDuplicates: z.boolean().optional()
}).strict();

export const QuestionOptionUpsertWithWhereUniqueWithoutQuestionInputSchema: z.ZodType<Prisma.QuestionOptionUpsertWithWhereUniqueWithoutQuestionInput> = z.object({
  where: z.lazy(() => QuestionOptionWhereUniqueInputSchema),
  update: z.union([ z.lazy(() => QuestionOptionUpdateWithoutQuestionInputSchema),z.lazy(() => QuestionOptionUncheckedUpdateWithoutQuestionInputSchema) ]),
  create: z.union([ z.lazy(() => QuestionOptionCreateWithoutQuestionInputSchema),z.lazy(() => QuestionOptionUncheckedCreateWithoutQuestionInputSchema) ]),
}).strict();

export const QuestionOptionUpdateWithWhereUniqueWithoutQuestionInputSchema: z.ZodType<Prisma.QuestionOptionUpdateWithWhereUniqueWithoutQuestionInput> = z.object({
  where: z.lazy(() => QuestionOptionWhereUniqueInputSchema),
  data: z.union([ z.lazy(() => QuestionOptionUpdateWithoutQuestionInputSchema),z.lazy(() => QuestionOptionUncheckedUpdateWithoutQuestionInputSchema) ]),
}).strict();

export const QuestionOptionUpdateManyWithWhereWithoutQuestionInputSchema: z.ZodType<Prisma.QuestionOptionUpdateManyWithWhereWithoutQuestionInput> = z.object({
  where: z.lazy(() => QuestionOptionScalarWhereInputSchema),
  data: z.union([ z.lazy(() => QuestionOptionUpdateManyMutationInputSchema),z.lazy(() => QuestionOptionUncheckedUpdateManyWithoutQuestionInputSchema) ]),
}).strict();

export const QuestionOptionScalarWhereInputSchema: z.ZodType<Prisma.QuestionOptionScalarWhereInput> = z.object({
  AND: z.union([ z.lazy(() => QuestionOptionScalarWhereInputSchema),z.lazy(() => QuestionOptionScalarWhereInputSchema).array() ]).optional(),
  OR: z.lazy(() => QuestionOptionScalarWhereInputSchema).array().optional(),
  NOT: z.union([ z.lazy(() => QuestionOptionScalarWhereInputSchema),z.lazy(() => QuestionOptionScalarWhereInputSchema).array() ]).optional(),
  id: z.union([ z.lazy(() => StringFilterSchema),z.string() ]).optional(),
  questionId: z.union([ z.lazy(() => StringFilterSchema),z.string() ]).optional(),
  text: z.union([ z.lazy(() => StringFilterSchema),z.string() ]).optional(),
  resolution: z.union([ z.lazy(() => EnumResolutionNullableFilterSchema),z.lazy(() => ResolutionSchema) ]).optional().nullable(),
  createdAt: z.union([ z.lazy(() => DateTimeFilterSchema),z.coerce.date() ]).optional(),
  userId: z.union([ z.lazy(() => StringFilterSchema),z.string() ]).optional(),
  resolvedAt: z.union([ z.lazy(() => DateTimeNullableFilterSchema),z.coerce.date() ]).optional().nullable(),
}).strict();

export const ForecastUpsertWithWhereUniqueWithoutQuestionInputSchema: z.ZodType<Prisma.ForecastUpsertWithWhereUniqueWithoutQuestionInput> = z.object({
  where: z.lazy(() => ForecastWhereUniqueInputSchema),
  update: z.union([ z.lazy(() => ForecastUpdateWithoutQuestionInputSchema),z.lazy(() => ForecastUncheckedUpdateWithoutQuestionInputSchema) ]),
  create: z.union([ z.lazy(() => ForecastCreateWithoutQuestionInputSchema),z.lazy(() => ForecastUncheckedCreateWithoutQuestionInputSchema) ]),
}).strict();

export const ForecastUpdateWithWhereUniqueWithoutQuestionInputSchema: z.ZodType<Prisma.ForecastUpdateWithWhereUniqueWithoutQuestionInput> = z.object({
  where: z.lazy(() => ForecastWhereUniqueInputSchema),
  data: z.union([ z.lazy(() => ForecastUpdateWithoutQuestionInputSchema),z.lazy(() => ForecastUncheckedUpdateWithoutQuestionInputSchema) ]),
}).strict();

export const ForecastUpdateManyWithWhereWithoutQuestionInputSchema: z.ZodType<Prisma.ForecastUpdateManyWithWhereWithoutQuestionInput> = z.object({
  where: z.lazy(() => ForecastScalarWhereInputSchema),
  data: z.union([ z.lazy(() => ForecastUpdateManyMutationInputSchema),z.lazy(() => ForecastUncheckedUpdateManyWithoutQuestionInputSchema) ]),
}).strict();

export const PingSlackMessageUpsertWithWhereUniqueWithoutQuestionInputSchema: z.ZodType<Prisma.PingSlackMessageUpsertWithWhereUniqueWithoutQuestionInput> = z.object({
  where: z.lazy(() => PingSlackMessageWhereUniqueInputSchema),
  update: z.union([ z.lazy(() => PingSlackMessageUpdateWithoutQuestionInputSchema),z.lazy(() => PingSlackMessageUncheckedUpdateWithoutQuestionInputSchema) ]),
  create: z.union([ z.lazy(() => PingSlackMessageCreateWithoutQuestionInputSchema),z.lazy(() => PingSlackMessageUncheckedCreateWithoutQuestionInputSchema) ]),
}).strict();

export const PingSlackMessageUpdateWithWhereUniqueWithoutQuestionInputSchema: z.ZodType<Prisma.PingSlackMessageUpdateWithWhereUniqueWithoutQuestionInput> = z.object({
  where: z.lazy(() => PingSlackMessageWhereUniqueInputSchema),
  data: z.union([ z.lazy(() => PingSlackMessageUpdateWithoutQuestionInputSchema),z.lazy(() => PingSlackMessageUncheckedUpdateWithoutQuestionInputSchema) ]),
}).strict();

export const PingSlackMessageUpdateManyWithWhereWithoutQuestionInputSchema: z.ZodType<Prisma.PingSlackMessageUpdateManyWithWhereWithoutQuestionInput> = z.object({
  where: z.lazy(() => PingSlackMessageScalarWhereInputSchema),
  data: z.union([ z.lazy(() => PingSlackMessageUpdateManyMutationInputSchema),z.lazy(() => PingSlackMessageUncheckedUpdateManyWithoutQuestionInputSchema) ]),
}).strict();

export const PingSlackMessageScalarWhereInputSchema: z.ZodType<Prisma.PingSlackMessageScalarWhereInput> = z.object({
  AND: z.union([ z.lazy(() => PingSlackMessageScalarWhereInputSchema),z.lazy(() => PingSlackMessageScalarWhereInputSchema).array() ]).optional(),
  OR: z.lazy(() => PingSlackMessageScalarWhereInputSchema).array().optional(),
  NOT: z.union([ z.lazy(() => PingSlackMessageScalarWhereInputSchema),z.lazy(() => PingSlackMessageScalarWhereInputSchema).array() ]).optional(),
  id: z.union([ z.lazy(() => IntFilterSchema),z.number() ]).optional(),
  questionId: z.union([ z.lazy(() => StringFilterSchema),z.string() ]).optional(),
  detailsId: z.union([ z.lazy(() => IntFilterSchema),z.number() ]).optional(),
}).strict();

export const ProfileUpsertWithoutQuestionsInputSchema: z.ZodType<Prisma.ProfileUpsertWithoutQuestionsInput> = z.object({
  update: z.union([ z.lazy(() => ProfileUpdateWithoutQuestionsInputSchema),z.lazy(() => ProfileUncheckedUpdateWithoutQuestionsInputSchema) ]),
  create: z.union([ z.lazy(() => ProfileCreateWithoutQuestionsInputSchema),z.lazy(() => ProfileUncheckedCreateWithoutQuestionsInputSchema) ]),
  where: z.lazy(() => ProfileWhereInputSchema).optional()
}).strict();

export const ProfileUpdateToOneWithWhereWithoutQuestionsInputSchema: z.ZodType<Prisma.ProfileUpdateToOneWithWhereWithoutQuestionsInput> = z.object({
  where: z.lazy(() => ProfileWhereInputSchema).optional(),
  data: z.union([ z.lazy(() => ProfileUpdateWithoutQuestionsInputSchema),z.lazy(() => ProfileUncheckedUpdateWithoutQuestionsInputSchema) ]),
}).strict();

export const ProfileUpdateWithoutQuestionsInputSchema: z.ZodType<Prisma.ProfileUpdateWithoutQuestionsInput> = z.object({
  createdAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  slackId: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  slackTeamId: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  forecasts: z.lazy(() => ForecastUpdateManyWithoutProfileNestedInputSchema).optional(),
  user: z.lazy(() => UserUpdateOneRequiredWithoutProfilesNestedInputSchema).optional(),
  resolutionMessages: z.lazy(() => ResolutionSlackMessageUpdateManyWithoutProfileNestedInputSchema).optional(),
  target: z.lazy(() => TargetUpdateOneWithoutProfileNestedInputSchema).optional()
}).strict();

export const ProfileUncheckedUpdateWithoutQuestionsInputSchema: z.ZodType<Prisma.ProfileUncheckedUpdateWithoutQuestionsInput> = z.object({
  id: z.union([ z.number().int(),z.lazy(() => IntFieldUpdateOperationsInputSchema) ]).optional(),
  createdAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  slackId: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  slackTeamId: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  userId: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  forecasts: z.lazy(() => ForecastUncheckedUpdateManyWithoutProfileNestedInputSchema).optional(),
  resolutionMessages: z.lazy(() => ResolutionSlackMessageUncheckedUpdateManyWithoutProfileNestedInputSchema).optional(),
  target: z.lazy(() => TargetUncheckedUpdateOneWithoutProfileNestedInputSchema).optional()
}).strict();

export const UserUpsertWithoutQuestionsInputSchema: z.ZodType<Prisma.UserUpsertWithoutQuestionsInput> = z.object({
  update: z.union([ z.lazy(() => UserUpdateWithoutQuestionsInputSchema),z.lazy(() => UserUncheckedUpdateWithoutQuestionsInputSchema) ]),
  create: z.union([ z.lazy(() => UserCreateWithoutQuestionsInputSchema),z.lazy(() => UserUncheckedCreateWithoutQuestionsInputSchema) ]),
  where: z.lazy(() => UserWhereInputSchema).optional()
}).strict();

export const UserUpdateToOneWithWhereWithoutQuestionsInputSchema: z.ZodType<Prisma.UserUpdateToOneWithWhereWithoutQuestionsInput> = z.object({
  where: z.lazy(() => UserWhereInputSchema).optional(),
  data: z.union([ z.lazy(() => UserUpdateWithoutQuestionsInputSchema),z.lazy(() => UserUncheckedUpdateWithoutQuestionsInputSchema) ]),
}).strict();

export const UserUpdateWithoutQuestionsInputSchema: z.ZodType<Prisma.UserUpdateWithoutQuestionsInput> = z.object({
  id: z.union([ z.string().cuid(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  name: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  createdAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  email: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  image: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  staleReminder: z.union([ z.boolean(),z.lazy(() => BoolFieldUpdateOperationsInputSchema) ]).optional(),
  unsubscribedFromEmailsAt: z.union([ z.coerce.date(),z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  apiKey: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  discordUserId: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  emailVerified: z.union([ z.coerce.date(),z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  forecasts: z.lazy(() => ForecastUpdateManyWithoutUserNestedInputSchema).optional(),
  profiles: z.lazy(() => ProfileUpdateManyWithoutUserNestedInputSchema).optional(),
  questionScores: z.lazy(() => QuestionScoreUpdateManyWithoutUserNestedInputSchema).optional(),
  questionsSharedWith: z.lazy(() => QuestionUpdateManyWithoutSharedWithNestedInputSchema).optional(),
  comments: z.lazy(() => CommentUpdateManyWithoutUserNestedInputSchema).optional(),
  target: z.lazy(() => TargetUpdateOneWithoutUserNestedInputSchema).optional(),
  authorOfLists: z.lazy(() => UserListUpdateManyWithoutAuthorNestedInputSchema).optional(),
  memberOfLists: z.lazy(() => UserListUpdateManyWithoutUsersNestedInputSchema).optional(),
  tags: z.lazy(() => TagUpdateManyWithoutUserNestedInputSchema).optional(),
  tournaments: z.lazy(() => TournamentUpdateManyWithoutAuthorNestedInputSchema).optional(),
  notifications: z.lazy(() => NotificationUpdateManyWithoutUserNestedInputSchema).optional(),
  questionOptions: z.lazy(() => QuestionOptionUpdateManyWithoutUserNestedInputSchema).optional(),
  accounts: z.lazy(() => AccountUpdateManyWithoutUserNestedInputSchema).optional()
}).strict();

export const UserUncheckedUpdateWithoutQuestionsInputSchema: z.ZodType<Prisma.UserUncheckedUpdateWithoutQuestionsInput> = z.object({
  id: z.union([ z.string().cuid(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  name: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  createdAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  email: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  image: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  staleReminder: z.union([ z.boolean(),z.lazy(() => BoolFieldUpdateOperationsInputSchema) ]).optional(),
  unsubscribedFromEmailsAt: z.union([ z.coerce.date(),z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  apiKey: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  discordUserId: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  emailVerified: z.union([ z.coerce.date(),z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  forecasts: z.lazy(() => ForecastUncheckedUpdateManyWithoutUserNestedInputSchema).optional(),
  profiles: z.lazy(() => ProfileUncheckedUpdateManyWithoutUserNestedInputSchema).optional(),
  questionScores: z.lazy(() => QuestionScoreUncheckedUpdateManyWithoutUserNestedInputSchema).optional(),
  questionsSharedWith: z.lazy(() => QuestionUncheckedUpdateManyWithoutSharedWithNestedInputSchema).optional(),
  comments: z.lazy(() => CommentUncheckedUpdateManyWithoutUserNestedInputSchema).optional(),
  target: z.lazy(() => TargetUncheckedUpdateOneWithoutUserNestedInputSchema).optional(),
  authorOfLists: z.lazy(() => UserListUncheckedUpdateManyWithoutAuthorNestedInputSchema).optional(),
  memberOfLists: z.lazy(() => UserListUncheckedUpdateManyWithoutUsersNestedInputSchema).optional(),
  tags: z.lazy(() => TagUncheckedUpdateManyWithoutUserNestedInputSchema).optional(),
  tournaments: z.lazy(() => TournamentUncheckedUpdateManyWithoutAuthorNestedInputSchema).optional(),
  notifications: z.lazy(() => NotificationUncheckedUpdateManyWithoutUserNestedInputSchema).optional(),
  questionOptions: z.lazy(() => QuestionOptionUncheckedUpdateManyWithoutUserNestedInputSchema).optional(),
  accounts: z.lazy(() => AccountUncheckedUpdateManyWithoutUserNestedInputSchema).optional()
}).strict();

export const UserUpsertWithWhereUniqueWithoutQuestionsSharedWithInputSchema: z.ZodType<Prisma.UserUpsertWithWhereUniqueWithoutQuestionsSharedWithInput> = z.object({
  where: z.lazy(() => UserWhereUniqueInputSchema),
  update: z.union([ z.lazy(() => UserUpdateWithoutQuestionsSharedWithInputSchema),z.lazy(() => UserUncheckedUpdateWithoutQuestionsSharedWithInputSchema) ]),
  create: z.union([ z.lazy(() => UserCreateWithoutQuestionsSharedWithInputSchema),z.lazy(() => UserUncheckedCreateWithoutQuestionsSharedWithInputSchema) ]),
}).strict();

export const UserUpdateWithWhereUniqueWithoutQuestionsSharedWithInputSchema: z.ZodType<Prisma.UserUpdateWithWhereUniqueWithoutQuestionsSharedWithInput> = z.object({
  where: z.lazy(() => UserWhereUniqueInputSchema),
  data: z.union([ z.lazy(() => UserUpdateWithoutQuestionsSharedWithInputSchema),z.lazy(() => UserUncheckedUpdateWithoutQuestionsSharedWithInputSchema) ]),
}).strict();

export const UserUpdateManyWithWhereWithoutQuestionsSharedWithInputSchema: z.ZodType<Prisma.UserUpdateManyWithWhereWithoutQuestionsSharedWithInput> = z.object({
  where: z.lazy(() => UserScalarWhereInputSchema),
  data: z.union([ z.lazy(() => UserUpdateManyMutationInputSchema),z.lazy(() => UserUncheckedUpdateManyWithoutQuestionsSharedWithInputSchema) ]),
}).strict();

export const UserScalarWhereInputSchema: z.ZodType<Prisma.UserScalarWhereInput> = z.object({
  AND: z.union([ z.lazy(() => UserScalarWhereInputSchema),z.lazy(() => UserScalarWhereInputSchema).array() ]).optional(),
  OR: z.lazy(() => UserScalarWhereInputSchema).array().optional(),
  NOT: z.union([ z.lazy(() => UserScalarWhereInputSchema),z.lazy(() => UserScalarWhereInputSchema).array() ]).optional(),
  id: z.union([ z.lazy(() => StringFilterSchema),z.string() ]).optional(),
  name: z.union([ z.lazy(() => StringNullableFilterSchema),z.string() ]).optional().nullable(),
  createdAt: z.union([ z.lazy(() => DateTimeFilterSchema),z.coerce.date() ]).optional(),
  email: z.union([ z.lazy(() => StringFilterSchema),z.string() ]).optional(),
  image: z.union([ z.lazy(() => StringNullableFilterSchema),z.string() ]).optional().nullable(),
  staleReminder: z.union([ z.lazy(() => BoolFilterSchema),z.boolean() ]).optional(),
  unsubscribedFromEmailsAt: z.union([ z.lazy(() => DateTimeNullableFilterSchema),z.coerce.date() ]).optional().nullable(),
  apiKey: z.union([ z.lazy(() => StringNullableFilterSchema),z.string() ]).optional().nullable(),
  discordUserId: z.union([ z.lazy(() => StringNullableFilterSchema),z.string() ]).optional().nullable(),
  emailVerified: z.union([ z.lazy(() => DateTimeNullableFilterSchema),z.coerce.date() ]).optional().nullable(),
}).strict();

export const UserListUpsertWithWhereUniqueWithoutQuestionsInputSchema: z.ZodType<Prisma.UserListUpsertWithWhereUniqueWithoutQuestionsInput> = z.object({
  where: z.lazy(() => UserListWhereUniqueInputSchema),
  update: z.union([ z.lazy(() => UserListUpdateWithoutQuestionsInputSchema),z.lazy(() => UserListUncheckedUpdateWithoutQuestionsInputSchema) ]),
  create: z.union([ z.lazy(() => UserListCreateWithoutQuestionsInputSchema),z.lazy(() => UserListUncheckedCreateWithoutQuestionsInputSchema) ]),
}).strict();

export const UserListUpdateWithWhereUniqueWithoutQuestionsInputSchema: z.ZodType<Prisma.UserListUpdateWithWhereUniqueWithoutQuestionsInput> = z.object({
  where: z.lazy(() => UserListWhereUniqueInputSchema),
  data: z.union([ z.lazy(() => UserListUpdateWithoutQuestionsInputSchema),z.lazy(() => UserListUncheckedUpdateWithoutQuestionsInputSchema) ]),
}).strict();

export const UserListUpdateManyWithWhereWithoutQuestionsInputSchema: z.ZodType<Prisma.UserListUpdateManyWithWhereWithoutQuestionsInput> = z.object({
  where: z.lazy(() => UserListScalarWhereInputSchema),
  data: z.union([ z.lazy(() => UserListUpdateManyMutationInputSchema),z.lazy(() => UserListUncheckedUpdateManyWithoutQuestionsInputSchema) ]),
}).strict();

export const UserListScalarWhereInputSchema: z.ZodType<Prisma.UserListScalarWhereInput> = z.object({
  AND: z.union([ z.lazy(() => UserListScalarWhereInputSchema),z.lazy(() => UserListScalarWhereInputSchema).array() ]).optional(),
  OR: z.lazy(() => UserListScalarWhereInputSchema).array().optional(),
  NOT: z.union([ z.lazy(() => UserListScalarWhereInputSchema),z.lazy(() => UserListScalarWhereInputSchema).array() ]).optional(),
  id: z.union([ z.lazy(() => StringFilterSchema),z.string() ]).optional(),
  createdAt: z.union([ z.lazy(() => DateTimeFilterSchema),z.coerce.date() ]).optional(),
  inviteId: z.union([ z.lazy(() => StringNullableFilterSchema),z.string() ]).optional().nullable(),
  name: z.union([ z.lazy(() => StringFilterSchema),z.string() ]).optional(),
  emailDomains: z.lazy(() => StringNullableListFilterSchema).optional(),
  syncToSlackTeamId: z.union([ z.lazy(() => StringNullableFilterSchema),z.string() ]).optional().nullable(),
  syncToSlackChannelId: z.union([ z.lazy(() => StringNullableFilterSchema),z.string() ]).optional().nullable(),
  authorId: z.union([ z.lazy(() => StringFilterSchema),z.string() ]).optional(),
}).strict();

export const QuestionScoreUpsertWithWhereUniqueWithoutQuestionInputSchema: z.ZodType<Prisma.QuestionScoreUpsertWithWhereUniqueWithoutQuestionInput> = z.object({
  where: z.lazy(() => QuestionScoreWhereUniqueInputSchema),
  update: z.union([ z.lazy(() => QuestionScoreUpdateWithoutQuestionInputSchema),z.lazy(() => QuestionScoreUncheckedUpdateWithoutQuestionInputSchema) ]),
  create: z.union([ z.lazy(() => QuestionScoreCreateWithoutQuestionInputSchema),z.lazy(() => QuestionScoreUncheckedCreateWithoutQuestionInputSchema) ]),
}).strict();

export const QuestionScoreUpdateWithWhereUniqueWithoutQuestionInputSchema: z.ZodType<Prisma.QuestionScoreUpdateWithWhereUniqueWithoutQuestionInput> = z.object({
  where: z.lazy(() => QuestionScoreWhereUniqueInputSchema),
  data: z.union([ z.lazy(() => QuestionScoreUpdateWithoutQuestionInputSchema),z.lazy(() => QuestionScoreUncheckedUpdateWithoutQuestionInputSchema) ]),
}).strict();

export const QuestionScoreUpdateManyWithWhereWithoutQuestionInputSchema: z.ZodType<Prisma.QuestionScoreUpdateManyWithWhereWithoutQuestionInput> = z.object({
  where: z.lazy(() => QuestionScoreScalarWhereInputSchema),
  data: z.union([ z.lazy(() => QuestionScoreUpdateManyMutationInputSchema),z.lazy(() => QuestionScoreUncheckedUpdateManyWithoutQuestionInputSchema) ]),
}).strict();

export const QuestionSlackMessageUpsertWithWhereUniqueWithoutQuestionInputSchema: z.ZodType<Prisma.QuestionSlackMessageUpsertWithWhereUniqueWithoutQuestionInput> = z.object({
  where: z.lazy(() => QuestionSlackMessageWhereUniqueInputSchema),
  update: z.union([ z.lazy(() => QuestionSlackMessageUpdateWithoutQuestionInputSchema),z.lazy(() => QuestionSlackMessageUncheckedUpdateWithoutQuestionInputSchema) ]),
  create: z.union([ z.lazy(() => QuestionSlackMessageCreateWithoutQuestionInputSchema),z.lazy(() => QuestionSlackMessageUncheckedCreateWithoutQuestionInputSchema) ]),
}).strict();

export const QuestionSlackMessageUpdateWithWhereUniqueWithoutQuestionInputSchema: z.ZodType<Prisma.QuestionSlackMessageUpdateWithWhereUniqueWithoutQuestionInput> = z.object({
  where: z.lazy(() => QuestionSlackMessageWhereUniqueInputSchema),
  data: z.union([ z.lazy(() => QuestionSlackMessageUpdateWithoutQuestionInputSchema),z.lazy(() => QuestionSlackMessageUncheckedUpdateWithoutQuestionInputSchema) ]),
}).strict();

export const QuestionSlackMessageUpdateManyWithWhereWithoutQuestionInputSchema: z.ZodType<Prisma.QuestionSlackMessageUpdateManyWithWhereWithoutQuestionInput> = z.object({
  where: z.lazy(() => QuestionSlackMessageScalarWhereInputSchema),
  data: z.union([ z.lazy(() => QuestionSlackMessageUpdateManyMutationInputSchema),z.lazy(() => QuestionSlackMessageUncheckedUpdateManyWithoutQuestionInputSchema) ]),
}).strict();

export const QuestionSlackMessageScalarWhereInputSchema: z.ZodType<Prisma.QuestionSlackMessageScalarWhereInput> = z.object({
  AND: z.union([ z.lazy(() => QuestionSlackMessageScalarWhereInputSchema),z.lazy(() => QuestionSlackMessageScalarWhereInputSchema).array() ]).optional(),
  OR: z.lazy(() => QuestionSlackMessageScalarWhereInputSchema).array().optional(),
  NOT: z.union([ z.lazy(() => QuestionSlackMessageScalarWhereInputSchema),z.lazy(() => QuestionSlackMessageScalarWhereInputSchema).array() ]).optional(),
  id: z.union([ z.lazy(() => IntFilterSchema),z.number() ]).optional(),
  questionId: z.union([ z.lazy(() => StringFilterSchema),z.string() ]).optional(),
  detailsId: z.union([ z.lazy(() => IntFilterSchema),z.number() ]).optional(),
  updatedAt: z.union([ z.lazy(() => DateTimeFilterSchema),z.coerce.date() ]).optional(),
}).strict();

export const ResolutionSlackMessageUpsertWithWhereUniqueWithoutQuestionInputSchema: z.ZodType<Prisma.ResolutionSlackMessageUpsertWithWhereUniqueWithoutQuestionInput> = z.object({
  where: z.lazy(() => ResolutionSlackMessageWhereUniqueInputSchema),
  update: z.union([ z.lazy(() => ResolutionSlackMessageUpdateWithoutQuestionInputSchema),z.lazy(() => ResolutionSlackMessageUncheckedUpdateWithoutQuestionInputSchema) ]),
  create: z.union([ z.lazy(() => ResolutionSlackMessageCreateWithoutQuestionInputSchema),z.lazy(() => ResolutionSlackMessageUncheckedCreateWithoutQuestionInputSchema) ]),
}).strict();

export const ResolutionSlackMessageUpdateWithWhereUniqueWithoutQuestionInputSchema: z.ZodType<Prisma.ResolutionSlackMessageUpdateWithWhereUniqueWithoutQuestionInput> = z.object({
  where: z.lazy(() => ResolutionSlackMessageWhereUniqueInputSchema),
  data: z.union([ z.lazy(() => ResolutionSlackMessageUpdateWithoutQuestionInputSchema),z.lazy(() => ResolutionSlackMessageUncheckedUpdateWithoutQuestionInputSchema) ]),
}).strict();

export const ResolutionSlackMessageUpdateManyWithWhereWithoutQuestionInputSchema: z.ZodType<Prisma.ResolutionSlackMessageUpdateManyWithWhereWithoutQuestionInput> = z.object({
  where: z.lazy(() => ResolutionSlackMessageScalarWhereInputSchema),
  data: z.union([ z.lazy(() => ResolutionSlackMessageUpdateManyMutationInputSchema),z.lazy(() => ResolutionSlackMessageUncheckedUpdateManyWithoutQuestionInputSchema) ]),
}).strict();

export const ResolutionSlackMessageScalarWhereInputSchema: z.ZodType<Prisma.ResolutionSlackMessageScalarWhereInput> = z.object({
  AND: z.union([ z.lazy(() => ResolutionSlackMessageScalarWhereInputSchema),z.lazy(() => ResolutionSlackMessageScalarWhereInputSchema).array() ]).optional(),
  OR: z.lazy(() => ResolutionSlackMessageScalarWhereInputSchema).array().optional(),
  NOT: z.union([ z.lazy(() => ResolutionSlackMessageScalarWhereInputSchema),z.lazy(() => ResolutionSlackMessageScalarWhereInputSchema).array() ]).optional(),
  id: z.union([ z.lazy(() => IntFilterSchema),z.number() ]).optional(),
  questionId: z.union([ z.lazy(() => StringFilterSchema),z.string() ]).optional(),
  detailsId: z.union([ z.lazy(() => IntFilterSchema),z.number() ]).optional(),
  profileId: z.union([ z.lazy(() => IntNullableFilterSchema),z.number() ]).optional().nullable(),
}).strict();

export const CommentUpsertWithWhereUniqueWithoutQuestionInputSchema: z.ZodType<Prisma.CommentUpsertWithWhereUniqueWithoutQuestionInput> = z.object({
  where: z.lazy(() => CommentWhereUniqueInputSchema),
  update: z.union([ z.lazy(() => CommentUpdateWithoutQuestionInputSchema),z.lazy(() => CommentUncheckedUpdateWithoutQuestionInputSchema) ]),
  create: z.union([ z.lazy(() => CommentCreateWithoutQuestionInputSchema),z.lazy(() => CommentUncheckedCreateWithoutQuestionInputSchema) ]),
}).strict();

export const CommentUpdateWithWhereUniqueWithoutQuestionInputSchema: z.ZodType<Prisma.CommentUpdateWithWhereUniqueWithoutQuestionInput> = z.object({
  where: z.lazy(() => CommentWhereUniqueInputSchema),
  data: z.union([ z.lazy(() => CommentUpdateWithoutQuestionInputSchema),z.lazy(() => CommentUncheckedUpdateWithoutQuestionInputSchema) ]),
}).strict();

export const CommentUpdateManyWithWhereWithoutQuestionInputSchema: z.ZodType<Prisma.CommentUpdateManyWithWhereWithoutQuestionInput> = z.object({
  where: z.lazy(() => CommentScalarWhereInputSchema),
  data: z.union([ z.lazy(() => CommentUpdateManyMutationInputSchema),z.lazy(() => CommentUncheckedUpdateManyWithoutQuestionInputSchema) ]),
}).strict();

export const CommentScalarWhereInputSchema: z.ZodType<Prisma.CommentScalarWhereInput> = z.object({
  AND: z.union([ z.lazy(() => CommentScalarWhereInputSchema),z.lazy(() => CommentScalarWhereInputSchema).array() ]).optional(),
  OR: z.lazy(() => CommentScalarWhereInputSchema).array().optional(),
  NOT: z.union([ z.lazy(() => CommentScalarWhereInputSchema),z.lazy(() => CommentScalarWhereInputSchema).array() ]).optional(),
  id: z.union([ z.lazy(() => IntFilterSchema),z.number() ]).optional(),
  createdAt: z.union([ z.lazy(() => DateTimeFilterSchema),z.coerce.date() ]).optional(),
  comment: z.union([ z.lazy(() => StringFilterSchema),z.string() ]).optional(),
  questionId: z.union([ z.lazy(() => StringFilterSchema),z.string() ]).optional(),
  userId: z.union([ z.lazy(() => StringFilterSchema),z.string() ]).optional(),
}).strict();

export const TagUpsertWithWhereUniqueWithoutQuestionsInputSchema: z.ZodType<Prisma.TagUpsertWithWhereUniqueWithoutQuestionsInput> = z.object({
  where: z.lazy(() => TagWhereUniqueInputSchema),
  update: z.union([ z.lazy(() => TagUpdateWithoutQuestionsInputSchema),z.lazy(() => TagUncheckedUpdateWithoutQuestionsInputSchema) ]),
  create: z.union([ z.lazy(() => TagCreateWithoutQuestionsInputSchema),z.lazy(() => TagUncheckedCreateWithoutQuestionsInputSchema) ]),
}).strict();

export const TagUpdateWithWhereUniqueWithoutQuestionsInputSchema: z.ZodType<Prisma.TagUpdateWithWhereUniqueWithoutQuestionsInput> = z.object({
  where: z.lazy(() => TagWhereUniqueInputSchema),
  data: z.union([ z.lazy(() => TagUpdateWithoutQuestionsInputSchema),z.lazy(() => TagUncheckedUpdateWithoutQuestionsInputSchema) ]),
}).strict();

export const TagUpdateManyWithWhereWithoutQuestionsInputSchema: z.ZodType<Prisma.TagUpdateManyWithWhereWithoutQuestionsInput> = z.object({
  where: z.lazy(() => TagScalarWhereInputSchema),
  data: z.union([ z.lazy(() => TagUpdateManyMutationInputSchema),z.lazy(() => TagUncheckedUpdateManyWithoutQuestionsInputSchema) ]),
}).strict();

export const TagScalarWhereInputSchema: z.ZodType<Prisma.TagScalarWhereInput> = z.object({
  AND: z.union([ z.lazy(() => TagScalarWhereInputSchema),z.lazy(() => TagScalarWhereInputSchema).array() ]).optional(),
  OR: z.lazy(() => TagScalarWhereInputSchema).array().optional(),
  NOT: z.union([ z.lazy(() => TagScalarWhereInputSchema),z.lazy(() => TagScalarWhereInputSchema).array() ]).optional(),
  id: z.union([ z.lazy(() => StringFilterSchema),z.string() ]).optional(),
  createdAt: z.union([ z.lazy(() => DateTimeFilterSchema),z.coerce.date() ]).optional(),
  name: z.union([ z.lazy(() => StringFilterSchema),z.string() ]).optional(),
  userId: z.union([ z.lazy(() => StringFilterSchema),z.string() ]).optional(),
}).strict();

export const TournamentUpsertWithWhereUniqueWithoutQuestionsInputSchema: z.ZodType<Prisma.TournamentUpsertWithWhereUniqueWithoutQuestionsInput> = z.object({
  where: z.lazy(() => TournamentWhereUniqueInputSchema),
  update: z.union([ z.lazy(() => TournamentUpdateWithoutQuestionsInputSchema),z.lazy(() => TournamentUncheckedUpdateWithoutQuestionsInputSchema) ]),
  create: z.union([ z.lazy(() => TournamentCreateWithoutQuestionsInputSchema),z.lazy(() => TournamentUncheckedCreateWithoutQuestionsInputSchema) ]),
}).strict();

export const TournamentUpdateWithWhereUniqueWithoutQuestionsInputSchema: z.ZodType<Prisma.TournamentUpdateWithWhereUniqueWithoutQuestionsInput> = z.object({
  where: z.lazy(() => TournamentWhereUniqueInputSchema),
  data: z.union([ z.lazy(() => TournamentUpdateWithoutQuestionsInputSchema),z.lazy(() => TournamentUncheckedUpdateWithoutQuestionsInputSchema) ]),
}).strict();

export const TournamentUpdateManyWithWhereWithoutQuestionsInputSchema: z.ZodType<Prisma.TournamentUpdateManyWithWhereWithoutQuestionsInput> = z.object({
  where: z.lazy(() => TournamentScalarWhereInputSchema),
  data: z.union([ z.lazy(() => TournamentUpdateManyMutationInputSchema),z.lazy(() => TournamentUncheckedUpdateManyWithoutQuestionsInputSchema) ]),
}).strict();

export const TournamentScalarWhereInputSchema: z.ZodType<Prisma.TournamentScalarWhereInput> = z.object({
  AND: z.union([ z.lazy(() => TournamentScalarWhereInputSchema),z.lazy(() => TournamentScalarWhereInputSchema).array() ]).optional(),
  OR: z.lazy(() => TournamentScalarWhereInputSchema).array().optional(),
  NOT: z.union([ z.lazy(() => TournamentScalarWhereInputSchema),z.lazy(() => TournamentScalarWhereInputSchema).array() ]).optional(),
  id: z.union([ z.lazy(() => StringFilterSchema),z.string() ]).optional(),
  createdAt: z.union([ z.lazy(() => DateTimeFilterSchema),z.coerce.date() ]).optional(),
  name: z.union([ z.lazy(() => StringFilterSchema),z.string() ]).optional(),
  description: z.union([ z.lazy(() => StringNullableFilterSchema),z.string() ]).optional().nullable(),
  authorId: z.union([ z.lazy(() => StringFilterSchema),z.string() ]).optional(),
  sharedPublicly: z.union([ z.lazy(() => BoolFilterSchema),z.boolean() ]).optional(),
  unlisted: z.union([ z.lazy(() => BoolFilterSchema),z.boolean() ]).optional(),
  userListId: z.union([ z.lazy(() => StringNullableFilterSchema),z.string() ]).optional().nullable(),
  anyoneInListCanEdit: z.union([ z.lazy(() => BoolFilterSchema),z.boolean() ]).optional(),
  showLeaderboard: z.union([ z.lazy(() => BoolFilterSchema),z.boolean() ]).optional(),
  predictYourYear: z.union([ z.lazy(() => IntNullableFilterSchema),z.number() ]).optional().nullable(),
  syncToSlackTeamId: z.union([ z.lazy(() => StringNullableFilterSchema),z.string() ]).optional().nullable(),
  syncToSlackChannelId: z.union([ z.lazy(() => StringNullableFilterSchema),z.string() ]).optional().nullable(),
}).strict();

export const NotificationUpsertWithWhereUniqueWithoutQuestionInputSchema: z.ZodType<Prisma.NotificationUpsertWithWhereUniqueWithoutQuestionInput> = z.object({
  where: z.lazy(() => NotificationWhereUniqueInputSchema),
  update: z.union([ z.lazy(() => NotificationUpdateWithoutQuestionInputSchema),z.lazy(() => NotificationUncheckedUpdateWithoutQuestionInputSchema) ]),
  create: z.union([ z.lazy(() => NotificationCreateWithoutQuestionInputSchema),z.lazy(() => NotificationUncheckedCreateWithoutQuestionInputSchema) ]),
}).strict();

export const NotificationUpdateWithWhereUniqueWithoutQuestionInputSchema: z.ZodType<Prisma.NotificationUpdateWithWhereUniqueWithoutQuestionInput> = z.object({
  where: z.lazy(() => NotificationWhereUniqueInputSchema),
  data: z.union([ z.lazy(() => NotificationUpdateWithoutQuestionInputSchema),z.lazy(() => NotificationUncheckedUpdateWithoutQuestionInputSchema) ]),
}).strict();

export const NotificationUpdateManyWithWhereWithoutQuestionInputSchema: z.ZodType<Prisma.NotificationUpdateManyWithWhereWithoutQuestionInput> = z.object({
  where: z.lazy(() => NotificationScalarWhereInputSchema),
  data: z.union([ z.lazy(() => NotificationUpdateManyMutationInputSchema),z.lazy(() => NotificationUncheckedUpdateManyWithoutQuestionInputSchema) ]),
}).strict();

export const NotificationScalarWhereInputSchema: z.ZodType<Prisma.NotificationScalarWhereInput> = z.object({
  AND: z.union([ z.lazy(() => NotificationScalarWhereInputSchema),z.lazy(() => NotificationScalarWhereInputSchema).array() ]).optional(),
  OR: z.lazy(() => NotificationScalarWhereInputSchema).array().optional(),
  NOT: z.union([ z.lazy(() => NotificationScalarWhereInputSchema),z.lazy(() => NotificationScalarWhereInputSchema).array() ]).optional(),
  id: z.union([ z.lazy(() => StringFilterSchema),z.string() ]).optional(),
  createdAt: z.union([ z.lazy(() => DateTimeFilterSchema),z.coerce.date() ]).optional(),
  emailSentAt: z.union([ z.lazy(() => DateTimeNullableFilterSchema),z.coerce.date() ]).optional().nullable(),
  title: z.union([ z.lazy(() => StringFilterSchema),z.string() ]).optional(),
  content: z.union([ z.lazy(() => StringFilterSchema),z.string() ]).optional(),
  url: z.union([ z.lazy(() => StringNullableFilterSchema),z.string() ]).optional().nullable(),
  tags: z.lazy(() => StringNullableListFilterSchema).optional(),
  read: z.union([ z.lazy(() => BoolFilterSchema),z.boolean() ]).optional(),
  userId: z.union([ z.lazy(() => StringFilterSchema),z.string() ]).optional(),
  questionId: z.union([ z.lazy(() => StringNullableFilterSchema),z.string() ]).optional().nullable(),
}).strict();

export const UserCreateWithoutTagsInputSchema: z.ZodType<Prisma.UserCreateWithoutTagsInput> = z.object({
  id: z.string().cuid().optional(),
  name: z.string().optional().nullable(),
  createdAt: z.coerce.date().optional(),
  email: z.string(),
  image: z.string().optional().nullable(),
  staleReminder: z.boolean().optional(),
  unsubscribedFromEmailsAt: z.coerce.date().optional().nullable(),
  apiKey: z.string().optional().nullable(),
  discordUserId: z.string().optional().nullable(),
  emailVerified: z.coerce.date().optional().nullable(),
  forecasts: z.lazy(() => ForecastCreateNestedManyWithoutUserInputSchema).optional(),
  profiles: z.lazy(() => ProfileCreateNestedManyWithoutUserInputSchema).optional(),
  questions: z.lazy(() => QuestionCreateNestedManyWithoutUserInputSchema).optional(),
  questionScores: z.lazy(() => QuestionScoreCreateNestedManyWithoutUserInputSchema).optional(),
  questionsSharedWith: z.lazy(() => QuestionCreateNestedManyWithoutSharedWithInputSchema).optional(),
  comments: z.lazy(() => CommentCreateNestedManyWithoutUserInputSchema).optional(),
  target: z.lazy(() => TargetCreateNestedOneWithoutUserInputSchema).optional(),
  authorOfLists: z.lazy(() => UserListCreateNestedManyWithoutAuthorInputSchema).optional(),
  memberOfLists: z.lazy(() => UserListCreateNestedManyWithoutUsersInputSchema).optional(),
  tournaments: z.lazy(() => TournamentCreateNestedManyWithoutAuthorInputSchema).optional(),
  notifications: z.lazy(() => NotificationCreateNestedManyWithoutUserInputSchema).optional(),
  questionOptions: z.lazy(() => QuestionOptionCreateNestedManyWithoutUserInputSchema).optional(),
  accounts: z.lazy(() => AccountCreateNestedManyWithoutUserInputSchema).optional()
}).strict();

export const UserUncheckedCreateWithoutTagsInputSchema: z.ZodType<Prisma.UserUncheckedCreateWithoutTagsInput> = z.object({
  id: z.string().cuid().optional(),
  name: z.string().optional().nullable(),
  createdAt: z.coerce.date().optional(),
  email: z.string(),
  image: z.string().optional().nullable(),
  staleReminder: z.boolean().optional(),
  unsubscribedFromEmailsAt: z.coerce.date().optional().nullable(),
  apiKey: z.string().optional().nullable(),
  discordUserId: z.string().optional().nullable(),
  emailVerified: z.coerce.date().optional().nullable(),
  forecasts: z.lazy(() => ForecastUncheckedCreateNestedManyWithoutUserInputSchema).optional(),
  profiles: z.lazy(() => ProfileUncheckedCreateNestedManyWithoutUserInputSchema).optional(),
  questions: z.lazy(() => QuestionUncheckedCreateNestedManyWithoutUserInputSchema).optional(),
  questionScores: z.lazy(() => QuestionScoreUncheckedCreateNestedManyWithoutUserInputSchema).optional(),
  questionsSharedWith: z.lazy(() => QuestionUncheckedCreateNestedManyWithoutSharedWithInputSchema).optional(),
  comments: z.lazy(() => CommentUncheckedCreateNestedManyWithoutUserInputSchema).optional(),
  target: z.lazy(() => TargetUncheckedCreateNestedOneWithoutUserInputSchema).optional(),
  authorOfLists: z.lazy(() => UserListUncheckedCreateNestedManyWithoutAuthorInputSchema).optional(),
  memberOfLists: z.lazy(() => UserListUncheckedCreateNestedManyWithoutUsersInputSchema).optional(),
  tournaments: z.lazy(() => TournamentUncheckedCreateNestedManyWithoutAuthorInputSchema).optional(),
  notifications: z.lazy(() => NotificationUncheckedCreateNestedManyWithoutUserInputSchema).optional(),
  questionOptions: z.lazy(() => QuestionOptionUncheckedCreateNestedManyWithoutUserInputSchema).optional(),
  accounts: z.lazy(() => AccountUncheckedCreateNestedManyWithoutUserInputSchema).optional()
}).strict();

export const UserCreateOrConnectWithoutTagsInputSchema: z.ZodType<Prisma.UserCreateOrConnectWithoutTagsInput> = z.object({
  where: z.lazy(() => UserWhereUniqueInputSchema),
  create: z.union([ z.lazy(() => UserCreateWithoutTagsInputSchema),z.lazy(() => UserUncheckedCreateWithoutTagsInputSchema) ]),
}).strict();

export const QuestionCreateWithoutTagsInputSchema: z.ZodType<Prisma.QuestionCreateWithoutTagsInput> = z.object({
  id: z.string().cuid().optional(),
  createdAt: z.coerce.date().optional(),
  comment: z.string().optional().nullable(),
  title: z.string(),
  type: z.lazy(() => QuestionTypeSchema).optional(),
  resolveBy: z.coerce.date(),
  resolved: z.boolean().optional(),
  pingedForResolution: z.boolean().optional(),
  resolution: z.lazy(() => ResolutionSchema).optional().nullable(),
  resolvedAt: z.coerce.date().optional().nullable(),
  notes: z.string().optional().nullable(),
  hideForecastsUntil: z.coerce.date().optional().nullable(),
  hideForecastsUntilPrediction: z.boolean().optional().nullable(),
  sharedPublicly: z.boolean().optional(),
  unlisted: z.boolean().optional(),
  exclusiveAnswers: z.boolean().optional().nullable(),
  options: z.lazy(() => QuestionOptionCreateNestedManyWithoutQuestionInputSchema).optional(),
  forecasts: z.lazy(() => ForecastCreateNestedManyWithoutQuestionInputSchema).optional(),
  pingResolveMessages: z.lazy(() => PingSlackMessageCreateNestedManyWithoutQuestionInputSchema).optional(),
  profile: z.lazy(() => ProfileCreateNestedOneWithoutQuestionsInputSchema).optional(),
  user: z.lazy(() => UserCreateNestedOneWithoutQuestionsInputSchema),
  sharedWith: z.lazy(() => UserCreateNestedManyWithoutQuestionsSharedWithInputSchema).optional(),
  sharedWithLists: z.lazy(() => UserListCreateNestedManyWithoutQuestionsInputSchema).optional(),
  questionScores: z.lazy(() => QuestionScoreCreateNestedManyWithoutQuestionInputSchema).optional(),
  questionMessages: z.lazy(() => QuestionSlackMessageCreateNestedManyWithoutQuestionInputSchema).optional(),
  resolutionMessages: z.lazy(() => ResolutionSlackMessageCreateNestedManyWithoutQuestionInputSchema).optional(),
  comments: z.lazy(() => CommentCreateNestedManyWithoutQuestionInputSchema).optional(),
  tournaments: z.lazy(() => TournamentCreateNestedManyWithoutQuestionsInputSchema).optional(),
  notifications: z.lazy(() => NotificationCreateNestedManyWithoutQuestionInputSchema).optional()
}).strict();

export const QuestionUncheckedCreateWithoutTagsInputSchema: z.ZodType<Prisma.QuestionUncheckedCreateWithoutTagsInput> = z.object({
  id: z.string().cuid().optional(),
  createdAt: z.coerce.date().optional(),
  comment: z.string().optional().nullable(),
  profileId: z.number().int().optional().nullable(),
  title: z.string(),
  type: z.lazy(() => QuestionTypeSchema).optional(),
  resolveBy: z.coerce.date(),
  resolved: z.boolean().optional(),
  pingedForResolution: z.boolean().optional(),
  resolution: z.lazy(() => ResolutionSchema).optional().nullable(),
  resolvedAt: z.coerce.date().optional().nullable(),
  notes: z.string().optional().nullable(),
  hideForecastsUntil: z.coerce.date().optional().nullable(),
  hideForecastsUntilPrediction: z.boolean().optional().nullable(),
  userId: z.string(),
  sharedPublicly: z.boolean().optional(),
  unlisted: z.boolean().optional(),
  exclusiveAnswers: z.boolean().optional().nullable(),
  options: z.lazy(() => QuestionOptionUncheckedCreateNestedManyWithoutQuestionInputSchema).optional(),
  forecasts: z.lazy(() => ForecastUncheckedCreateNestedManyWithoutQuestionInputSchema).optional(),
  pingResolveMessages: z.lazy(() => PingSlackMessageUncheckedCreateNestedManyWithoutQuestionInputSchema).optional(),
  sharedWith: z.lazy(() => UserUncheckedCreateNestedManyWithoutQuestionsSharedWithInputSchema).optional(),
  sharedWithLists: z.lazy(() => UserListUncheckedCreateNestedManyWithoutQuestionsInputSchema).optional(),
  questionScores: z.lazy(() => QuestionScoreUncheckedCreateNestedManyWithoutQuestionInputSchema).optional(),
  questionMessages: z.lazy(() => QuestionSlackMessageUncheckedCreateNestedManyWithoutQuestionInputSchema).optional(),
  resolutionMessages: z.lazy(() => ResolutionSlackMessageUncheckedCreateNestedManyWithoutQuestionInputSchema).optional(),
  comments: z.lazy(() => CommentUncheckedCreateNestedManyWithoutQuestionInputSchema).optional(),
  tournaments: z.lazy(() => TournamentUncheckedCreateNestedManyWithoutQuestionsInputSchema).optional(),
  notifications: z.lazy(() => NotificationUncheckedCreateNestedManyWithoutQuestionInputSchema).optional()
}).strict();

export const QuestionCreateOrConnectWithoutTagsInputSchema: z.ZodType<Prisma.QuestionCreateOrConnectWithoutTagsInput> = z.object({
  where: z.lazy(() => QuestionWhereUniqueInputSchema),
  create: z.union([ z.lazy(() => QuestionCreateWithoutTagsInputSchema),z.lazy(() => QuestionUncheckedCreateWithoutTagsInputSchema) ]),
}).strict();

export const UserUpsertWithoutTagsInputSchema: z.ZodType<Prisma.UserUpsertWithoutTagsInput> = z.object({
  update: z.union([ z.lazy(() => UserUpdateWithoutTagsInputSchema),z.lazy(() => UserUncheckedUpdateWithoutTagsInputSchema) ]),
  create: z.union([ z.lazy(() => UserCreateWithoutTagsInputSchema),z.lazy(() => UserUncheckedCreateWithoutTagsInputSchema) ]),
  where: z.lazy(() => UserWhereInputSchema).optional()
}).strict();

export const UserUpdateToOneWithWhereWithoutTagsInputSchema: z.ZodType<Prisma.UserUpdateToOneWithWhereWithoutTagsInput> = z.object({
  where: z.lazy(() => UserWhereInputSchema).optional(),
  data: z.union([ z.lazy(() => UserUpdateWithoutTagsInputSchema),z.lazy(() => UserUncheckedUpdateWithoutTagsInputSchema) ]),
}).strict();

export const UserUpdateWithoutTagsInputSchema: z.ZodType<Prisma.UserUpdateWithoutTagsInput> = z.object({
  id: z.union([ z.string().cuid(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  name: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  createdAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  email: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  image: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  staleReminder: z.union([ z.boolean(),z.lazy(() => BoolFieldUpdateOperationsInputSchema) ]).optional(),
  unsubscribedFromEmailsAt: z.union([ z.coerce.date(),z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  apiKey: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  discordUserId: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  emailVerified: z.union([ z.coerce.date(),z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  forecasts: z.lazy(() => ForecastUpdateManyWithoutUserNestedInputSchema).optional(),
  profiles: z.lazy(() => ProfileUpdateManyWithoutUserNestedInputSchema).optional(),
  questions: z.lazy(() => QuestionUpdateManyWithoutUserNestedInputSchema).optional(),
  questionScores: z.lazy(() => QuestionScoreUpdateManyWithoutUserNestedInputSchema).optional(),
  questionsSharedWith: z.lazy(() => QuestionUpdateManyWithoutSharedWithNestedInputSchema).optional(),
  comments: z.lazy(() => CommentUpdateManyWithoutUserNestedInputSchema).optional(),
  target: z.lazy(() => TargetUpdateOneWithoutUserNestedInputSchema).optional(),
  authorOfLists: z.lazy(() => UserListUpdateManyWithoutAuthorNestedInputSchema).optional(),
  memberOfLists: z.lazy(() => UserListUpdateManyWithoutUsersNestedInputSchema).optional(),
  tournaments: z.lazy(() => TournamentUpdateManyWithoutAuthorNestedInputSchema).optional(),
  notifications: z.lazy(() => NotificationUpdateManyWithoutUserNestedInputSchema).optional(),
  questionOptions: z.lazy(() => QuestionOptionUpdateManyWithoutUserNestedInputSchema).optional(),
  accounts: z.lazy(() => AccountUpdateManyWithoutUserNestedInputSchema).optional()
}).strict();

export const UserUncheckedUpdateWithoutTagsInputSchema: z.ZodType<Prisma.UserUncheckedUpdateWithoutTagsInput> = z.object({
  id: z.union([ z.string().cuid(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  name: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  createdAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  email: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  image: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  staleReminder: z.union([ z.boolean(),z.lazy(() => BoolFieldUpdateOperationsInputSchema) ]).optional(),
  unsubscribedFromEmailsAt: z.union([ z.coerce.date(),z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  apiKey: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  discordUserId: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  emailVerified: z.union([ z.coerce.date(),z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  forecasts: z.lazy(() => ForecastUncheckedUpdateManyWithoutUserNestedInputSchema).optional(),
  profiles: z.lazy(() => ProfileUncheckedUpdateManyWithoutUserNestedInputSchema).optional(),
  questions: z.lazy(() => QuestionUncheckedUpdateManyWithoutUserNestedInputSchema).optional(),
  questionScores: z.lazy(() => QuestionScoreUncheckedUpdateManyWithoutUserNestedInputSchema).optional(),
  questionsSharedWith: z.lazy(() => QuestionUncheckedUpdateManyWithoutSharedWithNestedInputSchema).optional(),
  comments: z.lazy(() => CommentUncheckedUpdateManyWithoutUserNestedInputSchema).optional(),
  target: z.lazy(() => TargetUncheckedUpdateOneWithoutUserNestedInputSchema).optional(),
  authorOfLists: z.lazy(() => UserListUncheckedUpdateManyWithoutAuthorNestedInputSchema).optional(),
  memberOfLists: z.lazy(() => UserListUncheckedUpdateManyWithoutUsersNestedInputSchema).optional(),
  tournaments: z.lazy(() => TournamentUncheckedUpdateManyWithoutAuthorNestedInputSchema).optional(),
  notifications: z.lazy(() => NotificationUncheckedUpdateManyWithoutUserNestedInputSchema).optional(),
  questionOptions: z.lazy(() => QuestionOptionUncheckedUpdateManyWithoutUserNestedInputSchema).optional(),
  accounts: z.lazy(() => AccountUncheckedUpdateManyWithoutUserNestedInputSchema).optional()
}).strict();

export const QuestionUpsertWithWhereUniqueWithoutTagsInputSchema: z.ZodType<Prisma.QuestionUpsertWithWhereUniqueWithoutTagsInput> = z.object({
  where: z.lazy(() => QuestionWhereUniqueInputSchema),
  update: z.union([ z.lazy(() => QuestionUpdateWithoutTagsInputSchema),z.lazy(() => QuestionUncheckedUpdateWithoutTagsInputSchema) ]),
  create: z.union([ z.lazy(() => QuestionCreateWithoutTagsInputSchema),z.lazy(() => QuestionUncheckedCreateWithoutTagsInputSchema) ]),
}).strict();

export const QuestionUpdateWithWhereUniqueWithoutTagsInputSchema: z.ZodType<Prisma.QuestionUpdateWithWhereUniqueWithoutTagsInput> = z.object({
  where: z.lazy(() => QuestionWhereUniqueInputSchema),
  data: z.union([ z.lazy(() => QuestionUpdateWithoutTagsInputSchema),z.lazy(() => QuestionUncheckedUpdateWithoutTagsInputSchema) ]),
}).strict();

export const QuestionUpdateManyWithWhereWithoutTagsInputSchema: z.ZodType<Prisma.QuestionUpdateManyWithWhereWithoutTagsInput> = z.object({
  where: z.lazy(() => QuestionScalarWhereInputSchema),
  data: z.union([ z.lazy(() => QuestionUpdateManyMutationInputSchema),z.lazy(() => QuestionUncheckedUpdateManyWithoutTagsInputSchema) ]),
}).strict();

export const QuestionScalarWhereInputSchema: z.ZodType<Prisma.QuestionScalarWhereInput> = z.object({
  AND: z.union([ z.lazy(() => QuestionScalarWhereInputSchema),z.lazy(() => QuestionScalarWhereInputSchema).array() ]).optional(),
  OR: z.lazy(() => QuestionScalarWhereInputSchema).array().optional(),
  NOT: z.union([ z.lazy(() => QuestionScalarWhereInputSchema),z.lazy(() => QuestionScalarWhereInputSchema).array() ]).optional(),
  id: z.union([ z.lazy(() => StringFilterSchema),z.string() ]).optional(),
  createdAt: z.union([ z.lazy(() => DateTimeFilterSchema),z.coerce.date() ]).optional(),
  comment: z.union([ z.lazy(() => StringNullableFilterSchema),z.string() ]).optional().nullable(),
  profileId: z.union([ z.lazy(() => IntNullableFilterSchema),z.number() ]).optional().nullable(),
  title: z.union([ z.lazy(() => StringFilterSchema),z.string() ]).optional(),
  type: z.union([ z.lazy(() => EnumQuestionTypeFilterSchema),z.lazy(() => QuestionTypeSchema) ]).optional(),
  resolveBy: z.union([ z.lazy(() => DateTimeFilterSchema),z.coerce.date() ]).optional(),
  resolved: z.union([ z.lazy(() => BoolFilterSchema),z.boolean() ]).optional(),
  pingedForResolution: z.union([ z.lazy(() => BoolFilterSchema),z.boolean() ]).optional(),
  resolution: z.union([ z.lazy(() => EnumResolutionNullableFilterSchema),z.lazy(() => ResolutionSchema) ]).optional().nullable(),
  resolvedAt: z.union([ z.lazy(() => DateTimeNullableFilterSchema),z.coerce.date() ]).optional().nullable(),
  notes: z.union([ z.lazy(() => StringNullableFilterSchema),z.string() ]).optional().nullable(),
  hideForecastsUntil: z.union([ z.lazy(() => DateTimeNullableFilterSchema),z.coerce.date() ]).optional().nullable(),
  hideForecastsUntilPrediction: z.union([ z.lazy(() => BoolNullableFilterSchema),z.boolean() ]).optional().nullable(),
  userId: z.union([ z.lazy(() => StringFilterSchema),z.string() ]).optional(),
  sharedPublicly: z.union([ z.lazy(() => BoolFilterSchema),z.boolean() ]).optional(),
  unlisted: z.union([ z.lazy(() => BoolFilterSchema),z.boolean() ]).optional(),
  exclusiveAnswers: z.union([ z.lazy(() => BoolNullableFilterSchema),z.boolean() ]).optional().nullable(),
}).strict();

export const SlackMessageCreateWithoutResolutionSlackMessageInputSchema: z.ZodType<Prisma.SlackMessageCreateWithoutResolutionSlackMessageInput> = z.object({
  ts: z.string(),
  channel: z.string(),
  teamId: z.string(),
  pingSlackMessage: z.lazy(() => PingSlackMessageCreateNestedOneWithoutMessageInputSchema).optional(),
  questionSlackMessage: z.lazy(() => QuestionSlackMessageCreateNestedOneWithoutMessageInputSchema).optional()
}).strict();

export const SlackMessageUncheckedCreateWithoutResolutionSlackMessageInputSchema: z.ZodType<Prisma.SlackMessageUncheckedCreateWithoutResolutionSlackMessageInput> = z.object({
  id: z.number().int().optional(),
  ts: z.string(),
  channel: z.string(),
  teamId: z.string(),
  pingSlackMessage: z.lazy(() => PingSlackMessageUncheckedCreateNestedOneWithoutMessageInputSchema).optional(),
  questionSlackMessage: z.lazy(() => QuestionSlackMessageUncheckedCreateNestedOneWithoutMessageInputSchema).optional()
}).strict();

export const SlackMessageCreateOrConnectWithoutResolutionSlackMessageInputSchema: z.ZodType<Prisma.SlackMessageCreateOrConnectWithoutResolutionSlackMessageInput> = z.object({
  where: z.lazy(() => SlackMessageWhereUniqueInputSchema),
  create: z.union([ z.lazy(() => SlackMessageCreateWithoutResolutionSlackMessageInputSchema),z.lazy(() => SlackMessageUncheckedCreateWithoutResolutionSlackMessageInputSchema) ]),
}).strict();

export const ProfileCreateWithoutResolutionMessagesInputSchema: z.ZodType<Prisma.ProfileCreateWithoutResolutionMessagesInput> = z.object({
  createdAt: z.coerce.date().optional(),
  slackId: z.string().optional().nullable(),
  slackTeamId: z.string().optional().nullable(),
  forecasts: z.lazy(() => ForecastCreateNestedManyWithoutProfileInputSchema).optional(),
  user: z.lazy(() => UserCreateNestedOneWithoutProfilesInputSchema),
  questions: z.lazy(() => QuestionCreateNestedManyWithoutProfileInputSchema).optional(),
  target: z.lazy(() => TargetCreateNestedOneWithoutProfileInputSchema).optional()
}).strict();

export const ProfileUncheckedCreateWithoutResolutionMessagesInputSchema: z.ZodType<Prisma.ProfileUncheckedCreateWithoutResolutionMessagesInput> = z.object({
  id: z.number().int().optional(),
  createdAt: z.coerce.date().optional(),
  slackId: z.string().optional().nullable(),
  slackTeamId: z.string().optional().nullable(),
  userId: z.string(),
  forecasts: z.lazy(() => ForecastUncheckedCreateNestedManyWithoutProfileInputSchema).optional(),
  questions: z.lazy(() => QuestionUncheckedCreateNestedManyWithoutProfileInputSchema).optional(),
  target: z.lazy(() => TargetUncheckedCreateNestedOneWithoutProfileInputSchema).optional()
}).strict();

export const ProfileCreateOrConnectWithoutResolutionMessagesInputSchema: z.ZodType<Prisma.ProfileCreateOrConnectWithoutResolutionMessagesInput> = z.object({
  where: z.lazy(() => ProfileWhereUniqueInputSchema),
  create: z.union([ z.lazy(() => ProfileCreateWithoutResolutionMessagesInputSchema),z.lazy(() => ProfileUncheckedCreateWithoutResolutionMessagesInputSchema) ]),
}).strict();

export const QuestionCreateWithoutResolutionMessagesInputSchema: z.ZodType<Prisma.QuestionCreateWithoutResolutionMessagesInput> = z.object({
  id: z.string().cuid().optional(),
  createdAt: z.coerce.date().optional(),
  comment: z.string().optional().nullable(),
  title: z.string(),
  type: z.lazy(() => QuestionTypeSchema).optional(),
  resolveBy: z.coerce.date(),
  resolved: z.boolean().optional(),
  pingedForResolution: z.boolean().optional(),
  resolution: z.lazy(() => ResolutionSchema).optional().nullable(),
  resolvedAt: z.coerce.date().optional().nullable(),
  notes: z.string().optional().nullable(),
  hideForecastsUntil: z.coerce.date().optional().nullable(),
  hideForecastsUntilPrediction: z.boolean().optional().nullable(),
  sharedPublicly: z.boolean().optional(),
  unlisted: z.boolean().optional(),
  exclusiveAnswers: z.boolean().optional().nullable(),
  options: z.lazy(() => QuestionOptionCreateNestedManyWithoutQuestionInputSchema).optional(),
  forecasts: z.lazy(() => ForecastCreateNestedManyWithoutQuestionInputSchema).optional(),
  pingResolveMessages: z.lazy(() => PingSlackMessageCreateNestedManyWithoutQuestionInputSchema).optional(),
  profile: z.lazy(() => ProfileCreateNestedOneWithoutQuestionsInputSchema).optional(),
  user: z.lazy(() => UserCreateNestedOneWithoutQuestionsInputSchema),
  sharedWith: z.lazy(() => UserCreateNestedManyWithoutQuestionsSharedWithInputSchema).optional(),
  sharedWithLists: z.lazy(() => UserListCreateNestedManyWithoutQuestionsInputSchema).optional(),
  questionScores: z.lazy(() => QuestionScoreCreateNestedManyWithoutQuestionInputSchema).optional(),
  questionMessages: z.lazy(() => QuestionSlackMessageCreateNestedManyWithoutQuestionInputSchema).optional(),
  comments: z.lazy(() => CommentCreateNestedManyWithoutQuestionInputSchema).optional(),
  tags: z.lazy(() => TagCreateNestedManyWithoutQuestionsInputSchema).optional(),
  tournaments: z.lazy(() => TournamentCreateNestedManyWithoutQuestionsInputSchema).optional(),
  notifications: z.lazy(() => NotificationCreateNestedManyWithoutQuestionInputSchema).optional()
}).strict();

export const QuestionUncheckedCreateWithoutResolutionMessagesInputSchema: z.ZodType<Prisma.QuestionUncheckedCreateWithoutResolutionMessagesInput> = z.object({
  id: z.string().cuid().optional(),
  createdAt: z.coerce.date().optional(),
  comment: z.string().optional().nullable(),
  profileId: z.number().int().optional().nullable(),
  title: z.string(),
  type: z.lazy(() => QuestionTypeSchema).optional(),
  resolveBy: z.coerce.date(),
  resolved: z.boolean().optional(),
  pingedForResolution: z.boolean().optional(),
  resolution: z.lazy(() => ResolutionSchema).optional().nullable(),
  resolvedAt: z.coerce.date().optional().nullable(),
  notes: z.string().optional().nullable(),
  hideForecastsUntil: z.coerce.date().optional().nullable(),
  hideForecastsUntilPrediction: z.boolean().optional().nullable(),
  userId: z.string(),
  sharedPublicly: z.boolean().optional(),
  unlisted: z.boolean().optional(),
  exclusiveAnswers: z.boolean().optional().nullable(),
  options: z.lazy(() => QuestionOptionUncheckedCreateNestedManyWithoutQuestionInputSchema).optional(),
  forecasts: z.lazy(() => ForecastUncheckedCreateNestedManyWithoutQuestionInputSchema).optional(),
  pingResolveMessages: z.lazy(() => PingSlackMessageUncheckedCreateNestedManyWithoutQuestionInputSchema).optional(),
  sharedWith: z.lazy(() => UserUncheckedCreateNestedManyWithoutQuestionsSharedWithInputSchema).optional(),
  sharedWithLists: z.lazy(() => UserListUncheckedCreateNestedManyWithoutQuestionsInputSchema).optional(),
  questionScores: z.lazy(() => QuestionScoreUncheckedCreateNestedManyWithoutQuestionInputSchema).optional(),
  questionMessages: z.lazy(() => QuestionSlackMessageUncheckedCreateNestedManyWithoutQuestionInputSchema).optional(),
  comments: z.lazy(() => CommentUncheckedCreateNestedManyWithoutQuestionInputSchema).optional(),
  tags: z.lazy(() => TagUncheckedCreateNestedManyWithoutQuestionsInputSchema).optional(),
  tournaments: z.lazy(() => TournamentUncheckedCreateNestedManyWithoutQuestionsInputSchema).optional(),
  notifications: z.lazy(() => NotificationUncheckedCreateNestedManyWithoutQuestionInputSchema).optional()
}).strict();

export const QuestionCreateOrConnectWithoutResolutionMessagesInputSchema: z.ZodType<Prisma.QuestionCreateOrConnectWithoutResolutionMessagesInput> = z.object({
  where: z.lazy(() => QuestionWhereUniqueInputSchema),
  create: z.union([ z.lazy(() => QuestionCreateWithoutResolutionMessagesInputSchema),z.lazy(() => QuestionUncheckedCreateWithoutResolutionMessagesInputSchema) ]),
}).strict();

export const SlackMessageUpsertWithoutResolutionSlackMessageInputSchema: z.ZodType<Prisma.SlackMessageUpsertWithoutResolutionSlackMessageInput> = z.object({
  update: z.union([ z.lazy(() => SlackMessageUpdateWithoutResolutionSlackMessageInputSchema),z.lazy(() => SlackMessageUncheckedUpdateWithoutResolutionSlackMessageInputSchema) ]),
  create: z.union([ z.lazy(() => SlackMessageCreateWithoutResolutionSlackMessageInputSchema),z.lazy(() => SlackMessageUncheckedCreateWithoutResolutionSlackMessageInputSchema) ]),
  where: z.lazy(() => SlackMessageWhereInputSchema).optional()
}).strict();

export const SlackMessageUpdateToOneWithWhereWithoutResolutionSlackMessageInputSchema: z.ZodType<Prisma.SlackMessageUpdateToOneWithWhereWithoutResolutionSlackMessageInput> = z.object({
  where: z.lazy(() => SlackMessageWhereInputSchema).optional(),
  data: z.union([ z.lazy(() => SlackMessageUpdateWithoutResolutionSlackMessageInputSchema),z.lazy(() => SlackMessageUncheckedUpdateWithoutResolutionSlackMessageInputSchema) ]),
}).strict();

export const SlackMessageUpdateWithoutResolutionSlackMessageInputSchema: z.ZodType<Prisma.SlackMessageUpdateWithoutResolutionSlackMessageInput> = z.object({
  ts: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  channel: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  teamId: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  pingSlackMessage: z.lazy(() => PingSlackMessageUpdateOneWithoutMessageNestedInputSchema).optional(),
  questionSlackMessage: z.lazy(() => QuestionSlackMessageUpdateOneWithoutMessageNestedInputSchema).optional()
}).strict();

export const SlackMessageUncheckedUpdateWithoutResolutionSlackMessageInputSchema: z.ZodType<Prisma.SlackMessageUncheckedUpdateWithoutResolutionSlackMessageInput> = z.object({
  id: z.union([ z.number().int(),z.lazy(() => IntFieldUpdateOperationsInputSchema) ]).optional(),
  ts: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  channel: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  teamId: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  pingSlackMessage: z.lazy(() => PingSlackMessageUncheckedUpdateOneWithoutMessageNestedInputSchema).optional(),
  questionSlackMessage: z.lazy(() => QuestionSlackMessageUncheckedUpdateOneWithoutMessageNestedInputSchema).optional()
}).strict();

export const ProfileUpsertWithoutResolutionMessagesInputSchema: z.ZodType<Prisma.ProfileUpsertWithoutResolutionMessagesInput> = z.object({
  update: z.union([ z.lazy(() => ProfileUpdateWithoutResolutionMessagesInputSchema),z.lazy(() => ProfileUncheckedUpdateWithoutResolutionMessagesInputSchema) ]),
  create: z.union([ z.lazy(() => ProfileCreateWithoutResolutionMessagesInputSchema),z.lazy(() => ProfileUncheckedCreateWithoutResolutionMessagesInputSchema) ]),
  where: z.lazy(() => ProfileWhereInputSchema).optional()
}).strict();

export const ProfileUpdateToOneWithWhereWithoutResolutionMessagesInputSchema: z.ZodType<Prisma.ProfileUpdateToOneWithWhereWithoutResolutionMessagesInput> = z.object({
  where: z.lazy(() => ProfileWhereInputSchema).optional(),
  data: z.union([ z.lazy(() => ProfileUpdateWithoutResolutionMessagesInputSchema),z.lazy(() => ProfileUncheckedUpdateWithoutResolutionMessagesInputSchema) ]),
}).strict();

export const ProfileUpdateWithoutResolutionMessagesInputSchema: z.ZodType<Prisma.ProfileUpdateWithoutResolutionMessagesInput> = z.object({
  createdAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  slackId: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  slackTeamId: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  forecasts: z.lazy(() => ForecastUpdateManyWithoutProfileNestedInputSchema).optional(),
  user: z.lazy(() => UserUpdateOneRequiredWithoutProfilesNestedInputSchema).optional(),
  questions: z.lazy(() => QuestionUpdateManyWithoutProfileNestedInputSchema).optional(),
  target: z.lazy(() => TargetUpdateOneWithoutProfileNestedInputSchema).optional()
}).strict();

export const ProfileUncheckedUpdateWithoutResolutionMessagesInputSchema: z.ZodType<Prisma.ProfileUncheckedUpdateWithoutResolutionMessagesInput> = z.object({
  id: z.union([ z.number().int(),z.lazy(() => IntFieldUpdateOperationsInputSchema) ]).optional(),
  createdAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  slackId: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  slackTeamId: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  userId: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  forecasts: z.lazy(() => ForecastUncheckedUpdateManyWithoutProfileNestedInputSchema).optional(),
  questions: z.lazy(() => QuestionUncheckedUpdateManyWithoutProfileNestedInputSchema).optional(),
  target: z.lazy(() => TargetUncheckedUpdateOneWithoutProfileNestedInputSchema).optional()
}).strict();

export const QuestionUpsertWithoutResolutionMessagesInputSchema: z.ZodType<Prisma.QuestionUpsertWithoutResolutionMessagesInput> = z.object({
  update: z.union([ z.lazy(() => QuestionUpdateWithoutResolutionMessagesInputSchema),z.lazy(() => QuestionUncheckedUpdateWithoutResolutionMessagesInputSchema) ]),
  create: z.union([ z.lazy(() => QuestionCreateWithoutResolutionMessagesInputSchema),z.lazy(() => QuestionUncheckedCreateWithoutResolutionMessagesInputSchema) ]),
  where: z.lazy(() => QuestionWhereInputSchema).optional()
}).strict();

export const QuestionUpdateToOneWithWhereWithoutResolutionMessagesInputSchema: z.ZodType<Prisma.QuestionUpdateToOneWithWhereWithoutResolutionMessagesInput> = z.object({
  where: z.lazy(() => QuestionWhereInputSchema).optional(),
  data: z.union([ z.lazy(() => QuestionUpdateWithoutResolutionMessagesInputSchema),z.lazy(() => QuestionUncheckedUpdateWithoutResolutionMessagesInputSchema) ]),
}).strict();

export const QuestionUpdateWithoutResolutionMessagesInputSchema: z.ZodType<Prisma.QuestionUpdateWithoutResolutionMessagesInput> = z.object({
  id: z.union([ z.string().cuid(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  createdAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  comment: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  title: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  type: z.union([ z.lazy(() => QuestionTypeSchema),z.lazy(() => EnumQuestionTypeFieldUpdateOperationsInputSchema) ]).optional(),
  resolveBy: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  resolved: z.union([ z.boolean(),z.lazy(() => BoolFieldUpdateOperationsInputSchema) ]).optional(),
  pingedForResolution: z.union([ z.boolean(),z.lazy(() => BoolFieldUpdateOperationsInputSchema) ]).optional(),
  resolution: z.union([ z.lazy(() => ResolutionSchema),z.lazy(() => NullableEnumResolutionFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  resolvedAt: z.union([ z.coerce.date(),z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  notes: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  hideForecastsUntil: z.union([ z.coerce.date(),z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  hideForecastsUntilPrediction: z.union([ z.boolean(),z.lazy(() => NullableBoolFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  sharedPublicly: z.union([ z.boolean(),z.lazy(() => BoolFieldUpdateOperationsInputSchema) ]).optional(),
  unlisted: z.union([ z.boolean(),z.lazy(() => BoolFieldUpdateOperationsInputSchema) ]).optional(),
  exclusiveAnswers: z.union([ z.boolean(),z.lazy(() => NullableBoolFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  options: z.lazy(() => QuestionOptionUpdateManyWithoutQuestionNestedInputSchema).optional(),
  forecasts: z.lazy(() => ForecastUpdateManyWithoutQuestionNestedInputSchema).optional(),
  pingResolveMessages: z.lazy(() => PingSlackMessageUpdateManyWithoutQuestionNestedInputSchema).optional(),
  profile: z.lazy(() => ProfileUpdateOneWithoutQuestionsNestedInputSchema).optional(),
  user: z.lazy(() => UserUpdateOneRequiredWithoutQuestionsNestedInputSchema).optional(),
  sharedWith: z.lazy(() => UserUpdateManyWithoutQuestionsSharedWithNestedInputSchema).optional(),
  sharedWithLists: z.lazy(() => UserListUpdateManyWithoutQuestionsNestedInputSchema).optional(),
  questionScores: z.lazy(() => QuestionScoreUpdateManyWithoutQuestionNestedInputSchema).optional(),
  questionMessages: z.lazy(() => QuestionSlackMessageUpdateManyWithoutQuestionNestedInputSchema).optional(),
  comments: z.lazy(() => CommentUpdateManyWithoutQuestionNestedInputSchema).optional(),
  tags: z.lazy(() => TagUpdateManyWithoutQuestionsNestedInputSchema).optional(),
  tournaments: z.lazy(() => TournamentUpdateManyWithoutQuestionsNestedInputSchema).optional(),
  notifications: z.lazy(() => NotificationUpdateManyWithoutQuestionNestedInputSchema).optional()
}).strict();

export const QuestionUncheckedUpdateWithoutResolutionMessagesInputSchema: z.ZodType<Prisma.QuestionUncheckedUpdateWithoutResolutionMessagesInput> = z.object({
  id: z.union([ z.string().cuid(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  createdAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  comment: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  profileId: z.union([ z.number().int(),z.lazy(() => NullableIntFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  title: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  type: z.union([ z.lazy(() => QuestionTypeSchema),z.lazy(() => EnumQuestionTypeFieldUpdateOperationsInputSchema) ]).optional(),
  resolveBy: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  resolved: z.union([ z.boolean(),z.lazy(() => BoolFieldUpdateOperationsInputSchema) ]).optional(),
  pingedForResolution: z.union([ z.boolean(),z.lazy(() => BoolFieldUpdateOperationsInputSchema) ]).optional(),
  resolution: z.union([ z.lazy(() => ResolutionSchema),z.lazy(() => NullableEnumResolutionFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  resolvedAt: z.union([ z.coerce.date(),z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  notes: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  hideForecastsUntil: z.union([ z.coerce.date(),z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  hideForecastsUntilPrediction: z.union([ z.boolean(),z.lazy(() => NullableBoolFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  userId: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  sharedPublicly: z.union([ z.boolean(),z.lazy(() => BoolFieldUpdateOperationsInputSchema) ]).optional(),
  unlisted: z.union([ z.boolean(),z.lazy(() => BoolFieldUpdateOperationsInputSchema) ]).optional(),
  exclusiveAnswers: z.union([ z.boolean(),z.lazy(() => NullableBoolFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  options: z.lazy(() => QuestionOptionUncheckedUpdateManyWithoutQuestionNestedInputSchema).optional(),
  forecasts: z.lazy(() => ForecastUncheckedUpdateManyWithoutQuestionNestedInputSchema).optional(),
  pingResolveMessages: z.lazy(() => PingSlackMessageUncheckedUpdateManyWithoutQuestionNestedInputSchema).optional(),
  sharedWith: z.lazy(() => UserUncheckedUpdateManyWithoutQuestionsSharedWithNestedInputSchema).optional(),
  sharedWithLists: z.lazy(() => UserListUncheckedUpdateManyWithoutQuestionsNestedInputSchema).optional(),
  questionScores: z.lazy(() => QuestionScoreUncheckedUpdateManyWithoutQuestionNestedInputSchema).optional(),
  questionMessages: z.lazy(() => QuestionSlackMessageUncheckedUpdateManyWithoutQuestionNestedInputSchema).optional(),
  comments: z.lazy(() => CommentUncheckedUpdateManyWithoutQuestionNestedInputSchema).optional(),
  tags: z.lazy(() => TagUncheckedUpdateManyWithoutQuestionsNestedInputSchema).optional(),
  tournaments: z.lazy(() => TournamentUncheckedUpdateManyWithoutQuestionsNestedInputSchema).optional(),
  notifications: z.lazy(() => NotificationUncheckedUpdateManyWithoutQuestionNestedInputSchema).optional()
}).strict();

export const SlackMessageCreateWithoutPingSlackMessageInputSchema: z.ZodType<Prisma.SlackMessageCreateWithoutPingSlackMessageInput> = z.object({
  ts: z.string(),
  channel: z.string(),
  teamId: z.string(),
  questionSlackMessage: z.lazy(() => QuestionSlackMessageCreateNestedOneWithoutMessageInputSchema).optional(),
  resolutionSlackMessage: z.lazy(() => ResolutionSlackMessageCreateNestedOneWithoutMessageInputSchema).optional()
}).strict();

export const SlackMessageUncheckedCreateWithoutPingSlackMessageInputSchema: z.ZodType<Prisma.SlackMessageUncheckedCreateWithoutPingSlackMessageInput> = z.object({
  id: z.number().int().optional(),
  ts: z.string(),
  channel: z.string(),
  teamId: z.string(),
  questionSlackMessage: z.lazy(() => QuestionSlackMessageUncheckedCreateNestedOneWithoutMessageInputSchema).optional(),
  resolutionSlackMessage: z.lazy(() => ResolutionSlackMessageUncheckedCreateNestedOneWithoutMessageInputSchema).optional()
}).strict();

export const SlackMessageCreateOrConnectWithoutPingSlackMessageInputSchema: z.ZodType<Prisma.SlackMessageCreateOrConnectWithoutPingSlackMessageInput> = z.object({
  where: z.lazy(() => SlackMessageWhereUniqueInputSchema),
  create: z.union([ z.lazy(() => SlackMessageCreateWithoutPingSlackMessageInputSchema),z.lazy(() => SlackMessageUncheckedCreateWithoutPingSlackMessageInputSchema) ]),
}).strict();

export const QuestionCreateWithoutPingResolveMessagesInputSchema: z.ZodType<Prisma.QuestionCreateWithoutPingResolveMessagesInput> = z.object({
  id: z.string().cuid().optional(),
  createdAt: z.coerce.date().optional(),
  comment: z.string().optional().nullable(),
  title: z.string(),
  type: z.lazy(() => QuestionTypeSchema).optional(),
  resolveBy: z.coerce.date(),
  resolved: z.boolean().optional(),
  pingedForResolution: z.boolean().optional(),
  resolution: z.lazy(() => ResolutionSchema).optional().nullable(),
  resolvedAt: z.coerce.date().optional().nullable(),
  notes: z.string().optional().nullable(),
  hideForecastsUntil: z.coerce.date().optional().nullable(),
  hideForecastsUntilPrediction: z.boolean().optional().nullable(),
  sharedPublicly: z.boolean().optional(),
  unlisted: z.boolean().optional(),
  exclusiveAnswers: z.boolean().optional().nullable(),
  options: z.lazy(() => QuestionOptionCreateNestedManyWithoutQuestionInputSchema).optional(),
  forecasts: z.lazy(() => ForecastCreateNestedManyWithoutQuestionInputSchema).optional(),
  profile: z.lazy(() => ProfileCreateNestedOneWithoutQuestionsInputSchema).optional(),
  user: z.lazy(() => UserCreateNestedOneWithoutQuestionsInputSchema),
  sharedWith: z.lazy(() => UserCreateNestedManyWithoutQuestionsSharedWithInputSchema).optional(),
  sharedWithLists: z.lazy(() => UserListCreateNestedManyWithoutQuestionsInputSchema).optional(),
  questionScores: z.lazy(() => QuestionScoreCreateNestedManyWithoutQuestionInputSchema).optional(),
  questionMessages: z.lazy(() => QuestionSlackMessageCreateNestedManyWithoutQuestionInputSchema).optional(),
  resolutionMessages: z.lazy(() => ResolutionSlackMessageCreateNestedManyWithoutQuestionInputSchema).optional(),
  comments: z.lazy(() => CommentCreateNestedManyWithoutQuestionInputSchema).optional(),
  tags: z.lazy(() => TagCreateNestedManyWithoutQuestionsInputSchema).optional(),
  tournaments: z.lazy(() => TournamentCreateNestedManyWithoutQuestionsInputSchema).optional(),
  notifications: z.lazy(() => NotificationCreateNestedManyWithoutQuestionInputSchema).optional()
}).strict();

export const QuestionUncheckedCreateWithoutPingResolveMessagesInputSchema: z.ZodType<Prisma.QuestionUncheckedCreateWithoutPingResolveMessagesInput> = z.object({
  id: z.string().cuid().optional(),
  createdAt: z.coerce.date().optional(),
  comment: z.string().optional().nullable(),
  profileId: z.number().int().optional().nullable(),
  title: z.string(),
  type: z.lazy(() => QuestionTypeSchema).optional(),
  resolveBy: z.coerce.date(),
  resolved: z.boolean().optional(),
  pingedForResolution: z.boolean().optional(),
  resolution: z.lazy(() => ResolutionSchema).optional().nullable(),
  resolvedAt: z.coerce.date().optional().nullable(),
  notes: z.string().optional().nullable(),
  hideForecastsUntil: z.coerce.date().optional().nullable(),
  hideForecastsUntilPrediction: z.boolean().optional().nullable(),
  userId: z.string(),
  sharedPublicly: z.boolean().optional(),
  unlisted: z.boolean().optional(),
  exclusiveAnswers: z.boolean().optional().nullable(),
  options: z.lazy(() => QuestionOptionUncheckedCreateNestedManyWithoutQuestionInputSchema).optional(),
  forecasts: z.lazy(() => ForecastUncheckedCreateNestedManyWithoutQuestionInputSchema).optional(),
  sharedWith: z.lazy(() => UserUncheckedCreateNestedManyWithoutQuestionsSharedWithInputSchema).optional(),
  sharedWithLists: z.lazy(() => UserListUncheckedCreateNestedManyWithoutQuestionsInputSchema).optional(),
  questionScores: z.lazy(() => QuestionScoreUncheckedCreateNestedManyWithoutQuestionInputSchema).optional(),
  questionMessages: z.lazy(() => QuestionSlackMessageUncheckedCreateNestedManyWithoutQuestionInputSchema).optional(),
  resolutionMessages: z.lazy(() => ResolutionSlackMessageUncheckedCreateNestedManyWithoutQuestionInputSchema).optional(),
  comments: z.lazy(() => CommentUncheckedCreateNestedManyWithoutQuestionInputSchema).optional(),
  tags: z.lazy(() => TagUncheckedCreateNestedManyWithoutQuestionsInputSchema).optional(),
  tournaments: z.lazy(() => TournamentUncheckedCreateNestedManyWithoutQuestionsInputSchema).optional(),
  notifications: z.lazy(() => NotificationUncheckedCreateNestedManyWithoutQuestionInputSchema).optional()
}).strict();

export const QuestionCreateOrConnectWithoutPingResolveMessagesInputSchema: z.ZodType<Prisma.QuestionCreateOrConnectWithoutPingResolveMessagesInput> = z.object({
  where: z.lazy(() => QuestionWhereUniqueInputSchema),
  create: z.union([ z.lazy(() => QuestionCreateWithoutPingResolveMessagesInputSchema),z.lazy(() => QuestionUncheckedCreateWithoutPingResolveMessagesInputSchema) ]),
}).strict();

export const SlackMessageUpsertWithoutPingSlackMessageInputSchema: z.ZodType<Prisma.SlackMessageUpsertWithoutPingSlackMessageInput> = z.object({
  update: z.union([ z.lazy(() => SlackMessageUpdateWithoutPingSlackMessageInputSchema),z.lazy(() => SlackMessageUncheckedUpdateWithoutPingSlackMessageInputSchema) ]),
  create: z.union([ z.lazy(() => SlackMessageCreateWithoutPingSlackMessageInputSchema),z.lazy(() => SlackMessageUncheckedCreateWithoutPingSlackMessageInputSchema) ]),
  where: z.lazy(() => SlackMessageWhereInputSchema).optional()
}).strict();

export const SlackMessageUpdateToOneWithWhereWithoutPingSlackMessageInputSchema: z.ZodType<Prisma.SlackMessageUpdateToOneWithWhereWithoutPingSlackMessageInput> = z.object({
  where: z.lazy(() => SlackMessageWhereInputSchema).optional(),
  data: z.union([ z.lazy(() => SlackMessageUpdateWithoutPingSlackMessageInputSchema),z.lazy(() => SlackMessageUncheckedUpdateWithoutPingSlackMessageInputSchema) ]),
}).strict();

export const SlackMessageUpdateWithoutPingSlackMessageInputSchema: z.ZodType<Prisma.SlackMessageUpdateWithoutPingSlackMessageInput> = z.object({
  ts: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  channel: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  teamId: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  questionSlackMessage: z.lazy(() => QuestionSlackMessageUpdateOneWithoutMessageNestedInputSchema).optional(),
  resolutionSlackMessage: z.lazy(() => ResolutionSlackMessageUpdateOneWithoutMessageNestedInputSchema).optional()
}).strict();

export const SlackMessageUncheckedUpdateWithoutPingSlackMessageInputSchema: z.ZodType<Prisma.SlackMessageUncheckedUpdateWithoutPingSlackMessageInput> = z.object({
  id: z.union([ z.number().int(),z.lazy(() => IntFieldUpdateOperationsInputSchema) ]).optional(),
  ts: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  channel: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  teamId: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  questionSlackMessage: z.lazy(() => QuestionSlackMessageUncheckedUpdateOneWithoutMessageNestedInputSchema).optional(),
  resolutionSlackMessage: z.lazy(() => ResolutionSlackMessageUncheckedUpdateOneWithoutMessageNestedInputSchema).optional()
}).strict();

export const QuestionUpsertWithoutPingResolveMessagesInputSchema: z.ZodType<Prisma.QuestionUpsertWithoutPingResolveMessagesInput> = z.object({
  update: z.union([ z.lazy(() => QuestionUpdateWithoutPingResolveMessagesInputSchema),z.lazy(() => QuestionUncheckedUpdateWithoutPingResolveMessagesInputSchema) ]),
  create: z.union([ z.lazy(() => QuestionCreateWithoutPingResolveMessagesInputSchema),z.lazy(() => QuestionUncheckedCreateWithoutPingResolveMessagesInputSchema) ]),
  where: z.lazy(() => QuestionWhereInputSchema).optional()
}).strict();

export const QuestionUpdateToOneWithWhereWithoutPingResolveMessagesInputSchema: z.ZodType<Prisma.QuestionUpdateToOneWithWhereWithoutPingResolveMessagesInput> = z.object({
  where: z.lazy(() => QuestionWhereInputSchema).optional(),
  data: z.union([ z.lazy(() => QuestionUpdateWithoutPingResolveMessagesInputSchema),z.lazy(() => QuestionUncheckedUpdateWithoutPingResolveMessagesInputSchema) ]),
}).strict();

export const QuestionUpdateWithoutPingResolveMessagesInputSchema: z.ZodType<Prisma.QuestionUpdateWithoutPingResolveMessagesInput> = z.object({
  id: z.union([ z.string().cuid(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  createdAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  comment: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  title: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  type: z.union([ z.lazy(() => QuestionTypeSchema),z.lazy(() => EnumQuestionTypeFieldUpdateOperationsInputSchema) ]).optional(),
  resolveBy: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  resolved: z.union([ z.boolean(),z.lazy(() => BoolFieldUpdateOperationsInputSchema) ]).optional(),
  pingedForResolution: z.union([ z.boolean(),z.lazy(() => BoolFieldUpdateOperationsInputSchema) ]).optional(),
  resolution: z.union([ z.lazy(() => ResolutionSchema),z.lazy(() => NullableEnumResolutionFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  resolvedAt: z.union([ z.coerce.date(),z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  notes: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  hideForecastsUntil: z.union([ z.coerce.date(),z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  hideForecastsUntilPrediction: z.union([ z.boolean(),z.lazy(() => NullableBoolFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  sharedPublicly: z.union([ z.boolean(),z.lazy(() => BoolFieldUpdateOperationsInputSchema) ]).optional(),
  unlisted: z.union([ z.boolean(),z.lazy(() => BoolFieldUpdateOperationsInputSchema) ]).optional(),
  exclusiveAnswers: z.union([ z.boolean(),z.lazy(() => NullableBoolFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  options: z.lazy(() => QuestionOptionUpdateManyWithoutQuestionNestedInputSchema).optional(),
  forecasts: z.lazy(() => ForecastUpdateManyWithoutQuestionNestedInputSchema).optional(),
  profile: z.lazy(() => ProfileUpdateOneWithoutQuestionsNestedInputSchema).optional(),
  user: z.lazy(() => UserUpdateOneRequiredWithoutQuestionsNestedInputSchema).optional(),
  sharedWith: z.lazy(() => UserUpdateManyWithoutQuestionsSharedWithNestedInputSchema).optional(),
  sharedWithLists: z.lazy(() => UserListUpdateManyWithoutQuestionsNestedInputSchema).optional(),
  questionScores: z.lazy(() => QuestionScoreUpdateManyWithoutQuestionNestedInputSchema).optional(),
  questionMessages: z.lazy(() => QuestionSlackMessageUpdateManyWithoutQuestionNestedInputSchema).optional(),
  resolutionMessages: z.lazy(() => ResolutionSlackMessageUpdateManyWithoutQuestionNestedInputSchema).optional(),
  comments: z.lazy(() => CommentUpdateManyWithoutQuestionNestedInputSchema).optional(),
  tags: z.lazy(() => TagUpdateManyWithoutQuestionsNestedInputSchema).optional(),
  tournaments: z.lazy(() => TournamentUpdateManyWithoutQuestionsNestedInputSchema).optional(),
  notifications: z.lazy(() => NotificationUpdateManyWithoutQuestionNestedInputSchema).optional()
}).strict();

export const QuestionUncheckedUpdateWithoutPingResolveMessagesInputSchema: z.ZodType<Prisma.QuestionUncheckedUpdateWithoutPingResolveMessagesInput> = z.object({
  id: z.union([ z.string().cuid(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  createdAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  comment: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  profileId: z.union([ z.number().int(),z.lazy(() => NullableIntFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  title: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  type: z.union([ z.lazy(() => QuestionTypeSchema),z.lazy(() => EnumQuestionTypeFieldUpdateOperationsInputSchema) ]).optional(),
  resolveBy: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  resolved: z.union([ z.boolean(),z.lazy(() => BoolFieldUpdateOperationsInputSchema) ]).optional(),
  pingedForResolution: z.union([ z.boolean(),z.lazy(() => BoolFieldUpdateOperationsInputSchema) ]).optional(),
  resolution: z.union([ z.lazy(() => ResolutionSchema),z.lazy(() => NullableEnumResolutionFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  resolvedAt: z.union([ z.coerce.date(),z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  notes: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  hideForecastsUntil: z.union([ z.coerce.date(),z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  hideForecastsUntilPrediction: z.union([ z.boolean(),z.lazy(() => NullableBoolFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  userId: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  sharedPublicly: z.union([ z.boolean(),z.lazy(() => BoolFieldUpdateOperationsInputSchema) ]).optional(),
  unlisted: z.union([ z.boolean(),z.lazy(() => BoolFieldUpdateOperationsInputSchema) ]).optional(),
  exclusiveAnswers: z.union([ z.boolean(),z.lazy(() => NullableBoolFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  options: z.lazy(() => QuestionOptionUncheckedUpdateManyWithoutQuestionNestedInputSchema).optional(),
  forecasts: z.lazy(() => ForecastUncheckedUpdateManyWithoutQuestionNestedInputSchema).optional(),
  sharedWith: z.lazy(() => UserUncheckedUpdateManyWithoutQuestionsSharedWithNestedInputSchema).optional(),
  sharedWithLists: z.lazy(() => UserListUncheckedUpdateManyWithoutQuestionsNestedInputSchema).optional(),
  questionScores: z.lazy(() => QuestionScoreUncheckedUpdateManyWithoutQuestionNestedInputSchema).optional(),
  questionMessages: z.lazy(() => QuestionSlackMessageUncheckedUpdateManyWithoutQuestionNestedInputSchema).optional(),
  resolutionMessages: z.lazy(() => ResolutionSlackMessageUncheckedUpdateManyWithoutQuestionNestedInputSchema).optional(),
  comments: z.lazy(() => CommentUncheckedUpdateManyWithoutQuestionNestedInputSchema).optional(),
  tags: z.lazy(() => TagUncheckedUpdateManyWithoutQuestionsNestedInputSchema).optional(),
  tournaments: z.lazy(() => TournamentUncheckedUpdateManyWithoutQuestionsNestedInputSchema).optional(),
  notifications: z.lazy(() => NotificationUncheckedUpdateManyWithoutQuestionNestedInputSchema).optional()
}).strict();

export const SlackMessageCreateWithoutQuestionSlackMessageInputSchema: z.ZodType<Prisma.SlackMessageCreateWithoutQuestionSlackMessageInput> = z.object({
  ts: z.string(),
  channel: z.string(),
  teamId: z.string(),
  pingSlackMessage: z.lazy(() => PingSlackMessageCreateNestedOneWithoutMessageInputSchema).optional(),
  resolutionSlackMessage: z.lazy(() => ResolutionSlackMessageCreateNestedOneWithoutMessageInputSchema).optional()
}).strict();

export const SlackMessageUncheckedCreateWithoutQuestionSlackMessageInputSchema: z.ZodType<Prisma.SlackMessageUncheckedCreateWithoutQuestionSlackMessageInput> = z.object({
  id: z.number().int().optional(),
  ts: z.string(),
  channel: z.string(),
  teamId: z.string(),
  pingSlackMessage: z.lazy(() => PingSlackMessageUncheckedCreateNestedOneWithoutMessageInputSchema).optional(),
  resolutionSlackMessage: z.lazy(() => ResolutionSlackMessageUncheckedCreateNestedOneWithoutMessageInputSchema).optional()
}).strict();

export const SlackMessageCreateOrConnectWithoutQuestionSlackMessageInputSchema: z.ZodType<Prisma.SlackMessageCreateOrConnectWithoutQuestionSlackMessageInput> = z.object({
  where: z.lazy(() => SlackMessageWhereUniqueInputSchema),
  create: z.union([ z.lazy(() => SlackMessageCreateWithoutQuestionSlackMessageInputSchema),z.lazy(() => SlackMessageUncheckedCreateWithoutQuestionSlackMessageInputSchema) ]),
}).strict();

export const QuestionCreateWithoutQuestionMessagesInputSchema: z.ZodType<Prisma.QuestionCreateWithoutQuestionMessagesInput> = z.object({
  id: z.string().cuid().optional(),
  createdAt: z.coerce.date().optional(),
  comment: z.string().optional().nullable(),
  title: z.string(),
  type: z.lazy(() => QuestionTypeSchema).optional(),
  resolveBy: z.coerce.date(),
  resolved: z.boolean().optional(),
  pingedForResolution: z.boolean().optional(),
  resolution: z.lazy(() => ResolutionSchema).optional().nullable(),
  resolvedAt: z.coerce.date().optional().nullable(),
  notes: z.string().optional().nullable(),
  hideForecastsUntil: z.coerce.date().optional().nullable(),
  hideForecastsUntilPrediction: z.boolean().optional().nullable(),
  sharedPublicly: z.boolean().optional(),
  unlisted: z.boolean().optional(),
  exclusiveAnswers: z.boolean().optional().nullable(),
  options: z.lazy(() => QuestionOptionCreateNestedManyWithoutQuestionInputSchema).optional(),
  forecasts: z.lazy(() => ForecastCreateNestedManyWithoutQuestionInputSchema).optional(),
  pingResolveMessages: z.lazy(() => PingSlackMessageCreateNestedManyWithoutQuestionInputSchema).optional(),
  profile: z.lazy(() => ProfileCreateNestedOneWithoutQuestionsInputSchema).optional(),
  user: z.lazy(() => UserCreateNestedOneWithoutQuestionsInputSchema),
  sharedWith: z.lazy(() => UserCreateNestedManyWithoutQuestionsSharedWithInputSchema).optional(),
  sharedWithLists: z.lazy(() => UserListCreateNestedManyWithoutQuestionsInputSchema).optional(),
  questionScores: z.lazy(() => QuestionScoreCreateNestedManyWithoutQuestionInputSchema).optional(),
  resolutionMessages: z.lazy(() => ResolutionSlackMessageCreateNestedManyWithoutQuestionInputSchema).optional(),
  comments: z.lazy(() => CommentCreateNestedManyWithoutQuestionInputSchema).optional(),
  tags: z.lazy(() => TagCreateNestedManyWithoutQuestionsInputSchema).optional(),
  tournaments: z.lazy(() => TournamentCreateNestedManyWithoutQuestionsInputSchema).optional(),
  notifications: z.lazy(() => NotificationCreateNestedManyWithoutQuestionInputSchema).optional()
}).strict();

export const QuestionUncheckedCreateWithoutQuestionMessagesInputSchema: z.ZodType<Prisma.QuestionUncheckedCreateWithoutQuestionMessagesInput> = z.object({
  id: z.string().cuid().optional(),
  createdAt: z.coerce.date().optional(),
  comment: z.string().optional().nullable(),
  profileId: z.number().int().optional().nullable(),
  title: z.string(),
  type: z.lazy(() => QuestionTypeSchema).optional(),
  resolveBy: z.coerce.date(),
  resolved: z.boolean().optional(),
  pingedForResolution: z.boolean().optional(),
  resolution: z.lazy(() => ResolutionSchema).optional().nullable(),
  resolvedAt: z.coerce.date().optional().nullable(),
  notes: z.string().optional().nullable(),
  hideForecastsUntil: z.coerce.date().optional().nullable(),
  hideForecastsUntilPrediction: z.boolean().optional().nullable(),
  userId: z.string(),
  sharedPublicly: z.boolean().optional(),
  unlisted: z.boolean().optional(),
  exclusiveAnswers: z.boolean().optional().nullable(),
  options: z.lazy(() => QuestionOptionUncheckedCreateNestedManyWithoutQuestionInputSchema).optional(),
  forecasts: z.lazy(() => ForecastUncheckedCreateNestedManyWithoutQuestionInputSchema).optional(),
  pingResolveMessages: z.lazy(() => PingSlackMessageUncheckedCreateNestedManyWithoutQuestionInputSchema).optional(),
  sharedWith: z.lazy(() => UserUncheckedCreateNestedManyWithoutQuestionsSharedWithInputSchema).optional(),
  sharedWithLists: z.lazy(() => UserListUncheckedCreateNestedManyWithoutQuestionsInputSchema).optional(),
  questionScores: z.lazy(() => QuestionScoreUncheckedCreateNestedManyWithoutQuestionInputSchema).optional(),
  resolutionMessages: z.lazy(() => ResolutionSlackMessageUncheckedCreateNestedManyWithoutQuestionInputSchema).optional(),
  comments: z.lazy(() => CommentUncheckedCreateNestedManyWithoutQuestionInputSchema).optional(),
  tags: z.lazy(() => TagUncheckedCreateNestedManyWithoutQuestionsInputSchema).optional(),
  tournaments: z.lazy(() => TournamentUncheckedCreateNestedManyWithoutQuestionsInputSchema).optional(),
  notifications: z.lazy(() => NotificationUncheckedCreateNestedManyWithoutQuestionInputSchema).optional()
}).strict();

export const QuestionCreateOrConnectWithoutQuestionMessagesInputSchema: z.ZodType<Prisma.QuestionCreateOrConnectWithoutQuestionMessagesInput> = z.object({
  where: z.lazy(() => QuestionWhereUniqueInputSchema),
  create: z.union([ z.lazy(() => QuestionCreateWithoutQuestionMessagesInputSchema),z.lazy(() => QuestionUncheckedCreateWithoutQuestionMessagesInputSchema) ]),
}).strict();

export const SlackMessageUpsertWithoutQuestionSlackMessageInputSchema: z.ZodType<Prisma.SlackMessageUpsertWithoutQuestionSlackMessageInput> = z.object({
  update: z.union([ z.lazy(() => SlackMessageUpdateWithoutQuestionSlackMessageInputSchema),z.lazy(() => SlackMessageUncheckedUpdateWithoutQuestionSlackMessageInputSchema) ]),
  create: z.union([ z.lazy(() => SlackMessageCreateWithoutQuestionSlackMessageInputSchema),z.lazy(() => SlackMessageUncheckedCreateWithoutQuestionSlackMessageInputSchema) ]),
  where: z.lazy(() => SlackMessageWhereInputSchema).optional()
}).strict();

export const SlackMessageUpdateToOneWithWhereWithoutQuestionSlackMessageInputSchema: z.ZodType<Prisma.SlackMessageUpdateToOneWithWhereWithoutQuestionSlackMessageInput> = z.object({
  where: z.lazy(() => SlackMessageWhereInputSchema).optional(),
  data: z.union([ z.lazy(() => SlackMessageUpdateWithoutQuestionSlackMessageInputSchema),z.lazy(() => SlackMessageUncheckedUpdateWithoutQuestionSlackMessageInputSchema) ]),
}).strict();

export const SlackMessageUpdateWithoutQuestionSlackMessageInputSchema: z.ZodType<Prisma.SlackMessageUpdateWithoutQuestionSlackMessageInput> = z.object({
  ts: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  channel: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  teamId: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  pingSlackMessage: z.lazy(() => PingSlackMessageUpdateOneWithoutMessageNestedInputSchema).optional(),
  resolutionSlackMessage: z.lazy(() => ResolutionSlackMessageUpdateOneWithoutMessageNestedInputSchema).optional()
}).strict();

export const SlackMessageUncheckedUpdateWithoutQuestionSlackMessageInputSchema: z.ZodType<Prisma.SlackMessageUncheckedUpdateWithoutQuestionSlackMessageInput> = z.object({
  id: z.union([ z.number().int(),z.lazy(() => IntFieldUpdateOperationsInputSchema) ]).optional(),
  ts: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  channel: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  teamId: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  pingSlackMessage: z.lazy(() => PingSlackMessageUncheckedUpdateOneWithoutMessageNestedInputSchema).optional(),
  resolutionSlackMessage: z.lazy(() => ResolutionSlackMessageUncheckedUpdateOneWithoutMessageNestedInputSchema).optional()
}).strict();

export const QuestionUpsertWithoutQuestionMessagesInputSchema: z.ZodType<Prisma.QuestionUpsertWithoutQuestionMessagesInput> = z.object({
  update: z.union([ z.lazy(() => QuestionUpdateWithoutQuestionMessagesInputSchema),z.lazy(() => QuestionUncheckedUpdateWithoutQuestionMessagesInputSchema) ]),
  create: z.union([ z.lazy(() => QuestionCreateWithoutQuestionMessagesInputSchema),z.lazy(() => QuestionUncheckedCreateWithoutQuestionMessagesInputSchema) ]),
  where: z.lazy(() => QuestionWhereInputSchema).optional()
}).strict();

export const QuestionUpdateToOneWithWhereWithoutQuestionMessagesInputSchema: z.ZodType<Prisma.QuestionUpdateToOneWithWhereWithoutQuestionMessagesInput> = z.object({
  where: z.lazy(() => QuestionWhereInputSchema).optional(),
  data: z.union([ z.lazy(() => QuestionUpdateWithoutQuestionMessagesInputSchema),z.lazy(() => QuestionUncheckedUpdateWithoutQuestionMessagesInputSchema) ]),
}).strict();

export const QuestionUpdateWithoutQuestionMessagesInputSchema: z.ZodType<Prisma.QuestionUpdateWithoutQuestionMessagesInput> = z.object({
  id: z.union([ z.string().cuid(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  createdAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  comment: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  title: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  type: z.union([ z.lazy(() => QuestionTypeSchema),z.lazy(() => EnumQuestionTypeFieldUpdateOperationsInputSchema) ]).optional(),
  resolveBy: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  resolved: z.union([ z.boolean(),z.lazy(() => BoolFieldUpdateOperationsInputSchema) ]).optional(),
  pingedForResolution: z.union([ z.boolean(),z.lazy(() => BoolFieldUpdateOperationsInputSchema) ]).optional(),
  resolution: z.union([ z.lazy(() => ResolutionSchema),z.lazy(() => NullableEnumResolutionFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  resolvedAt: z.union([ z.coerce.date(),z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  notes: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  hideForecastsUntil: z.union([ z.coerce.date(),z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  hideForecastsUntilPrediction: z.union([ z.boolean(),z.lazy(() => NullableBoolFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  sharedPublicly: z.union([ z.boolean(),z.lazy(() => BoolFieldUpdateOperationsInputSchema) ]).optional(),
  unlisted: z.union([ z.boolean(),z.lazy(() => BoolFieldUpdateOperationsInputSchema) ]).optional(),
  exclusiveAnswers: z.union([ z.boolean(),z.lazy(() => NullableBoolFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  options: z.lazy(() => QuestionOptionUpdateManyWithoutQuestionNestedInputSchema).optional(),
  forecasts: z.lazy(() => ForecastUpdateManyWithoutQuestionNestedInputSchema).optional(),
  pingResolveMessages: z.lazy(() => PingSlackMessageUpdateManyWithoutQuestionNestedInputSchema).optional(),
  profile: z.lazy(() => ProfileUpdateOneWithoutQuestionsNestedInputSchema).optional(),
  user: z.lazy(() => UserUpdateOneRequiredWithoutQuestionsNestedInputSchema).optional(),
  sharedWith: z.lazy(() => UserUpdateManyWithoutQuestionsSharedWithNestedInputSchema).optional(),
  sharedWithLists: z.lazy(() => UserListUpdateManyWithoutQuestionsNestedInputSchema).optional(),
  questionScores: z.lazy(() => QuestionScoreUpdateManyWithoutQuestionNestedInputSchema).optional(),
  resolutionMessages: z.lazy(() => ResolutionSlackMessageUpdateManyWithoutQuestionNestedInputSchema).optional(),
  comments: z.lazy(() => CommentUpdateManyWithoutQuestionNestedInputSchema).optional(),
  tags: z.lazy(() => TagUpdateManyWithoutQuestionsNestedInputSchema).optional(),
  tournaments: z.lazy(() => TournamentUpdateManyWithoutQuestionsNestedInputSchema).optional(),
  notifications: z.lazy(() => NotificationUpdateManyWithoutQuestionNestedInputSchema).optional()
}).strict();

export const QuestionUncheckedUpdateWithoutQuestionMessagesInputSchema: z.ZodType<Prisma.QuestionUncheckedUpdateWithoutQuestionMessagesInput> = z.object({
  id: z.union([ z.string().cuid(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  createdAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  comment: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  profileId: z.union([ z.number().int(),z.lazy(() => NullableIntFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  title: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  type: z.union([ z.lazy(() => QuestionTypeSchema),z.lazy(() => EnumQuestionTypeFieldUpdateOperationsInputSchema) ]).optional(),
  resolveBy: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  resolved: z.union([ z.boolean(),z.lazy(() => BoolFieldUpdateOperationsInputSchema) ]).optional(),
  pingedForResolution: z.union([ z.boolean(),z.lazy(() => BoolFieldUpdateOperationsInputSchema) ]).optional(),
  resolution: z.union([ z.lazy(() => ResolutionSchema),z.lazy(() => NullableEnumResolutionFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  resolvedAt: z.union([ z.coerce.date(),z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  notes: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  hideForecastsUntil: z.union([ z.coerce.date(),z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  hideForecastsUntilPrediction: z.union([ z.boolean(),z.lazy(() => NullableBoolFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  userId: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  sharedPublicly: z.union([ z.boolean(),z.lazy(() => BoolFieldUpdateOperationsInputSchema) ]).optional(),
  unlisted: z.union([ z.boolean(),z.lazy(() => BoolFieldUpdateOperationsInputSchema) ]).optional(),
  exclusiveAnswers: z.union([ z.boolean(),z.lazy(() => NullableBoolFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  options: z.lazy(() => QuestionOptionUncheckedUpdateManyWithoutQuestionNestedInputSchema).optional(),
  forecasts: z.lazy(() => ForecastUncheckedUpdateManyWithoutQuestionNestedInputSchema).optional(),
  pingResolveMessages: z.lazy(() => PingSlackMessageUncheckedUpdateManyWithoutQuestionNestedInputSchema).optional(),
  sharedWith: z.lazy(() => UserUncheckedUpdateManyWithoutQuestionsSharedWithNestedInputSchema).optional(),
  sharedWithLists: z.lazy(() => UserListUncheckedUpdateManyWithoutQuestionsNestedInputSchema).optional(),
  questionScores: z.lazy(() => QuestionScoreUncheckedUpdateManyWithoutQuestionNestedInputSchema).optional(),
  resolutionMessages: z.lazy(() => ResolutionSlackMessageUncheckedUpdateManyWithoutQuestionNestedInputSchema).optional(),
  comments: z.lazy(() => CommentUncheckedUpdateManyWithoutQuestionNestedInputSchema).optional(),
  tags: z.lazy(() => TagUncheckedUpdateManyWithoutQuestionsNestedInputSchema).optional(),
  tournaments: z.lazy(() => TournamentUncheckedUpdateManyWithoutQuestionsNestedInputSchema).optional(),
  notifications: z.lazy(() => NotificationUncheckedUpdateManyWithoutQuestionNestedInputSchema).optional()
}).strict();

export const PingSlackMessageCreateWithoutMessageInputSchema: z.ZodType<Prisma.PingSlackMessageCreateWithoutMessageInput> = z.object({
  question: z.lazy(() => QuestionCreateNestedOneWithoutPingResolveMessagesInputSchema)
}).strict();

export const PingSlackMessageUncheckedCreateWithoutMessageInputSchema: z.ZodType<Prisma.PingSlackMessageUncheckedCreateWithoutMessageInput> = z.object({
  id: z.number().int().optional(),
  questionId: z.string()
}).strict();

export const PingSlackMessageCreateOrConnectWithoutMessageInputSchema: z.ZodType<Prisma.PingSlackMessageCreateOrConnectWithoutMessageInput> = z.object({
  where: z.lazy(() => PingSlackMessageWhereUniqueInputSchema),
  create: z.union([ z.lazy(() => PingSlackMessageCreateWithoutMessageInputSchema),z.lazy(() => PingSlackMessageUncheckedCreateWithoutMessageInputSchema) ]),
}).strict();

export const QuestionSlackMessageCreateWithoutMessageInputSchema: z.ZodType<Prisma.QuestionSlackMessageCreateWithoutMessageInput> = z.object({
  updatedAt: z.coerce.date().optional(),
  question: z.lazy(() => QuestionCreateNestedOneWithoutQuestionMessagesInputSchema)
}).strict();

export const QuestionSlackMessageUncheckedCreateWithoutMessageInputSchema: z.ZodType<Prisma.QuestionSlackMessageUncheckedCreateWithoutMessageInput> = z.object({
  id: z.number().int().optional(),
  questionId: z.string(),
  updatedAt: z.coerce.date().optional()
}).strict();

export const QuestionSlackMessageCreateOrConnectWithoutMessageInputSchema: z.ZodType<Prisma.QuestionSlackMessageCreateOrConnectWithoutMessageInput> = z.object({
  where: z.lazy(() => QuestionSlackMessageWhereUniqueInputSchema),
  create: z.union([ z.lazy(() => QuestionSlackMessageCreateWithoutMessageInputSchema),z.lazy(() => QuestionSlackMessageUncheckedCreateWithoutMessageInputSchema) ]),
}).strict();

export const ResolutionSlackMessageCreateWithoutMessageInputSchema: z.ZodType<Prisma.ResolutionSlackMessageCreateWithoutMessageInput> = z.object({
  profile: z.lazy(() => ProfileCreateNestedOneWithoutResolutionMessagesInputSchema).optional(),
  question: z.lazy(() => QuestionCreateNestedOneWithoutResolutionMessagesInputSchema)
}).strict();

export const ResolutionSlackMessageUncheckedCreateWithoutMessageInputSchema: z.ZodType<Prisma.ResolutionSlackMessageUncheckedCreateWithoutMessageInput> = z.object({
  id: z.number().int().optional(),
  questionId: z.string(),
  profileId: z.number().int().optional().nullable()
}).strict();

export const ResolutionSlackMessageCreateOrConnectWithoutMessageInputSchema: z.ZodType<Prisma.ResolutionSlackMessageCreateOrConnectWithoutMessageInput> = z.object({
  where: z.lazy(() => ResolutionSlackMessageWhereUniqueInputSchema),
  create: z.union([ z.lazy(() => ResolutionSlackMessageCreateWithoutMessageInputSchema),z.lazy(() => ResolutionSlackMessageUncheckedCreateWithoutMessageInputSchema) ]),
}).strict();

export const PingSlackMessageUpsertWithoutMessageInputSchema: z.ZodType<Prisma.PingSlackMessageUpsertWithoutMessageInput> = z.object({
  update: z.union([ z.lazy(() => PingSlackMessageUpdateWithoutMessageInputSchema),z.lazy(() => PingSlackMessageUncheckedUpdateWithoutMessageInputSchema) ]),
  create: z.union([ z.lazy(() => PingSlackMessageCreateWithoutMessageInputSchema),z.lazy(() => PingSlackMessageUncheckedCreateWithoutMessageInputSchema) ]),
  where: z.lazy(() => PingSlackMessageWhereInputSchema).optional()
}).strict();

export const PingSlackMessageUpdateToOneWithWhereWithoutMessageInputSchema: z.ZodType<Prisma.PingSlackMessageUpdateToOneWithWhereWithoutMessageInput> = z.object({
  where: z.lazy(() => PingSlackMessageWhereInputSchema).optional(),
  data: z.union([ z.lazy(() => PingSlackMessageUpdateWithoutMessageInputSchema),z.lazy(() => PingSlackMessageUncheckedUpdateWithoutMessageInputSchema) ]),
}).strict();

export const PingSlackMessageUpdateWithoutMessageInputSchema: z.ZodType<Prisma.PingSlackMessageUpdateWithoutMessageInput> = z.object({
  question: z.lazy(() => QuestionUpdateOneRequiredWithoutPingResolveMessagesNestedInputSchema).optional()
}).strict();

export const PingSlackMessageUncheckedUpdateWithoutMessageInputSchema: z.ZodType<Prisma.PingSlackMessageUncheckedUpdateWithoutMessageInput> = z.object({
  id: z.union([ z.number().int(),z.lazy(() => IntFieldUpdateOperationsInputSchema) ]).optional(),
  questionId: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
}).strict();

export const QuestionSlackMessageUpsertWithoutMessageInputSchema: z.ZodType<Prisma.QuestionSlackMessageUpsertWithoutMessageInput> = z.object({
  update: z.union([ z.lazy(() => QuestionSlackMessageUpdateWithoutMessageInputSchema),z.lazy(() => QuestionSlackMessageUncheckedUpdateWithoutMessageInputSchema) ]),
  create: z.union([ z.lazy(() => QuestionSlackMessageCreateWithoutMessageInputSchema),z.lazy(() => QuestionSlackMessageUncheckedCreateWithoutMessageInputSchema) ]),
  where: z.lazy(() => QuestionSlackMessageWhereInputSchema).optional()
}).strict();

export const QuestionSlackMessageUpdateToOneWithWhereWithoutMessageInputSchema: z.ZodType<Prisma.QuestionSlackMessageUpdateToOneWithWhereWithoutMessageInput> = z.object({
  where: z.lazy(() => QuestionSlackMessageWhereInputSchema).optional(),
  data: z.union([ z.lazy(() => QuestionSlackMessageUpdateWithoutMessageInputSchema),z.lazy(() => QuestionSlackMessageUncheckedUpdateWithoutMessageInputSchema) ]),
}).strict();

export const QuestionSlackMessageUpdateWithoutMessageInputSchema: z.ZodType<Prisma.QuestionSlackMessageUpdateWithoutMessageInput> = z.object({
  updatedAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  question: z.lazy(() => QuestionUpdateOneRequiredWithoutQuestionMessagesNestedInputSchema).optional()
}).strict();

export const QuestionSlackMessageUncheckedUpdateWithoutMessageInputSchema: z.ZodType<Prisma.QuestionSlackMessageUncheckedUpdateWithoutMessageInput> = z.object({
  id: z.union([ z.number().int(),z.lazy(() => IntFieldUpdateOperationsInputSchema) ]).optional(),
  questionId: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  updatedAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
}).strict();

export const ResolutionSlackMessageUpsertWithoutMessageInputSchema: z.ZodType<Prisma.ResolutionSlackMessageUpsertWithoutMessageInput> = z.object({
  update: z.union([ z.lazy(() => ResolutionSlackMessageUpdateWithoutMessageInputSchema),z.lazy(() => ResolutionSlackMessageUncheckedUpdateWithoutMessageInputSchema) ]),
  create: z.union([ z.lazy(() => ResolutionSlackMessageCreateWithoutMessageInputSchema),z.lazy(() => ResolutionSlackMessageUncheckedCreateWithoutMessageInputSchema) ]),
  where: z.lazy(() => ResolutionSlackMessageWhereInputSchema).optional()
}).strict();

export const ResolutionSlackMessageUpdateToOneWithWhereWithoutMessageInputSchema: z.ZodType<Prisma.ResolutionSlackMessageUpdateToOneWithWhereWithoutMessageInput> = z.object({
  where: z.lazy(() => ResolutionSlackMessageWhereInputSchema).optional(),
  data: z.union([ z.lazy(() => ResolutionSlackMessageUpdateWithoutMessageInputSchema),z.lazy(() => ResolutionSlackMessageUncheckedUpdateWithoutMessageInputSchema) ]),
}).strict();

export const ResolutionSlackMessageUpdateWithoutMessageInputSchema: z.ZodType<Prisma.ResolutionSlackMessageUpdateWithoutMessageInput> = z.object({
  profile: z.lazy(() => ProfileUpdateOneWithoutResolutionMessagesNestedInputSchema).optional(),
  question: z.lazy(() => QuestionUpdateOneRequiredWithoutResolutionMessagesNestedInputSchema).optional()
}).strict();

export const ResolutionSlackMessageUncheckedUpdateWithoutMessageInputSchema: z.ZodType<Prisma.ResolutionSlackMessageUncheckedUpdateWithoutMessageInput> = z.object({
  id: z.union([ z.number().int(),z.lazy(() => IntFieldUpdateOperationsInputSchema) ]).optional(),
  questionId: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  profileId: z.union([ z.number().int(),z.lazy(() => NullableIntFieldUpdateOperationsInputSchema) ]).optional().nullable(),
}).strict();

export const ForecastCreateWithoutUserInputSchema: z.ZodType<Prisma.ForecastCreateWithoutUserInput> = z.object({
  createdAt: z.coerce.date().optional(),
  comment: z.string().optional().nullable(),
  forecast: z.union([z.number(),z.string(),z.instanceof(Decimal),z.instanceof(Prisma.Decimal),DecimalJsLikeSchema,]).refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' }),
  option: z.lazy(() => QuestionOptionCreateNestedOneWithoutForecastsInputSchema).optional(),
  profile: z.lazy(() => ProfileCreateNestedOneWithoutForecastsInputSchema).optional(),
  question: z.lazy(() => QuestionCreateNestedOneWithoutForecastsInputSchema)
}).strict();

export const ForecastUncheckedCreateWithoutUserInputSchema: z.ZodType<Prisma.ForecastUncheckedCreateWithoutUserInput> = z.object({
  id: z.number().int().optional(),
  createdAt: z.coerce.date().optional(),
  comment: z.string().optional().nullable(),
  forecast: z.union([z.number(),z.string(),z.instanceof(Decimal),z.instanceof(Prisma.Decimal),DecimalJsLikeSchema,]).refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' }),
  profileId: z.number().int().optional().nullable(),
  questionId: z.string(),
  optionId: z.string().optional().nullable()
}).strict();

export const ForecastCreateOrConnectWithoutUserInputSchema: z.ZodType<Prisma.ForecastCreateOrConnectWithoutUserInput> = z.object({
  where: z.lazy(() => ForecastWhereUniqueInputSchema),
  create: z.union([ z.lazy(() => ForecastCreateWithoutUserInputSchema),z.lazy(() => ForecastUncheckedCreateWithoutUserInputSchema) ]),
}).strict();

export const ForecastCreateManyUserInputEnvelopeSchema: z.ZodType<Prisma.ForecastCreateManyUserInputEnvelope> = z.object({
  data: z.union([ z.lazy(() => ForecastCreateManyUserInputSchema),z.lazy(() => ForecastCreateManyUserInputSchema).array() ]),
  skipDuplicates: z.boolean().optional()
}).strict();

export const ProfileCreateWithoutUserInputSchema: z.ZodType<Prisma.ProfileCreateWithoutUserInput> = z.object({
  createdAt: z.coerce.date().optional(),
  slackId: z.string().optional().nullable(),
  slackTeamId: z.string().optional().nullable(),
  forecasts: z.lazy(() => ForecastCreateNestedManyWithoutProfileInputSchema).optional(),
  questions: z.lazy(() => QuestionCreateNestedManyWithoutProfileInputSchema).optional(),
  resolutionMessages: z.lazy(() => ResolutionSlackMessageCreateNestedManyWithoutProfileInputSchema).optional(),
  target: z.lazy(() => TargetCreateNestedOneWithoutProfileInputSchema).optional()
}).strict();

export const ProfileUncheckedCreateWithoutUserInputSchema: z.ZodType<Prisma.ProfileUncheckedCreateWithoutUserInput> = z.object({
  id: z.number().int().optional(),
  createdAt: z.coerce.date().optional(),
  slackId: z.string().optional().nullable(),
  slackTeamId: z.string().optional().nullable(),
  forecasts: z.lazy(() => ForecastUncheckedCreateNestedManyWithoutProfileInputSchema).optional(),
  questions: z.lazy(() => QuestionUncheckedCreateNestedManyWithoutProfileInputSchema).optional(),
  resolutionMessages: z.lazy(() => ResolutionSlackMessageUncheckedCreateNestedManyWithoutProfileInputSchema).optional(),
  target: z.lazy(() => TargetUncheckedCreateNestedOneWithoutProfileInputSchema).optional()
}).strict();

export const ProfileCreateOrConnectWithoutUserInputSchema: z.ZodType<Prisma.ProfileCreateOrConnectWithoutUserInput> = z.object({
  where: z.lazy(() => ProfileWhereUniqueInputSchema),
  create: z.union([ z.lazy(() => ProfileCreateWithoutUserInputSchema),z.lazy(() => ProfileUncheckedCreateWithoutUserInputSchema) ]),
}).strict();

export const ProfileCreateManyUserInputEnvelopeSchema: z.ZodType<Prisma.ProfileCreateManyUserInputEnvelope> = z.object({
  data: z.union([ z.lazy(() => ProfileCreateManyUserInputSchema),z.lazy(() => ProfileCreateManyUserInputSchema).array() ]),
  skipDuplicates: z.boolean().optional()
}).strict();

export const QuestionCreateWithoutUserInputSchema: z.ZodType<Prisma.QuestionCreateWithoutUserInput> = z.object({
  id: z.string().cuid().optional(),
  createdAt: z.coerce.date().optional(),
  comment: z.string().optional().nullable(),
  title: z.string(),
  type: z.lazy(() => QuestionTypeSchema).optional(),
  resolveBy: z.coerce.date(),
  resolved: z.boolean().optional(),
  pingedForResolution: z.boolean().optional(),
  resolution: z.lazy(() => ResolutionSchema).optional().nullable(),
  resolvedAt: z.coerce.date().optional().nullable(),
  notes: z.string().optional().nullable(),
  hideForecastsUntil: z.coerce.date().optional().nullable(),
  hideForecastsUntilPrediction: z.boolean().optional().nullable(),
  sharedPublicly: z.boolean().optional(),
  unlisted: z.boolean().optional(),
  exclusiveAnswers: z.boolean().optional().nullable(),
  options: z.lazy(() => QuestionOptionCreateNestedManyWithoutQuestionInputSchema).optional(),
  forecasts: z.lazy(() => ForecastCreateNestedManyWithoutQuestionInputSchema).optional(),
  pingResolveMessages: z.lazy(() => PingSlackMessageCreateNestedManyWithoutQuestionInputSchema).optional(),
  profile: z.lazy(() => ProfileCreateNestedOneWithoutQuestionsInputSchema).optional(),
  sharedWith: z.lazy(() => UserCreateNestedManyWithoutQuestionsSharedWithInputSchema).optional(),
  sharedWithLists: z.lazy(() => UserListCreateNestedManyWithoutQuestionsInputSchema).optional(),
  questionScores: z.lazy(() => QuestionScoreCreateNestedManyWithoutQuestionInputSchema).optional(),
  questionMessages: z.lazy(() => QuestionSlackMessageCreateNestedManyWithoutQuestionInputSchema).optional(),
  resolutionMessages: z.lazy(() => ResolutionSlackMessageCreateNestedManyWithoutQuestionInputSchema).optional(),
  comments: z.lazy(() => CommentCreateNestedManyWithoutQuestionInputSchema).optional(),
  tags: z.lazy(() => TagCreateNestedManyWithoutQuestionsInputSchema).optional(),
  tournaments: z.lazy(() => TournamentCreateNestedManyWithoutQuestionsInputSchema).optional(),
  notifications: z.lazy(() => NotificationCreateNestedManyWithoutQuestionInputSchema).optional()
}).strict();

export const QuestionUncheckedCreateWithoutUserInputSchema: z.ZodType<Prisma.QuestionUncheckedCreateWithoutUserInput> = z.object({
  id: z.string().cuid().optional(),
  createdAt: z.coerce.date().optional(),
  comment: z.string().optional().nullable(),
  profileId: z.number().int().optional().nullable(),
  title: z.string(),
  type: z.lazy(() => QuestionTypeSchema).optional(),
  resolveBy: z.coerce.date(),
  resolved: z.boolean().optional(),
  pingedForResolution: z.boolean().optional(),
  resolution: z.lazy(() => ResolutionSchema).optional().nullable(),
  resolvedAt: z.coerce.date().optional().nullable(),
  notes: z.string().optional().nullable(),
  hideForecastsUntil: z.coerce.date().optional().nullable(),
  hideForecastsUntilPrediction: z.boolean().optional().nullable(),
  sharedPublicly: z.boolean().optional(),
  unlisted: z.boolean().optional(),
  exclusiveAnswers: z.boolean().optional().nullable(),
  options: z.lazy(() => QuestionOptionUncheckedCreateNestedManyWithoutQuestionInputSchema).optional(),
  forecasts: z.lazy(() => ForecastUncheckedCreateNestedManyWithoutQuestionInputSchema).optional(),
  pingResolveMessages: z.lazy(() => PingSlackMessageUncheckedCreateNestedManyWithoutQuestionInputSchema).optional(),
  sharedWith: z.lazy(() => UserUncheckedCreateNestedManyWithoutQuestionsSharedWithInputSchema).optional(),
  sharedWithLists: z.lazy(() => UserListUncheckedCreateNestedManyWithoutQuestionsInputSchema).optional(),
  questionScores: z.lazy(() => QuestionScoreUncheckedCreateNestedManyWithoutQuestionInputSchema).optional(),
  questionMessages: z.lazy(() => QuestionSlackMessageUncheckedCreateNestedManyWithoutQuestionInputSchema).optional(),
  resolutionMessages: z.lazy(() => ResolutionSlackMessageUncheckedCreateNestedManyWithoutQuestionInputSchema).optional(),
  comments: z.lazy(() => CommentUncheckedCreateNestedManyWithoutQuestionInputSchema).optional(),
  tags: z.lazy(() => TagUncheckedCreateNestedManyWithoutQuestionsInputSchema).optional(),
  tournaments: z.lazy(() => TournamentUncheckedCreateNestedManyWithoutQuestionsInputSchema).optional(),
  notifications: z.lazy(() => NotificationUncheckedCreateNestedManyWithoutQuestionInputSchema).optional()
}).strict();

export const QuestionCreateOrConnectWithoutUserInputSchema: z.ZodType<Prisma.QuestionCreateOrConnectWithoutUserInput> = z.object({
  where: z.lazy(() => QuestionWhereUniqueInputSchema),
  create: z.union([ z.lazy(() => QuestionCreateWithoutUserInputSchema),z.lazy(() => QuestionUncheckedCreateWithoutUserInputSchema) ]),
}).strict();

export const QuestionCreateManyUserInputEnvelopeSchema: z.ZodType<Prisma.QuestionCreateManyUserInputEnvelope> = z.object({
  data: z.union([ z.lazy(() => QuestionCreateManyUserInputSchema),z.lazy(() => QuestionCreateManyUserInputSchema).array() ]),
  skipDuplicates: z.boolean().optional()
}).strict();

export const QuestionScoreCreateWithoutUserInputSchema: z.ZodType<Prisma.QuestionScoreCreateWithoutUserInput> = z.object({
  createdAt: z.coerce.date().optional(),
  relativeScore: z.union([z.number(),z.string(),z.instanceof(Decimal),z.instanceof(Prisma.Decimal),DecimalJsLikeSchema,]).refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' }).optional().nullable(),
  userQuestionComboId: z.string(),
  absoluteScore: z.union([z.number(),z.string(),z.instanceof(Decimal),z.instanceof(Prisma.Decimal),DecimalJsLikeSchema,]).refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' }),
  rank: z.number().int(),
  question: z.lazy(() => QuestionCreateNestedOneWithoutQuestionScoresInputSchema),
  QuestionOption: z.lazy(() => QuestionOptionCreateNestedOneWithoutQuestionScoresInputSchema).optional()
}).strict();

export const QuestionScoreUncheckedCreateWithoutUserInputSchema: z.ZodType<Prisma.QuestionScoreUncheckedCreateWithoutUserInput> = z.object({
  id: z.number().int().optional(),
  createdAt: z.coerce.date().optional(),
  relativeScore: z.union([z.number(),z.string(),z.instanceof(Decimal),z.instanceof(Prisma.Decimal),DecimalJsLikeSchema,]).refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' }).optional().nullable(),
  questionId: z.string(),
  userQuestionComboId: z.string(),
  absoluteScore: z.union([z.number(),z.string(),z.instanceof(Decimal),z.instanceof(Prisma.Decimal),DecimalJsLikeSchema,]).refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' }),
  rank: z.number().int(),
  questionOptionId: z.string().optional().nullable()
}).strict();

export const QuestionScoreCreateOrConnectWithoutUserInputSchema: z.ZodType<Prisma.QuestionScoreCreateOrConnectWithoutUserInput> = z.object({
  where: z.lazy(() => QuestionScoreWhereUniqueInputSchema),
  create: z.union([ z.lazy(() => QuestionScoreCreateWithoutUserInputSchema),z.lazy(() => QuestionScoreUncheckedCreateWithoutUserInputSchema) ]),
}).strict();

export const QuestionScoreCreateManyUserInputEnvelopeSchema: z.ZodType<Prisma.QuestionScoreCreateManyUserInputEnvelope> = z.object({
  data: z.union([ z.lazy(() => QuestionScoreCreateManyUserInputSchema),z.lazy(() => QuestionScoreCreateManyUserInputSchema).array() ]),
  skipDuplicates: z.boolean().optional()
}).strict();

export const QuestionCreateWithoutSharedWithInputSchema: z.ZodType<Prisma.QuestionCreateWithoutSharedWithInput> = z.object({
  id: z.string().cuid().optional(),
  createdAt: z.coerce.date().optional(),
  comment: z.string().optional().nullable(),
  title: z.string(),
  type: z.lazy(() => QuestionTypeSchema).optional(),
  resolveBy: z.coerce.date(),
  resolved: z.boolean().optional(),
  pingedForResolution: z.boolean().optional(),
  resolution: z.lazy(() => ResolutionSchema).optional().nullable(),
  resolvedAt: z.coerce.date().optional().nullable(),
  notes: z.string().optional().nullable(),
  hideForecastsUntil: z.coerce.date().optional().nullable(),
  hideForecastsUntilPrediction: z.boolean().optional().nullable(),
  sharedPublicly: z.boolean().optional(),
  unlisted: z.boolean().optional(),
  exclusiveAnswers: z.boolean().optional().nullable(),
  options: z.lazy(() => QuestionOptionCreateNestedManyWithoutQuestionInputSchema).optional(),
  forecasts: z.lazy(() => ForecastCreateNestedManyWithoutQuestionInputSchema).optional(),
  pingResolveMessages: z.lazy(() => PingSlackMessageCreateNestedManyWithoutQuestionInputSchema).optional(),
  profile: z.lazy(() => ProfileCreateNestedOneWithoutQuestionsInputSchema).optional(),
  user: z.lazy(() => UserCreateNestedOneWithoutQuestionsInputSchema),
  sharedWithLists: z.lazy(() => UserListCreateNestedManyWithoutQuestionsInputSchema).optional(),
  questionScores: z.lazy(() => QuestionScoreCreateNestedManyWithoutQuestionInputSchema).optional(),
  questionMessages: z.lazy(() => QuestionSlackMessageCreateNestedManyWithoutQuestionInputSchema).optional(),
  resolutionMessages: z.lazy(() => ResolutionSlackMessageCreateNestedManyWithoutQuestionInputSchema).optional(),
  comments: z.lazy(() => CommentCreateNestedManyWithoutQuestionInputSchema).optional(),
  tags: z.lazy(() => TagCreateNestedManyWithoutQuestionsInputSchema).optional(),
  tournaments: z.lazy(() => TournamentCreateNestedManyWithoutQuestionsInputSchema).optional(),
  notifications: z.lazy(() => NotificationCreateNestedManyWithoutQuestionInputSchema).optional()
}).strict();

export const QuestionUncheckedCreateWithoutSharedWithInputSchema: z.ZodType<Prisma.QuestionUncheckedCreateWithoutSharedWithInput> = z.object({
  id: z.string().cuid().optional(),
  createdAt: z.coerce.date().optional(),
  comment: z.string().optional().nullable(),
  profileId: z.number().int().optional().nullable(),
  title: z.string(),
  type: z.lazy(() => QuestionTypeSchema).optional(),
  resolveBy: z.coerce.date(),
  resolved: z.boolean().optional(),
  pingedForResolution: z.boolean().optional(),
  resolution: z.lazy(() => ResolutionSchema).optional().nullable(),
  resolvedAt: z.coerce.date().optional().nullable(),
  notes: z.string().optional().nullable(),
  hideForecastsUntil: z.coerce.date().optional().nullable(),
  hideForecastsUntilPrediction: z.boolean().optional().nullable(),
  userId: z.string(),
  sharedPublicly: z.boolean().optional(),
  unlisted: z.boolean().optional(),
  exclusiveAnswers: z.boolean().optional().nullable(),
  options: z.lazy(() => QuestionOptionUncheckedCreateNestedManyWithoutQuestionInputSchema).optional(),
  forecasts: z.lazy(() => ForecastUncheckedCreateNestedManyWithoutQuestionInputSchema).optional(),
  pingResolveMessages: z.lazy(() => PingSlackMessageUncheckedCreateNestedManyWithoutQuestionInputSchema).optional(),
  sharedWithLists: z.lazy(() => UserListUncheckedCreateNestedManyWithoutQuestionsInputSchema).optional(),
  questionScores: z.lazy(() => QuestionScoreUncheckedCreateNestedManyWithoutQuestionInputSchema).optional(),
  questionMessages: z.lazy(() => QuestionSlackMessageUncheckedCreateNestedManyWithoutQuestionInputSchema).optional(),
  resolutionMessages: z.lazy(() => ResolutionSlackMessageUncheckedCreateNestedManyWithoutQuestionInputSchema).optional(),
  comments: z.lazy(() => CommentUncheckedCreateNestedManyWithoutQuestionInputSchema).optional(),
  tags: z.lazy(() => TagUncheckedCreateNestedManyWithoutQuestionsInputSchema).optional(),
  tournaments: z.lazy(() => TournamentUncheckedCreateNestedManyWithoutQuestionsInputSchema).optional(),
  notifications: z.lazy(() => NotificationUncheckedCreateNestedManyWithoutQuestionInputSchema).optional()
}).strict();

export const QuestionCreateOrConnectWithoutSharedWithInputSchema: z.ZodType<Prisma.QuestionCreateOrConnectWithoutSharedWithInput> = z.object({
  where: z.lazy(() => QuestionWhereUniqueInputSchema),
  create: z.union([ z.lazy(() => QuestionCreateWithoutSharedWithInputSchema),z.lazy(() => QuestionUncheckedCreateWithoutSharedWithInputSchema) ]),
}).strict();

export const CommentCreateWithoutUserInputSchema: z.ZodType<Prisma.CommentCreateWithoutUserInput> = z.object({
  createdAt: z.coerce.date().optional(),
  comment: z.string(),
  question: z.lazy(() => QuestionCreateNestedOneWithoutCommentsInputSchema)
}).strict();

export const CommentUncheckedCreateWithoutUserInputSchema: z.ZodType<Prisma.CommentUncheckedCreateWithoutUserInput> = z.object({
  id: z.number().int().optional(),
  createdAt: z.coerce.date().optional(),
  comment: z.string(),
  questionId: z.string()
}).strict();

export const CommentCreateOrConnectWithoutUserInputSchema: z.ZodType<Prisma.CommentCreateOrConnectWithoutUserInput> = z.object({
  where: z.lazy(() => CommentWhereUniqueInputSchema),
  create: z.union([ z.lazy(() => CommentCreateWithoutUserInputSchema),z.lazy(() => CommentUncheckedCreateWithoutUserInputSchema) ]),
}).strict();

export const CommentCreateManyUserInputEnvelopeSchema: z.ZodType<Prisma.CommentCreateManyUserInputEnvelope> = z.object({
  data: z.union([ z.lazy(() => CommentCreateManyUserInputSchema),z.lazy(() => CommentCreateManyUserInputSchema).array() ]),
  skipDuplicates: z.boolean().optional()
}).strict();

export const TargetCreateWithoutUserInputSchema: z.ZodType<Prisma.TargetCreateWithoutUserInput> = z.object({
  type: z.lazy(() => TargetTypeSchema),
  goal: z.number().int(),
  lastFailedAt: z.coerce.date().optional(),
  notifyOn: z.lazy(() => DayOfTheWeekSchema),
  lastNotified: z.coerce.date().optional(),
  profile: z.lazy(() => ProfileCreateNestedOneWithoutTargetInputSchema).optional()
}).strict();

export const TargetUncheckedCreateWithoutUserInputSchema: z.ZodType<Prisma.TargetUncheckedCreateWithoutUserInput> = z.object({
  id: z.number().int().optional(),
  profileId: z.number().int().optional().nullable(),
  type: z.lazy(() => TargetTypeSchema),
  goal: z.number().int(),
  lastFailedAt: z.coerce.date().optional(),
  notifyOn: z.lazy(() => DayOfTheWeekSchema),
  lastNotified: z.coerce.date().optional()
}).strict();

export const TargetCreateOrConnectWithoutUserInputSchema: z.ZodType<Prisma.TargetCreateOrConnectWithoutUserInput> = z.object({
  where: z.lazy(() => TargetWhereUniqueInputSchema),
  create: z.union([ z.lazy(() => TargetCreateWithoutUserInputSchema),z.lazy(() => TargetUncheckedCreateWithoutUserInputSchema) ]),
}).strict();

export const UserListCreateWithoutAuthorInputSchema: z.ZodType<Prisma.UserListCreateWithoutAuthorInput> = z.object({
  id: z.string().cuid().optional(),
  createdAt: z.coerce.date().optional(),
  inviteId: z.string().cuid().optional().nullable(),
  name: z.string(),
  emailDomains: z.union([ z.lazy(() => UserListCreateemailDomainsInputSchema),z.string().array() ]).optional(),
  syncToSlackTeamId: z.string().optional().nullable(),
  syncToSlackChannelId: z.string().optional().nullable(),
  users: z.lazy(() => UserCreateNestedManyWithoutMemberOfListsInputSchema).optional(),
  questions: z.lazy(() => QuestionCreateNestedManyWithoutSharedWithListsInputSchema).optional(),
  tournaments: z.lazy(() => TournamentCreateNestedManyWithoutUserListInputSchema).optional()
}).strict();

export const UserListUncheckedCreateWithoutAuthorInputSchema: z.ZodType<Prisma.UserListUncheckedCreateWithoutAuthorInput> = z.object({
  id: z.string().cuid().optional(),
  createdAt: z.coerce.date().optional(),
  inviteId: z.string().cuid().optional().nullable(),
  name: z.string(),
  emailDomains: z.union([ z.lazy(() => UserListCreateemailDomainsInputSchema),z.string().array() ]).optional(),
  syncToSlackTeamId: z.string().optional().nullable(),
  syncToSlackChannelId: z.string().optional().nullable(),
  users: z.lazy(() => UserUncheckedCreateNestedManyWithoutMemberOfListsInputSchema).optional(),
  questions: z.lazy(() => QuestionUncheckedCreateNestedManyWithoutSharedWithListsInputSchema).optional(),
  tournaments: z.lazy(() => TournamentUncheckedCreateNestedManyWithoutUserListInputSchema).optional()
}).strict();

export const UserListCreateOrConnectWithoutAuthorInputSchema: z.ZodType<Prisma.UserListCreateOrConnectWithoutAuthorInput> = z.object({
  where: z.lazy(() => UserListWhereUniqueInputSchema),
  create: z.union([ z.lazy(() => UserListCreateWithoutAuthorInputSchema),z.lazy(() => UserListUncheckedCreateWithoutAuthorInputSchema) ]),
}).strict();

export const UserListCreateManyAuthorInputEnvelopeSchema: z.ZodType<Prisma.UserListCreateManyAuthorInputEnvelope> = z.object({
  data: z.union([ z.lazy(() => UserListCreateManyAuthorInputSchema),z.lazy(() => UserListCreateManyAuthorInputSchema).array() ]),
  skipDuplicates: z.boolean().optional()
}).strict();

export const UserListCreateWithoutUsersInputSchema: z.ZodType<Prisma.UserListCreateWithoutUsersInput> = z.object({
  id: z.string().cuid().optional(),
  createdAt: z.coerce.date().optional(),
  inviteId: z.string().cuid().optional().nullable(),
  name: z.string(),
  emailDomains: z.union([ z.lazy(() => UserListCreateemailDomainsInputSchema),z.string().array() ]).optional(),
  syncToSlackTeamId: z.string().optional().nullable(),
  syncToSlackChannelId: z.string().optional().nullable(),
  author: z.lazy(() => UserCreateNestedOneWithoutAuthorOfListsInputSchema),
  questions: z.lazy(() => QuestionCreateNestedManyWithoutSharedWithListsInputSchema).optional(),
  tournaments: z.lazy(() => TournamentCreateNestedManyWithoutUserListInputSchema).optional()
}).strict();

export const UserListUncheckedCreateWithoutUsersInputSchema: z.ZodType<Prisma.UserListUncheckedCreateWithoutUsersInput> = z.object({
  id: z.string().cuid().optional(),
  createdAt: z.coerce.date().optional(),
  inviteId: z.string().cuid().optional().nullable(),
  name: z.string(),
  emailDomains: z.union([ z.lazy(() => UserListCreateemailDomainsInputSchema),z.string().array() ]).optional(),
  syncToSlackTeamId: z.string().optional().nullable(),
  syncToSlackChannelId: z.string().optional().nullable(),
  authorId: z.string(),
  questions: z.lazy(() => QuestionUncheckedCreateNestedManyWithoutSharedWithListsInputSchema).optional(),
  tournaments: z.lazy(() => TournamentUncheckedCreateNestedManyWithoutUserListInputSchema).optional()
}).strict();

export const UserListCreateOrConnectWithoutUsersInputSchema: z.ZodType<Prisma.UserListCreateOrConnectWithoutUsersInput> = z.object({
  where: z.lazy(() => UserListWhereUniqueInputSchema),
  create: z.union([ z.lazy(() => UserListCreateWithoutUsersInputSchema),z.lazy(() => UserListUncheckedCreateWithoutUsersInputSchema) ]),
}).strict();

export const TagCreateWithoutUserInputSchema: z.ZodType<Prisma.TagCreateWithoutUserInput> = z.object({
  id: z.string().cuid().optional(),
  createdAt: z.coerce.date().optional(),
  name: z.string(),
  questions: z.lazy(() => QuestionCreateNestedManyWithoutTagsInputSchema).optional()
}).strict();

export const TagUncheckedCreateWithoutUserInputSchema: z.ZodType<Prisma.TagUncheckedCreateWithoutUserInput> = z.object({
  id: z.string().cuid().optional(),
  createdAt: z.coerce.date().optional(),
  name: z.string(),
  questions: z.lazy(() => QuestionUncheckedCreateNestedManyWithoutTagsInputSchema).optional()
}).strict();

export const TagCreateOrConnectWithoutUserInputSchema: z.ZodType<Prisma.TagCreateOrConnectWithoutUserInput> = z.object({
  where: z.lazy(() => TagWhereUniqueInputSchema),
  create: z.union([ z.lazy(() => TagCreateWithoutUserInputSchema),z.lazy(() => TagUncheckedCreateWithoutUserInputSchema) ]),
}).strict();

export const TagCreateManyUserInputEnvelopeSchema: z.ZodType<Prisma.TagCreateManyUserInputEnvelope> = z.object({
  data: z.union([ z.lazy(() => TagCreateManyUserInputSchema),z.lazy(() => TagCreateManyUserInputSchema).array() ]),
  skipDuplicates: z.boolean().optional()
}).strict();

export const TournamentCreateWithoutAuthorInputSchema: z.ZodType<Prisma.TournamentCreateWithoutAuthorInput> = z.object({
  id: z.string().cuid().optional(),
  createdAt: z.coerce.date().optional(),
  name: z.string(),
  description: z.string().optional().nullable(),
  sharedPublicly: z.boolean().optional(),
  unlisted: z.boolean().optional(),
  anyoneInListCanEdit: z.boolean().optional(),
  showLeaderboard: z.boolean().optional(),
  predictYourYear: z.number().int().optional().nullable(),
  syncToSlackTeamId: z.string().optional().nullable(),
  syncToSlackChannelId: z.string().optional().nullable(),
  questions: z.lazy(() => QuestionCreateNestedManyWithoutTournamentsInputSchema).optional(),
  userList: z.lazy(() => UserListCreateNestedOneWithoutTournamentsInputSchema).optional()
}).strict();

export const TournamentUncheckedCreateWithoutAuthorInputSchema: z.ZodType<Prisma.TournamentUncheckedCreateWithoutAuthorInput> = z.object({
  id: z.string().cuid().optional(),
  createdAt: z.coerce.date().optional(),
  name: z.string(),
  description: z.string().optional().nullable(),
  sharedPublicly: z.boolean().optional(),
  unlisted: z.boolean().optional(),
  userListId: z.string().optional().nullable(),
  anyoneInListCanEdit: z.boolean().optional(),
  showLeaderboard: z.boolean().optional(),
  predictYourYear: z.number().int().optional().nullable(),
  syncToSlackTeamId: z.string().optional().nullable(),
  syncToSlackChannelId: z.string().optional().nullable(),
  questions: z.lazy(() => QuestionUncheckedCreateNestedManyWithoutTournamentsInputSchema).optional()
}).strict();

export const TournamentCreateOrConnectWithoutAuthorInputSchema: z.ZodType<Prisma.TournamentCreateOrConnectWithoutAuthorInput> = z.object({
  where: z.lazy(() => TournamentWhereUniqueInputSchema),
  create: z.union([ z.lazy(() => TournamentCreateWithoutAuthorInputSchema),z.lazy(() => TournamentUncheckedCreateWithoutAuthorInputSchema) ]),
}).strict();

export const TournamentCreateManyAuthorInputEnvelopeSchema: z.ZodType<Prisma.TournamentCreateManyAuthorInputEnvelope> = z.object({
  data: z.union([ z.lazy(() => TournamentCreateManyAuthorInputSchema),z.lazy(() => TournamentCreateManyAuthorInputSchema).array() ]),
  skipDuplicates: z.boolean().optional()
}).strict();

export const NotificationCreateWithoutUserInputSchema: z.ZodType<Prisma.NotificationCreateWithoutUserInput> = z.object({
  id: z.string().cuid().optional(),
  createdAt: z.coerce.date().optional(),
  emailSentAt: z.coerce.date().optional().nullable(),
  title: z.string(),
  content: z.string(),
  url: z.string().optional().nullable(),
  tags: z.union([ z.lazy(() => NotificationCreatetagsInputSchema),z.string().array() ]).optional(),
  read: z.boolean().optional(),
  question: z.lazy(() => QuestionCreateNestedOneWithoutNotificationsInputSchema).optional()
}).strict();

export const NotificationUncheckedCreateWithoutUserInputSchema: z.ZodType<Prisma.NotificationUncheckedCreateWithoutUserInput> = z.object({
  id: z.string().cuid().optional(),
  createdAt: z.coerce.date().optional(),
  emailSentAt: z.coerce.date().optional().nullable(),
  title: z.string(),
  content: z.string(),
  url: z.string().optional().nullable(),
  tags: z.union([ z.lazy(() => NotificationCreatetagsInputSchema),z.string().array() ]).optional(),
  read: z.boolean().optional(),
  questionId: z.string().optional().nullable()
}).strict();

export const NotificationCreateOrConnectWithoutUserInputSchema: z.ZodType<Prisma.NotificationCreateOrConnectWithoutUserInput> = z.object({
  where: z.lazy(() => NotificationWhereUniqueInputSchema),
  create: z.union([ z.lazy(() => NotificationCreateWithoutUserInputSchema),z.lazy(() => NotificationUncheckedCreateWithoutUserInputSchema) ]),
}).strict();

export const NotificationCreateManyUserInputEnvelopeSchema: z.ZodType<Prisma.NotificationCreateManyUserInputEnvelope> = z.object({
  data: z.union([ z.lazy(() => NotificationCreateManyUserInputSchema),z.lazy(() => NotificationCreateManyUserInputSchema).array() ]),
  skipDuplicates: z.boolean().optional()
}).strict();

export const QuestionOptionCreateWithoutUserInputSchema: z.ZodType<Prisma.QuestionOptionCreateWithoutUserInput> = z.object({
  id: z.string().cuid().optional(),
  text: z.string(),
  resolution: z.lazy(() => ResolutionSchema).optional().nullable(),
  createdAt: z.coerce.date().optional(),
  resolvedAt: z.coerce.date().optional().nullable(),
  question: z.lazy(() => QuestionCreateNestedOneWithoutOptionsInputSchema),
  forecasts: z.lazy(() => ForecastCreateNestedManyWithoutOptionInputSchema).optional(),
  questionScores: z.lazy(() => QuestionScoreCreateNestedManyWithoutQuestionOptionInputSchema).optional()
}).strict();

export const QuestionOptionUncheckedCreateWithoutUserInputSchema: z.ZodType<Prisma.QuestionOptionUncheckedCreateWithoutUserInput> = z.object({
  id: z.string().cuid().optional(),
  questionId: z.string(),
  text: z.string(),
  resolution: z.lazy(() => ResolutionSchema).optional().nullable(),
  createdAt: z.coerce.date().optional(),
  resolvedAt: z.coerce.date().optional().nullable(),
  forecasts: z.lazy(() => ForecastUncheckedCreateNestedManyWithoutOptionInputSchema).optional(),
  questionScores: z.lazy(() => QuestionScoreUncheckedCreateNestedManyWithoutQuestionOptionInputSchema).optional()
}).strict();

export const QuestionOptionCreateOrConnectWithoutUserInputSchema: z.ZodType<Prisma.QuestionOptionCreateOrConnectWithoutUserInput> = z.object({
  where: z.lazy(() => QuestionOptionWhereUniqueInputSchema),
  create: z.union([ z.lazy(() => QuestionOptionCreateWithoutUserInputSchema),z.lazy(() => QuestionOptionUncheckedCreateWithoutUserInputSchema) ]),
}).strict();

export const QuestionOptionCreateManyUserInputEnvelopeSchema: z.ZodType<Prisma.QuestionOptionCreateManyUserInputEnvelope> = z.object({
  data: z.union([ z.lazy(() => QuestionOptionCreateManyUserInputSchema),z.lazy(() => QuestionOptionCreateManyUserInputSchema).array() ]),
  skipDuplicates: z.boolean().optional()
}).strict();

export const AccountCreateWithoutUserInputSchema: z.ZodType<Prisma.AccountCreateWithoutUserInput> = z.object({
  id: z.string().cuid().optional(),
  type: z.string(),
  provider: z.string(),
  providerAccountId: z.string(),
  refresh_token: z.string().optional().nullable(),
  access_token: z.string().optional().nullable(),
  expires_at: z.number().int().optional().nullable(),
  token_type: z.string().optional().nullable(),
  scope: z.string().optional().nullable(),
  id_token: z.string().optional().nullable(),
  session_state: z.string().optional().nullable()
}).strict();

export const AccountUncheckedCreateWithoutUserInputSchema: z.ZodType<Prisma.AccountUncheckedCreateWithoutUserInput> = z.object({
  id: z.string().cuid().optional(),
  type: z.string(),
  provider: z.string(),
  providerAccountId: z.string(),
  refresh_token: z.string().optional().nullable(),
  access_token: z.string().optional().nullable(),
  expires_at: z.number().int().optional().nullable(),
  token_type: z.string().optional().nullable(),
  scope: z.string().optional().nullable(),
  id_token: z.string().optional().nullable(),
  session_state: z.string().optional().nullable()
}).strict();

export const AccountCreateOrConnectWithoutUserInputSchema: z.ZodType<Prisma.AccountCreateOrConnectWithoutUserInput> = z.object({
  where: z.lazy(() => AccountWhereUniqueInputSchema),
  create: z.union([ z.lazy(() => AccountCreateWithoutUserInputSchema),z.lazy(() => AccountUncheckedCreateWithoutUserInputSchema) ]),
}).strict();

export const AccountCreateManyUserInputEnvelopeSchema: z.ZodType<Prisma.AccountCreateManyUserInputEnvelope> = z.object({
  data: z.union([ z.lazy(() => AccountCreateManyUserInputSchema),z.lazy(() => AccountCreateManyUserInputSchema).array() ]),
  skipDuplicates: z.boolean().optional()
}).strict();

export const ForecastUpsertWithWhereUniqueWithoutUserInputSchema: z.ZodType<Prisma.ForecastUpsertWithWhereUniqueWithoutUserInput> = z.object({
  where: z.lazy(() => ForecastWhereUniqueInputSchema),
  update: z.union([ z.lazy(() => ForecastUpdateWithoutUserInputSchema),z.lazy(() => ForecastUncheckedUpdateWithoutUserInputSchema) ]),
  create: z.union([ z.lazy(() => ForecastCreateWithoutUserInputSchema),z.lazy(() => ForecastUncheckedCreateWithoutUserInputSchema) ]),
}).strict();

export const ForecastUpdateWithWhereUniqueWithoutUserInputSchema: z.ZodType<Prisma.ForecastUpdateWithWhereUniqueWithoutUserInput> = z.object({
  where: z.lazy(() => ForecastWhereUniqueInputSchema),
  data: z.union([ z.lazy(() => ForecastUpdateWithoutUserInputSchema),z.lazy(() => ForecastUncheckedUpdateWithoutUserInputSchema) ]),
}).strict();

export const ForecastUpdateManyWithWhereWithoutUserInputSchema: z.ZodType<Prisma.ForecastUpdateManyWithWhereWithoutUserInput> = z.object({
  where: z.lazy(() => ForecastScalarWhereInputSchema),
  data: z.union([ z.lazy(() => ForecastUpdateManyMutationInputSchema),z.lazy(() => ForecastUncheckedUpdateManyWithoutUserInputSchema) ]),
}).strict();

export const ProfileUpsertWithWhereUniqueWithoutUserInputSchema: z.ZodType<Prisma.ProfileUpsertWithWhereUniqueWithoutUserInput> = z.object({
  where: z.lazy(() => ProfileWhereUniqueInputSchema),
  update: z.union([ z.lazy(() => ProfileUpdateWithoutUserInputSchema),z.lazy(() => ProfileUncheckedUpdateWithoutUserInputSchema) ]),
  create: z.union([ z.lazy(() => ProfileCreateWithoutUserInputSchema),z.lazy(() => ProfileUncheckedCreateWithoutUserInputSchema) ]),
}).strict();

export const ProfileUpdateWithWhereUniqueWithoutUserInputSchema: z.ZodType<Prisma.ProfileUpdateWithWhereUniqueWithoutUserInput> = z.object({
  where: z.lazy(() => ProfileWhereUniqueInputSchema),
  data: z.union([ z.lazy(() => ProfileUpdateWithoutUserInputSchema),z.lazy(() => ProfileUncheckedUpdateWithoutUserInputSchema) ]),
}).strict();

export const ProfileUpdateManyWithWhereWithoutUserInputSchema: z.ZodType<Prisma.ProfileUpdateManyWithWhereWithoutUserInput> = z.object({
  where: z.lazy(() => ProfileScalarWhereInputSchema),
  data: z.union([ z.lazy(() => ProfileUpdateManyMutationInputSchema),z.lazy(() => ProfileUncheckedUpdateManyWithoutUserInputSchema) ]),
}).strict();

export const ProfileScalarWhereInputSchema: z.ZodType<Prisma.ProfileScalarWhereInput> = z.object({
  AND: z.union([ z.lazy(() => ProfileScalarWhereInputSchema),z.lazy(() => ProfileScalarWhereInputSchema).array() ]).optional(),
  OR: z.lazy(() => ProfileScalarWhereInputSchema).array().optional(),
  NOT: z.union([ z.lazy(() => ProfileScalarWhereInputSchema),z.lazy(() => ProfileScalarWhereInputSchema).array() ]).optional(),
  id: z.union([ z.lazy(() => IntFilterSchema),z.number() ]).optional(),
  createdAt: z.union([ z.lazy(() => DateTimeFilterSchema),z.coerce.date() ]).optional(),
  slackId: z.union([ z.lazy(() => StringNullableFilterSchema),z.string() ]).optional().nullable(),
  slackTeamId: z.union([ z.lazy(() => StringNullableFilterSchema),z.string() ]).optional().nullable(),
  userId: z.union([ z.lazy(() => StringFilterSchema),z.string() ]).optional(),
}).strict();

export const QuestionUpsertWithWhereUniqueWithoutUserInputSchema: z.ZodType<Prisma.QuestionUpsertWithWhereUniqueWithoutUserInput> = z.object({
  where: z.lazy(() => QuestionWhereUniqueInputSchema),
  update: z.union([ z.lazy(() => QuestionUpdateWithoutUserInputSchema),z.lazy(() => QuestionUncheckedUpdateWithoutUserInputSchema) ]),
  create: z.union([ z.lazy(() => QuestionCreateWithoutUserInputSchema),z.lazy(() => QuestionUncheckedCreateWithoutUserInputSchema) ]),
}).strict();

export const QuestionUpdateWithWhereUniqueWithoutUserInputSchema: z.ZodType<Prisma.QuestionUpdateWithWhereUniqueWithoutUserInput> = z.object({
  where: z.lazy(() => QuestionWhereUniqueInputSchema),
  data: z.union([ z.lazy(() => QuestionUpdateWithoutUserInputSchema),z.lazy(() => QuestionUncheckedUpdateWithoutUserInputSchema) ]),
}).strict();

export const QuestionUpdateManyWithWhereWithoutUserInputSchema: z.ZodType<Prisma.QuestionUpdateManyWithWhereWithoutUserInput> = z.object({
  where: z.lazy(() => QuestionScalarWhereInputSchema),
  data: z.union([ z.lazy(() => QuestionUpdateManyMutationInputSchema),z.lazy(() => QuestionUncheckedUpdateManyWithoutUserInputSchema) ]),
}).strict();

export const QuestionScoreUpsertWithWhereUniqueWithoutUserInputSchema: z.ZodType<Prisma.QuestionScoreUpsertWithWhereUniqueWithoutUserInput> = z.object({
  where: z.lazy(() => QuestionScoreWhereUniqueInputSchema),
  update: z.union([ z.lazy(() => QuestionScoreUpdateWithoutUserInputSchema),z.lazy(() => QuestionScoreUncheckedUpdateWithoutUserInputSchema) ]),
  create: z.union([ z.lazy(() => QuestionScoreCreateWithoutUserInputSchema),z.lazy(() => QuestionScoreUncheckedCreateWithoutUserInputSchema) ]),
}).strict();

export const QuestionScoreUpdateWithWhereUniqueWithoutUserInputSchema: z.ZodType<Prisma.QuestionScoreUpdateWithWhereUniqueWithoutUserInput> = z.object({
  where: z.lazy(() => QuestionScoreWhereUniqueInputSchema),
  data: z.union([ z.lazy(() => QuestionScoreUpdateWithoutUserInputSchema),z.lazy(() => QuestionScoreUncheckedUpdateWithoutUserInputSchema) ]),
}).strict();

export const QuestionScoreUpdateManyWithWhereWithoutUserInputSchema: z.ZodType<Prisma.QuestionScoreUpdateManyWithWhereWithoutUserInput> = z.object({
  where: z.lazy(() => QuestionScoreScalarWhereInputSchema),
  data: z.union([ z.lazy(() => QuestionScoreUpdateManyMutationInputSchema),z.lazy(() => QuestionScoreUncheckedUpdateManyWithoutUserInputSchema) ]),
}).strict();

export const QuestionUpsertWithWhereUniqueWithoutSharedWithInputSchema: z.ZodType<Prisma.QuestionUpsertWithWhereUniqueWithoutSharedWithInput> = z.object({
  where: z.lazy(() => QuestionWhereUniqueInputSchema),
  update: z.union([ z.lazy(() => QuestionUpdateWithoutSharedWithInputSchema),z.lazy(() => QuestionUncheckedUpdateWithoutSharedWithInputSchema) ]),
  create: z.union([ z.lazy(() => QuestionCreateWithoutSharedWithInputSchema),z.lazy(() => QuestionUncheckedCreateWithoutSharedWithInputSchema) ]),
}).strict();

export const QuestionUpdateWithWhereUniqueWithoutSharedWithInputSchema: z.ZodType<Prisma.QuestionUpdateWithWhereUniqueWithoutSharedWithInput> = z.object({
  where: z.lazy(() => QuestionWhereUniqueInputSchema),
  data: z.union([ z.lazy(() => QuestionUpdateWithoutSharedWithInputSchema),z.lazy(() => QuestionUncheckedUpdateWithoutSharedWithInputSchema) ]),
}).strict();

export const QuestionUpdateManyWithWhereWithoutSharedWithInputSchema: z.ZodType<Prisma.QuestionUpdateManyWithWhereWithoutSharedWithInput> = z.object({
  where: z.lazy(() => QuestionScalarWhereInputSchema),
  data: z.union([ z.lazy(() => QuestionUpdateManyMutationInputSchema),z.lazy(() => QuestionUncheckedUpdateManyWithoutSharedWithInputSchema) ]),
}).strict();

export const CommentUpsertWithWhereUniqueWithoutUserInputSchema: z.ZodType<Prisma.CommentUpsertWithWhereUniqueWithoutUserInput> = z.object({
  where: z.lazy(() => CommentWhereUniqueInputSchema),
  update: z.union([ z.lazy(() => CommentUpdateWithoutUserInputSchema),z.lazy(() => CommentUncheckedUpdateWithoutUserInputSchema) ]),
  create: z.union([ z.lazy(() => CommentCreateWithoutUserInputSchema),z.lazy(() => CommentUncheckedCreateWithoutUserInputSchema) ]),
}).strict();

export const CommentUpdateWithWhereUniqueWithoutUserInputSchema: z.ZodType<Prisma.CommentUpdateWithWhereUniqueWithoutUserInput> = z.object({
  where: z.lazy(() => CommentWhereUniqueInputSchema),
  data: z.union([ z.lazy(() => CommentUpdateWithoutUserInputSchema),z.lazy(() => CommentUncheckedUpdateWithoutUserInputSchema) ]),
}).strict();

export const CommentUpdateManyWithWhereWithoutUserInputSchema: z.ZodType<Prisma.CommentUpdateManyWithWhereWithoutUserInput> = z.object({
  where: z.lazy(() => CommentScalarWhereInputSchema),
  data: z.union([ z.lazy(() => CommentUpdateManyMutationInputSchema),z.lazy(() => CommentUncheckedUpdateManyWithoutUserInputSchema) ]),
}).strict();

export const TargetUpsertWithoutUserInputSchema: z.ZodType<Prisma.TargetUpsertWithoutUserInput> = z.object({
  update: z.union([ z.lazy(() => TargetUpdateWithoutUserInputSchema),z.lazy(() => TargetUncheckedUpdateWithoutUserInputSchema) ]),
  create: z.union([ z.lazy(() => TargetCreateWithoutUserInputSchema),z.lazy(() => TargetUncheckedCreateWithoutUserInputSchema) ]),
  where: z.lazy(() => TargetWhereInputSchema).optional()
}).strict();

export const TargetUpdateToOneWithWhereWithoutUserInputSchema: z.ZodType<Prisma.TargetUpdateToOneWithWhereWithoutUserInput> = z.object({
  where: z.lazy(() => TargetWhereInputSchema).optional(),
  data: z.union([ z.lazy(() => TargetUpdateWithoutUserInputSchema),z.lazy(() => TargetUncheckedUpdateWithoutUserInputSchema) ]),
}).strict();

export const TargetUpdateWithoutUserInputSchema: z.ZodType<Prisma.TargetUpdateWithoutUserInput> = z.object({
  type: z.union([ z.lazy(() => TargetTypeSchema),z.lazy(() => EnumTargetTypeFieldUpdateOperationsInputSchema) ]).optional(),
  goal: z.union([ z.number().int(),z.lazy(() => IntFieldUpdateOperationsInputSchema) ]).optional(),
  lastFailedAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  notifyOn: z.union([ z.lazy(() => DayOfTheWeekSchema),z.lazy(() => EnumDayOfTheWeekFieldUpdateOperationsInputSchema) ]).optional(),
  lastNotified: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  profile: z.lazy(() => ProfileUpdateOneWithoutTargetNestedInputSchema).optional()
}).strict();

export const TargetUncheckedUpdateWithoutUserInputSchema: z.ZodType<Prisma.TargetUncheckedUpdateWithoutUserInput> = z.object({
  id: z.union([ z.number().int(),z.lazy(() => IntFieldUpdateOperationsInputSchema) ]).optional(),
  profileId: z.union([ z.number().int(),z.lazy(() => NullableIntFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  type: z.union([ z.lazy(() => TargetTypeSchema),z.lazy(() => EnumTargetTypeFieldUpdateOperationsInputSchema) ]).optional(),
  goal: z.union([ z.number().int(),z.lazy(() => IntFieldUpdateOperationsInputSchema) ]).optional(),
  lastFailedAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  notifyOn: z.union([ z.lazy(() => DayOfTheWeekSchema),z.lazy(() => EnumDayOfTheWeekFieldUpdateOperationsInputSchema) ]).optional(),
  lastNotified: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
}).strict();

export const UserListUpsertWithWhereUniqueWithoutAuthorInputSchema: z.ZodType<Prisma.UserListUpsertWithWhereUniqueWithoutAuthorInput> = z.object({
  where: z.lazy(() => UserListWhereUniqueInputSchema),
  update: z.union([ z.lazy(() => UserListUpdateWithoutAuthorInputSchema),z.lazy(() => UserListUncheckedUpdateWithoutAuthorInputSchema) ]),
  create: z.union([ z.lazy(() => UserListCreateWithoutAuthorInputSchema),z.lazy(() => UserListUncheckedCreateWithoutAuthorInputSchema) ]),
}).strict();

export const UserListUpdateWithWhereUniqueWithoutAuthorInputSchema: z.ZodType<Prisma.UserListUpdateWithWhereUniqueWithoutAuthorInput> = z.object({
  where: z.lazy(() => UserListWhereUniqueInputSchema),
  data: z.union([ z.lazy(() => UserListUpdateWithoutAuthorInputSchema),z.lazy(() => UserListUncheckedUpdateWithoutAuthorInputSchema) ]),
}).strict();

export const UserListUpdateManyWithWhereWithoutAuthorInputSchema: z.ZodType<Prisma.UserListUpdateManyWithWhereWithoutAuthorInput> = z.object({
  where: z.lazy(() => UserListScalarWhereInputSchema),
  data: z.union([ z.lazy(() => UserListUpdateManyMutationInputSchema),z.lazy(() => UserListUncheckedUpdateManyWithoutAuthorInputSchema) ]),
}).strict();

export const UserListUpsertWithWhereUniqueWithoutUsersInputSchema: z.ZodType<Prisma.UserListUpsertWithWhereUniqueWithoutUsersInput> = z.object({
  where: z.lazy(() => UserListWhereUniqueInputSchema),
  update: z.union([ z.lazy(() => UserListUpdateWithoutUsersInputSchema),z.lazy(() => UserListUncheckedUpdateWithoutUsersInputSchema) ]),
  create: z.union([ z.lazy(() => UserListCreateWithoutUsersInputSchema),z.lazy(() => UserListUncheckedCreateWithoutUsersInputSchema) ]),
}).strict();

export const UserListUpdateWithWhereUniqueWithoutUsersInputSchema: z.ZodType<Prisma.UserListUpdateWithWhereUniqueWithoutUsersInput> = z.object({
  where: z.lazy(() => UserListWhereUniqueInputSchema),
  data: z.union([ z.lazy(() => UserListUpdateWithoutUsersInputSchema),z.lazy(() => UserListUncheckedUpdateWithoutUsersInputSchema) ]),
}).strict();

export const UserListUpdateManyWithWhereWithoutUsersInputSchema: z.ZodType<Prisma.UserListUpdateManyWithWhereWithoutUsersInput> = z.object({
  where: z.lazy(() => UserListScalarWhereInputSchema),
  data: z.union([ z.lazy(() => UserListUpdateManyMutationInputSchema),z.lazy(() => UserListUncheckedUpdateManyWithoutUsersInputSchema) ]),
}).strict();

export const TagUpsertWithWhereUniqueWithoutUserInputSchema: z.ZodType<Prisma.TagUpsertWithWhereUniqueWithoutUserInput> = z.object({
  where: z.lazy(() => TagWhereUniqueInputSchema),
  update: z.union([ z.lazy(() => TagUpdateWithoutUserInputSchema),z.lazy(() => TagUncheckedUpdateWithoutUserInputSchema) ]),
  create: z.union([ z.lazy(() => TagCreateWithoutUserInputSchema),z.lazy(() => TagUncheckedCreateWithoutUserInputSchema) ]),
}).strict();

export const TagUpdateWithWhereUniqueWithoutUserInputSchema: z.ZodType<Prisma.TagUpdateWithWhereUniqueWithoutUserInput> = z.object({
  where: z.lazy(() => TagWhereUniqueInputSchema),
  data: z.union([ z.lazy(() => TagUpdateWithoutUserInputSchema),z.lazy(() => TagUncheckedUpdateWithoutUserInputSchema) ]),
}).strict();

export const TagUpdateManyWithWhereWithoutUserInputSchema: z.ZodType<Prisma.TagUpdateManyWithWhereWithoutUserInput> = z.object({
  where: z.lazy(() => TagScalarWhereInputSchema),
  data: z.union([ z.lazy(() => TagUpdateManyMutationInputSchema),z.lazy(() => TagUncheckedUpdateManyWithoutUserInputSchema) ]),
}).strict();

export const TournamentUpsertWithWhereUniqueWithoutAuthorInputSchema: z.ZodType<Prisma.TournamentUpsertWithWhereUniqueWithoutAuthorInput> = z.object({
  where: z.lazy(() => TournamentWhereUniqueInputSchema),
  update: z.union([ z.lazy(() => TournamentUpdateWithoutAuthorInputSchema),z.lazy(() => TournamentUncheckedUpdateWithoutAuthorInputSchema) ]),
  create: z.union([ z.lazy(() => TournamentCreateWithoutAuthorInputSchema),z.lazy(() => TournamentUncheckedCreateWithoutAuthorInputSchema) ]),
}).strict();

export const TournamentUpdateWithWhereUniqueWithoutAuthorInputSchema: z.ZodType<Prisma.TournamentUpdateWithWhereUniqueWithoutAuthorInput> = z.object({
  where: z.lazy(() => TournamentWhereUniqueInputSchema),
  data: z.union([ z.lazy(() => TournamentUpdateWithoutAuthorInputSchema),z.lazy(() => TournamentUncheckedUpdateWithoutAuthorInputSchema) ]),
}).strict();

export const TournamentUpdateManyWithWhereWithoutAuthorInputSchema: z.ZodType<Prisma.TournamentUpdateManyWithWhereWithoutAuthorInput> = z.object({
  where: z.lazy(() => TournamentScalarWhereInputSchema),
  data: z.union([ z.lazy(() => TournamentUpdateManyMutationInputSchema),z.lazy(() => TournamentUncheckedUpdateManyWithoutAuthorInputSchema) ]),
}).strict();

export const NotificationUpsertWithWhereUniqueWithoutUserInputSchema: z.ZodType<Prisma.NotificationUpsertWithWhereUniqueWithoutUserInput> = z.object({
  where: z.lazy(() => NotificationWhereUniqueInputSchema),
  update: z.union([ z.lazy(() => NotificationUpdateWithoutUserInputSchema),z.lazy(() => NotificationUncheckedUpdateWithoutUserInputSchema) ]),
  create: z.union([ z.lazy(() => NotificationCreateWithoutUserInputSchema),z.lazy(() => NotificationUncheckedCreateWithoutUserInputSchema) ]),
}).strict();

export const NotificationUpdateWithWhereUniqueWithoutUserInputSchema: z.ZodType<Prisma.NotificationUpdateWithWhereUniqueWithoutUserInput> = z.object({
  where: z.lazy(() => NotificationWhereUniqueInputSchema),
  data: z.union([ z.lazy(() => NotificationUpdateWithoutUserInputSchema),z.lazy(() => NotificationUncheckedUpdateWithoutUserInputSchema) ]),
}).strict();

export const NotificationUpdateManyWithWhereWithoutUserInputSchema: z.ZodType<Prisma.NotificationUpdateManyWithWhereWithoutUserInput> = z.object({
  where: z.lazy(() => NotificationScalarWhereInputSchema),
  data: z.union([ z.lazy(() => NotificationUpdateManyMutationInputSchema),z.lazy(() => NotificationUncheckedUpdateManyWithoutUserInputSchema) ]),
}).strict();

export const QuestionOptionUpsertWithWhereUniqueWithoutUserInputSchema: z.ZodType<Prisma.QuestionOptionUpsertWithWhereUniqueWithoutUserInput> = z.object({
  where: z.lazy(() => QuestionOptionWhereUniqueInputSchema),
  update: z.union([ z.lazy(() => QuestionOptionUpdateWithoutUserInputSchema),z.lazy(() => QuestionOptionUncheckedUpdateWithoutUserInputSchema) ]),
  create: z.union([ z.lazy(() => QuestionOptionCreateWithoutUserInputSchema),z.lazy(() => QuestionOptionUncheckedCreateWithoutUserInputSchema) ]),
}).strict();

export const QuestionOptionUpdateWithWhereUniqueWithoutUserInputSchema: z.ZodType<Prisma.QuestionOptionUpdateWithWhereUniqueWithoutUserInput> = z.object({
  where: z.lazy(() => QuestionOptionWhereUniqueInputSchema),
  data: z.union([ z.lazy(() => QuestionOptionUpdateWithoutUserInputSchema),z.lazy(() => QuestionOptionUncheckedUpdateWithoutUserInputSchema) ]),
}).strict();

export const QuestionOptionUpdateManyWithWhereWithoutUserInputSchema: z.ZodType<Prisma.QuestionOptionUpdateManyWithWhereWithoutUserInput> = z.object({
  where: z.lazy(() => QuestionOptionScalarWhereInputSchema),
  data: z.union([ z.lazy(() => QuestionOptionUpdateManyMutationInputSchema),z.lazy(() => QuestionOptionUncheckedUpdateManyWithoutUserInputSchema) ]),
}).strict();

export const AccountUpsertWithWhereUniqueWithoutUserInputSchema: z.ZodType<Prisma.AccountUpsertWithWhereUniqueWithoutUserInput> = z.object({
  where: z.lazy(() => AccountWhereUniqueInputSchema),
  update: z.union([ z.lazy(() => AccountUpdateWithoutUserInputSchema),z.lazy(() => AccountUncheckedUpdateWithoutUserInputSchema) ]),
  create: z.union([ z.lazy(() => AccountCreateWithoutUserInputSchema),z.lazy(() => AccountUncheckedCreateWithoutUserInputSchema) ]),
}).strict();

export const AccountUpdateWithWhereUniqueWithoutUserInputSchema: z.ZodType<Prisma.AccountUpdateWithWhereUniqueWithoutUserInput> = z.object({
  where: z.lazy(() => AccountWhereUniqueInputSchema),
  data: z.union([ z.lazy(() => AccountUpdateWithoutUserInputSchema),z.lazy(() => AccountUncheckedUpdateWithoutUserInputSchema) ]),
}).strict();

export const AccountUpdateManyWithWhereWithoutUserInputSchema: z.ZodType<Prisma.AccountUpdateManyWithWhereWithoutUserInput> = z.object({
  where: z.lazy(() => AccountScalarWhereInputSchema),
  data: z.union([ z.lazy(() => AccountUpdateManyMutationInputSchema),z.lazy(() => AccountUncheckedUpdateManyWithoutUserInputSchema) ]),
}).strict();

export const AccountScalarWhereInputSchema: z.ZodType<Prisma.AccountScalarWhereInput> = z.object({
  AND: z.union([ z.lazy(() => AccountScalarWhereInputSchema),z.lazy(() => AccountScalarWhereInputSchema).array() ]).optional(),
  OR: z.lazy(() => AccountScalarWhereInputSchema).array().optional(),
  NOT: z.union([ z.lazy(() => AccountScalarWhereInputSchema),z.lazy(() => AccountScalarWhereInputSchema).array() ]).optional(),
  id: z.union([ z.lazy(() => StringFilterSchema),z.string() ]).optional(),
  userId: z.union([ z.lazy(() => StringFilterSchema),z.string() ]).optional(),
  type: z.union([ z.lazy(() => StringFilterSchema),z.string() ]).optional(),
  provider: z.union([ z.lazy(() => StringFilterSchema),z.string() ]).optional(),
  providerAccountId: z.union([ z.lazy(() => StringFilterSchema),z.string() ]).optional(),
  refresh_token: z.union([ z.lazy(() => StringNullableFilterSchema),z.string() ]).optional().nullable(),
  access_token: z.union([ z.lazy(() => StringNullableFilterSchema),z.string() ]).optional().nullable(),
  expires_at: z.union([ z.lazy(() => IntNullableFilterSchema),z.number() ]).optional().nullable(),
  token_type: z.union([ z.lazy(() => StringNullableFilterSchema),z.string() ]).optional().nullable(),
  scope: z.union([ z.lazy(() => StringNullableFilterSchema),z.string() ]).optional().nullable(),
  id_token: z.union([ z.lazy(() => StringNullableFilterSchema),z.string() ]).optional().nullable(),
  session_state: z.union([ z.lazy(() => StringNullableFilterSchema),z.string() ]).optional().nullable(),
}).strict();

export const ForecastCreateWithoutProfileInputSchema: z.ZodType<Prisma.ForecastCreateWithoutProfileInput> = z.object({
  createdAt: z.coerce.date().optional(),
  comment: z.string().optional().nullable(),
  forecast: z.union([z.number(),z.string(),z.instanceof(Decimal),z.instanceof(Prisma.Decimal),DecimalJsLikeSchema,]).refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' }),
  option: z.lazy(() => QuestionOptionCreateNestedOneWithoutForecastsInputSchema).optional(),
  question: z.lazy(() => QuestionCreateNestedOneWithoutForecastsInputSchema),
  user: z.lazy(() => UserCreateNestedOneWithoutForecastsInputSchema)
}).strict();

export const ForecastUncheckedCreateWithoutProfileInputSchema: z.ZodType<Prisma.ForecastUncheckedCreateWithoutProfileInput> = z.object({
  id: z.number().int().optional(),
  createdAt: z.coerce.date().optional(),
  comment: z.string().optional().nullable(),
  forecast: z.union([z.number(),z.string(),z.instanceof(Decimal),z.instanceof(Prisma.Decimal),DecimalJsLikeSchema,]).refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' }),
  questionId: z.string(),
  optionId: z.string().optional().nullable(),
  userId: z.string()
}).strict();

export const ForecastCreateOrConnectWithoutProfileInputSchema: z.ZodType<Prisma.ForecastCreateOrConnectWithoutProfileInput> = z.object({
  where: z.lazy(() => ForecastWhereUniqueInputSchema),
  create: z.union([ z.lazy(() => ForecastCreateWithoutProfileInputSchema),z.lazy(() => ForecastUncheckedCreateWithoutProfileInputSchema) ]),
}).strict();

export const ForecastCreateManyProfileInputEnvelopeSchema: z.ZodType<Prisma.ForecastCreateManyProfileInputEnvelope> = z.object({
  data: z.union([ z.lazy(() => ForecastCreateManyProfileInputSchema),z.lazy(() => ForecastCreateManyProfileInputSchema).array() ]),
  skipDuplicates: z.boolean().optional()
}).strict();

export const UserCreateWithoutProfilesInputSchema: z.ZodType<Prisma.UserCreateWithoutProfilesInput> = z.object({
  id: z.string().cuid().optional(),
  name: z.string().optional().nullable(),
  createdAt: z.coerce.date().optional(),
  email: z.string(),
  image: z.string().optional().nullable(),
  staleReminder: z.boolean().optional(),
  unsubscribedFromEmailsAt: z.coerce.date().optional().nullable(),
  apiKey: z.string().optional().nullable(),
  discordUserId: z.string().optional().nullable(),
  emailVerified: z.coerce.date().optional().nullable(),
  forecasts: z.lazy(() => ForecastCreateNestedManyWithoutUserInputSchema).optional(),
  questions: z.lazy(() => QuestionCreateNestedManyWithoutUserInputSchema).optional(),
  questionScores: z.lazy(() => QuestionScoreCreateNestedManyWithoutUserInputSchema).optional(),
  questionsSharedWith: z.lazy(() => QuestionCreateNestedManyWithoutSharedWithInputSchema).optional(),
  comments: z.lazy(() => CommentCreateNestedManyWithoutUserInputSchema).optional(),
  target: z.lazy(() => TargetCreateNestedOneWithoutUserInputSchema).optional(),
  authorOfLists: z.lazy(() => UserListCreateNestedManyWithoutAuthorInputSchema).optional(),
  memberOfLists: z.lazy(() => UserListCreateNestedManyWithoutUsersInputSchema).optional(),
  tags: z.lazy(() => TagCreateNestedManyWithoutUserInputSchema).optional(),
  tournaments: z.lazy(() => TournamentCreateNestedManyWithoutAuthorInputSchema).optional(),
  notifications: z.lazy(() => NotificationCreateNestedManyWithoutUserInputSchema).optional(),
  questionOptions: z.lazy(() => QuestionOptionCreateNestedManyWithoutUserInputSchema).optional(),
  accounts: z.lazy(() => AccountCreateNestedManyWithoutUserInputSchema).optional()
}).strict();

export const UserUncheckedCreateWithoutProfilesInputSchema: z.ZodType<Prisma.UserUncheckedCreateWithoutProfilesInput> = z.object({
  id: z.string().cuid().optional(),
  name: z.string().optional().nullable(),
  createdAt: z.coerce.date().optional(),
  email: z.string(),
  image: z.string().optional().nullable(),
  staleReminder: z.boolean().optional(),
  unsubscribedFromEmailsAt: z.coerce.date().optional().nullable(),
  apiKey: z.string().optional().nullable(),
  discordUserId: z.string().optional().nullable(),
  emailVerified: z.coerce.date().optional().nullable(),
  forecasts: z.lazy(() => ForecastUncheckedCreateNestedManyWithoutUserInputSchema).optional(),
  questions: z.lazy(() => QuestionUncheckedCreateNestedManyWithoutUserInputSchema).optional(),
  questionScores: z.lazy(() => QuestionScoreUncheckedCreateNestedManyWithoutUserInputSchema).optional(),
  questionsSharedWith: z.lazy(() => QuestionUncheckedCreateNestedManyWithoutSharedWithInputSchema).optional(),
  comments: z.lazy(() => CommentUncheckedCreateNestedManyWithoutUserInputSchema).optional(),
  target: z.lazy(() => TargetUncheckedCreateNestedOneWithoutUserInputSchema).optional(),
  authorOfLists: z.lazy(() => UserListUncheckedCreateNestedManyWithoutAuthorInputSchema).optional(),
  memberOfLists: z.lazy(() => UserListUncheckedCreateNestedManyWithoutUsersInputSchema).optional(),
  tags: z.lazy(() => TagUncheckedCreateNestedManyWithoutUserInputSchema).optional(),
  tournaments: z.lazy(() => TournamentUncheckedCreateNestedManyWithoutAuthorInputSchema).optional(),
  notifications: z.lazy(() => NotificationUncheckedCreateNestedManyWithoutUserInputSchema).optional(),
  questionOptions: z.lazy(() => QuestionOptionUncheckedCreateNestedManyWithoutUserInputSchema).optional(),
  accounts: z.lazy(() => AccountUncheckedCreateNestedManyWithoutUserInputSchema).optional()
}).strict();

export const UserCreateOrConnectWithoutProfilesInputSchema: z.ZodType<Prisma.UserCreateOrConnectWithoutProfilesInput> = z.object({
  where: z.lazy(() => UserWhereUniqueInputSchema),
  create: z.union([ z.lazy(() => UserCreateWithoutProfilesInputSchema),z.lazy(() => UserUncheckedCreateWithoutProfilesInputSchema) ]),
}).strict();

export const QuestionCreateWithoutProfileInputSchema: z.ZodType<Prisma.QuestionCreateWithoutProfileInput> = z.object({
  id: z.string().cuid().optional(),
  createdAt: z.coerce.date().optional(),
  comment: z.string().optional().nullable(),
  title: z.string(),
  type: z.lazy(() => QuestionTypeSchema).optional(),
  resolveBy: z.coerce.date(),
  resolved: z.boolean().optional(),
  pingedForResolution: z.boolean().optional(),
  resolution: z.lazy(() => ResolutionSchema).optional().nullable(),
  resolvedAt: z.coerce.date().optional().nullable(),
  notes: z.string().optional().nullable(),
  hideForecastsUntil: z.coerce.date().optional().nullable(),
  hideForecastsUntilPrediction: z.boolean().optional().nullable(),
  sharedPublicly: z.boolean().optional(),
  unlisted: z.boolean().optional(),
  exclusiveAnswers: z.boolean().optional().nullable(),
  options: z.lazy(() => QuestionOptionCreateNestedManyWithoutQuestionInputSchema).optional(),
  forecasts: z.lazy(() => ForecastCreateNestedManyWithoutQuestionInputSchema).optional(),
  pingResolveMessages: z.lazy(() => PingSlackMessageCreateNestedManyWithoutQuestionInputSchema).optional(),
  user: z.lazy(() => UserCreateNestedOneWithoutQuestionsInputSchema),
  sharedWith: z.lazy(() => UserCreateNestedManyWithoutQuestionsSharedWithInputSchema).optional(),
  sharedWithLists: z.lazy(() => UserListCreateNestedManyWithoutQuestionsInputSchema).optional(),
  questionScores: z.lazy(() => QuestionScoreCreateNestedManyWithoutQuestionInputSchema).optional(),
  questionMessages: z.lazy(() => QuestionSlackMessageCreateNestedManyWithoutQuestionInputSchema).optional(),
  resolutionMessages: z.lazy(() => ResolutionSlackMessageCreateNestedManyWithoutQuestionInputSchema).optional(),
  comments: z.lazy(() => CommentCreateNestedManyWithoutQuestionInputSchema).optional(),
  tags: z.lazy(() => TagCreateNestedManyWithoutQuestionsInputSchema).optional(),
  tournaments: z.lazy(() => TournamentCreateNestedManyWithoutQuestionsInputSchema).optional(),
  notifications: z.lazy(() => NotificationCreateNestedManyWithoutQuestionInputSchema).optional()
}).strict();

export const QuestionUncheckedCreateWithoutProfileInputSchema: z.ZodType<Prisma.QuestionUncheckedCreateWithoutProfileInput> = z.object({
  id: z.string().cuid().optional(),
  createdAt: z.coerce.date().optional(),
  comment: z.string().optional().nullable(),
  title: z.string(),
  type: z.lazy(() => QuestionTypeSchema).optional(),
  resolveBy: z.coerce.date(),
  resolved: z.boolean().optional(),
  pingedForResolution: z.boolean().optional(),
  resolution: z.lazy(() => ResolutionSchema).optional().nullable(),
  resolvedAt: z.coerce.date().optional().nullable(),
  notes: z.string().optional().nullable(),
  hideForecastsUntil: z.coerce.date().optional().nullable(),
  hideForecastsUntilPrediction: z.boolean().optional().nullable(),
  userId: z.string(),
  sharedPublicly: z.boolean().optional(),
  unlisted: z.boolean().optional(),
  exclusiveAnswers: z.boolean().optional().nullable(),
  options: z.lazy(() => QuestionOptionUncheckedCreateNestedManyWithoutQuestionInputSchema).optional(),
  forecasts: z.lazy(() => ForecastUncheckedCreateNestedManyWithoutQuestionInputSchema).optional(),
  pingResolveMessages: z.lazy(() => PingSlackMessageUncheckedCreateNestedManyWithoutQuestionInputSchema).optional(),
  sharedWith: z.lazy(() => UserUncheckedCreateNestedManyWithoutQuestionsSharedWithInputSchema).optional(),
  sharedWithLists: z.lazy(() => UserListUncheckedCreateNestedManyWithoutQuestionsInputSchema).optional(),
  questionScores: z.lazy(() => QuestionScoreUncheckedCreateNestedManyWithoutQuestionInputSchema).optional(),
  questionMessages: z.lazy(() => QuestionSlackMessageUncheckedCreateNestedManyWithoutQuestionInputSchema).optional(),
  resolutionMessages: z.lazy(() => ResolutionSlackMessageUncheckedCreateNestedManyWithoutQuestionInputSchema).optional(),
  comments: z.lazy(() => CommentUncheckedCreateNestedManyWithoutQuestionInputSchema).optional(),
  tags: z.lazy(() => TagUncheckedCreateNestedManyWithoutQuestionsInputSchema).optional(),
  tournaments: z.lazy(() => TournamentUncheckedCreateNestedManyWithoutQuestionsInputSchema).optional(),
  notifications: z.lazy(() => NotificationUncheckedCreateNestedManyWithoutQuestionInputSchema).optional()
}).strict();

export const QuestionCreateOrConnectWithoutProfileInputSchema: z.ZodType<Prisma.QuestionCreateOrConnectWithoutProfileInput> = z.object({
  where: z.lazy(() => QuestionWhereUniqueInputSchema),
  create: z.union([ z.lazy(() => QuestionCreateWithoutProfileInputSchema),z.lazy(() => QuestionUncheckedCreateWithoutProfileInputSchema) ]),
}).strict();

export const QuestionCreateManyProfileInputEnvelopeSchema: z.ZodType<Prisma.QuestionCreateManyProfileInputEnvelope> = z.object({
  data: z.union([ z.lazy(() => QuestionCreateManyProfileInputSchema),z.lazy(() => QuestionCreateManyProfileInputSchema).array() ]),
  skipDuplicates: z.boolean().optional()
}).strict();

export const ResolutionSlackMessageCreateWithoutProfileInputSchema: z.ZodType<Prisma.ResolutionSlackMessageCreateWithoutProfileInput> = z.object({
  message: z.lazy(() => SlackMessageCreateNestedOneWithoutResolutionSlackMessageInputSchema),
  question: z.lazy(() => QuestionCreateNestedOneWithoutResolutionMessagesInputSchema)
}).strict();

export const ResolutionSlackMessageUncheckedCreateWithoutProfileInputSchema: z.ZodType<Prisma.ResolutionSlackMessageUncheckedCreateWithoutProfileInput> = z.object({
  id: z.number().int().optional(),
  questionId: z.string(),
  detailsId: z.number().int()
}).strict();

export const ResolutionSlackMessageCreateOrConnectWithoutProfileInputSchema: z.ZodType<Prisma.ResolutionSlackMessageCreateOrConnectWithoutProfileInput> = z.object({
  where: z.lazy(() => ResolutionSlackMessageWhereUniqueInputSchema),
  create: z.union([ z.lazy(() => ResolutionSlackMessageCreateWithoutProfileInputSchema),z.lazy(() => ResolutionSlackMessageUncheckedCreateWithoutProfileInputSchema) ]),
}).strict();

export const ResolutionSlackMessageCreateManyProfileInputEnvelopeSchema: z.ZodType<Prisma.ResolutionSlackMessageCreateManyProfileInputEnvelope> = z.object({
  data: z.union([ z.lazy(() => ResolutionSlackMessageCreateManyProfileInputSchema),z.lazy(() => ResolutionSlackMessageCreateManyProfileInputSchema).array() ]),
  skipDuplicates: z.boolean().optional()
}).strict();

export const TargetCreateWithoutProfileInputSchema: z.ZodType<Prisma.TargetCreateWithoutProfileInput> = z.object({
  type: z.lazy(() => TargetTypeSchema),
  goal: z.number().int(),
  lastFailedAt: z.coerce.date().optional(),
  notifyOn: z.lazy(() => DayOfTheWeekSchema),
  lastNotified: z.coerce.date().optional(),
  user: z.lazy(() => UserCreateNestedOneWithoutTargetInputSchema)
}).strict();

export const TargetUncheckedCreateWithoutProfileInputSchema: z.ZodType<Prisma.TargetUncheckedCreateWithoutProfileInput> = z.object({
  id: z.number().int().optional(),
  userId: z.string(),
  type: z.lazy(() => TargetTypeSchema),
  goal: z.number().int(),
  lastFailedAt: z.coerce.date().optional(),
  notifyOn: z.lazy(() => DayOfTheWeekSchema),
  lastNotified: z.coerce.date().optional()
}).strict();

export const TargetCreateOrConnectWithoutProfileInputSchema: z.ZodType<Prisma.TargetCreateOrConnectWithoutProfileInput> = z.object({
  where: z.lazy(() => TargetWhereUniqueInputSchema),
  create: z.union([ z.lazy(() => TargetCreateWithoutProfileInputSchema),z.lazy(() => TargetUncheckedCreateWithoutProfileInputSchema) ]),
}).strict();

export const ForecastUpsertWithWhereUniqueWithoutProfileInputSchema: z.ZodType<Prisma.ForecastUpsertWithWhereUniqueWithoutProfileInput> = z.object({
  where: z.lazy(() => ForecastWhereUniqueInputSchema),
  update: z.union([ z.lazy(() => ForecastUpdateWithoutProfileInputSchema),z.lazy(() => ForecastUncheckedUpdateWithoutProfileInputSchema) ]),
  create: z.union([ z.lazy(() => ForecastCreateWithoutProfileInputSchema),z.lazy(() => ForecastUncheckedCreateWithoutProfileInputSchema) ]),
}).strict();

export const ForecastUpdateWithWhereUniqueWithoutProfileInputSchema: z.ZodType<Prisma.ForecastUpdateWithWhereUniqueWithoutProfileInput> = z.object({
  where: z.lazy(() => ForecastWhereUniqueInputSchema),
  data: z.union([ z.lazy(() => ForecastUpdateWithoutProfileInputSchema),z.lazy(() => ForecastUncheckedUpdateWithoutProfileInputSchema) ]),
}).strict();

export const ForecastUpdateManyWithWhereWithoutProfileInputSchema: z.ZodType<Prisma.ForecastUpdateManyWithWhereWithoutProfileInput> = z.object({
  where: z.lazy(() => ForecastScalarWhereInputSchema),
  data: z.union([ z.lazy(() => ForecastUpdateManyMutationInputSchema),z.lazy(() => ForecastUncheckedUpdateManyWithoutProfileInputSchema) ]),
}).strict();

export const UserUpsertWithoutProfilesInputSchema: z.ZodType<Prisma.UserUpsertWithoutProfilesInput> = z.object({
  update: z.union([ z.lazy(() => UserUpdateWithoutProfilesInputSchema),z.lazy(() => UserUncheckedUpdateWithoutProfilesInputSchema) ]),
  create: z.union([ z.lazy(() => UserCreateWithoutProfilesInputSchema),z.lazy(() => UserUncheckedCreateWithoutProfilesInputSchema) ]),
  where: z.lazy(() => UserWhereInputSchema).optional()
}).strict();

export const UserUpdateToOneWithWhereWithoutProfilesInputSchema: z.ZodType<Prisma.UserUpdateToOneWithWhereWithoutProfilesInput> = z.object({
  where: z.lazy(() => UserWhereInputSchema).optional(),
  data: z.union([ z.lazy(() => UserUpdateWithoutProfilesInputSchema),z.lazy(() => UserUncheckedUpdateWithoutProfilesInputSchema) ]),
}).strict();

export const UserUpdateWithoutProfilesInputSchema: z.ZodType<Prisma.UserUpdateWithoutProfilesInput> = z.object({
  id: z.union([ z.string().cuid(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  name: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  createdAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  email: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  image: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  staleReminder: z.union([ z.boolean(),z.lazy(() => BoolFieldUpdateOperationsInputSchema) ]).optional(),
  unsubscribedFromEmailsAt: z.union([ z.coerce.date(),z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  apiKey: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  discordUserId: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  emailVerified: z.union([ z.coerce.date(),z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  forecasts: z.lazy(() => ForecastUpdateManyWithoutUserNestedInputSchema).optional(),
  questions: z.lazy(() => QuestionUpdateManyWithoutUserNestedInputSchema).optional(),
  questionScores: z.lazy(() => QuestionScoreUpdateManyWithoutUserNestedInputSchema).optional(),
  questionsSharedWith: z.lazy(() => QuestionUpdateManyWithoutSharedWithNestedInputSchema).optional(),
  comments: z.lazy(() => CommentUpdateManyWithoutUserNestedInputSchema).optional(),
  target: z.lazy(() => TargetUpdateOneWithoutUserNestedInputSchema).optional(),
  authorOfLists: z.lazy(() => UserListUpdateManyWithoutAuthorNestedInputSchema).optional(),
  memberOfLists: z.lazy(() => UserListUpdateManyWithoutUsersNestedInputSchema).optional(),
  tags: z.lazy(() => TagUpdateManyWithoutUserNestedInputSchema).optional(),
  tournaments: z.lazy(() => TournamentUpdateManyWithoutAuthorNestedInputSchema).optional(),
  notifications: z.lazy(() => NotificationUpdateManyWithoutUserNestedInputSchema).optional(),
  questionOptions: z.lazy(() => QuestionOptionUpdateManyWithoutUserNestedInputSchema).optional(),
  accounts: z.lazy(() => AccountUpdateManyWithoutUserNestedInputSchema).optional()
}).strict();

export const UserUncheckedUpdateWithoutProfilesInputSchema: z.ZodType<Prisma.UserUncheckedUpdateWithoutProfilesInput> = z.object({
  id: z.union([ z.string().cuid(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  name: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  createdAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  email: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  image: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  staleReminder: z.union([ z.boolean(),z.lazy(() => BoolFieldUpdateOperationsInputSchema) ]).optional(),
  unsubscribedFromEmailsAt: z.union([ z.coerce.date(),z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  apiKey: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  discordUserId: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  emailVerified: z.union([ z.coerce.date(),z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  forecasts: z.lazy(() => ForecastUncheckedUpdateManyWithoutUserNestedInputSchema).optional(),
  questions: z.lazy(() => QuestionUncheckedUpdateManyWithoutUserNestedInputSchema).optional(),
  questionScores: z.lazy(() => QuestionScoreUncheckedUpdateManyWithoutUserNestedInputSchema).optional(),
  questionsSharedWith: z.lazy(() => QuestionUncheckedUpdateManyWithoutSharedWithNestedInputSchema).optional(),
  comments: z.lazy(() => CommentUncheckedUpdateManyWithoutUserNestedInputSchema).optional(),
  target: z.lazy(() => TargetUncheckedUpdateOneWithoutUserNestedInputSchema).optional(),
  authorOfLists: z.lazy(() => UserListUncheckedUpdateManyWithoutAuthorNestedInputSchema).optional(),
  memberOfLists: z.lazy(() => UserListUncheckedUpdateManyWithoutUsersNestedInputSchema).optional(),
  tags: z.lazy(() => TagUncheckedUpdateManyWithoutUserNestedInputSchema).optional(),
  tournaments: z.lazy(() => TournamentUncheckedUpdateManyWithoutAuthorNestedInputSchema).optional(),
  notifications: z.lazy(() => NotificationUncheckedUpdateManyWithoutUserNestedInputSchema).optional(),
  questionOptions: z.lazy(() => QuestionOptionUncheckedUpdateManyWithoutUserNestedInputSchema).optional(),
  accounts: z.lazy(() => AccountUncheckedUpdateManyWithoutUserNestedInputSchema).optional()
}).strict();

export const QuestionUpsertWithWhereUniqueWithoutProfileInputSchema: z.ZodType<Prisma.QuestionUpsertWithWhereUniqueWithoutProfileInput> = z.object({
  where: z.lazy(() => QuestionWhereUniqueInputSchema),
  update: z.union([ z.lazy(() => QuestionUpdateWithoutProfileInputSchema),z.lazy(() => QuestionUncheckedUpdateWithoutProfileInputSchema) ]),
  create: z.union([ z.lazy(() => QuestionCreateWithoutProfileInputSchema),z.lazy(() => QuestionUncheckedCreateWithoutProfileInputSchema) ]),
}).strict();

export const QuestionUpdateWithWhereUniqueWithoutProfileInputSchema: z.ZodType<Prisma.QuestionUpdateWithWhereUniqueWithoutProfileInput> = z.object({
  where: z.lazy(() => QuestionWhereUniqueInputSchema),
  data: z.union([ z.lazy(() => QuestionUpdateWithoutProfileInputSchema),z.lazy(() => QuestionUncheckedUpdateWithoutProfileInputSchema) ]),
}).strict();

export const QuestionUpdateManyWithWhereWithoutProfileInputSchema: z.ZodType<Prisma.QuestionUpdateManyWithWhereWithoutProfileInput> = z.object({
  where: z.lazy(() => QuestionScalarWhereInputSchema),
  data: z.union([ z.lazy(() => QuestionUpdateManyMutationInputSchema),z.lazy(() => QuestionUncheckedUpdateManyWithoutProfileInputSchema) ]),
}).strict();

export const ResolutionSlackMessageUpsertWithWhereUniqueWithoutProfileInputSchema: z.ZodType<Prisma.ResolutionSlackMessageUpsertWithWhereUniqueWithoutProfileInput> = z.object({
  where: z.lazy(() => ResolutionSlackMessageWhereUniqueInputSchema),
  update: z.union([ z.lazy(() => ResolutionSlackMessageUpdateWithoutProfileInputSchema),z.lazy(() => ResolutionSlackMessageUncheckedUpdateWithoutProfileInputSchema) ]),
  create: z.union([ z.lazy(() => ResolutionSlackMessageCreateWithoutProfileInputSchema),z.lazy(() => ResolutionSlackMessageUncheckedCreateWithoutProfileInputSchema) ]),
}).strict();

export const ResolutionSlackMessageUpdateWithWhereUniqueWithoutProfileInputSchema: z.ZodType<Prisma.ResolutionSlackMessageUpdateWithWhereUniqueWithoutProfileInput> = z.object({
  where: z.lazy(() => ResolutionSlackMessageWhereUniqueInputSchema),
  data: z.union([ z.lazy(() => ResolutionSlackMessageUpdateWithoutProfileInputSchema),z.lazy(() => ResolutionSlackMessageUncheckedUpdateWithoutProfileInputSchema) ]),
}).strict();

export const ResolutionSlackMessageUpdateManyWithWhereWithoutProfileInputSchema: z.ZodType<Prisma.ResolutionSlackMessageUpdateManyWithWhereWithoutProfileInput> = z.object({
  where: z.lazy(() => ResolutionSlackMessageScalarWhereInputSchema),
  data: z.union([ z.lazy(() => ResolutionSlackMessageUpdateManyMutationInputSchema),z.lazy(() => ResolutionSlackMessageUncheckedUpdateManyWithoutProfileInputSchema) ]),
}).strict();

export const TargetUpsertWithoutProfileInputSchema: z.ZodType<Prisma.TargetUpsertWithoutProfileInput> = z.object({
  update: z.union([ z.lazy(() => TargetUpdateWithoutProfileInputSchema),z.lazy(() => TargetUncheckedUpdateWithoutProfileInputSchema) ]),
  create: z.union([ z.lazy(() => TargetCreateWithoutProfileInputSchema),z.lazy(() => TargetUncheckedCreateWithoutProfileInputSchema) ]),
  where: z.lazy(() => TargetWhereInputSchema).optional()
}).strict();

export const TargetUpdateToOneWithWhereWithoutProfileInputSchema: z.ZodType<Prisma.TargetUpdateToOneWithWhereWithoutProfileInput> = z.object({
  where: z.lazy(() => TargetWhereInputSchema).optional(),
  data: z.union([ z.lazy(() => TargetUpdateWithoutProfileInputSchema),z.lazy(() => TargetUncheckedUpdateWithoutProfileInputSchema) ]),
}).strict();

export const TargetUpdateWithoutProfileInputSchema: z.ZodType<Prisma.TargetUpdateWithoutProfileInput> = z.object({
  type: z.union([ z.lazy(() => TargetTypeSchema),z.lazy(() => EnumTargetTypeFieldUpdateOperationsInputSchema) ]).optional(),
  goal: z.union([ z.number().int(),z.lazy(() => IntFieldUpdateOperationsInputSchema) ]).optional(),
  lastFailedAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  notifyOn: z.union([ z.lazy(() => DayOfTheWeekSchema),z.lazy(() => EnumDayOfTheWeekFieldUpdateOperationsInputSchema) ]).optional(),
  lastNotified: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  user: z.lazy(() => UserUpdateOneRequiredWithoutTargetNestedInputSchema).optional()
}).strict();

export const TargetUncheckedUpdateWithoutProfileInputSchema: z.ZodType<Prisma.TargetUncheckedUpdateWithoutProfileInput> = z.object({
  id: z.union([ z.number().int(),z.lazy(() => IntFieldUpdateOperationsInputSchema) ]).optional(),
  userId: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  type: z.union([ z.lazy(() => TargetTypeSchema),z.lazy(() => EnumTargetTypeFieldUpdateOperationsInputSchema) ]).optional(),
  goal: z.union([ z.number().int(),z.lazy(() => IntFieldUpdateOperationsInputSchema) ]).optional(),
  lastFailedAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  notifyOn: z.union([ z.lazy(() => DayOfTheWeekSchema),z.lazy(() => EnumDayOfTheWeekFieldUpdateOperationsInputSchema) ]).optional(),
  lastNotified: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
}).strict();

export const UserCreateWithoutTargetInputSchema: z.ZodType<Prisma.UserCreateWithoutTargetInput> = z.object({
  id: z.string().cuid().optional(),
  name: z.string().optional().nullable(),
  createdAt: z.coerce.date().optional(),
  email: z.string(),
  image: z.string().optional().nullable(),
  staleReminder: z.boolean().optional(),
  unsubscribedFromEmailsAt: z.coerce.date().optional().nullable(),
  apiKey: z.string().optional().nullable(),
  discordUserId: z.string().optional().nullable(),
  emailVerified: z.coerce.date().optional().nullable(),
  forecasts: z.lazy(() => ForecastCreateNestedManyWithoutUserInputSchema).optional(),
  profiles: z.lazy(() => ProfileCreateNestedManyWithoutUserInputSchema).optional(),
  questions: z.lazy(() => QuestionCreateNestedManyWithoutUserInputSchema).optional(),
  questionScores: z.lazy(() => QuestionScoreCreateNestedManyWithoutUserInputSchema).optional(),
  questionsSharedWith: z.lazy(() => QuestionCreateNestedManyWithoutSharedWithInputSchema).optional(),
  comments: z.lazy(() => CommentCreateNestedManyWithoutUserInputSchema).optional(),
  authorOfLists: z.lazy(() => UserListCreateNestedManyWithoutAuthorInputSchema).optional(),
  memberOfLists: z.lazy(() => UserListCreateNestedManyWithoutUsersInputSchema).optional(),
  tags: z.lazy(() => TagCreateNestedManyWithoutUserInputSchema).optional(),
  tournaments: z.lazy(() => TournamentCreateNestedManyWithoutAuthorInputSchema).optional(),
  notifications: z.lazy(() => NotificationCreateNestedManyWithoutUserInputSchema).optional(),
  questionOptions: z.lazy(() => QuestionOptionCreateNestedManyWithoutUserInputSchema).optional(),
  accounts: z.lazy(() => AccountCreateNestedManyWithoutUserInputSchema).optional()
}).strict();

export const UserUncheckedCreateWithoutTargetInputSchema: z.ZodType<Prisma.UserUncheckedCreateWithoutTargetInput> = z.object({
  id: z.string().cuid().optional(),
  name: z.string().optional().nullable(),
  createdAt: z.coerce.date().optional(),
  email: z.string(),
  image: z.string().optional().nullable(),
  staleReminder: z.boolean().optional(),
  unsubscribedFromEmailsAt: z.coerce.date().optional().nullable(),
  apiKey: z.string().optional().nullable(),
  discordUserId: z.string().optional().nullable(),
  emailVerified: z.coerce.date().optional().nullable(),
  forecasts: z.lazy(() => ForecastUncheckedCreateNestedManyWithoutUserInputSchema).optional(),
  profiles: z.lazy(() => ProfileUncheckedCreateNestedManyWithoutUserInputSchema).optional(),
  questions: z.lazy(() => QuestionUncheckedCreateNestedManyWithoutUserInputSchema).optional(),
  questionScores: z.lazy(() => QuestionScoreUncheckedCreateNestedManyWithoutUserInputSchema).optional(),
  questionsSharedWith: z.lazy(() => QuestionUncheckedCreateNestedManyWithoutSharedWithInputSchema).optional(),
  comments: z.lazy(() => CommentUncheckedCreateNestedManyWithoutUserInputSchema).optional(),
  authorOfLists: z.lazy(() => UserListUncheckedCreateNestedManyWithoutAuthorInputSchema).optional(),
  memberOfLists: z.lazy(() => UserListUncheckedCreateNestedManyWithoutUsersInputSchema).optional(),
  tags: z.lazy(() => TagUncheckedCreateNestedManyWithoutUserInputSchema).optional(),
  tournaments: z.lazy(() => TournamentUncheckedCreateNestedManyWithoutAuthorInputSchema).optional(),
  notifications: z.lazy(() => NotificationUncheckedCreateNestedManyWithoutUserInputSchema).optional(),
  questionOptions: z.lazy(() => QuestionOptionUncheckedCreateNestedManyWithoutUserInputSchema).optional(),
  accounts: z.lazy(() => AccountUncheckedCreateNestedManyWithoutUserInputSchema).optional()
}).strict();

export const UserCreateOrConnectWithoutTargetInputSchema: z.ZodType<Prisma.UserCreateOrConnectWithoutTargetInput> = z.object({
  where: z.lazy(() => UserWhereUniqueInputSchema),
  create: z.union([ z.lazy(() => UserCreateWithoutTargetInputSchema),z.lazy(() => UserUncheckedCreateWithoutTargetInputSchema) ]),
}).strict();

export const ProfileCreateWithoutTargetInputSchema: z.ZodType<Prisma.ProfileCreateWithoutTargetInput> = z.object({
  createdAt: z.coerce.date().optional(),
  slackId: z.string().optional().nullable(),
  slackTeamId: z.string().optional().nullable(),
  forecasts: z.lazy(() => ForecastCreateNestedManyWithoutProfileInputSchema).optional(),
  user: z.lazy(() => UserCreateNestedOneWithoutProfilesInputSchema),
  questions: z.lazy(() => QuestionCreateNestedManyWithoutProfileInputSchema).optional(),
  resolutionMessages: z.lazy(() => ResolutionSlackMessageCreateNestedManyWithoutProfileInputSchema).optional()
}).strict();

export const ProfileUncheckedCreateWithoutTargetInputSchema: z.ZodType<Prisma.ProfileUncheckedCreateWithoutTargetInput> = z.object({
  id: z.number().int().optional(),
  createdAt: z.coerce.date().optional(),
  slackId: z.string().optional().nullable(),
  slackTeamId: z.string().optional().nullable(),
  userId: z.string(),
  forecasts: z.lazy(() => ForecastUncheckedCreateNestedManyWithoutProfileInputSchema).optional(),
  questions: z.lazy(() => QuestionUncheckedCreateNestedManyWithoutProfileInputSchema).optional(),
  resolutionMessages: z.lazy(() => ResolutionSlackMessageUncheckedCreateNestedManyWithoutProfileInputSchema).optional()
}).strict();

export const ProfileCreateOrConnectWithoutTargetInputSchema: z.ZodType<Prisma.ProfileCreateOrConnectWithoutTargetInput> = z.object({
  where: z.lazy(() => ProfileWhereUniqueInputSchema),
  create: z.union([ z.lazy(() => ProfileCreateWithoutTargetInputSchema),z.lazy(() => ProfileUncheckedCreateWithoutTargetInputSchema) ]),
}).strict();

export const UserUpsertWithoutTargetInputSchema: z.ZodType<Prisma.UserUpsertWithoutTargetInput> = z.object({
  update: z.union([ z.lazy(() => UserUpdateWithoutTargetInputSchema),z.lazy(() => UserUncheckedUpdateWithoutTargetInputSchema) ]),
  create: z.union([ z.lazy(() => UserCreateWithoutTargetInputSchema),z.lazy(() => UserUncheckedCreateWithoutTargetInputSchema) ]),
  where: z.lazy(() => UserWhereInputSchema).optional()
}).strict();

export const UserUpdateToOneWithWhereWithoutTargetInputSchema: z.ZodType<Prisma.UserUpdateToOneWithWhereWithoutTargetInput> = z.object({
  where: z.lazy(() => UserWhereInputSchema).optional(),
  data: z.union([ z.lazy(() => UserUpdateWithoutTargetInputSchema),z.lazy(() => UserUncheckedUpdateWithoutTargetInputSchema) ]),
}).strict();

export const UserUpdateWithoutTargetInputSchema: z.ZodType<Prisma.UserUpdateWithoutTargetInput> = z.object({
  id: z.union([ z.string().cuid(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  name: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  createdAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  email: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  image: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  staleReminder: z.union([ z.boolean(),z.lazy(() => BoolFieldUpdateOperationsInputSchema) ]).optional(),
  unsubscribedFromEmailsAt: z.union([ z.coerce.date(),z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  apiKey: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  discordUserId: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  emailVerified: z.union([ z.coerce.date(),z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  forecasts: z.lazy(() => ForecastUpdateManyWithoutUserNestedInputSchema).optional(),
  profiles: z.lazy(() => ProfileUpdateManyWithoutUserNestedInputSchema).optional(),
  questions: z.lazy(() => QuestionUpdateManyWithoutUserNestedInputSchema).optional(),
  questionScores: z.lazy(() => QuestionScoreUpdateManyWithoutUserNestedInputSchema).optional(),
  questionsSharedWith: z.lazy(() => QuestionUpdateManyWithoutSharedWithNestedInputSchema).optional(),
  comments: z.lazy(() => CommentUpdateManyWithoutUserNestedInputSchema).optional(),
  authorOfLists: z.lazy(() => UserListUpdateManyWithoutAuthorNestedInputSchema).optional(),
  memberOfLists: z.lazy(() => UserListUpdateManyWithoutUsersNestedInputSchema).optional(),
  tags: z.lazy(() => TagUpdateManyWithoutUserNestedInputSchema).optional(),
  tournaments: z.lazy(() => TournamentUpdateManyWithoutAuthorNestedInputSchema).optional(),
  notifications: z.lazy(() => NotificationUpdateManyWithoutUserNestedInputSchema).optional(),
  questionOptions: z.lazy(() => QuestionOptionUpdateManyWithoutUserNestedInputSchema).optional(),
  accounts: z.lazy(() => AccountUpdateManyWithoutUserNestedInputSchema).optional()
}).strict();

export const UserUncheckedUpdateWithoutTargetInputSchema: z.ZodType<Prisma.UserUncheckedUpdateWithoutTargetInput> = z.object({
  id: z.union([ z.string().cuid(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  name: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  createdAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  email: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  image: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  staleReminder: z.union([ z.boolean(),z.lazy(() => BoolFieldUpdateOperationsInputSchema) ]).optional(),
  unsubscribedFromEmailsAt: z.union([ z.coerce.date(),z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  apiKey: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  discordUserId: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  emailVerified: z.union([ z.coerce.date(),z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  forecasts: z.lazy(() => ForecastUncheckedUpdateManyWithoutUserNestedInputSchema).optional(),
  profiles: z.lazy(() => ProfileUncheckedUpdateManyWithoutUserNestedInputSchema).optional(),
  questions: z.lazy(() => QuestionUncheckedUpdateManyWithoutUserNestedInputSchema).optional(),
  questionScores: z.lazy(() => QuestionScoreUncheckedUpdateManyWithoutUserNestedInputSchema).optional(),
  questionsSharedWith: z.lazy(() => QuestionUncheckedUpdateManyWithoutSharedWithNestedInputSchema).optional(),
  comments: z.lazy(() => CommentUncheckedUpdateManyWithoutUserNestedInputSchema).optional(),
  authorOfLists: z.lazy(() => UserListUncheckedUpdateManyWithoutAuthorNestedInputSchema).optional(),
  memberOfLists: z.lazy(() => UserListUncheckedUpdateManyWithoutUsersNestedInputSchema).optional(),
  tags: z.lazy(() => TagUncheckedUpdateManyWithoutUserNestedInputSchema).optional(),
  tournaments: z.lazy(() => TournamentUncheckedUpdateManyWithoutAuthorNestedInputSchema).optional(),
  notifications: z.lazy(() => NotificationUncheckedUpdateManyWithoutUserNestedInputSchema).optional(),
  questionOptions: z.lazy(() => QuestionOptionUncheckedUpdateManyWithoutUserNestedInputSchema).optional(),
  accounts: z.lazy(() => AccountUncheckedUpdateManyWithoutUserNestedInputSchema).optional()
}).strict();

export const ProfileUpsertWithoutTargetInputSchema: z.ZodType<Prisma.ProfileUpsertWithoutTargetInput> = z.object({
  update: z.union([ z.lazy(() => ProfileUpdateWithoutTargetInputSchema),z.lazy(() => ProfileUncheckedUpdateWithoutTargetInputSchema) ]),
  create: z.union([ z.lazy(() => ProfileCreateWithoutTargetInputSchema),z.lazy(() => ProfileUncheckedCreateWithoutTargetInputSchema) ]),
  where: z.lazy(() => ProfileWhereInputSchema).optional()
}).strict();

export const ProfileUpdateToOneWithWhereWithoutTargetInputSchema: z.ZodType<Prisma.ProfileUpdateToOneWithWhereWithoutTargetInput> = z.object({
  where: z.lazy(() => ProfileWhereInputSchema).optional(),
  data: z.union([ z.lazy(() => ProfileUpdateWithoutTargetInputSchema),z.lazy(() => ProfileUncheckedUpdateWithoutTargetInputSchema) ]),
}).strict();

export const ProfileUpdateWithoutTargetInputSchema: z.ZodType<Prisma.ProfileUpdateWithoutTargetInput> = z.object({
  createdAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  slackId: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  slackTeamId: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  forecasts: z.lazy(() => ForecastUpdateManyWithoutProfileNestedInputSchema).optional(),
  user: z.lazy(() => UserUpdateOneRequiredWithoutProfilesNestedInputSchema).optional(),
  questions: z.lazy(() => QuestionUpdateManyWithoutProfileNestedInputSchema).optional(),
  resolutionMessages: z.lazy(() => ResolutionSlackMessageUpdateManyWithoutProfileNestedInputSchema).optional()
}).strict();

export const ProfileUncheckedUpdateWithoutTargetInputSchema: z.ZodType<Prisma.ProfileUncheckedUpdateWithoutTargetInput> = z.object({
  id: z.union([ z.number().int(),z.lazy(() => IntFieldUpdateOperationsInputSchema) ]).optional(),
  createdAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  slackId: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  slackTeamId: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  userId: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  forecasts: z.lazy(() => ForecastUncheckedUpdateManyWithoutProfileNestedInputSchema).optional(),
  questions: z.lazy(() => QuestionUncheckedUpdateManyWithoutProfileNestedInputSchema).optional(),
  resolutionMessages: z.lazy(() => ResolutionSlackMessageUncheckedUpdateManyWithoutProfileNestedInputSchema).optional()
}).strict();

export const UserCreateWithoutAccountsInputSchema: z.ZodType<Prisma.UserCreateWithoutAccountsInput> = z.object({
  id: z.string().cuid().optional(),
  name: z.string().optional().nullable(),
  createdAt: z.coerce.date().optional(),
  email: z.string(),
  image: z.string().optional().nullable(),
  staleReminder: z.boolean().optional(),
  unsubscribedFromEmailsAt: z.coerce.date().optional().nullable(),
  apiKey: z.string().optional().nullable(),
  discordUserId: z.string().optional().nullable(),
  emailVerified: z.coerce.date().optional().nullable(),
  forecasts: z.lazy(() => ForecastCreateNestedManyWithoutUserInputSchema).optional(),
  profiles: z.lazy(() => ProfileCreateNestedManyWithoutUserInputSchema).optional(),
  questions: z.lazy(() => QuestionCreateNestedManyWithoutUserInputSchema).optional(),
  questionScores: z.lazy(() => QuestionScoreCreateNestedManyWithoutUserInputSchema).optional(),
  questionsSharedWith: z.lazy(() => QuestionCreateNestedManyWithoutSharedWithInputSchema).optional(),
  comments: z.lazy(() => CommentCreateNestedManyWithoutUserInputSchema).optional(),
  target: z.lazy(() => TargetCreateNestedOneWithoutUserInputSchema).optional(),
  authorOfLists: z.lazy(() => UserListCreateNestedManyWithoutAuthorInputSchema).optional(),
  memberOfLists: z.lazy(() => UserListCreateNestedManyWithoutUsersInputSchema).optional(),
  tags: z.lazy(() => TagCreateNestedManyWithoutUserInputSchema).optional(),
  tournaments: z.lazy(() => TournamentCreateNestedManyWithoutAuthorInputSchema).optional(),
  notifications: z.lazy(() => NotificationCreateNestedManyWithoutUserInputSchema).optional(),
  questionOptions: z.lazy(() => QuestionOptionCreateNestedManyWithoutUserInputSchema).optional()
}).strict();

export const UserUncheckedCreateWithoutAccountsInputSchema: z.ZodType<Prisma.UserUncheckedCreateWithoutAccountsInput> = z.object({
  id: z.string().cuid().optional(),
  name: z.string().optional().nullable(),
  createdAt: z.coerce.date().optional(),
  email: z.string(),
  image: z.string().optional().nullable(),
  staleReminder: z.boolean().optional(),
  unsubscribedFromEmailsAt: z.coerce.date().optional().nullable(),
  apiKey: z.string().optional().nullable(),
  discordUserId: z.string().optional().nullable(),
  emailVerified: z.coerce.date().optional().nullable(),
  forecasts: z.lazy(() => ForecastUncheckedCreateNestedManyWithoutUserInputSchema).optional(),
  profiles: z.lazy(() => ProfileUncheckedCreateNestedManyWithoutUserInputSchema).optional(),
  questions: z.lazy(() => QuestionUncheckedCreateNestedManyWithoutUserInputSchema).optional(),
  questionScores: z.lazy(() => QuestionScoreUncheckedCreateNestedManyWithoutUserInputSchema).optional(),
  questionsSharedWith: z.lazy(() => QuestionUncheckedCreateNestedManyWithoutSharedWithInputSchema).optional(),
  comments: z.lazy(() => CommentUncheckedCreateNestedManyWithoutUserInputSchema).optional(),
  target: z.lazy(() => TargetUncheckedCreateNestedOneWithoutUserInputSchema).optional(),
  authorOfLists: z.lazy(() => UserListUncheckedCreateNestedManyWithoutAuthorInputSchema).optional(),
  memberOfLists: z.lazy(() => UserListUncheckedCreateNestedManyWithoutUsersInputSchema).optional(),
  tags: z.lazy(() => TagUncheckedCreateNestedManyWithoutUserInputSchema).optional(),
  tournaments: z.lazy(() => TournamentUncheckedCreateNestedManyWithoutAuthorInputSchema).optional(),
  notifications: z.lazy(() => NotificationUncheckedCreateNestedManyWithoutUserInputSchema).optional(),
  questionOptions: z.lazy(() => QuestionOptionUncheckedCreateNestedManyWithoutUserInputSchema).optional()
}).strict();

export const UserCreateOrConnectWithoutAccountsInputSchema: z.ZodType<Prisma.UserCreateOrConnectWithoutAccountsInput> = z.object({
  where: z.lazy(() => UserWhereUniqueInputSchema),
  create: z.union([ z.lazy(() => UserCreateWithoutAccountsInputSchema),z.lazy(() => UserUncheckedCreateWithoutAccountsInputSchema) ]),
}).strict();

export const UserUpsertWithoutAccountsInputSchema: z.ZodType<Prisma.UserUpsertWithoutAccountsInput> = z.object({
  update: z.union([ z.lazy(() => UserUpdateWithoutAccountsInputSchema),z.lazy(() => UserUncheckedUpdateWithoutAccountsInputSchema) ]),
  create: z.union([ z.lazy(() => UserCreateWithoutAccountsInputSchema),z.lazy(() => UserUncheckedCreateWithoutAccountsInputSchema) ]),
  where: z.lazy(() => UserWhereInputSchema).optional()
}).strict();

export const UserUpdateToOneWithWhereWithoutAccountsInputSchema: z.ZodType<Prisma.UserUpdateToOneWithWhereWithoutAccountsInput> = z.object({
  where: z.lazy(() => UserWhereInputSchema).optional(),
  data: z.union([ z.lazy(() => UserUpdateWithoutAccountsInputSchema),z.lazy(() => UserUncheckedUpdateWithoutAccountsInputSchema) ]),
}).strict();

export const UserUpdateWithoutAccountsInputSchema: z.ZodType<Prisma.UserUpdateWithoutAccountsInput> = z.object({
  id: z.union([ z.string().cuid(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  name: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  createdAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  email: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  image: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  staleReminder: z.union([ z.boolean(),z.lazy(() => BoolFieldUpdateOperationsInputSchema) ]).optional(),
  unsubscribedFromEmailsAt: z.union([ z.coerce.date(),z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  apiKey: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  discordUserId: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  emailVerified: z.union([ z.coerce.date(),z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  forecasts: z.lazy(() => ForecastUpdateManyWithoutUserNestedInputSchema).optional(),
  profiles: z.lazy(() => ProfileUpdateManyWithoutUserNestedInputSchema).optional(),
  questions: z.lazy(() => QuestionUpdateManyWithoutUserNestedInputSchema).optional(),
  questionScores: z.lazy(() => QuestionScoreUpdateManyWithoutUserNestedInputSchema).optional(),
  questionsSharedWith: z.lazy(() => QuestionUpdateManyWithoutSharedWithNestedInputSchema).optional(),
  comments: z.lazy(() => CommentUpdateManyWithoutUserNestedInputSchema).optional(),
  target: z.lazy(() => TargetUpdateOneWithoutUserNestedInputSchema).optional(),
  authorOfLists: z.lazy(() => UserListUpdateManyWithoutAuthorNestedInputSchema).optional(),
  memberOfLists: z.lazy(() => UserListUpdateManyWithoutUsersNestedInputSchema).optional(),
  tags: z.lazy(() => TagUpdateManyWithoutUserNestedInputSchema).optional(),
  tournaments: z.lazy(() => TournamentUpdateManyWithoutAuthorNestedInputSchema).optional(),
  notifications: z.lazy(() => NotificationUpdateManyWithoutUserNestedInputSchema).optional(),
  questionOptions: z.lazy(() => QuestionOptionUpdateManyWithoutUserNestedInputSchema).optional()
}).strict();

export const UserUncheckedUpdateWithoutAccountsInputSchema: z.ZodType<Prisma.UserUncheckedUpdateWithoutAccountsInput> = z.object({
  id: z.union([ z.string().cuid(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  name: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  createdAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  email: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  image: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  staleReminder: z.union([ z.boolean(),z.lazy(() => BoolFieldUpdateOperationsInputSchema) ]).optional(),
  unsubscribedFromEmailsAt: z.union([ z.coerce.date(),z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  apiKey: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  discordUserId: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  emailVerified: z.union([ z.coerce.date(),z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  forecasts: z.lazy(() => ForecastUncheckedUpdateManyWithoutUserNestedInputSchema).optional(),
  profiles: z.lazy(() => ProfileUncheckedUpdateManyWithoutUserNestedInputSchema).optional(),
  questions: z.lazy(() => QuestionUncheckedUpdateManyWithoutUserNestedInputSchema).optional(),
  questionScores: z.lazy(() => QuestionScoreUncheckedUpdateManyWithoutUserNestedInputSchema).optional(),
  questionsSharedWith: z.lazy(() => QuestionUncheckedUpdateManyWithoutSharedWithNestedInputSchema).optional(),
  comments: z.lazy(() => CommentUncheckedUpdateManyWithoutUserNestedInputSchema).optional(),
  target: z.lazy(() => TargetUncheckedUpdateOneWithoutUserNestedInputSchema).optional(),
  authorOfLists: z.lazy(() => UserListUncheckedUpdateManyWithoutAuthorNestedInputSchema).optional(),
  memberOfLists: z.lazy(() => UserListUncheckedUpdateManyWithoutUsersNestedInputSchema).optional(),
  tags: z.lazy(() => TagUncheckedUpdateManyWithoutUserNestedInputSchema).optional(),
  tournaments: z.lazy(() => TournamentUncheckedUpdateManyWithoutAuthorNestedInputSchema).optional(),
  notifications: z.lazy(() => NotificationUncheckedUpdateManyWithoutUserNestedInputSchema).optional(),
  questionOptions: z.lazy(() => QuestionOptionUncheckedUpdateManyWithoutUserNestedInputSchema).optional()
}).strict();

export const QuestionCreateWithoutCommentsInputSchema: z.ZodType<Prisma.QuestionCreateWithoutCommentsInput> = z.object({
  id: z.string().cuid().optional(),
  createdAt: z.coerce.date().optional(),
  comment: z.string().optional().nullable(),
  title: z.string(),
  type: z.lazy(() => QuestionTypeSchema).optional(),
  resolveBy: z.coerce.date(),
  resolved: z.boolean().optional(),
  pingedForResolution: z.boolean().optional(),
  resolution: z.lazy(() => ResolutionSchema).optional().nullable(),
  resolvedAt: z.coerce.date().optional().nullable(),
  notes: z.string().optional().nullable(),
  hideForecastsUntil: z.coerce.date().optional().nullable(),
  hideForecastsUntilPrediction: z.boolean().optional().nullable(),
  sharedPublicly: z.boolean().optional(),
  unlisted: z.boolean().optional(),
  exclusiveAnswers: z.boolean().optional().nullable(),
  options: z.lazy(() => QuestionOptionCreateNestedManyWithoutQuestionInputSchema).optional(),
  forecasts: z.lazy(() => ForecastCreateNestedManyWithoutQuestionInputSchema).optional(),
  pingResolveMessages: z.lazy(() => PingSlackMessageCreateNestedManyWithoutQuestionInputSchema).optional(),
  profile: z.lazy(() => ProfileCreateNestedOneWithoutQuestionsInputSchema).optional(),
  user: z.lazy(() => UserCreateNestedOneWithoutQuestionsInputSchema),
  sharedWith: z.lazy(() => UserCreateNestedManyWithoutQuestionsSharedWithInputSchema).optional(),
  sharedWithLists: z.lazy(() => UserListCreateNestedManyWithoutQuestionsInputSchema).optional(),
  questionScores: z.lazy(() => QuestionScoreCreateNestedManyWithoutQuestionInputSchema).optional(),
  questionMessages: z.lazy(() => QuestionSlackMessageCreateNestedManyWithoutQuestionInputSchema).optional(),
  resolutionMessages: z.lazy(() => ResolutionSlackMessageCreateNestedManyWithoutQuestionInputSchema).optional(),
  tags: z.lazy(() => TagCreateNestedManyWithoutQuestionsInputSchema).optional(),
  tournaments: z.lazy(() => TournamentCreateNestedManyWithoutQuestionsInputSchema).optional(),
  notifications: z.lazy(() => NotificationCreateNestedManyWithoutQuestionInputSchema).optional()
}).strict();

export const QuestionUncheckedCreateWithoutCommentsInputSchema: z.ZodType<Prisma.QuestionUncheckedCreateWithoutCommentsInput> = z.object({
  id: z.string().cuid().optional(),
  createdAt: z.coerce.date().optional(),
  comment: z.string().optional().nullable(),
  profileId: z.number().int().optional().nullable(),
  title: z.string(),
  type: z.lazy(() => QuestionTypeSchema).optional(),
  resolveBy: z.coerce.date(),
  resolved: z.boolean().optional(),
  pingedForResolution: z.boolean().optional(),
  resolution: z.lazy(() => ResolutionSchema).optional().nullable(),
  resolvedAt: z.coerce.date().optional().nullable(),
  notes: z.string().optional().nullable(),
  hideForecastsUntil: z.coerce.date().optional().nullable(),
  hideForecastsUntilPrediction: z.boolean().optional().nullable(),
  userId: z.string(),
  sharedPublicly: z.boolean().optional(),
  unlisted: z.boolean().optional(),
  exclusiveAnswers: z.boolean().optional().nullable(),
  options: z.lazy(() => QuestionOptionUncheckedCreateNestedManyWithoutQuestionInputSchema).optional(),
  forecasts: z.lazy(() => ForecastUncheckedCreateNestedManyWithoutQuestionInputSchema).optional(),
  pingResolveMessages: z.lazy(() => PingSlackMessageUncheckedCreateNestedManyWithoutQuestionInputSchema).optional(),
  sharedWith: z.lazy(() => UserUncheckedCreateNestedManyWithoutQuestionsSharedWithInputSchema).optional(),
  sharedWithLists: z.lazy(() => UserListUncheckedCreateNestedManyWithoutQuestionsInputSchema).optional(),
  questionScores: z.lazy(() => QuestionScoreUncheckedCreateNestedManyWithoutQuestionInputSchema).optional(),
  questionMessages: z.lazy(() => QuestionSlackMessageUncheckedCreateNestedManyWithoutQuestionInputSchema).optional(),
  resolutionMessages: z.lazy(() => ResolutionSlackMessageUncheckedCreateNestedManyWithoutQuestionInputSchema).optional(),
  tags: z.lazy(() => TagUncheckedCreateNestedManyWithoutQuestionsInputSchema).optional(),
  tournaments: z.lazy(() => TournamentUncheckedCreateNestedManyWithoutQuestionsInputSchema).optional(),
  notifications: z.lazy(() => NotificationUncheckedCreateNestedManyWithoutQuestionInputSchema).optional()
}).strict();

export const QuestionCreateOrConnectWithoutCommentsInputSchema: z.ZodType<Prisma.QuestionCreateOrConnectWithoutCommentsInput> = z.object({
  where: z.lazy(() => QuestionWhereUniqueInputSchema),
  create: z.union([ z.lazy(() => QuestionCreateWithoutCommentsInputSchema),z.lazy(() => QuestionUncheckedCreateWithoutCommentsInputSchema) ]),
}).strict();

export const UserCreateWithoutCommentsInputSchema: z.ZodType<Prisma.UserCreateWithoutCommentsInput> = z.object({
  id: z.string().cuid().optional(),
  name: z.string().optional().nullable(),
  createdAt: z.coerce.date().optional(),
  email: z.string(),
  image: z.string().optional().nullable(),
  staleReminder: z.boolean().optional(),
  unsubscribedFromEmailsAt: z.coerce.date().optional().nullable(),
  apiKey: z.string().optional().nullable(),
  discordUserId: z.string().optional().nullable(),
  emailVerified: z.coerce.date().optional().nullable(),
  forecasts: z.lazy(() => ForecastCreateNestedManyWithoutUserInputSchema).optional(),
  profiles: z.lazy(() => ProfileCreateNestedManyWithoutUserInputSchema).optional(),
  questions: z.lazy(() => QuestionCreateNestedManyWithoutUserInputSchema).optional(),
  questionScores: z.lazy(() => QuestionScoreCreateNestedManyWithoutUserInputSchema).optional(),
  questionsSharedWith: z.lazy(() => QuestionCreateNestedManyWithoutSharedWithInputSchema).optional(),
  target: z.lazy(() => TargetCreateNestedOneWithoutUserInputSchema).optional(),
  authorOfLists: z.lazy(() => UserListCreateNestedManyWithoutAuthorInputSchema).optional(),
  memberOfLists: z.lazy(() => UserListCreateNestedManyWithoutUsersInputSchema).optional(),
  tags: z.lazy(() => TagCreateNestedManyWithoutUserInputSchema).optional(),
  tournaments: z.lazy(() => TournamentCreateNestedManyWithoutAuthorInputSchema).optional(),
  notifications: z.lazy(() => NotificationCreateNestedManyWithoutUserInputSchema).optional(),
  questionOptions: z.lazy(() => QuestionOptionCreateNestedManyWithoutUserInputSchema).optional(),
  accounts: z.lazy(() => AccountCreateNestedManyWithoutUserInputSchema).optional()
}).strict();

export const UserUncheckedCreateWithoutCommentsInputSchema: z.ZodType<Prisma.UserUncheckedCreateWithoutCommentsInput> = z.object({
  id: z.string().cuid().optional(),
  name: z.string().optional().nullable(),
  createdAt: z.coerce.date().optional(),
  email: z.string(),
  image: z.string().optional().nullable(),
  staleReminder: z.boolean().optional(),
  unsubscribedFromEmailsAt: z.coerce.date().optional().nullable(),
  apiKey: z.string().optional().nullable(),
  discordUserId: z.string().optional().nullable(),
  emailVerified: z.coerce.date().optional().nullable(),
  forecasts: z.lazy(() => ForecastUncheckedCreateNestedManyWithoutUserInputSchema).optional(),
  profiles: z.lazy(() => ProfileUncheckedCreateNestedManyWithoutUserInputSchema).optional(),
  questions: z.lazy(() => QuestionUncheckedCreateNestedManyWithoutUserInputSchema).optional(),
  questionScores: z.lazy(() => QuestionScoreUncheckedCreateNestedManyWithoutUserInputSchema).optional(),
  questionsSharedWith: z.lazy(() => QuestionUncheckedCreateNestedManyWithoutSharedWithInputSchema).optional(),
  target: z.lazy(() => TargetUncheckedCreateNestedOneWithoutUserInputSchema).optional(),
  authorOfLists: z.lazy(() => UserListUncheckedCreateNestedManyWithoutAuthorInputSchema).optional(),
  memberOfLists: z.lazy(() => UserListUncheckedCreateNestedManyWithoutUsersInputSchema).optional(),
  tags: z.lazy(() => TagUncheckedCreateNestedManyWithoutUserInputSchema).optional(),
  tournaments: z.lazy(() => TournamentUncheckedCreateNestedManyWithoutAuthorInputSchema).optional(),
  notifications: z.lazy(() => NotificationUncheckedCreateNestedManyWithoutUserInputSchema).optional(),
  questionOptions: z.lazy(() => QuestionOptionUncheckedCreateNestedManyWithoutUserInputSchema).optional(),
  accounts: z.lazy(() => AccountUncheckedCreateNestedManyWithoutUserInputSchema).optional()
}).strict();

export const UserCreateOrConnectWithoutCommentsInputSchema: z.ZodType<Prisma.UserCreateOrConnectWithoutCommentsInput> = z.object({
  where: z.lazy(() => UserWhereUniqueInputSchema),
  create: z.union([ z.lazy(() => UserCreateWithoutCommentsInputSchema),z.lazy(() => UserUncheckedCreateWithoutCommentsInputSchema) ]),
}).strict();

export const QuestionUpsertWithoutCommentsInputSchema: z.ZodType<Prisma.QuestionUpsertWithoutCommentsInput> = z.object({
  update: z.union([ z.lazy(() => QuestionUpdateWithoutCommentsInputSchema),z.lazy(() => QuestionUncheckedUpdateWithoutCommentsInputSchema) ]),
  create: z.union([ z.lazy(() => QuestionCreateWithoutCommentsInputSchema),z.lazy(() => QuestionUncheckedCreateWithoutCommentsInputSchema) ]),
  where: z.lazy(() => QuestionWhereInputSchema).optional()
}).strict();

export const QuestionUpdateToOneWithWhereWithoutCommentsInputSchema: z.ZodType<Prisma.QuestionUpdateToOneWithWhereWithoutCommentsInput> = z.object({
  where: z.lazy(() => QuestionWhereInputSchema).optional(),
  data: z.union([ z.lazy(() => QuestionUpdateWithoutCommentsInputSchema),z.lazy(() => QuestionUncheckedUpdateWithoutCommentsInputSchema) ]),
}).strict();

export const QuestionUpdateWithoutCommentsInputSchema: z.ZodType<Prisma.QuestionUpdateWithoutCommentsInput> = z.object({
  id: z.union([ z.string().cuid(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  createdAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  comment: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  title: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  type: z.union([ z.lazy(() => QuestionTypeSchema),z.lazy(() => EnumQuestionTypeFieldUpdateOperationsInputSchema) ]).optional(),
  resolveBy: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  resolved: z.union([ z.boolean(),z.lazy(() => BoolFieldUpdateOperationsInputSchema) ]).optional(),
  pingedForResolution: z.union([ z.boolean(),z.lazy(() => BoolFieldUpdateOperationsInputSchema) ]).optional(),
  resolution: z.union([ z.lazy(() => ResolutionSchema),z.lazy(() => NullableEnumResolutionFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  resolvedAt: z.union([ z.coerce.date(),z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  notes: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  hideForecastsUntil: z.union([ z.coerce.date(),z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  hideForecastsUntilPrediction: z.union([ z.boolean(),z.lazy(() => NullableBoolFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  sharedPublicly: z.union([ z.boolean(),z.lazy(() => BoolFieldUpdateOperationsInputSchema) ]).optional(),
  unlisted: z.union([ z.boolean(),z.lazy(() => BoolFieldUpdateOperationsInputSchema) ]).optional(),
  exclusiveAnswers: z.union([ z.boolean(),z.lazy(() => NullableBoolFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  options: z.lazy(() => QuestionOptionUpdateManyWithoutQuestionNestedInputSchema).optional(),
  forecasts: z.lazy(() => ForecastUpdateManyWithoutQuestionNestedInputSchema).optional(),
  pingResolveMessages: z.lazy(() => PingSlackMessageUpdateManyWithoutQuestionNestedInputSchema).optional(),
  profile: z.lazy(() => ProfileUpdateOneWithoutQuestionsNestedInputSchema).optional(),
  user: z.lazy(() => UserUpdateOneRequiredWithoutQuestionsNestedInputSchema).optional(),
  sharedWith: z.lazy(() => UserUpdateManyWithoutQuestionsSharedWithNestedInputSchema).optional(),
  sharedWithLists: z.lazy(() => UserListUpdateManyWithoutQuestionsNestedInputSchema).optional(),
  questionScores: z.lazy(() => QuestionScoreUpdateManyWithoutQuestionNestedInputSchema).optional(),
  questionMessages: z.lazy(() => QuestionSlackMessageUpdateManyWithoutQuestionNestedInputSchema).optional(),
  resolutionMessages: z.lazy(() => ResolutionSlackMessageUpdateManyWithoutQuestionNestedInputSchema).optional(),
  tags: z.lazy(() => TagUpdateManyWithoutQuestionsNestedInputSchema).optional(),
  tournaments: z.lazy(() => TournamentUpdateManyWithoutQuestionsNestedInputSchema).optional(),
  notifications: z.lazy(() => NotificationUpdateManyWithoutQuestionNestedInputSchema).optional()
}).strict();

export const QuestionUncheckedUpdateWithoutCommentsInputSchema: z.ZodType<Prisma.QuestionUncheckedUpdateWithoutCommentsInput> = z.object({
  id: z.union([ z.string().cuid(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  createdAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  comment: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  profileId: z.union([ z.number().int(),z.lazy(() => NullableIntFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  title: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  type: z.union([ z.lazy(() => QuestionTypeSchema),z.lazy(() => EnumQuestionTypeFieldUpdateOperationsInputSchema) ]).optional(),
  resolveBy: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  resolved: z.union([ z.boolean(),z.lazy(() => BoolFieldUpdateOperationsInputSchema) ]).optional(),
  pingedForResolution: z.union([ z.boolean(),z.lazy(() => BoolFieldUpdateOperationsInputSchema) ]).optional(),
  resolution: z.union([ z.lazy(() => ResolutionSchema),z.lazy(() => NullableEnumResolutionFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  resolvedAt: z.union([ z.coerce.date(),z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  notes: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  hideForecastsUntil: z.union([ z.coerce.date(),z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  hideForecastsUntilPrediction: z.union([ z.boolean(),z.lazy(() => NullableBoolFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  userId: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  sharedPublicly: z.union([ z.boolean(),z.lazy(() => BoolFieldUpdateOperationsInputSchema) ]).optional(),
  unlisted: z.union([ z.boolean(),z.lazy(() => BoolFieldUpdateOperationsInputSchema) ]).optional(),
  exclusiveAnswers: z.union([ z.boolean(),z.lazy(() => NullableBoolFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  options: z.lazy(() => QuestionOptionUncheckedUpdateManyWithoutQuestionNestedInputSchema).optional(),
  forecasts: z.lazy(() => ForecastUncheckedUpdateManyWithoutQuestionNestedInputSchema).optional(),
  pingResolveMessages: z.lazy(() => PingSlackMessageUncheckedUpdateManyWithoutQuestionNestedInputSchema).optional(),
  sharedWith: z.lazy(() => UserUncheckedUpdateManyWithoutQuestionsSharedWithNestedInputSchema).optional(),
  sharedWithLists: z.lazy(() => UserListUncheckedUpdateManyWithoutQuestionsNestedInputSchema).optional(),
  questionScores: z.lazy(() => QuestionScoreUncheckedUpdateManyWithoutQuestionNestedInputSchema).optional(),
  questionMessages: z.lazy(() => QuestionSlackMessageUncheckedUpdateManyWithoutQuestionNestedInputSchema).optional(),
  resolutionMessages: z.lazy(() => ResolutionSlackMessageUncheckedUpdateManyWithoutQuestionNestedInputSchema).optional(),
  tags: z.lazy(() => TagUncheckedUpdateManyWithoutQuestionsNestedInputSchema).optional(),
  tournaments: z.lazy(() => TournamentUncheckedUpdateManyWithoutQuestionsNestedInputSchema).optional(),
  notifications: z.lazy(() => NotificationUncheckedUpdateManyWithoutQuestionNestedInputSchema).optional()
}).strict();

export const UserUpsertWithoutCommentsInputSchema: z.ZodType<Prisma.UserUpsertWithoutCommentsInput> = z.object({
  update: z.union([ z.lazy(() => UserUpdateWithoutCommentsInputSchema),z.lazy(() => UserUncheckedUpdateWithoutCommentsInputSchema) ]),
  create: z.union([ z.lazy(() => UserCreateWithoutCommentsInputSchema),z.lazy(() => UserUncheckedCreateWithoutCommentsInputSchema) ]),
  where: z.lazy(() => UserWhereInputSchema).optional()
}).strict();

export const UserUpdateToOneWithWhereWithoutCommentsInputSchema: z.ZodType<Prisma.UserUpdateToOneWithWhereWithoutCommentsInput> = z.object({
  where: z.lazy(() => UserWhereInputSchema).optional(),
  data: z.union([ z.lazy(() => UserUpdateWithoutCommentsInputSchema),z.lazy(() => UserUncheckedUpdateWithoutCommentsInputSchema) ]),
}).strict();

export const UserUpdateWithoutCommentsInputSchema: z.ZodType<Prisma.UserUpdateWithoutCommentsInput> = z.object({
  id: z.union([ z.string().cuid(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  name: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  createdAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  email: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  image: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  staleReminder: z.union([ z.boolean(),z.lazy(() => BoolFieldUpdateOperationsInputSchema) ]).optional(),
  unsubscribedFromEmailsAt: z.union([ z.coerce.date(),z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  apiKey: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  discordUserId: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  emailVerified: z.union([ z.coerce.date(),z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  forecasts: z.lazy(() => ForecastUpdateManyWithoutUserNestedInputSchema).optional(),
  profiles: z.lazy(() => ProfileUpdateManyWithoutUserNestedInputSchema).optional(),
  questions: z.lazy(() => QuestionUpdateManyWithoutUserNestedInputSchema).optional(),
  questionScores: z.lazy(() => QuestionScoreUpdateManyWithoutUserNestedInputSchema).optional(),
  questionsSharedWith: z.lazy(() => QuestionUpdateManyWithoutSharedWithNestedInputSchema).optional(),
  target: z.lazy(() => TargetUpdateOneWithoutUserNestedInputSchema).optional(),
  authorOfLists: z.lazy(() => UserListUpdateManyWithoutAuthorNestedInputSchema).optional(),
  memberOfLists: z.lazy(() => UserListUpdateManyWithoutUsersNestedInputSchema).optional(),
  tags: z.lazy(() => TagUpdateManyWithoutUserNestedInputSchema).optional(),
  tournaments: z.lazy(() => TournamentUpdateManyWithoutAuthorNestedInputSchema).optional(),
  notifications: z.lazy(() => NotificationUpdateManyWithoutUserNestedInputSchema).optional(),
  questionOptions: z.lazy(() => QuestionOptionUpdateManyWithoutUserNestedInputSchema).optional(),
  accounts: z.lazy(() => AccountUpdateManyWithoutUserNestedInputSchema).optional()
}).strict();

export const UserUncheckedUpdateWithoutCommentsInputSchema: z.ZodType<Prisma.UserUncheckedUpdateWithoutCommentsInput> = z.object({
  id: z.union([ z.string().cuid(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  name: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  createdAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  email: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  image: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  staleReminder: z.union([ z.boolean(),z.lazy(() => BoolFieldUpdateOperationsInputSchema) ]).optional(),
  unsubscribedFromEmailsAt: z.union([ z.coerce.date(),z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  apiKey: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  discordUserId: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  emailVerified: z.union([ z.coerce.date(),z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  forecasts: z.lazy(() => ForecastUncheckedUpdateManyWithoutUserNestedInputSchema).optional(),
  profiles: z.lazy(() => ProfileUncheckedUpdateManyWithoutUserNestedInputSchema).optional(),
  questions: z.lazy(() => QuestionUncheckedUpdateManyWithoutUserNestedInputSchema).optional(),
  questionScores: z.lazy(() => QuestionScoreUncheckedUpdateManyWithoutUserNestedInputSchema).optional(),
  questionsSharedWith: z.lazy(() => QuestionUncheckedUpdateManyWithoutSharedWithNestedInputSchema).optional(),
  target: z.lazy(() => TargetUncheckedUpdateOneWithoutUserNestedInputSchema).optional(),
  authorOfLists: z.lazy(() => UserListUncheckedUpdateManyWithoutAuthorNestedInputSchema).optional(),
  memberOfLists: z.lazy(() => UserListUncheckedUpdateManyWithoutUsersNestedInputSchema).optional(),
  tags: z.lazy(() => TagUncheckedUpdateManyWithoutUserNestedInputSchema).optional(),
  tournaments: z.lazy(() => TournamentUncheckedUpdateManyWithoutAuthorNestedInputSchema).optional(),
  notifications: z.lazy(() => NotificationUncheckedUpdateManyWithoutUserNestedInputSchema).optional(),
  questionOptions: z.lazy(() => QuestionOptionUncheckedUpdateManyWithoutUserNestedInputSchema).optional(),
  accounts: z.lazy(() => AccountUncheckedUpdateManyWithoutUserNestedInputSchema).optional()
}).strict();

export const UserCreateWithoutAuthorOfListsInputSchema: z.ZodType<Prisma.UserCreateWithoutAuthorOfListsInput> = z.object({
  id: z.string().cuid().optional(),
  name: z.string().optional().nullable(),
  createdAt: z.coerce.date().optional(),
  email: z.string(),
  image: z.string().optional().nullable(),
  staleReminder: z.boolean().optional(),
  unsubscribedFromEmailsAt: z.coerce.date().optional().nullable(),
  apiKey: z.string().optional().nullable(),
  discordUserId: z.string().optional().nullable(),
  emailVerified: z.coerce.date().optional().nullable(),
  forecasts: z.lazy(() => ForecastCreateNestedManyWithoutUserInputSchema).optional(),
  profiles: z.lazy(() => ProfileCreateNestedManyWithoutUserInputSchema).optional(),
  questions: z.lazy(() => QuestionCreateNestedManyWithoutUserInputSchema).optional(),
  questionScores: z.lazy(() => QuestionScoreCreateNestedManyWithoutUserInputSchema).optional(),
  questionsSharedWith: z.lazy(() => QuestionCreateNestedManyWithoutSharedWithInputSchema).optional(),
  comments: z.lazy(() => CommentCreateNestedManyWithoutUserInputSchema).optional(),
  target: z.lazy(() => TargetCreateNestedOneWithoutUserInputSchema).optional(),
  memberOfLists: z.lazy(() => UserListCreateNestedManyWithoutUsersInputSchema).optional(),
  tags: z.lazy(() => TagCreateNestedManyWithoutUserInputSchema).optional(),
  tournaments: z.lazy(() => TournamentCreateNestedManyWithoutAuthorInputSchema).optional(),
  notifications: z.lazy(() => NotificationCreateNestedManyWithoutUserInputSchema).optional(),
  questionOptions: z.lazy(() => QuestionOptionCreateNestedManyWithoutUserInputSchema).optional(),
  accounts: z.lazy(() => AccountCreateNestedManyWithoutUserInputSchema).optional()
}).strict();

export const UserUncheckedCreateWithoutAuthorOfListsInputSchema: z.ZodType<Prisma.UserUncheckedCreateWithoutAuthorOfListsInput> = z.object({
  id: z.string().cuid().optional(),
  name: z.string().optional().nullable(),
  createdAt: z.coerce.date().optional(),
  email: z.string(),
  image: z.string().optional().nullable(),
  staleReminder: z.boolean().optional(),
  unsubscribedFromEmailsAt: z.coerce.date().optional().nullable(),
  apiKey: z.string().optional().nullable(),
  discordUserId: z.string().optional().nullable(),
  emailVerified: z.coerce.date().optional().nullable(),
  forecasts: z.lazy(() => ForecastUncheckedCreateNestedManyWithoutUserInputSchema).optional(),
  profiles: z.lazy(() => ProfileUncheckedCreateNestedManyWithoutUserInputSchema).optional(),
  questions: z.lazy(() => QuestionUncheckedCreateNestedManyWithoutUserInputSchema).optional(),
  questionScores: z.lazy(() => QuestionScoreUncheckedCreateNestedManyWithoutUserInputSchema).optional(),
  questionsSharedWith: z.lazy(() => QuestionUncheckedCreateNestedManyWithoutSharedWithInputSchema).optional(),
  comments: z.lazy(() => CommentUncheckedCreateNestedManyWithoutUserInputSchema).optional(),
  target: z.lazy(() => TargetUncheckedCreateNestedOneWithoutUserInputSchema).optional(),
  memberOfLists: z.lazy(() => UserListUncheckedCreateNestedManyWithoutUsersInputSchema).optional(),
  tags: z.lazy(() => TagUncheckedCreateNestedManyWithoutUserInputSchema).optional(),
  tournaments: z.lazy(() => TournamentUncheckedCreateNestedManyWithoutAuthorInputSchema).optional(),
  notifications: z.lazy(() => NotificationUncheckedCreateNestedManyWithoutUserInputSchema).optional(),
  questionOptions: z.lazy(() => QuestionOptionUncheckedCreateNestedManyWithoutUserInputSchema).optional(),
  accounts: z.lazy(() => AccountUncheckedCreateNestedManyWithoutUserInputSchema).optional()
}).strict();

export const UserCreateOrConnectWithoutAuthorOfListsInputSchema: z.ZodType<Prisma.UserCreateOrConnectWithoutAuthorOfListsInput> = z.object({
  where: z.lazy(() => UserWhereUniqueInputSchema),
  create: z.union([ z.lazy(() => UserCreateWithoutAuthorOfListsInputSchema),z.lazy(() => UserUncheckedCreateWithoutAuthorOfListsInputSchema) ]),
}).strict();

export const UserCreateWithoutMemberOfListsInputSchema: z.ZodType<Prisma.UserCreateWithoutMemberOfListsInput> = z.object({
  id: z.string().cuid().optional(),
  name: z.string().optional().nullable(),
  createdAt: z.coerce.date().optional(),
  email: z.string(),
  image: z.string().optional().nullable(),
  staleReminder: z.boolean().optional(),
  unsubscribedFromEmailsAt: z.coerce.date().optional().nullable(),
  apiKey: z.string().optional().nullable(),
  discordUserId: z.string().optional().nullable(),
  emailVerified: z.coerce.date().optional().nullable(),
  forecasts: z.lazy(() => ForecastCreateNestedManyWithoutUserInputSchema).optional(),
  profiles: z.lazy(() => ProfileCreateNestedManyWithoutUserInputSchema).optional(),
  questions: z.lazy(() => QuestionCreateNestedManyWithoutUserInputSchema).optional(),
  questionScores: z.lazy(() => QuestionScoreCreateNestedManyWithoutUserInputSchema).optional(),
  questionsSharedWith: z.lazy(() => QuestionCreateNestedManyWithoutSharedWithInputSchema).optional(),
  comments: z.lazy(() => CommentCreateNestedManyWithoutUserInputSchema).optional(),
  target: z.lazy(() => TargetCreateNestedOneWithoutUserInputSchema).optional(),
  authorOfLists: z.lazy(() => UserListCreateNestedManyWithoutAuthorInputSchema).optional(),
  tags: z.lazy(() => TagCreateNestedManyWithoutUserInputSchema).optional(),
  tournaments: z.lazy(() => TournamentCreateNestedManyWithoutAuthorInputSchema).optional(),
  notifications: z.lazy(() => NotificationCreateNestedManyWithoutUserInputSchema).optional(),
  questionOptions: z.lazy(() => QuestionOptionCreateNestedManyWithoutUserInputSchema).optional(),
  accounts: z.lazy(() => AccountCreateNestedManyWithoutUserInputSchema).optional()
}).strict();

export const UserUncheckedCreateWithoutMemberOfListsInputSchema: z.ZodType<Prisma.UserUncheckedCreateWithoutMemberOfListsInput> = z.object({
  id: z.string().cuid().optional(),
  name: z.string().optional().nullable(),
  createdAt: z.coerce.date().optional(),
  email: z.string(),
  image: z.string().optional().nullable(),
  staleReminder: z.boolean().optional(),
  unsubscribedFromEmailsAt: z.coerce.date().optional().nullable(),
  apiKey: z.string().optional().nullable(),
  discordUserId: z.string().optional().nullable(),
  emailVerified: z.coerce.date().optional().nullable(),
  forecasts: z.lazy(() => ForecastUncheckedCreateNestedManyWithoutUserInputSchema).optional(),
  profiles: z.lazy(() => ProfileUncheckedCreateNestedManyWithoutUserInputSchema).optional(),
  questions: z.lazy(() => QuestionUncheckedCreateNestedManyWithoutUserInputSchema).optional(),
  questionScores: z.lazy(() => QuestionScoreUncheckedCreateNestedManyWithoutUserInputSchema).optional(),
  questionsSharedWith: z.lazy(() => QuestionUncheckedCreateNestedManyWithoutSharedWithInputSchema).optional(),
  comments: z.lazy(() => CommentUncheckedCreateNestedManyWithoutUserInputSchema).optional(),
  target: z.lazy(() => TargetUncheckedCreateNestedOneWithoutUserInputSchema).optional(),
  authorOfLists: z.lazy(() => UserListUncheckedCreateNestedManyWithoutAuthorInputSchema).optional(),
  tags: z.lazy(() => TagUncheckedCreateNestedManyWithoutUserInputSchema).optional(),
  tournaments: z.lazy(() => TournamentUncheckedCreateNestedManyWithoutAuthorInputSchema).optional(),
  notifications: z.lazy(() => NotificationUncheckedCreateNestedManyWithoutUserInputSchema).optional(),
  questionOptions: z.lazy(() => QuestionOptionUncheckedCreateNestedManyWithoutUserInputSchema).optional(),
  accounts: z.lazy(() => AccountUncheckedCreateNestedManyWithoutUserInputSchema).optional()
}).strict();

export const UserCreateOrConnectWithoutMemberOfListsInputSchema: z.ZodType<Prisma.UserCreateOrConnectWithoutMemberOfListsInput> = z.object({
  where: z.lazy(() => UserWhereUniqueInputSchema),
  create: z.union([ z.lazy(() => UserCreateWithoutMemberOfListsInputSchema),z.lazy(() => UserUncheckedCreateWithoutMemberOfListsInputSchema) ]),
}).strict();

export const QuestionCreateWithoutSharedWithListsInputSchema: z.ZodType<Prisma.QuestionCreateWithoutSharedWithListsInput> = z.object({
  id: z.string().cuid().optional(),
  createdAt: z.coerce.date().optional(),
  comment: z.string().optional().nullable(),
  title: z.string(),
  type: z.lazy(() => QuestionTypeSchema).optional(),
  resolveBy: z.coerce.date(),
  resolved: z.boolean().optional(),
  pingedForResolution: z.boolean().optional(),
  resolution: z.lazy(() => ResolutionSchema).optional().nullable(),
  resolvedAt: z.coerce.date().optional().nullable(),
  notes: z.string().optional().nullable(),
  hideForecastsUntil: z.coerce.date().optional().nullable(),
  hideForecastsUntilPrediction: z.boolean().optional().nullable(),
  sharedPublicly: z.boolean().optional(),
  unlisted: z.boolean().optional(),
  exclusiveAnswers: z.boolean().optional().nullable(),
  options: z.lazy(() => QuestionOptionCreateNestedManyWithoutQuestionInputSchema).optional(),
  forecasts: z.lazy(() => ForecastCreateNestedManyWithoutQuestionInputSchema).optional(),
  pingResolveMessages: z.lazy(() => PingSlackMessageCreateNestedManyWithoutQuestionInputSchema).optional(),
  profile: z.lazy(() => ProfileCreateNestedOneWithoutQuestionsInputSchema).optional(),
  user: z.lazy(() => UserCreateNestedOneWithoutQuestionsInputSchema),
  sharedWith: z.lazy(() => UserCreateNestedManyWithoutQuestionsSharedWithInputSchema).optional(),
  questionScores: z.lazy(() => QuestionScoreCreateNestedManyWithoutQuestionInputSchema).optional(),
  questionMessages: z.lazy(() => QuestionSlackMessageCreateNestedManyWithoutQuestionInputSchema).optional(),
  resolutionMessages: z.lazy(() => ResolutionSlackMessageCreateNestedManyWithoutQuestionInputSchema).optional(),
  comments: z.lazy(() => CommentCreateNestedManyWithoutQuestionInputSchema).optional(),
  tags: z.lazy(() => TagCreateNestedManyWithoutQuestionsInputSchema).optional(),
  tournaments: z.lazy(() => TournamentCreateNestedManyWithoutQuestionsInputSchema).optional(),
  notifications: z.lazy(() => NotificationCreateNestedManyWithoutQuestionInputSchema).optional()
}).strict();

export const QuestionUncheckedCreateWithoutSharedWithListsInputSchema: z.ZodType<Prisma.QuestionUncheckedCreateWithoutSharedWithListsInput> = z.object({
  id: z.string().cuid().optional(),
  createdAt: z.coerce.date().optional(),
  comment: z.string().optional().nullable(),
  profileId: z.number().int().optional().nullable(),
  title: z.string(),
  type: z.lazy(() => QuestionTypeSchema).optional(),
  resolveBy: z.coerce.date(),
  resolved: z.boolean().optional(),
  pingedForResolution: z.boolean().optional(),
  resolution: z.lazy(() => ResolutionSchema).optional().nullable(),
  resolvedAt: z.coerce.date().optional().nullable(),
  notes: z.string().optional().nullable(),
  hideForecastsUntil: z.coerce.date().optional().nullable(),
  hideForecastsUntilPrediction: z.boolean().optional().nullable(),
  userId: z.string(),
  sharedPublicly: z.boolean().optional(),
  unlisted: z.boolean().optional(),
  exclusiveAnswers: z.boolean().optional().nullable(),
  options: z.lazy(() => QuestionOptionUncheckedCreateNestedManyWithoutQuestionInputSchema).optional(),
  forecasts: z.lazy(() => ForecastUncheckedCreateNestedManyWithoutQuestionInputSchema).optional(),
  pingResolveMessages: z.lazy(() => PingSlackMessageUncheckedCreateNestedManyWithoutQuestionInputSchema).optional(),
  sharedWith: z.lazy(() => UserUncheckedCreateNestedManyWithoutQuestionsSharedWithInputSchema).optional(),
  questionScores: z.lazy(() => QuestionScoreUncheckedCreateNestedManyWithoutQuestionInputSchema).optional(),
  questionMessages: z.lazy(() => QuestionSlackMessageUncheckedCreateNestedManyWithoutQuestionInputSchema).optional(),
  resolutionMessages: z.lazy(() => ResolutionSlackMessageUncheckedCreateNestedManyWithoutQuestionInputSchema).optional(),
  comments: z.lazy(() => CommentUncheckedCreateNestedManyWithoutQuestionInputSchema).optional(),
  tags: z.lazy(() => TagUncheckedCreateNestedManyWithoutQuestionsInputSchema).optional(),
  tournaments: z.lazy(() => TournamentUncheckedCreateNestedManyWithoutQuestionsInputSchema).optional(),
  notifications: z.lazy(() => NotificationUncheckedCreateNestedManyWithoutQuestionInputSchema).optional()
}).strict();

export const QuestionCreateOrConnectWithoutSharedWithListsInputSchema: z.ZodType<Prisma.QuestionCreateOrConnectWithoutSharedWithListsInput> = z.object({
  where: z.lazy(() => QuestionWhereUniqueInputSchema),
  create: z.union([ z.lazy(() => QuestionCreateWithoutSharedWithListsInputSchema),z.lazy(() => QuestionUncheckedCreateWithoutSharedWithListsInputSchema) ]),
}).strict();

export const TournamentCreateWithoutUserListInputSchema: z.ZodType<Prisma.TournamentCreateWithoutUserListInput> = z.object({
  id: z.string().cuid().optional(),
  createdAt: z.coerce.date().optional(),
  name: z.string(),
  description: z.string().optional().nullable(),
  sharedPublicly: z.boolean().optional(),
  unlisted: z.boolean().optional(),
  anyoneInListCanEdit: z.boolean().optional(),
  showLeaderboard: z.boolean().optional(),
  predictYourYear: z.number().int().optional().nullable(),
  syncToSlackTeamId: z.string().optional().nullable(),
  syncToSlackChannelId: z.string().optional().nullable(),
  questions: z.lazy(() => QuestionCreateNestedManyWithoutTournamentsInputSchema).optional(),
  author: z.lazy(() => UserCreateNestedOneWithoutTournamentsInputSchema)
}).strict();

export const TournamentUncheckedCreateWithoutUserListInputSchema: z.ZodType<Prisma.TournamentUncheckedCreateWithoutUserListInput> = z.object({
  id: z.string().cuid().optional(),
  createdAt: z.coerce.date().optional(),
  name: z.string(),
  description: z.string().optional().nullable(),
  authorId: z.string(),
  sharedPublicly: z.boolean().optional(),
  unlisted: z.boolean().optional(),
  anyoneInListCanEdit: z.boolean().optional(),
  showLeaderboard: z.boolean().optional(),
  predictYourYear: z.number().int().optional().nullable(),
  syncToSlackTeamId: z.string().optional().nullable(),
  syncToSlackChannelId: z.string().optional().nullable(),
  questions: z.lazy(() => QuestionUncheckedCreateNestedManyWithoutTournamentsInputSchema).optional()
}).strict();

export const TournamentCreateOrConnectWithoutUserListInputSchema: z.ZodType<Prisma.TournamentCreateOrConnectWithoutUserListInput> = z.object({
  where: z.lazy(() => TournamentWhereUniqueInputSchema),
  create: z.union([ z.lazy(() => TournamentCreateWithoutUserListInputSchema),z.lazy(() => TournamentUncheckedCreateWithoutUserListInputSchema) ]),
}).strict();

export const TournamentCreateManyUserListInputEnvelopeSchema: z.ZodType<Prisma.TournamentCreateManyUserListInputEnvelope> = z.object({
  data: z.union([ z.lazy(() => TournamentCreateManyUserListInputSchema),z.lazy(() => TournamentCreateManyUserListInputSchema).array() ]),
  skipDuplicates: z.boolean().optional()
}).strict();

export const UserUpsertWithoutAuthorOfListsInputSchema: z.ZodType<Prisma.UserUpsertWithoutAuthorOfListsInput> = z.object({
  update: z.union([ z.lazy(() => UserUpdateWithoutAuthorOfListsInputSchema),z.lazy(() => UserUncheckedUpdateWithoutAuthorOfListsInputSchema) ]),
  create: z.union([ z.lazy(() => UserCreateWithoutAuthorOfListsInputSchema),z.lazy(() => UserUncheckedCreateWithoutAuthorOfListsInputSchema) ]),
  where: z.lazy(() => UserWhereInputSchema).optional()
}).strict();

export const UserUpdateToOneWithWhereWithoutAuthorOfListsInputSchema: z.ZodType<Prisma.UserUpdateToOneWithWhereWithoutAuthorOfListsInput> = z.object({
  where: z.lazy(() => UserWhereInputSchema).optional(),
  data: z.union([ z.lazy(() => UserUpdateWithoutAuthorOfListsInputSchema),z.lazy(() => UserUncheckedUpdateWithoutAuthorOfListsInputSchema) ]),
}).strict();

export const UserUpdateWithoutAuthorOfListsInputSchema: z.ZodType<Prisma.UserUpdateWithoutAuthorOfListsInput> = z.object({
  id: z.union([ z.string().cuid(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  name: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  createdAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  email: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  image: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  staleReminder: z.union([ z.boolean(),z.lazy(() => BoolFieldUpdateOperationsInputSchema) ]).optional(),
  unsubscribedFromEmailsAt: z.union([ z.coerce.date(),z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  apiKey: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  discordUserId: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  emailVerified: z.union([ z.coerce.date(),z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  forecasts: z.lazy(() => ForecastUpdateManyWithoutUserNestedInputSchema).optional(),
  profiles: z.lazy(() => ProfileUpdateManyWithoutUserNestedInputSchema).optional(),
  questions: z.lazy(() => QuestionUpdateManyWithoutUserNestedInputSchema).optional(),
  questionScores: z.lazy(() => QuestionScoreUpdateManyWithoutUserNestedInputSchema).optional(),
  questionsSharedWith: z.lazy(() => QuestionUpdateManyWithoutSharedWithNestedInputSchema).optional(),
  comments: z.lazy(() => CommentUpdateManyWithoutUserNestedInputSchema).optional(),
  target: z.lazy(() => TargetUpdateOneWithoutUserNestedInputSchema).optional(),
  memberOfLists: z.lazy(() => UserListUpdateManyWithoutUsersNestedInputSchema).optional(),
  tags: z.lazy(() => TagUpdateManyWithoutUserNestedInputSchema).optional(),
  tournaments: z.lazy(() => TournamentUpdateManyWithoutAuthorNestedInputSchema).optional(),
  notifications: z.lazy(() => NotificationUpdateManyWithoutUserNestedInputSchema).optional(),
  questionOptions: z.lazy(() => QuestionOptionUpdateManyWithoutUserNestedInputSchema).optional(),
  accounts: z.lazy(() => AccountUpdateManyWithoutUserNestedInputSchema).optional()
}).strict();

export const UserUncheckedUpdateWithoutAuthorOfListsInputSchema: z.ZodType<Prisma.UserUncheckedUpdateWithoutAuthorOfListsInput> = z.object({
  id: z.union([ z.string().cuid(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  name: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  createdAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  email: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  image: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  staleReminder: z.union([ z.boolean(),z.lazy(() => BoolFieldUpdateOperationsInputSchema) ]).optional(),
  unsubscribedFromEmailsAt: z.union([ z.coerce.date(),z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  apiKey: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  discordUserId: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  emailVerified: z.union([ z.coerce.date(),z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  forecasts: z.lazy(() => ForecastUncheckedUpdateManyWithoutUserNestedInputSchema).optional(),
  profiles: z.lazy(() => ProfileUncheckedUpdateManyWithoutUserNestedInputSchema).optional(),
  questions: z.lazy(() => QuestionUncheckedUpdateManyWithoutUserNestedInputSchema).optional(),
  questionScores: z.lazy(() => QuestionScoreUncheckedUpdateManyWithoutUserNestedInputSchema).optional(),
  questionsSharedWith: z.lazy(() => QuestionUncheckedUpdateManyWithoutSharedWithNestedInputSchema).optional(),
  comments: z.lazy(() => CommentUncheckedUpdateManyWithoutUserNestedInputSchema).optional(),
  target: z.lazy(() => TargetUncheckedUpdateOneWithoutUserNestedInputSchema).optional(),
  memberOfLists: z.lazy(() => UserListUncheckedUpdateManyWithoutUsersNestedInputSchema).optional(),
  tags: z.lazy(() => TagUncheckedUpdateManyWithoutUserNestedInputSchema).optional(),
  tournaments: z.lazy(() => TournamentUncheckedUpdateManyWithoutAuthorNestedInputSchema).optional(),
  notifications: z.lazy(() => NotificationUncheckedUpdateManyWithoutUserNestedInputSchema).optional(),
  questionOptions: z.lazy(() => QuestionOptionUncheckedUpdateManyWithoutUserNestedInputSchema).optional(),
  accounts: z.lazy(() => AccountUncheckedUpdateManyWithoutUserNestedInputSchema).optional()
}).strict();

export const UserUpsertWithWhereUniqueWithoutMemberOfListsInputSchema: z.ZodType<Prisma.UserUpsertWithWhereUniqueWithoutMemberOfListsInput> = z.object({
  where: z.lazy(() => UserWhereUniqueInputSchema),
  update: z.union([ z.lazy(() => UserUpdateWithoutMemberOfListsInputSchema),z.lazy(() => UserUncheckedUpdateWithoutMemberOfListsInputSchema) ]),
  create: z.union([ z.lazy(() => UserCreateWithoutMemberOfListsInputSchema),z.lazy(() => UserUncheckedCreateWithoutMemberOfListsInputSchema) ]),
}).strict();

export const UserUpdateWithWhereUniqueWithoutMemberOfListsInputSchema: z.ZodType<Prisma.UserUpdateWithWhereUniqueWithoutMemberOfListsInput> = z.object({
  where: z.lazy(() => UserWhereUniqueInputSchema),
  data: z.union([ z.lazy(() => UserUpdateWithoutMemberOfListsInputSchema),z.lazy(() => UserUncheckedUpdateWithoutMemberOfListsInputSchema) ]),
}).strict();

export const UserUpdateManyWithWhereWithoutMemberOfListsInputSchema: z.ZodType<Prisma.UserUpdateManyWithWhereWithoutMemberOfListsInput> = z.object({
  where: z.lazy(() => UserScalarWhereInputSchema),
  data: z.union([ z.lazy(() => UserUpdateManyMutationInputSchema),z.lazy(() => UserUncheckedUpdateManyWithoutMemberOfListsInputSchema) ]),
}).strict();

export const QuestionUpsertWithWhereUniqueWithoutSharedWithListsInputSchema: z.ZodType<Prisma.QuestionUpsertWithWhereUniqueWithoutSharedWithListsInput> = z.object({
  where: z.lazy(() => QuestionWhereUniqueInputSchema),
  update: z.union([ z.lazy(() => QuestionUpdateWithoutSharedWithListsInputSchema),z.lazy(() => QuestionUncheckedUpdateWithoutSharedWithListsInputSchema) ]),
  create: z.union([ z.lazy(() => QuestionCreateWithoutSharedWithListsInputSchema),z.lazy(() => QuestionUncheckedCreateWithoutSharedWithListsInputSchema) ]),
}).strict();

export const QuestionUpdateWithWhereUniqueWithoutSharedWithListsInputSchema: z.ZodType<Prisma.QuestionUpdateWithWhereUniqueWithoutSharedWithListsInput> = z.object({
  where: z.lazy(() => QuestionWhereUniqueInputSchema),
  data: z.union([ z.lazy(() => QuestionUpdateWithoutSharedWithListsInputSchema),z.lazy(() => QuestionUncheckedUpdateWithoutSharedWithListsInputSchema) ]),
}).strict();

export const QuestionUpdateManyWithWhereWithoutSharedWithListsInputSchema: z.ZodType<Prisma.QuestionUpdateManyWithWhereWithoutSharedWithListsInput> = z.object({
  where: z.lazy(() => QuestionScalarWhereInputSchema),
  data: z.union([ z.lazy(() => QuestionUpdateManyMutationInputSchema),z.lazy(() => QuestionUncheckedUpdateManyWithoutSharedWithListsInputSchema) ]),
}).strict();

export const TournamentUpsertWithWhereUniqueWithoutUserListInputSchema: z.ZodType<Prisma.TournamentUpsertWithWhereUniqueWithoutUserListInput> = z.object({
  where: z.lazy(() => TournamentWhereUniqueInputSchema),
  update: z.union([ z.lazy(() => TournamentUpdateWithoutUserListInputSchema),z.lazy(() => TournamentUncheckedUpdateWithoutUserListInputSchema) ]),
  create: z.union([ z.lazy(() => TournamentCreateWithoutUserListInputSchema),z.lazy(() => TournamentUncheckedCreateWithoutUserListInputSchema) ]),
}).strict();

export const TournamentUpdateWithWhereUniqueWithoutUserListInputSchema: z.ZodType<Prisma.TournamentUpdateWithWhereUniqueWithoutUserListInput> = z.object({
  where: z.lazy(() => TournamentWhereUniqueInputSchema),
  data: z.union([ z.lazy(() => TournamentUpdateWithoutUserListInputSchema),z.lazy(() => TournamentUncheckedUpdateWithoutUserListInputSchema) ]),
}).strict();

export const TournamentUpdateManyWithWhereWithoutUserListInputSchema: z.ZodType<Prisma.TournamentUpdateManyWithWhereWithoutUserListInput> = z.object({
  where: z.lazy(() => TournamentScalarWhereInputSchema),
  data: z.union([ z.lazy(() => TournamentUpdateManyMutationInputSchema),z.lazy(() => TournamentUncheckedUpdateManyWithoutUserListInputSchema) ]),
}).strict();

export const QuestionCreateWithoutTournamentsInputSchema: z.ZodType<Prisma.QuestionCreateWithoutTournamentsInput> = z.object({
  id: z.string().cuid().optional(),
  createdAt: z.coerce.date().optional(),
  comment: z.string().optional().nullable(),
  title: z.string(),
  type: z.lazy(() => QuestionTypeSchema).optional(),
  resolveBy: z.coerce.date(),
  resolved: z.boolean().optional(),
  pingedForResolution: z.boolean().optional(),
  resolution: z.lazy(() => ResolutionSchema).optional().nullable(),
  resolvedAt: z.coerce.date().optional().nullable(),
  notes: z.string().optional().nullable(),
  hideForecastsUntil: z.coerce.date().optional().nullable(),
  hideForecastsUntilPrediction: z.boolean().optional().nullable(),
  sharedPublicly: z.boolean().optional(),
  unlisted: z.boolean().optional(),
  exclusiveAnswers: z.boolean().optional().nullable(),
  options: z.lazy(() => QuestionOptionCreateNestedManyWithoutQuestionInputSchema).optional(),
  forecasts: z.lazy(() => ForecastCreateNestedManyWithoutQuestionInputSchema).optional(),
  pingResolveMessages: z.lazy(() => PingSlackMessageCreateNestedManyWithoutQuestionInputSchema).optional(),
  profile: z.lazy(() => ProfileCreateNestedOneWithoutQuestionsInputSchema).optional(),
  user: z.lazy(() => UserCreateNestedOneWithoutQuestionsInputSchema),
  sharedWith: z.lazy(() => UserCreateNestedManyWithoutQuestionsSharedWithInputSchema).optional(),
  sharedWithLists: z.lazy(() => UserListCreateNestedManyWithoutQuestionsInputSchema).optional(),
  questionScores: z.lazy(() => QuestionScoreCreateNestedManyWithoutQuestionInputSchema).optional(),
  questionMessages: z.lazy(() => QuestionSlackMessageCreateNestedManyWithoutQuestionInputSchema).optional(),
  resolutionMessages: z.lazy(() => ResolutionSlackMessageCreateNestedManyWithoutQuestionInputSchema).optional(),
  comments: z.lazy(() => CommentCreateNestedManyWithoutQuestionInputSchema).optional(),
  tags: z.lazy(() => TagCreateNestedManyWithoutQuestionsInputSchema).optional(),
  notifications: z.lazy(() => NotificationCreateNestedManyWithoutQuestionInputSchema).optional()
}).strict();

export const QuestionUncheckedCreateWithoutTournamentsInputSchema: z.ZodType<Prisma.QuestionUncheckedCreateWithoutTournamentsInput> = z.object({
  id: z.string().cuid().optional(),
  createdAt: z.coerce.date().optional(),
  comment: z.string().optional().nullable(),
  profileId: z.number().int().optional().nullable(),
  title: z.string(),
  type: z.lazy(() => QuestionTypeSchema).optional(),
  resolveBy: z.coerce.date(),
  resolved: z.boolean().optional(),
  pingedForResolution: z.boolean().optional(),
  resolution: z.lazy(() => ResolutionSchema).optional().nullable(),
  resolvedAt: z.coerce.date().optional().nullable(),
  notes: z.string().optional().nullable(),
  hideForecastsUntil: z.coerce.date().optional().nullable(),
  hideForecastsUntilPrediction: z.boolean().optional().nullable(),
  userId: z.string(),
  sharedPublicly: z.boolean().optional(),
  unlisted: z.boolean().optional(),
  exclusiveAnswers: z.boolean().optional().nullable(),
  options: z.lazy(() => QuestionOptionUncheckedCreateNestedManyWithoutQuestionInputSchema).optional(),
  forecasts: z.lazy(() => ForecastUncheckedCreateNestedManyWithoutQuestionInputSchema).optional(),
  pingResolveMessages: z.lazy(() => PingSlackMessageUncheckedCreateNestedManyWithoutQuestionInputSchema).optional(),
  sharedWith: z.lazy(() => UserUncheckedCreateNestedManyWithoutQuestionsSharedWithInputSchema).optional(),
  sharedWithLists: z.lazy(() => UserListUncheckedCreateNestedManyWithoutQuestionsInputSchema).optional(),
  questionScores: z.lazy(() => QuestionScoreUncheckedCreateNestedManyWithoutQuestionInputSchema).optional(),
  questionMessages: z.lazy(() => QuestionSlackMessageUncheckedCreateNestedManyWithoutQuestionInputSchema).optional(),
  resolutionMessages: z.lazy(() => ResolutionSlackMessageUncheckedCreateNestedManyWithoutQuestionInputSchema).optional(),
  comments: z.lazy(() => CommentUncheckedCreateNestedManyWithoutQuestionInputSchema).optional(),
  tags: z.lazy(() => TagUncheckedCreateNestedManyWithoutQuestionsInputSchema).optional(),
  notifications: z.lazy(() => NotificationUncheckedCreateNestedManyWithoutQuestionInputSchema).optional()
}).strict();

export const QuestionCreateOrConnectWithoutTournamentsInputSchema: z.ZodType<Prisma.QuestionCreateOrConnectWithoutTournamentsInput> = z.object({
  where: z.lazy(() => QuestionWhereUniqueInputSchema),
  create: z.union([ z.lazy(() => QuestionCreateWithoutTournamentsInputSchema),z.lazy(() => QuestionUncheckedCreateWithoutTournamentsInputSchema) ]),
}).strict();

export const UserCreateWithoutTournamentsInputSchema: z.ZodType<Prisma.UserCreateWithoutTournamentsInput> = z.object({
  id: z.string().cuid().optional(),
  name: z.string().optional().nullable(),
  createdAt: z.coerce.date().optional(),
  email: z.string(),
  image: z.string().optional().nullable(),
  staleReminder: z.boolean().optional(),
  unsubscribedFromEmailsAt: z.coerce.date().optional().nullable(),
  apiKey: z.string().optional().nullable(),
  discordUserId: z.string().optional().nullable(),
  emailVerified: z.coerce.date().optional().nullable(),
  forecasts: z.lazy(() => ForecastCreateNestedManyWithoutUserInputSchema).optional(),
  profiles: z.lazy(() => ProfileCreateNestedManyWithoutUserInputSchema).optional(),
  questions: z.lazy(() => QuestionCreateNestedManyWithoutUserInputSchema).optional(),
  questionScores: z.lazy(() => QuestionScoreCreateNestedManyWithoutUserInputSchema).optional(),
  questionsSharedWith: z.lazy(() => QuestionCreateNestedManyWithoutSharedWithInputSchema).optional(),
  comments: z.lazy(() => CommentCreateNestedManyWithoutUserInputSchema).optional(),
  target: z.lazy(() => TargetCreateNestedOneWithoutUserInputSchema).optional(),
  authorOfLists: z.lazy(() => UserListCreateNestedManyWithoutAuthorInputSchema).optional(),
  memberOfLists: z.lazy(() => UserListCreateNestedManyWithoutUsersInputSchema).optional(),
  tags: z.lazy(() => TagCreateNestedManyWithoutUserInputSchema).optional(),
  notifications: z.lazy(() => NotificationCreateNestedManyWithoutUserInputSchema).optional(),
  questionOptions: z.lazy(() => QuestionOptionCreateNestedManyWithoutUserInputSchema).optional(),
  accounts: z.lazy(() => AccountCreateNestedManyWithoutUserInputSchema).optional()
}).strict();

export const UserUncheckedCreateWithoutTournamentsInputSchema: z.ZodType<Prisma.UserUncheckedCreateWithoutTournamentsInput> = z.object({
  id: z.string().cuid().optional(),
  name: z.string().optional().nullable(),
  createdAt: z.coerce.date().optional(),
  email: z.string(),
  image: z.string().optional().nullable(),
  staleReminder: z.boolean().optional(),
  unsubscribedFromEmailsAt: z.coerce.date().optional().nullable(),
  apiKey: z.string().optional().nullable(),
  discordUserId: z.string().optional().nullable(),
  emailVerified: z.coerce.date().optional().nullable(),
  forecasts: z.lazy(() => ForecastUncheckedCreateNestedManyWithoutUserInputSchema).optional(),
  profiles: z.lazy(() => ProfileUncheckedCreateNestedManyWithoutUserInputSchema).optional(),
  questions: z.lazy(() => QuestionUncheckedCreateNestedManyWithoutUserInputSchema).optional(),
  questionScores: z.lazy(() => QuestionScoreUncheckedCreateNestedManyWithoutUserInputSchema).optional(),
  questionsSharedWith: z.lazy(() => QuestionUncheckedCreateNestedManyWithoutSharedWithInputSchema).optional(),
  comments: z.lazy(() => CommentUncheckedCreateNestedManyWithoutUserInputSchema).optional(),
  target: z.lazy(() => TargetUncheckedCreateNestedOneWithoutUserInputSchema).optional(),
  authorOfLists: z.lazy(() => UserListUncheckedCreateNestedManyWithoutAuthorInputSchema).optional(),
  memberOfLists: z.lazy(() => UserListUncheckedCreateNestedManyWithoutUsersInputSchema).optional(),
  tags: z.lazy(() => TagUncheckedCreateNestedManyWithoutUserInputSchema).optional(),
  notifications: z.lazy(() => NotificationUncheckedCreateNestedManyWithoutUserInputSchema).optional(),
  questionOptions: z.lazy(() => QuestionOptionUncheckedCreateNestedManyWithoutUserInputSchema).optional(),
  accounts: z.lazy(() => AccountUncheckedCreateNestedManyWithoutUserInputSchema).optional()
}).strict();

export const UserCreateOrConnectWithoutTournamentsInputSchema: z.ZodType<Prisma.UserCreateOrConnectWithoutTournamentsInput> = z.object({
  where: z.lazy(() => UserWhereUniqueInputSchema),
  create: z.union([ z.lazy(() => UserCreateWithoutTournamentsInputSchema),z.lazy(() => UserUncheckedCreateWithoutTournamentsInputSchema) ]),
}).strict();

export const UserListCreateWithoutTournamentsInputSchema: z.ZodType<Prisma.UserListCreateWithoutTournamentsInput> = z.object({
  id: z.string().cuid().optional(),
  createdAt: z.coerce.date().optional(),
  inviteId: z.string().cuid().optional().nullable(),
  name: z.string(),
  emailDomains: z.union([ z.lazy(() => UserListCreateemailDomainsInputSchema),z.string().array() ]).optional(),
  syncToSlackTeamId: z.string().optional().nullable(),
  syncToSlackChannelId: z.string().optional().nullable(),
  author: z.lazy(() => UserCreateNestedOneWithoutAuthorOfListsInputSchema),
  users: z.lazy(() => UserCreateNestedManyWithoutMemberOfListsInputSchema).optional(),
  questions: z.lazy(() => QuestionCreateNestedManyWithoutSharedWithListsInputSchema).optional()
}).strict();

export const UserListUncheckedCreateWithoutTournamentsInputSchema: z.ZodType<Prisma.UserListUncheckedCreateWithoutTournamentsInput> = z.object({
  id: z.string().cuid().optional(),
  createdAt: z.coerce.date().optional(),
  inviteId: z.string().cuid().optional().nullable(),
  name: z.string(),
  emailDomains: z.union([ z.lazy(() => UserListCreateemailDomainsInputSchema),z.string().array() ]).optional(),
  syncToSlackTeamId: z.string().optional().nullable(),
  syncToSlackChannelId: z.string().optional().nullable(),
  authorId: z.string(),
  users: z.lazy(() => UserUncheckedCreateNestedManyWithoutMemberOfListsInputSchema).optional(),
  questions: z.lazy(() => QuestionUncheckedCreateNestedManyWithoutSharedWithListsInputSchema).optional()
}).strict();

export const UserListCreateOrConnectWithoutTournamentsInputSchema: z.ZodType<Prisma.UserListCreateOrConnectWithoutTournamentsInput> = z.object({
  where: z.lazy(() => UserListWhereUniqueInputSchema),
  create: z.union([ z.lazy(() => UserListCreateWithoutTournamentsInputSchema),z.lazy(() => UserListUncheckedCreateWithoutTournamentsInputSchema) ]),
}).strict();

export const QuestionUpsertWithWhereUniqueWithoutTournamentsInputSchema: z.ZodType<Prisma.QuestionUpsertWithWhereUniqueWithoutTournamentsInput> = z.object({
  where: z.lazy(() => QuestionWhereUniqueInputSchema),
  update: z.union([ z.lazy(() => QuestionUpdateWithoutTournamentsInputSchema),z.lazy(() => QuestionUncheckedUpdateWithoutTournamentsInputSchema) ]),
  create: z.union([ z.lazy(() => QuestionCreateWithoutTournamentsInputSchema),z.lazy(() => QuestionUncheckedCreateWithoutTournamentsInputSchema) ]),
}).strict();

export const QuestionUpdateWithWhereUniqueWithoutTournamentsInputSchema: z.ZodType<Prisma.QuestionUpdateWithWhereUniqueWithoutTournamentsInput> = z.object({
  where: z.lazy(() => QuestionWhereUniqueInputSchema),
  data: z.union([ z.lazy(() => QuestionUpdateWithoutTournamentsInputSchema),z.lazy(() => QuestionUncheckedUpdateWithoutTournamentsInputSchema) ]),
}).strict();

export const QuestionUpdateManyWithWhereWithoutTournamentsInputSchema: z.ZodType<Prisma.QuestionUpdateManyWithWhereWithoutTournamentsInput> = z.object({
  where: z.lazy(() => QuestionScalarWhereInputSchema),
  data: z.union([ z.lazy(() => QuestionUpdateManyMutationInputSchema),z.lazy(() => QuestionUncheckedUpdateManyWithoutTournamentsInputSchema) ]),
}).strict();

export const UserUpsertWithoutTournamentsInputSchema: z.ZodType<Prisma.UserUpsertWithoutTournamentsInput> = z.object({
  update: z.union([ z.lazy(() => UserUpdateWithoutTournamentsInputSchema),z.lazy(() => UserUncheckedUpdateWithoutTournamentsInputSchema) ]),
  create: z.union([ z.lazy(() => UserCreateWithoutTournamentsInputSchema),z.lazy(() => UserUncheckedCreateWithoutTournamentsInputSchema) ]),
  where: z.lazy(() => UserWhereInputSchema).optional()
}).strict();

export const UserUpdateToOneWithWhereWithoutTournamentsInputSchema: z.ZodType<Prisma.UserUpdateToOneWithWhereWithoutTournamentsInput> = z.object({
  where: z.lazy(() => UserWhereInputSchema).optional(),
  data: z.union([ z.lazy(() => UserUpdateWithoutTournamentsInputSchema),z.lazy(() => UserUncheckedUpdateWithoutTournamentsInputSchema) ]),
}).strict();

export const UserUpdateWithoutTournamentsInputSchema: z.ZodType<Prisma.UserUpdateWithoutTournamentsInput> = z.object({
  id: z.union([ z.string().cuid(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  name: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  createdAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  email: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  image: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  staleReminder: z.union([ z.boolean(),z.lazy(() => BoolFieldUpdateOperationsInputSchema) ]).optional(),
  unsubscribedFromEmailsAt: z.union([ z.coerce.date(),z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  apiKey: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  discordUserId: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  emailVerified: z.union([ z.coerce.date(),z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  forecasts: z.lazy(() => ForecastUpdateManyWithoutUserNestedInputSchema).optional(),
  profiles: z.lazy(() => ProfileUpdateManyWithoutUserNestedInputSchema).optional(),
  questions: z.lazy(() => QuestionUpdateManyWithoutUserNestedInputSchema).optional(),
  questionScores: z.lazy(() => QuestionScoreUpdateManyWithoutUserNestedInputSchema).optional(),
  questionsSharedWith: z.lazy(() => QuestionUpdateManyWithoutSharedWithNestedInputSchema).optional(),
  comments: z.lazy(() => CommentUpdateManyWithoutUserNestedInputSchema).optional(),
  target: z.lazy(() => TargetUpdateOneWithoutUserNestedInputSchema).optional(),
  authorOfLists: z.lazy(() => UserListUpdateManyWithoutAuthorNestedInputSchema).optional(),
  memberOfLists: z.lazy(() => UserListUpdateManyWithoutUsersNestedInputSchema).optional(),
  tags: z.lazy(() => TagUpdateManyWithoutUserNestedInputSchema).optional(),
  notifications: z.lazy(() => NotificationUpdateManyWithoutUserNestedInputSchema).optional(),
  questionOptions: z.lazy(() => QuestionOptionUpdateManyWithoutUserNestedInputSchema).optional(),
  accounts: z.lazy(() => AccountUpdateManyWithoutUserNestedInputSchema).optional()
}).strict();

export const UserUncheckedUpdateWithoutTournamentsInputSchema: z.ZodType<Prisma.UserUncheckedUpdateWithoutTournamentsInput> = z.object({
  id: z.union([ z.string().cuid(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  name: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  createdAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  email: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  image: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  staleReminder: z.union([ z.boolean(),z.lazy(() => BoolFieldUpdateOperationsInputSchema) ]).optional(),
  unsubscribedFromEmailsAt: z.union([ z.coerce.date(),z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  apiKey: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  discordUserId: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  emailVerified: z.union([ z.coerce.date(),z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  forecasts: z.lazy(() => ForecastUncheckedUpdateManyWithoutUserNestedInputSchema).optional(),
  profiles: z.lazy(() => ProfileUncheckedUpdateManyWithoutUserNestedInputSchema).optional(),
  questions: z.lazy(() => QuestionUncheckedUpdateManyWithoutUserNestedInputSchema).optional(),
  questionScores: z.lazy(() => QuestionScoreUncheckedUpdateManyWithoutUserNestedInputSchema).optional(),
  questionsSharedWith: z.lazy(() => QuestionUncheckedUpdateManyWithoutSharedWithNestedInputSchema).optional(),
  comments: z.lazy(() => CommentUncheckedUpdateManyWithoutUserNestedInputSchema).optional(),
  target: z.lazy(() => TargetUncheckedUpdateOneWithoutUserNestedInputSchema).optional(),
  authorOfLists: z.lazy(() => UserListUncheckedUpdateManyWithoutAuthorNestedInputSchema).optional(),
  memberOfLists: z.lazy(() => UserListUncheckedUpdateManyWithoutUsersNestedInputSchema).optional(),
  tags: z.lazy(() => TagUncheckedUpdateManyWithoutUserNestedInputSchema).optional(),
  notifications: z.lazy(() => NotificationUncheckedUpdateManyWithoutUserNestedInputSchema).optional(),
  questionOptions: z.lazy(() => QuestionOptionUncheckedUpdateManyWithoutUserNestedInputSchema).optional(),
  accounts: z.lazy(() => AccountUncheckedUpdateManyWithoutUserNestedInputSchema).optional()
}).strict();

export const UserListUpsertWithoutTournamentsInputSchema: z.ZodType<Prisma.UserListUpsertWithoutTournamentsInput> = z.object({
  update: z.union([ z.lazy(() => UserListUpdateWithoutTournamentsInputSchema),z.lazy(() => UserListUncheckedUpdateWithoutTournamentsInputSchema) ]),
  create: z.union([ z.lazy(() => UserListCreateWithoutTournamentsInputSchema),z.lazy(() => UserListUncheckedCreateWithoutTournamentsInputSchema) ]),
  where: z.lazy(() => UserListWhereInputSchema).optional()
}).strict();

export const UserListUpdateToOneWithWhereWithoutTournamentsInputSchema: z.ZodType<Prisma.UserListUpdateToOneWithWhereWithoutTournamentsInput> = z.object({
  where: z.lazy(() => UserListWhereInputSchema).optional(),
  data: z.union([ z.lazy(() => UserListUpdateWithoutTournamentsInputSchema),z.lazy(() => UserListUncheckedUpdateWithoutTournamentsInputSchema) ]),
}).strict();

export const UserListUpdateWithoutTournamentsInputSchema: z.ZodType<Prisma.UserListUpdateWithoutTournamentsInput> = z.object({
  id: z.union([ z.string().cuid(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  createdAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  inviteId: z.union([ z.string().cuid(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  name: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  emailDomains: z.union([ z.lazy(() => UserListUpdateemailDomainsInputSchema),z.string().array() ]).optional(),
  syncToSlackTeamId: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  syncToSlackChannelId: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  author: z.lazy(() => UserUpdateOneRequiredWithoutAuthorOfListsNestedInputSchema).optional(),
  users: z.lazy(() => UserUpdateManyWithoutMemberOfListsNestedInputSchema).optional(),
  questions: z.lazy(() => QuestionUpdateManyWithoutSharedWithListsNestedInputSchema).optional()
}).strict();

export const UserListUncheckedUpdateWithoutTournamentsInputSchema: z.ZodType<Prisma.UserListUncheckedUpdateWithoutTournamentsInput> = z.object({
  id: z.union([ z.string().cuid(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  createdAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  inviteId: z.union([ z.string().cuid(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  name: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  emailDomains: z.union([ z.lazy(() => UserListUpdateemailDomainsInputSchema),z.string().array() ]).optional(),
  syncToSlackTeamId: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  syncToSlackChannelId: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  authorId: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  users: z.lazy(() => UserUncheckedUpdateManyWithoutMemberOfListsNestedInputSchema).optional(),
  questions: z.lazy(() => QuestionUncheckedUpdateManyWithoutSharedWithListsNestedInputSchema).optional()
}).strict();

export const UserCreateWithoutNotificationsInputSchema: z.ZodType<Prisma.UserCreateWithoutNotificationsInput> = z.object({
  id: z.string().cuid().optional(),
  name: z.string().optional().nullable(),
  createdAt: z.coerce.date().optional(),
  email: z.string(),
  image: z.string().optional().nullable(),
  staleReminder: z.boolean().optional(),
  unsubscribedFromEmailsAt: z.coerce.date().optional().nullable(),
  apiKey: z.string().optional().nullable(),
  discordUserId: z.string().optional().nullable(),
  emailVerified: z.coerce.date().optional().nullable(),
  forecasts: z.lazy(() => ForecastCreateNestedManyWithoutUserInputSchema).optional(),
  profiles: z.lazy(() => ProfileCreateNestedManyWithoutUserInputSchema).optional(),
  questions: z.lazy(() => QuestionCreateNestedManyWithoutUserInputSchema).optional(),
  questionScores: z.lazy(() => QuestionScoreCreateNestedManyWithoutUserInputSchema).optional(),
  questionsSharedWith: z.lazy(() => QuestionCreateNestedManyWithoutSharedWithInputSchema).optional(),
  comments: z.lazy(() => CommentCreateNestedManyWithoutUserInputSchema).optional(),
  target: z.lazy(() => TargetCreateNestedOneWithoutUserInputSchema).optional(),
  authorOfLists: z.lazy(() => UserListCreateNestedManyWithoutAuthorInputSchema).optional(),
  memberOfLists: z.lazy(() => UserListCreateNestedManyWithoutUsersInputSchema).optional(),
  tags: z.lazy(() => TagCreateNestedManyWithoutUserInputSchema).optional(),
  tournaments: z.lazy(() => TournamentCreateNestedManyWithoutAuthorInputSchema).optional(),
  questionOptions: z.lazy(() => QuestionOptionCreateNestedManyWithoutUserInputSchema).optional(),
  accounts: z.lazy(() => AccountCreateNestedManyWithoutUserInputSchema).optional()
}).strict();

export const UserUncheckedCreateWithoutNotificationsInputSchema: z.ZodType<Prisma.UserUncheckedCreateWithoutNotificationsInput> = z.object({
  id: z.string().cuid().optional(),
  name: z.string().optional().nullable(),
  createdAt: z.coerce.date().optional(),
  email: z.string(),
  image: z.string().optional().nullable(),
  staleReminder: z.boolean().optional(),
  unsubscribedFromEmailsAt: z.coerce.date().optional().nullable(),
  apiKey: z.string().optional().nullable(),
  discordUserId: z.string().optional().nullable(),
  emailVerified: z.coerce.date().optional().nullable(),
  forecasts: z.lazy(() => ForecastUncheckedCreateNestedManyWithoutUserInputSchema).optional(),
  profiles: z.lazy(() => ProfileUncheckedCreateNestedManyWithoutUserInputSchema).optional(),
  questions: z.lazy(() => QuestionUncheckedCreateNestedManyWithoutUserInputSchema).optional(),
  questionScores: z.lazy(() => QuestionScoreUncheckedCreateNestedManyWithoutUserInputSchema).optional(),
  questionsSharedWith: z.lazy(() => QuestionUncheckedCreateNestedManyWithoutSharedWithInputSchema).optional(),
  comments: z.lazy(() => CommentUncheckedCreateNestedManyWithoutUserInputSchema).optional(),
  target: z.lazy(() => TargetUncheckedCreateNestedOneWithoutUserInputSchema).optional(),
  authorOfLists: z.lazy(() => UserListUncheckedCreateNestedManyWithoutAuthorInputSchema).optional(),
  memberOfLists: z.lazy(() => UserListUncheckedCreateNestedManyWithoutUsersInputSchema).optional(),
  tags: z.lazy(() => TagUncheckedCreateNestedManyWithoutUserInputSchema).optional(),
  tournaments: z.lazy(() => TournamentUncheckedCreateNestedManyWithoutAuthorInputSchema).optional(),
  questionOptions: z.lazy(() => QuestionOptionUncheckedCreateNestedManyWithoutUserInputSchema).optional(),
  accounts: z.lazy(() => AccountUncheckedCreateNestedManyWithoutUserInputSchema).optional()
}).strict();

export const UserCreateOrConnectWithoutNotificationsInputSchema: z.ZodType<Prisma.UserCreateOrConnectWithoutNotificationsInput> = z.object({
  where: z.lazy(() => UserWhereUniqueInputSchema),
  create: z.union([ z.lazy(() => UserCreateWithoutNotificationsInputSchema),z.lazy(() => UserUncheckedCreateWithoutNotificationsInputSchema) ]),
}).strict();

export const QuestionCreateWithoutNotificationsInputSchema: z.ZodType<Prisma.QuestionCreateWithoutNotificationsInput> = z.object({
  id: z.string().cuid().optional(),
  createdAt: z.coerce.date().optional(),
  comment: z.string().optional().nullable(),
  title: z.string(),
  type: z.lazy(() => QuestionTypeSchema).optional(),
  resolveBy: z.coerce.date(),
  resolved: z.boolean().optional(),
  pingedForResolution: z.boolean().optional(),
  resolution: z.lazy(() => ResolutionSchema).optional().nullable(),
  resolvedAt: z.coerce.date().optional().nullable(),
  notes: z.string().optional().nullable(),
  hideForecastsUntil: z.coerce.date().optional().nullable(),
  hideForecastsUntilPrediction: z.boolean().optional().nullable(),
  sharedPublicly: z.boolean().optional(),
  unlisted: z.boolean().optional(),
  exclusiveAnswers: z.boolean().optional().nullable(),
  options: z.lazy(() => QuestionOptionCreateNestedManyWithoutQuestionInputSchema).optional(),
  forecasts: z.lazy(() => ForecastCreateNestedManyWithoutQuestionInputSchema).optional(),
  pingResolveMessages: z.lazy(() => PingSlackMessageCreateNestedManyWithoutQuestionInputSchema).optional(),
  profile: z.lazy(() => ProfileCreateNestedOneWithoutQuestionsInputSchema).optional(),
  user: z.lazy(() => UserCreateNestedOneWithoutQuestionsInputSchema),
  sharedWith: z.lazy(() => UserCreateNestedManyWithoutQuestionsSharedWithInputSchema).optional(),
  sharedWithLists: z.lazy(() => UserListCreateNestedManyWithoutQuestionsInputSchema).optional(),
  questionScores: z.lazy(() => QuestionScoreCreateNestedManyWithoutQuestionInputSchema).optional(),
  questionMessages: z.lazy(() => QuestionSlackMessageCreateNestedManyWithoutQuestionInputSchema).optional(),
  resolutionMessages: z.lazy(() => ResolutionSlackMessageCreateNestedManyWithoutQuestionInputSchema).optional(),
  comments: z.lazy(() => CommentCreateNestedManyWithoutQuestionInputSchema).optional(),
  tags: z.lazy(() => TagCreateNestedManyWithoutQuestionsInputSchema).optional(),
  tournaments: z.lazy(() => TournamentCreateNestedManyWithoutQuestionsInputSchema).optional()
}).strict();

export const QuestionUncheckedCreateWithoutNotificationsInputSchema: z.ZodType<Prisma.QuestionUncheckedCreateWithoutNotificationsInput> = z.object({
  id: z.string().cuid().optional(),
  createdAt: z.coerce.date().optional(),
  comment: z.string().optional().nullable(),
  profileId: z.number().int().optional().nullable(),
  title: z.string(),
  type: z.lazy(() => QuestionTypeSchema).optional(),
  resolveBy: z.coerce.date(),
  resolved: z.boolean().optional(),
  pingedForResolution: z.boolean().optional(),
  resolution: z.lazy(() => ResolutionSchema).optional().nullable(),
  resolvedAt: z.coerce.date().optional().nullable(),
  notes: z.string().optional().nullable(),
  hideForecastsUntil: z.coerce.date().optional().nullable(),
  hideForecastsUntilPrediction: z.boolean().optional().nullable(),
  userId: z.string(),
  sharedPublicly: z.boolean().optional(),
  unlisted: z.boolean().optional(),
  exclusiveAnswers: z.boolean().optional().nullable(),
  options: z.lazy(() => QuestionOptionUncheckedCreateNestedManyWithoutQuestionInputSchema).optional(),
  forecasts: z.lazy(() => ForecastUncheckedCreateNestedManyWithoutQuestionInputSchema).optional(),
  pingResolveMessages: z.lazy(() => PingSlackMessageUncheckedCreateNestedManyWithoutQuestionInputSchema).optional(),
  sharedWith: z.lazy(() => UserUncheckedCreateNestedManyWithoutQuestionsSharedWithInputSchema).optional(),
  sharedWithLists: z.lazy(() => UserListUncheckedCreateNestedManyWithoutQuestionsInputSchema).optional(),
  questionScores: z.lazy(() => QuestionScoreUncheckedCreateNestedManyWithoutQuestionInputSchema).optional(),
  questionMessages: z.lazy(() => QuestionSlackMessageUncheckedCreateNestedManyWithoutQuestionInputSchema).optional(),
  resolutionMessages: z.lazy(() => ResolutionSlackMessageUncheckedCreateNestedManyWithoutQuestionInputSchema).optional(),
  comments: z.lazy(() => CommentUncheckedCreateNestedManyWithoutQuestionInputSchema).optional(),
  tags: z.lazy(() => TagUncheckedCreateNestedManyWithoutQuestionsInputSchema).optional(),
  tournaments: z.lazy(() => TournamentUncheckedCreateNestedManyWithoutQuestionsInputSchema).optional()
}).strict();

export const QuestionCreateOrConnectWithoutNotificationsInputSchema: z.ZodType<Prisma.QuestionCreateOrConnectWithoutNotificationsInput> = z.object({
  where: z.lazy(() => QuestionWhereUniqueInputSchema),
  create: z.union([ z.lazy(() => QuestionCreateWithoutNotificationsInputSchema),z.lazy(() => QuestionUncheckedCreateWithoutNotificationsInputSchema) ]),
}).strict();

export const UserUpsertWithoutNotificationsInputSchema: z.ZodType<Prisma.UserUpsertWithoutNotificationsInput> = z.object({
  update: z.union([ z.lazy(() => UserUpdateWithoutNotificationsInputSchema),z.lazy(() => UserUncheckedUpdateWithoutNotificationsInputSchema) ]),
  create: z.union([ z.lazy(() => UserCreateWithoutNotificationsInputSchema),z.lazy(() => UserUncheckedCreateWithoutNotificationsInputSchema) ]),
  where: z.lazy(() => UserWhereInputSchema).optional()
}).strict();

export const UserUpdateToOneWithWhereWithoutNotificationsInputSchema: z.ZodType<Prisma.UserUpdateToOneWithWhereWithoutNotificationsInput> = z.object({
  where: z.lazy(() => UserWhereInputSchema).optional(),
  data: z.union([ z.lazy(() => UserUpdateWithoutNotificationsInputSchema),z.lazy(() => UserUncheckedUpdateWithoutNotificationsInputSchema) ]),
}).strict();

export const UserUpdateWithoutNotificationsInputSchema: z.ZodType<Prisma.UserUpdateWithoutNotificationsInput> = z.object({
  id: z.union([ z.string().cuid(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  name: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  createdAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  email: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  image: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  staleReminder: z.union([ z.boolean(),z.lazy(() => BoolFieldUpdateOperationsInputSchema) ]).optional(),
  unsubscribedFromEmailsAt: z.union([ z.coerce.date(),z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  apiKey: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  discordUserId: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  emailVerified: z.union([ z.coerce.date(),z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  forecasts: z.lazy(() => ForecastUpdateManyWithoutUserNestedInputSchema).optional(),
  profiles: z.lazy(() => ProfileUpdateManyWithoutUserNestedInputSchema).optional(),
  questions: z.lazy(() => QuestionUpdateManyWithoutUserNestedInputSchema).optional(),
  questionScores: z.lazy(() => QuestionScoreUpdateManyWithoutUserNestedInputSchema).optional(),
  questionsSharedWith: z.lazy(() => QuestionUpdateManyWithoutSharedWithNestedInputSchema).optional(),
  comments: z.lazy(() => CommentUpdateManyWithoutUserNestedInputSchema).optional(),
  target: z.lazy(() => TargetUpdateOneWithoutUserNestedInputSchema).optional(),
  authorOfLists: z.lazy(() => UserListUpdateManyWithoutAuthorNestedInputSchema).optional(),
  memberOfLists: z.lazy(() => UserListUpdateManyWithoutUsersNestedInputSchema).optional(),
  tags: z.lazy(() => TagUpdateManyWithoutUserNestedInputSchema).optional(),
  tournaments: z.lazy(() => TournamentUpdateManyWithoutAuthorNestedInputSchema).optional(),
  questionOptions: z.lazy(() => QuestionOptionUpdateManyWithoutUserNestedInputSchema).optional(),
  accounts: z.lazy(() => AccountUpdateManyWithoutUserNestedInputSchema).optional()
}).strict();

export const UserUncheckedUpdateWithoutNotificationsInputSchema: z.ZodType<Prisma.UserUncheckedUpdateWithoutNotificationsInput> = z.object({
  id: z.union([ z.string().cuid(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  name: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  createdAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  email: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  image: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  staleReminder: z.union([ z.boolean(),z.lazy(() => BoolFieldUpdateOperationsInputSchema) ]).optional(),
  unsubscribedFromEmailsAt: z.union([ z.coerce.date(),z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  apiKey: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  discordUserId: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  emailVerified: z.union([ z.coerce.date(),z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  forecasts: z.lazy(() => ForecastUncheckedUpdateManyWithoutUserNestedInputSchema).optional(),
  profiles: z.lazy(() => ProfileUncheckedUpdateManyWithoutUserNestedInputSchema).optional(),
  questions: z.lazy(() => QuestionUncheckedUpdateManyWithoutUserNestedInputSchema).optional(),
  questionScores: z.lazy(() => QuestionScoreUncheckedUpdateManyWithoutUserNestedInputSchema).optional(),
  questionsSharedWith: z.lazy(() => QuestionUncheckedUpdateManyWithoutSharedWithNestedInputSchema).optional(),
  comments: z.lazy(() => CommentUncheckedUpdateManyWithoutUserNestedInputSchema).optional(),
  target: z.lazy(() => TargetUncheckedUpdateOneWithoutUserNestedInputSchema).optional(),
  authorOfLists: z.lazy(() => UserListUncheckedUpdateManyWithoutAuthorNestedInputSchema).optional(),
  memberOfLists: z.lazy(() => UserListUncheckedUpdateManyWithoutUsersNestedInputSchema).optional(),
  tags: z.lazy(() => TagUncheckedUpdateManyWithoutUserNestedInputSchema).optional(),
  tournaments: z.lazy(() => TournamentUncheckedUpdateManyWithoutAuthorNestedInputSchema).optional(),
  questionOptions: z.lazy(() => QuestionOptionUncheckedUpdateManyWithoutUserNestedInputSchema).optional(),
  accounts: z.lazy(() => AccountUncheckedUpdateManyWithoutUserNestedInputSchema).optional()
}).strict();

export const QuestionUpsertWithoutNotificationsInputSchema: z.ZodType<Prisma.QuestionUpsertWithoutNotificationsInput> = z.object({
  update: z.union([ z.lazy(() => QuestionUpdateWithoutNotificationsInputSchema),z.lazy(() => QuestionUncheckedUpdateWithoutNotificationsInputSchema) ]),
  create: z.union([ z.lazy(() => QuestionCreateWithoutNotificationsInputSchema),z.lazy(() => QuestionUncheckedCreateWithoutNotificationsInputSchema) ]),
  where: z.lazy(() => QuestionWhereInputSchema).optional()
}).strict();

export const QuestionUpdateToOneWithWhereWithoutNotificationsInputSchema: z.ZodType<Prisma.QuestionUpdateToOneWithWhereWithoutNotificationsInput> = z.object({
  where: z.lazy(() => QuestionWhereInputSchema).optional(),
  data: z.union([ z.lazy(() => QuestionUpdateWithoutNotificationsInputSchema),z.lazy(() => QuestionUncheckedUpdateWithoutNotificationsInputSchema) ]),
}).strict();

export const QuestionUpdateWithoutNotificationsInputSchema: z.ZodType<Prisma.QuestionUpdateWithoutNotificationsInput> = z.object({
  id: z.union([ z.string().cuid(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  createdAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  comment: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  title: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  type: z.union([ z.lazy(() => QuestionTypeSchema),z.lazy(() => EnumQuestionTypeFieldUpdateOperationsInputSchema) ]).optional(),
  resolveBy: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  resolved: z.union([ z.boolean(),z.lazy(() => BoolFieldUpdateOperationsInputSchema) ]).optional(),
  pingedForResolution: z.union([ z.boolean(),z.lazy(() => BoolFieldUpdateOperationsInputSchema) ]).optional(),
  resolution: z.union([ z.lazy(() => ResolutionSchema),z.lazy(() => NullableEnumResolutionFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  resolvedAt: z.union([ z.coerce.date(),z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  notes: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  hideForecastsUntil: z.union([ z.coerce.date(),z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  hideForecastsUntilPrediction: z.union([ z.boolean(),z.lazy(() => NullableBoolFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  sharedPublicly: z.union([ z.boolean(),z.lazy(() => BoolFieldUpdateOperationsInputSchema) ]).optional(),
  unlisted: z.union([ z.boolean(),z.lazy(() => BoolFieldUpdateOperationsInputSchema) ]).optional(),
  exclusiveAnswers: z.union([ z.boolean(),z.lazy(() => NullableBoolFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  options: z.lazy(() => QuestionOptionUpdateManyWithoutQuestionNestedInputSchema).optional(),
  forecasts: z.lazy(() => ForecastUpdateManyWithoutQuestionNestedInputSchema).optional(),
  pingResolveMessages: z.lazy(() => PingSlackMessageUpdateManyWithoutQuestionNestedInputSchema).optional(),
  profile: z.lazy(() => ProfileUpdateOneWithoutQuestionsNestedInputSchema).optional(),
  user: z.lazy(() => UserUpdateOneRequiredWithoutQuestionsNestedInputSchema).optional(),
  sharedWith: z.lazy(() => UserUpdateManyWithoutQuestionsSharedWithNestedInputSchema).optional(),
  sharedWithLists: z.lazy(() => UserListUpdateManyWithoutQuestionsNestedInputSchema).optional(),
  questionScores: z.lazy(() => QuestionScoreUpdateManyWithoutQuestionNestedInputSchema).optional(),
  questionMessages: z.lazy(() => QuestionSlackMessageUpdateManyWithoutQuestionNestedInputSchema).optional(),
  resolutionMessages: z.lazy(() => ResolutionSlackMessageUpdateManyWithoutQuestionNestedInputSchema).optional(),
  comments: z.lazy(() => CommentUpdateManyWithoutQuestionNestedInputSchema).optional(),
  tags: z.lazy(() => TagUpdateManyWithoutQuestionsNestedInputSchema).optional(),
  tournaments: z.lazy(() => TournamentUpdateManyWithoutQuestionsNestedInputSchema).optional()
}).strict();

export const QuestionUncheckedUpdateWithoutNotificationsInputSchema: z.ZodType<Prisma.QuestionUncheckedUpdateWithoutNotificationsInput> = z.object({
  id: z.union([ z.string().cuid(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  createdAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  comment: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  profileId: z.union([ z.number().int(),z.lazy(() => NullableIntFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  title: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  type: z.union([ z.lazy(() => QuestionTypeSchema),z.lazy(() => EnumQuestionTypeFieldUpdateOperationsInputSchema) ]).optional(),
  resolveBy: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  resolved: z.union([ z.boolean(),z.lazy(() => BoolFieldUpdateOperationsInputSchema) ]).optional(),
  pingedForResolution: z.union([ z.boolean(),z.lazy(() => BoolFieldUpdateOperationsInputSchema) ]).optional(),
  resolution: z.union([ z.lazy(() => ResolutionSchema),z.lazy(() => NullableEnumResolutionFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  resolvedAt: z.union([ z.coerce.date(),z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  notes: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  hideForecastsUntil: z.union([ z.coerce.date(),z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  hideForecastsUntilPrediction: z.union([ z.boolean(),z.lazy(() => NullableBoolFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  userId: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  sharedPublicly: z.union([ z.boolean(),z.lazy(() => BoolFieldUpdateOperationsInputSchema) ]).optional(),
  unlisted: z.union([ z.boolean(),z.lazy(() => BoolFieldUpdateOperationsInputSchema) ]).optional(),
  exclusiveAnswers: z.union([ z.boolean(),z.lazy(() => NullableBoolFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  options: z.lazy(() => QuestionOptionUncheckedUpdateManyWithoutQuestionNestedInputSchema).optional(),
  forecasts: z.lazy(() => ForecastUncheckedUpdateManyWithoutQuestionNestedInputSchema).optional(),
  pingResolveMessages: z.lazy(() => PingSlackMessageUncheckedUpdateManyWithoutQuestionNestedInputSchema).optional(),
  sharedWith: z.lazy(() => UserUncheckedUpdateManyWithoutQuestionsSharedWithNestedInputSchema).optional(),
  sharedWithLists: z.lazy(() => UserListUncheckedUpdateManyWithoutQuestionsNestedInputSchema).optional(),
  questionScores: z.lazy(() => QuestionScoreUncheckedUpdateManyWithoutQuestionNestedInputSchema).optional(),
  questionMessages: z.lazy(() => QuestionSlackMessageUncheckedUpdateManyWithoutQuestionNestedInputSchema).optional(),
  resolutionMessages: z.lazy(() => ResolutionSlackMessageUncheckedUpdateManyWithoutQuestionNestedInputSchema).optional(),
  comments: z.lazy(() => CommentUncheckedUpdateManyWithoutQuestionNestedInputSchema).optional(),
  tags: z.lazy(() => TagUncheckedUpdateManyWithoutQuestionsNestedInputSchema).optional(),
  tournaments: z.lazy(() => TournamentUncheckedUpdateManyWithoutQuestionsNestedInputSchema).optional()
}).strict();

export const ForecastCreateManyOptionInputSchema: z.ZodType<Prisma.ForecastCreateManyOptionInput> = z.object({
  id: z.number().int().optional(),
  createdAt: z.coerce.date().optional(),
  comment: z.string().optional().nullable(),
  forecast: z.union([z.number(),z.string(),z.instanceof(Decimal),z.instanceof(Prisma.Decimal),DecimalJsLikeSchema,]).refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' }),
  profileId: z.number().int().optional().nullable(),
  questionId: z.string(),
  userId: z.string()
}).strict();

export const QuestionScoreCreateManyQuestionOptionInputSchema: z.ZodType<Prisma.QuestionScoreCreateManyQuestionOptionInput> = z.object({
  id: z.number().int().optional(),
  createdAt: z.coerce.date().optional(),
  relativeScore: z.union([z.number(),z.string(),z.instanceof(Decimal),z.instanceof(Prisma.Decimal),DecimalJsLikeSchema,]).refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' }).optional().nullable(),
  questionId: z.string(),
  userQuestionComboId: z.string(),
  absoluteScore: z.union([z.number(),z.string(),z.instanceof(Decimal),z.instanceof(Prisma.Decimal),DecimalJsLikeSchema,]).refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' }),
  rank: z.number().int(),
  userId: z.string()
}).strict();

export const ForecastUpdateWithoutOptionInputSchema: z.ZodType<Prisma.ForecastUpdateWithoutOptionInput> = z.object({
  createdAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  comment: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  forecast: z.union([ z.union([z.number(),z.string(),z.instanceof(Decimal),z.instanceof(Prisma.Decimal),DecimalJsLikeSchema,]).refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' }),z.lazy(() => DecimalFieldUpdateOperationsInputSchema) ]).optional(),
  profile: z.lazy(() => ProfileUpdateOneWithoutForecastsNestedInputSchema).optional(),
  question: z.lazy(() => QuestionUpdateOneRequiredWithoutForecastsNestedInputSchema).optional(),
  user: z.lazy(() => UserUpdateOneRequiredWithoutForecastsNestedInputSchema).optional()
}).strict();

export const ForecastUncheckedUpdateWithoutOptionInputSchema: z.ZodType<Prisma.ForecastUncheckedUpdateWithoutOptionInput> = z.object({
  id: z.union([ z.number().int(),z.lazy(() => IntFieldUpdateOperationsInputSchema) ]).optional(),
  createdAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  comment: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  forecast: z.union([ z.union([z.number(),z.string(),z.instanceof(Decimal),z.instanceof(Prisma.Decimal),DecimalJsLikeSchema,]).refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' }),z.lazy(() => DecimalFieldUpdateOperationsInputSchema) ]).optional(),
  profileId: z.union([ z.number().int(),z.lazy(() => NullableIntFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  questionId: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  userId: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
}).strict();

export const ForecastUncheckedUpdateManyWithoutOptionInputSchema: z.ZodType<Prisma.ForecastUncheckedUpdateManyWithoutOptionInput> = z.object({
  id: z.union([ z.number().int(),z.lazy(() => IntFieldUpdateOperationsInputSchema) ]).optional(),
  createdAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  comment: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  forecast: z.union([ z.union([z.number(),z.string(),z.instanceof(Decimal),z.instanceof(Prisma.Decimal),DecimalJsLikeSchema,]).refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' }),z.lazy(() => DecimalFieldUpdateOperationsInputSchema) ]).optional(),
  profileId: z.union([ z.number().int(),z.lazy(() => NullableIntFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  questionId: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  userId: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
}).strict();

export const QuestionScoreUpdateWithoutQuestionOptionInputSchema: z.ZodType<Prisma.QuestionScoreUpdateWithoutQuestionOptionInput> = z.object({
  createdAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  relativeScore: z.union([ z.union([z.number(),z.string(),z.instanceof(Decimal),z.instanceof(Prisma.Decimal),DecimalJsLikeSchema,]).refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' }),z.lazy(() => NullableDecimalFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  userQuestionComboId: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  absoluteScore: z.union([ z.union([z.number(),z.string(),z.instanceof(Decimal),z.instanceof(Prisma.Decimal),DecimalJsLikeSchema,]).refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' }),z.lazy(() => DecimalFieldUpdateOperationsInputSchema) ]).optional(),
  rank: z.union([ z.number().int(),z.lazy(() => IntFieldUpdateOperationsInputSchema) ]).optional(),
  question: z.lazy(() => QuestionUpdateOneRequiredWithoutQuestionScoresNestedInputSchema).optional(),
  user: z.lazy(() => UserUpdateOneRequiredWithoutQuestionScoresNestedInputSchema).optional()
}).strict();

export const QuestionScoreUncheckedUpdateWithoutQuestionOptionInputSchema: z.ZodType<Prisma.QuestionScoreUncheckedUpdateWithoutQuestionOptionInput> = z.object({
  id: z.union([ z.number().int(),z.lazy(() => IntFieldUpdateOperationsInputSchema) ]).optional(),
  createdAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  relativeScore: z.union([ z.union([z.number(),z.string(),z.instanceof(Decimal),z.instanceof(Prisma.Decimal),DecimalJsLikeSchema,]).refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' }),z.lazy(() => NullableDecimalFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  questionId: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  userQuestionComboId: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  absoluteScore: z.union([ z.union([z.number(),z.string(),z.instanceof(Decimal),z.instanceof(Prisma.Decimal),DecimalJsLikeSchema,]).refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' }),z.lazy(() => DecimalFieldUpdateOperationsInputSchema) ]).optional(),
  rank: z.union([ z.number().int(),z.lazy(() => IntFieldUpdateOperationsInputSchema) ]).optional(),
  userId: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
}).strict();

export const QuestionScoreUncheckedUpdateManyWithoutQuestionOptionInputSchema: z.ZodType<Prisma.QuestionScoreUncheckedUpdateManyWithoutQuestionOptionInput> = z.object({
  id: z.union([ z.number().int(),z.lazy(() => IntFieldUpdateOperationsInputSchema) ]).optional(),
  createdAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  relativeScore: z.union([ z.union([z.number(),z.string(),z.instanceof(Decimal),z.instanceof(Prisma.Decimal),DecimalJsLikeSchema,]).refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' }),z.lazy(() => NullableDecimalFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  questionId: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  userQuestionComboId: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  absoluteScore: z.union([ z.union([z.number(),z.string(),z.instanceof(Decimal),z.instanceof(Prisma.Decimal),DecimalJsLikeSchema,]).refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' }),z.lazy(() => DecimalFieldUpdateOperationsInputSchema) ]).optional(),
  rank: z.union([ z.number().int(),z.lazy(() => IntFieldUpdateOperationsInputSchema) ]).optional(),
  userId: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
}).strict();

export const QuestionOptionCreateManyQuestionInputSchema: z.ZodType<Prisma.QuestionOptionCreateManyQuestionInput> = z.object({
  id: z.string().cuid().optional(),
  text: z.string(),
  resolution: z.lazy(() => ResolutionSchema).optional().nullable(),
  createdAt: z.coerce.date().optional(),
  userId: z.string(),
  resolvedAt: z.coerce.date().optional().nullable()
}).strict();

export const ForecastCreateManyQuestionInputSchema: z.ZodType<Prisma.ForecastCreateManyQuestionInput> = z.object({
  id: z.number().int().optional(),
  createdAt: z.coerce.date().optional(),
  comment: z.string().optional().nullable(),
  forecast: z.union([z.number(),z.string(),z.instanceof(Decimal),z.instanceof(Prisma.Decimal),DecimalJsLikeSchema,]).refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' }),
  profileId: z.number().int().optional().nullable(),
  optionId: z.string().optional().nullable(),
  userId: z.string()
}).strict();

export const PingSlackMessageCreateManyQuestionInputSchema: z.ZodType<Prisma.PingSlackMessageCreateManyQuestionInput> = z.object({
  id: z.number().int().optional(),
  detailsId: z.number().int()
}).strict();

export const QuestionScoreCreateManyQuestionInputSchema: z.ZodType<Prisma.QuestionScoreCreateManyQuestionInput> = z.object({
  id: z.number().int().optional(),
  createdAt: z.coerce.date().optional(),
  relativeScore: z.union([z.number(),z.string(),z.instanceof(Decimal),z.instanceof(Prisma.Decimal),DecimalJsLikeSchema,]).refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' }).optional().nullable(),
  userQuestionComboId: z.string(),
  absoluteScore: z.union([z.number(),z.string(),z.instanceof(Decimal),z.instanceof(Prisma.Decimal),DecimalJsLikeSchema,]).refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' }),
  rank: z.number().int(),
  userId: z.string(),
  questionOptionId: z.string().optional().nullable()
}).strict();

export const QuestionSlackMessageCreateManyQuestionInputSchema: z.ZodType<Prisma.QuestionSlackMessageCreateManyQuestionInput> = z.object({
  id: z.number().int().optional(),
  detailsId: z.number().int(),
  updatedAt: z.coerce.date().optional()
}).strict();

export const ResolutionSlackMessageCreateManyQuestionInputSchema: z.ZodType<Prisma.ResolutionSlackMessageCreateManyQuestionInput> = z.object({
  id: z.number().int().optional(),
  detailsId: z.number().int(),
  profileId: z.number().int().optional().nullable()
}).strict();

export const CommentCreateManyQuestionInputSchema: z.ZodType<Prisma.CommentCreateManyQuestionInput> = z.object({
  id: z.number().int().optional(),
  createdAt: z.coerce.date().optional(),
  comment: z.string(),
  userId: z.string()
}).strict();

export const NotificationCreateManyQuestionInputSchema: z.ZodType<Prisma.NotificationCreateManyQuestionInput> = z.object({
  id: z.string().cuid().optional(),
  createdAt: z.coerce.date().optional(),
  emailSentAt: z.coerce.date().optional().nullable(),
  title: z.string(),
  content: z.string(),
  url: z.string().optional().nullable(),
  tags: z.union([ z.lazy(() => NotificationCreatetagsInputSchema),z.string().array() ]).optional(),
  read: z.boolean().optional(),
  userId: z.string()
}).strict();

export const QuestionOptionUpdateWithoutQuestionInputSchema: z.ZodType<Prisma.QuestionOptionUpdateWithoutQuestionInput> = z.object({
  id: z.union([ z.string().cuid(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  text: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  resolution: z.union([ z.lazy(() => ResolutionSchema),z.lazy(() => NullableEnumResolutionFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  createdAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  resolvedAt: z.union([ z.coerce.date(),z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  forecasts: z.lazy(() => ForecastUpdateManyWithoutOptionNestedInputSchema).optional(),
  user: z.lazy(() => UserUpdateOneRequiredWithoutQuestionOptionsNestedInputSchema).optional(),
  questionScores: z.lazy(() => QuestionScoreUpdateManyWithoutQuestionOptionNestedInputSchema).optional()
}).strict();

export const QuestionOptionUncheckedUpdateWithoutQuestionInputSchema: z.ZodType<Prisma.QuestionOptionUncheckedUpdateWithoutQuestionInput> = z.object({
  id: z.union([ z.string().cuid(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  text: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  resolution: z.union([ z.lazy(() => ResolutionSchema),z.lazy(() => NullableEnumResolutionFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  createdAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  userId: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  resolvedAt: z.union([ z.coerce.date(),z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  forecasts: z.lazy(() => ForecastUncheckedUpdateManyWithoutOptionNestedInputSchema).optional(),
  questionScores: z.lazy(() => QuestionScoreUncheckedUpdateManyWithoutQuestionOptionNestedInputSchema).optional()
}).strict();

export const QuestionOptionUncheckedUpdateManyWithoutQuestionInputSchema: z.ZodType<Prisma.QuestionOptionUncheckedUpdateManyWithoutQuestionInput> = z.object({
  id: z.union([ z.string().cuid(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  text: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  resolution: z.union([ z.lazy(() => ResolutionSchema),z.lazy(() => NullableEnumResolutionFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  createdAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  userId: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  resolvedAt: z.union([ z.coerce.date(),z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema) ]).optional().nullable(),
}).strict();

export const ForecastUpdateWithoutQuestionInputSchema: z.ZodType<Prisma.ForecastUpdateWithoutQuestionInput> = z.object({
  createdAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  comment: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  forecast: z.union([ z.union([z.number(),z.string(),z.instanceof(Decimal),z.instanceof(Prisma.Decimal),DecimalJsLikeSchema,]).refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' }),z.lazy(() => DecimalFieldUpdateOperationsInputSchema) ]).optional(),
  option: z.lazy(() => QuestionOptionUpdateOneWithoutForecastsNestedInputSchema).optional(),
  profile: z.lazy(() => ProfileUpdateOneWithoutForecastsNestedInputSchema).optional(),
  user: z.lazy(() => UserUpdateOneRequiredWithoutForecastsNestedInputSchema).optional()
}).strict();

export const ForecastUncheckedUpdateWithoutQuestionInputSchema: z.ZodType<Prisma.ForecastUncheckedUpdateWithoutQuestionInput> = z.object({
  id: z.union([ z.number().int(),z.lazy(() => IntFieldUpdateOperationsInputSchema) ]).optional(),
  createdAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  comment: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  forecast: z.union([ z.union([z.number(),z.string(),z.instanceof(Decimal),z.instanceof(Prisma.Decimal),DecimalJsLikeSchema,]).refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' }),z.lazy(() => DecimalFieldUpdateOperationsInputSchema) ]).optional(),
  profileId: z.union([ z.number().int(),z.lazy(() => NullableIntFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  optionId: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  userId: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
}).strict();

export const ForecastUncheckedUpdateManyWithoutQuestionInputSchema: z.ZodType<Prisma.ForecastUncheckedUpdateManyWithoutQuestionInput> = z.object({
  id: z.union([ z.number().int(),z.lazy(() => IntFieldUpdateOperationsInputSchema) ]).optional(),
  createdAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  comment: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  forecast: z.union([ z.union([z.number(),z.string(),z.instanceof(Decimal),z.instanceof(Prisma.Decimal),DecimalJsLikeSchema,]).refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' }),z.lazy(() => DecimalFieldUpdateOperationsInputSchema) ]).optional(),
  profileId: z.union([ z.number().int(),z.lazy(() => NullableIntFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  optionId: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  userId: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
}).strict();

export const PingSlackMessageUpdateWithoutQuestionInputSchema: z.ZodType<Prisma.PingSlackMessageUpdateWithoutQuestionInput> = z.object({
  message: z.lazy(() => SlackMessageUpdateOneRequiredWithoutPingSlackMessageNestedInputSchema).optional()
}).strict();

export const PingSlackMessageUncheckedUpdateWithoutQuestionInputSchema: z.ZodType<Prisma.PingSlackMessageUncheckedUpdateWithoutQuestionInput> = z.object({
  id: z.union([ z.number().int(),z.lazy(() => IntFieldUpdateOperationsInputSchema) ]).optional(),
  detailsId: z.union([ z.number().int(),z.lazy(() => IntFieldUpdateOperationsInputSchema) ]).optional(),
}).strict();

export const PingSlackMessageUncheckedUpdateManyWithoutQuestionInputSchema: z.ZodType<Prisma.PingSlackMessageUncheckedUpdateManyWithoutQuestionInput> = z.object({
  id: z.union([ z.number().int(),z.lazy(() => IntFieldUpdateOperationsInputSchema) ]).optional(),
  detailsId: z.union([ z.number().int(),z.lazy(() => IntFieldUpdateOperationsInputSchema) ]).optional(),
}).strict();

export const UserUpdateWithoutQuestionsSharedWithInputSchema: z.ZodType<Prisma.UserUpdateWithoutQuestionsSharedWithInput> = z.object({
  id: z.union([ z.string().cuid(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  name: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  createdAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  email: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  image: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  staleReminder: z.union([ z.boolean(),z.lazy(() => BoolFieldUpdateOperationsInputSchema) ]).optional(),
  unsubscribedFromEmailsAt: z.union([ z.coerce.date(),z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  apiKey: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  discordUserId: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  emailVerified: z.union([ z.coerce.date(),z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  forecasts: z.lazy(() => ForecastUpdateManyWithoutUserNestedInputSchema).optional(),
  profiles: z.lazy(() => ProfileUpdateManyWithoutUserNestedInputSchema).optional(),
  questions: z.lazy(() => QuestionUpdateManyWithoutUserNestedInputSchema).optional(),
  questionScores: z.lazy(() => QuestionScoreUpdateManyWithoutUserNestedInputSchema).optional(),
  comments: z.lazy(() => CommentUpdateManyWithoutUserNestedInputSchema).optional(),
  target: z.lazy(() => TargetUpdateOneWithoutUserNestedInputSchema).optional(),
  authorOfLists: z.lazy(() => UserListUpdateManyWithoutAuthorNestedInputSchema).optional(),
  memberOfLists: z.lazy(() => UserListUpdateManyWithoutUsersNestedInputSchema).optional(),
  tags: z.lazy(() => TagUpdateManyWithoutUserNestedInputSchema).optional(),
  tournaments: z.lazy(() => TournamentUpdateManyWithoutAuthorNestedInputSchema).optional(),
  notifications: z.lazy(() => NotificationUpdateManyWithoutUserNestedInputSchema).optional(),
  questionOptions: z.lazy(() => QuestionOptionUpdateManyWithoutUserNestedInputSchema).optional(),
  accounts: z.lazy(() => AccountUpdateManyWithoutUserNestedInputSchema).optional()
}).strict();

export const UserUncheckedUpdateWithoutQuestionsSharedWithInputSchema: z.ZodType<Prisma.UserUncheckedUpdateWithoutQuestionsSharedWithInput> = z.object({
  id: z.union([ z.string().cuid(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  name: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  createdAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  email: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  image: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  staleReminder: z.union([ z.boolean(),z.lazy(() => BoolFieldUpdateOperationsInputSchema) ]).optional(),
  unsubscribedFromEmailsAt: z.union([ z.coerce.date(),z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  apiKey: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  discordUserId: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  emailVerified: z.union([ z.coerce.date(),z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  forecasts: z.lazy(() => ForecastUncheckedUpdateManyWithoutUserNestedInputSchema).optional(),
  profiles: z.lazy(() => ProfileUncheckedUpdateManyWithoutUserNestedInputSchema).optional(),
  questions: z.lazy(() => QuestionUncheckedUpdateManyWithoutUserNestedInputSchema).optional(),
  questionScores: z.lazy(() => QuestionScoreUncheckedUpdateManyWithoutUserNestedInputSchema).optional(),
  comments: z.lazy(() => CommentUncheckedUpdateManyWithoutUserNestedInputSchema).optional(),
  target: z.lazy(() => TargetUncheckedUpdateOneWithoutUserNestedInputSchema).optional(),
  authorOfLists: z.lazy(() => UserListUncheckedUpdateManyWithoutAuthorNestedInputSchema).optional(),
  memberOfLists: z.lazy(() => UserListUncheckedUpdateManyWithoutUsersNestedInputSchema).optional(),
  tags: z.lazy(() => TagUncheckedUpdateManyWithoutUserNestedInputSchema).optional(),
  tournaments: z.lazy(() => TournamentUncheckedUpdateManyWithoutAuthorNestedInputSchema).optional(),
  notifications: z.lazy(() => NotificationUncheckedUpdateManyWithoutUserNestedInputSchema).optional(),
  questionOptions: z.lazy(() => QuestionOptionUncheckedUpdateManyWithoutUserNestedInputSchema).optional(),
  accounts: z.lazy(() => AccountUncheckedUpdateManyWithoutUserNestedInputSchema).optional()
}).strict();

export const UserUncheckedUpdateManyWithoutQuestionsSharedWithInputSchema: z.ZodType<Prisma.UserUncheckedUpdateManyWithoutQuestionsSharedWithInput> = z.object({
  id: z.union([ z.string().cuid(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  name: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  createdAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  email: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  image: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  staleReminder: z.union([ z.boolean(),z.lazy(() => BoolFieldUpdateOperationsInputSchema) ]).optional(),
  unsubscribedFromEmailsAt: z.union([ z.coerce.date(),z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  apiKey: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  discordUserId: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  emailVerified: z.union([ z.coerce.date(),z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema) ]).optional().nullable(),
}).strict();

export const UserListUpdateWithoutQuestionsInputSchema: z.ZodType<Prisma.UserListUpdateWithoutQuestionsInput> = z.object({
  id: z.union([ z.string().cuid(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  createdAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  inviteId: z.union([ z.string().cuid(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  name: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  emailDomains: z.union([ z.lazy(() => UserListUpdateemailDomainsInputSchema),z.string().array() ]).optional(),
  syncToSlackTeamId: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  syncToSlackChannelId: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  author: z.lazy(() => UserUpdateOneRequiredWithoutAuthorOfListsNestedInputSchema).optional(),
  users: z.lazy(() => UserUpdateManyWithoutMemberOfListsNestedInputSchema).optional(),
  tournaments: z.lazy(() => TournamentUpdateManyWithoutUserListNestedInputSchema).optional()
}).strict();

export const UserListUncheckedUpdateWithoutQuestionsInputSchema: z.ZodType<Prisma.UserListUncheckedUpdateWithoutQuestionsInput> = z.object({
  id: z.union([ z.string().cuid(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  createdAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  inviteId: z.union([ z.string().cuid(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  name: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  emailDomains: z.union([ z.lazy(() => UserListUpdateemailDomainsInputSchema),z.string().array() ]).optional(),
  syncToSlackTeamId: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  syncToSlackChannelId: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  authorId: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  users: z.lazy(() => UserUncheckedUpdateManyWithoutMemberOfListsNestedInputSchema).optional(),
  tournaments: z.lazy(() => TournamentUncheckedUpdateManyWithoutUserListNestedInputSchema).optional()
}).strict();

export const UserListUncheckedUpdateManyWithoutQuestionsInputSchema: z.ZodType<Prisma.UserListUncheckedUpdateManyWithoutQuestionsInput> = z.object({
  id: z.union([ z.string().cuid(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  createdAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  inviteId: z.union([ z.string().cuid(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  name: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  emailDomains: z.union([ z.lazy(() => UserListUpdateemailDomainsInputSchema),z.string().array() ]).optional(),
  syncToSlackTeamId: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  syncToSlackChannelId: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  authorId: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
}).strict();

export const QuestionScoreUpdateWithoutQuestionInputSchema: z.ZodType<Prisma.QuestionScoreUpdateWithoutQuestionInput> = z.object({
  createdAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  relativeScore: z.union([ z.union([z.number(),z.string(),z.instanceof(Decimal),z.instanceof(Prisma.Decimal),DecimalJsLikeSchema,]).refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' }),z.lazy(() => NullableDecimalFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  userQuestionComboId: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  absoluteScore: z.union([ z.union([z.number(),z.string(),z.instanceof(Decimal),z.instanceof(Prisma.Decimal),DecimalJsLikeSchema,]).refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' }),z.lazy(() => DecimalFieldUpdateOperationsInputSchema) ]).optional(),
  rank: z.union([ z.number().int(),z.lazy(() => IntFieldUpdateOperationsInputSchema) ]).optional(),
  user: z.lazy(() => UserUpdateOneRequiredWithoutQuestionScoresNestedInputSchema).optional(),
  QuestionOption: z.lazy(() => QuestionOptionUpdateOneWithoutQuestionScoresNestedInputSchema).optional()
}).strict();

export const QuestionScoreUncheckedUpdateWithoutQuestionInputSchema: z.ZodType<Prisma.QuestionScoreUncheckedUpdateWithoutQuestionInput> = z.object({
  id: z.union([ z.number().int(),z.lazy(() => IntFieldUpdateOperationsInputSchema) ]).optional(),
  createdAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  relativeScore: z.union([ z.union([z.number(),z.string(),z.instanceof(Decimal),z.instanceof(Prisma.Decimal),DecimalJsLikeSchema,]).refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' }),z.lazy(() => NullableDecimalFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  userQuestionComboId: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  absoluteScore: z.union([ z.union([z.number(),z.string(),z.instanceof(Decimal),z.instanceof(Prisma.Decimal),DecimalJsLikeSchema,]).refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' }),z.lazy(() => DecimalFieldUpdateOperationsInputSchema) ]).optional(),
  rank: z.union([ z.number().int(),z.lazy(() => IntFieldUpdateOperationsInputSchema) ]).optional(),
  userId: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  questionOptionId: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
}).strict();

export const QuestionScoreUncheckedUpdateManyWithoutQuestionInputSchema: z.ZodType<Prisma.QuestionScoreUncheckedUpdateManyWithoutQuestionInput> = z.object({
  id: z.union([ z.number().int(),z.lazy(() => IntFieldUpdateOperationsInputSchema) ]).optional(),
  createdAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  relativeScore: z.union([ z.union([z.number(),z.string(),z.instanceof(Decimal),z.instanceof(Prisma.Decimal),DecimalJsLikeSchema,]).refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' }),z.lazy(() => NullableDecimalFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  userQuestionComboId: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  absoluteScore: z.union([ z.union([z.number(),z.string(),z.instanceof(Decimal),z.instanceof(Prisma.Decimal),DecimalJsLikeSchema,]).refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' }),z.lazy(() => DecimalFieldUpdateOperationsInputSchema) ]).optional(),
  rank: z.union([ z.number().int(),z.lazy(() => IntFieldUpdateOperationsInputSchema) ]).optional(),
  userId: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  questionOptionId: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
}).strict();

export const QuestionSlackMessageUpdateWithoutQuestionInputSchema: z.ZodType<Prisma.QuestionSlackMessageUpdateWithoutQuestionInput> = z.object({
  updatedAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  message: z.lazy(() => SlackMessageUpdateOneRequiredWithoutQuestionSlackMessageNestedInputSchema).optional()
}).strict();

export const QuestionSlackMessageUncheckedUpdateWithoutQuestionInputSchema: z.ZodType<Prisma.QuestionSlackMessageUncheckedUpdateWithoutQuestionInput> = z.object({
  id: z.union([ z.number().int(),z.lazy(() => IntFieldUpdateOperationsInputSchema) ]).optional(),
  detailsId: z.union([ z.number().int(),z.lazy(() => IntFieldUpdateOperationsInputSchema) ]).optional(),
  updatedAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
}).strict();

export const QuestionSlackMessageUncheckedUpdateManyWithoutQuestionInputSchema: z.ZodType<Prisma.QuestionSlackMessageUncheckedUpdateManyWithoutQuestionInput> = z.object({
  id: z.union([ z.number().int(),z.lazy(() => IntFieldUpdateOperationsInputSchema) ]).optional(),
  detailsId: z.union([ z.number().int(),z.lazy(() => IntFieldUpdateOperationsInputSchema) ]).optional(),
  updatedAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
}).strict();

export const ResolutionSlackMessageUpdateWithoutQuestionInputSchema: z.ZodType<Prisma.ResolutionSlackMessageUpdateWithoutQuestionInput> = z.object({
  message: z.lazy(() => SlackMessageUpdateOneRequiredWithoutResolutionSlackMessageNestedInputSchema).optional(),
  profile: z.lazy(() => ProfileUpdateOneWithoutResolutionMessagesNestedInputSchema).optional()
}).strict();

export const ResolutionSlackMessageUncheckedUpdateWithoutQuestionInputSchema: z.ZodType<Prisma.ResolutionSlackMessageUncheckedUpdateWithoutQuestionInput> = z.object({
  id: z.union([ z.number().int(),z.lazy(() => IntFieldUpdateOperationsInputSchema) ]).optional(),
  detailsId: z.union([ z.number().int(),z.lazy(() => IntFieldUpdateOperationsInputSchema) ]).optional(),
  profileId: z.union([ z.number().int(),z.lazy(() => NullableIntFieldUpdateOperationsInputSchema) ]).optional().nullable(),
}).strict();

export const ResolutionSlackMessageUncheckedUpdateManyWithoutQuestionInputSchema: z.ZodType<Prisma.ResolutionSlackMessageUncheckedUpdateManyWithoutQuestionInput> = z.object({
  id: z.union([ z.number().int(),z.lazy(() => IntFieldUpdateOperationsInputSchema) ]).optional(),
  detailsId: z.union([ z.number().int(),z.lazy(() => IntFieldUpdateOperationsInputSchema) ]).optional(),
  profileId: z.union([ z.number().int(),z.lazy(() => NullableIntFieldUpdateOperationsInputSchema) ]).optional().nullable(),
}).strict();

export const CommentUpdateWithoutQuestionInputSchema: z.ZodType<Prisma.CommentUpdateWithoutQuestionInput> = z.object({
  createdAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  comment: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  user: z.lazy(() => UserUpdateOneRequiredWithoutCommentsNestedInputSchema).optional()
}).strict();

export const CommentUncheckedUpdateWithoutQuestionInputSchema: z.ZodType<Prisma.CommentUncheckedUpdateWithoutQuestionInput> = z.object({
  id: z.union([ z.number().int(),z.lazy(() => IntFieldUpdateOperationsInputSchema) ]).optional(),
  createdAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  comment: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  userId: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
}).strict();

export const CommentUncheckedUpdateManyWithoutQuestionInputSchema: z.ZodType<Prisma.CommentUncheckedUpdateManyWithoutQuestionInput> = z.object({
  id: z.union([ z.number().int(),z.lazy(() => IntFieldUpdateOperationsInputSchema) ]).optional(),
  createdAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  comment: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  userId: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
}).strict();

export const TagUpdateWithoutQuestionsInputSchema: z.ZodType<Prisma.TagUpdateWithoutQuestionsInput> = z.object({
  id: z.union([ z.string().cuid(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  createdAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  name: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  user: z.lazy(() => UserUpdateOneRequiredWithoutTagsNestedInputSchema).optional()
}).strict();

export const TagUncheckedUpdateWithoutQuestionsInputSchema: z.ZodType<Prisma.TagUncheckedUpdateWithoutQuestionsInput> = z.object({
  id: z.union([ z.string().cuid(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  createdAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  name: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  userId: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
}).strict();

export const TagUncheckedUpdateManyWithoutQuestionsInputSchema: z.ZodType<Prisma.TagUncheckedUpdateManyWithoutQuestionsInput> = z.object({
  id: z.union([ z.string().cuid(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  createdAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  name: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  userId: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
}).strict();

export const TournamentUpdateWithoutQuestionsInputSchema: z.ZodType<Prisma.TournamentUpdateWithoutQuestionsInput> = z.object({
  id: z.union([ z.string().cuid(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  createdAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  name: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  description: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  sharedPublicly: z.union([ z.boolean(),z.lazy(() => BoolFieldUpdateOperationsInputSchema) ]).optional(),
  unlisted: z.union([ z.boolean(),z.lazy(() => BoolFieldUpdateOperationsInputSchema) ]).optional(),
  anyoneInListCanEdit: z.union([ z.boolean(),z.lazy(() => BoolFieldUpdateOperationsInputSchema) ]).optional(),
  showLeaderboard: z.union([ z.boolean(),z.lazy(() => BoolFieldUpdateOperationsInputSchema) ]).optional(),
  predictYourYear: z.union([ z.number().int(),z.lazy(() => NullableIntFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  syncToSlackTeamId: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  syncToSlackChannelId: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  author: z.lazy(() => UserUpdateOneRequiredWithoutTournamentsNestedInputSchema).optional(),
  userList: z.lazy(() => UserListUpdateOneWithoutTournamentsNestedInputSchema).optional()
}).strict();

export const TournamentUncheckedUpdateWithoutQuestionsInputSchema: z.ZodType<Prisma.TournamentUncheckedUpdateWithoutQuestionsInput> = z.object({
  id: z.union([ z.string().cuid(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  createdAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  name: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  description: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  authorId: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  sharedPublicly: z.union([ z.boolean(),z.lazy(() => BoolFieldUpdateOperationsInputSchema) ]).optional(),
  unlisted: z.union([ z.boolean(),z.lazy(() => BoolFieldUpdateOperationsInputSchema) ]).optional(),
  userListId: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  anyoneInListCanEdit: z.union([ z.boolean(),z.lazy(() => BoolFieldUpdateOperationsInputSchema) ]).optional(),
  showLeaderboard: z.union([ z.boolean(),z.lazy(() => BoolFieldUpdateOperationsInputSchema) ]).optional(),
  predictYourYear: z.union([ z.number().int(),z.lazy(() => NullableIntFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  syncToSlackTeamId: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  syncToSlackChannelId: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
}).strict();

export const TournamentUncheckedUpdateManyWithoutQuestionsInputSchema: z.ZodType<Prisma.TournamentUncheckedUpdateManyWithoutQuestionsInput> = z.object({
  id: z.union([ z.string().cuid(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  createdAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  name: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  description: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  authorId: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  sharedPublicly: z.union([ z.boolean(),z.lazy(() => BoolFieldUpdateOperationsInputSchema) ]).optional(),
  unlisted: z.union([ z.boolean(),z.lazy(() => BoolFieldUpdateOperationsInputSchema) ]).optional(),
  userListId: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  anyoneInListCanEdit: z.union([ z.boolean(),z.lazy(() => BoolFieldUpdateOperationsInputSchema) ]).optional(),
  showLeaderboard: z.union([ z.boolean(),z.lazy(() => BoolFieldUpdateOperationsInputSchema) ]).optional(),
  predictYourYear: z.union([ z.number().int(),z.lazy(() => NullableIntFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  syncToSlackTeamId: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  syncToSlackChannelId: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
}).strict();

export const NotificationUpdateWithoutQuestionInputSchema: z.ZodType<Prisma.NotificationUpdateWithoutQuestionInput> = z.object({
  id: z.union([ z.string().cuid(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  createdAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  emailSentAt: z.union([ z.coerce.date(),z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  title: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  content: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  url: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  tags: z.union([ z.lazy(() => NotificationUpdatetagsInputSchema),z.string().array() ]).optional(),
  read: z.union([ z.boolean(),z.lazy(() => BoolFieldUpdateOperationsInputSchema) ]).optional(),
  user: z.lazy(() => UserUpdateOneRequiredWithoutNotificationsNestedInputSchema).optional()
}).strict();

export const NotificationUncheckedUpdateWithoutQuestionInputSchema: z.ZodType<Prisma.NotificationUncheckedUpdateWithoutQuestionInput> = z.object({
  id: z.union([ z.string().cuid(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  createdAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  emailSentAt: z.union([ z.coerce.date(),z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  title: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  content: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  url: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  tags: z.union([ z.lazy(() => NotificationUpdatetagsInputSchema),z.string().array() ]).optional(),
  read: z.union([ z.boolean(),z.lazy(() => BoolFieldUpdateOperationsInputSchema) ]).optional(),
  userId: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
}).strict();

export const NotificationUncheckedUpdateManyWithoutQuestionInputSchema: z.ZodType<Prisma.NotificationUncheckedUpdateManyWithoutQuestionInput> = z.object({
  id: z.union([ z.string().cuid(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  createdAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  emailSentAt: z.union([ z.coerce.date(),z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  title: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  content: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  url: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  tags: z.union([ z.lazy(() => NotificationUpdatetagsInputSchema),z.string().array() ]).optional(),
  read: z.union([ z.boolean(),z.lazy(() => BoolFieldUpdateOperationsInputSchema) ]).optional(),
  userId: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
}).strict();

export const QuestionUpdateWithoutTagsInputSchema: z.ZodType<Prisma.QuestionUpdateWithoutTagsInput> = z.object({
  id: z.union([ z.string().cuid(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  createdAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  comment: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  title: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  type: z.union([ z.lazy(() => QuestionTypeSchema),z.lazy(() => EnumQuestionTypeFieldUpdateOperationsInputSchema) ]).optional(),
  resolveBy: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  resolved: z.union([ z.boolean(),z.lazy(() => BoolFieldUpdateOperationsInputSchema) ]).optional(),
  pingedForResolution: z.union([ z.boolean(),z.lazy(() => BoolFieldUpdateOperationsInputSchema) ]).optional(),
  resolution: z.union([ z.lazy(() => ResolutionSchema),z.lazy(() => NullableEnumResolutionFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  resolvedAt: z.union([ z.coerce.date(),z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  notes: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  hideForecastsUntil: z.union([ z.coerce.date(),z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  hideForecastsUntilPrediction: z.union([ z.boolean(),z.lazy(() => NullableBoolFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  sharedPublicly: z.union([ z.boolean(),z.lazy(() => BoolFieldUpdateOperationsInputSchema) ]).optional(),
  unlisted: z.union([ z.boolean(),z.lazy(() => BoolFieldUpdateOperationsInputSchema) ]).optional(),
  exclusiveAnswers: z.union([ z.boolean(),z.lazy(() => NullableBoolFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  options: z.lazy(() => QuestionOptionUpdateManyWithoutQuestionNestedInputSchema).optional(),
  forecasts: z.lazy(() => ForecastUpdateManyWithoutQuestionNestedInputSchema).optional(),
  pingResolveMessages: z.lazy(() => PingSlackMessageUpdateManyWithoutQuestionNestedInputSchema).optional(),
  profile: z.lazy(() => ProfileUpdateOneWithoutQuestionsNestedInputSchema).optional(),
  user: z.lazy(() => UserUpdateOneRequiredWithoutQuestionsNestedInputSchema).optional(),
  sharedWith: z.lazy(() => UserUpdateManyWithoutQuestionsSharedWithNestedInputSchema).optional(),
  sharedWithLists: z.lazy(() => UserListUpdateManyWithoutQuestionsNestedInputSchema).optional(),
  questionScores: z.lazy(() => QuestionScoreUpdateManyWithoutQuestionNestedInputSchema).optional(),
  questionMessages: z.lazy(() => QuestionSlackMessageUpdateManyWithoutQuestionNestedInputSchema).optional(),
  resolutionMessages: z.lazy(() => ResolutionSlackMessageUpdateManyWithoutQuestionNestedInputSchema).optional(),
  comments: z.lazy(() => CommentUpdateManyWithoutQuestionNestedInputSchema).optional(),
  tournaments: z.lazy(() => TournamentUpdateManyWithoutQuestionsNestedInputSchema).optional(),
  notifications: z.lazy(() => NotificationUpdateManyWithoutQuestionNestedInputSchema).optional()
}).strict();

export const QuestionUncheckedUpdateWithoutTagsInputSchema: z.ZodType<Prisma.QuestionUncheckedUpdateWithoutTagsInput> = z.object({
  id: z.union([ z.string().cuid(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  createdAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  comment: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  profileId: z.union([ z.number().int(),z.lazy(() => NullableIntFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  title: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  type: z.union([ z.lazy(() => QuestionTypeSchema),z.lazy(() => EnumQuestionTypeFieldUpdateOperationsInputSchema) ]).optional(),
  resolveBy: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  resolved: z.union([ z.boolean(),z.lazy(() => BoolFieldUpdateOperationsInputSchema) ]).optional(),
  pingedForResolution: z.union([ z.boolean(),z.lazy(() => BoolFieldUpdateOperationsInputSchema) ]).optional(),
  resolution: z.union([ z.lazy(() => ResolutionSchema),z.lazy(() => NullableEnumResolutionFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  resolvedAt: z.union([ z.coerce.date(),z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  notes: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  hideForecastsUntil: z.union([ z.coerce.date(),z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  hideForecastsUntilPrediction: z.union([ z.boolean(),z.lazy(() => NullableBoolFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  userId: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  sharedPublicly: z.union([ z.boolean(),z.lazy(() => BoolFieldUpdateOperationsInputSchema) ]).optional(),
  unlisted: z.union([ z.boolean(),z.lazy(() => BoolFieldUpdateOperationsInputSchema) ]).optional(),
  exclusiveAnswers: z.union([ z.boolean(),z.lazy(() => NullableBoolFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  options: z.lazy(() => QuestionOptionUncheckedUpdateManyWithoutQuestionNestedInputSchema).optional(),
  forecasts: z.lazy(() => ForecastUncheckedUpdateManyWithoutQuestionNestedInputSchema).optional(),
  pingResolveMessages: z.lazy(() => PingSlackMessageUncheckedUpdateManyWithoutQuestionNestedInputSchema).optional(),
  sharedWith: z.lazy(() => UserUncheckedUpdateManyWithoutQuestionsSharedWithNestedInputSchema).optional(),
  sharedWithLists: z.lazy(() => UserListUncheckedUpdateManyWithoutQuestionsNestedInputSchema).optional(),
  questionScores: z.lazy(() => QuestionScoreUncheckedUpdateManyWithoutQuestionNestedInputSchema).optional(),
  questionMessages: z.lazy(() => QuestionSlackMessageUncheckedUpdateManyWithoutQuestionNestedInputSchema).optional(),
  resolutionMessages: z.lazy(() => ResolutionSlackMessageUncheckedUpdateManyWithoutQuestionNestedInputSchema).optional(),
  comments: z.lazy(() => CommentUncheckedUpdateManyWithoutQuestionNestedInputSchema).optional(),
  tournaments: z.lazy(() => TournamentUncheckedUpdateManyWithoutQuestionsNestedInputSchema).optional(),
  notifications: z.lazy(() => NotificationUncheckedUpdateManyWithoutQuestionNestedInputSchema).optional()
}).strict();

export const QuestionUncheckedUpdateManyWithoutTagsInputSchema: z.ZodType<Prisma.QuestionUncheckedUpdateManyWithoutTagsInput> = z.object({
  id: z.union([ z.string().cuid(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  createdAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  comment: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  profileId: z.union([ z.number().int(),z.lazy(() => NullableIntFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  title: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  type: z.union([ z.lazy(() => QuestionTypeSchema),z.lazy(() => EnumQuestionTypeFieldUpdateOperationsInputSchema) ]).optional(),
  resolveBy: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  resolved: z.union([ z.boolean(),z.lazy(() => BoolFieldUpdateOperationsInputSchema) ]).optional(),
  pingedForResolution: z.union([ z.boolean(),z.lazy(() => BoolFieldUpdateOperationsInputSchema) ]).optional(),
  resolution: z.union([ z.lazy(() => ResolutionSchema),z.lazy(() => NullableEnumResolutionFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  resolvedAt: z.union([ z.coerce.date(),z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  notes: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  hideForecastsUntil: z.union([ z.coerce.date(),z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  hideForecastsUntilPrediction: z.union([ z.boolean(),z.lazy(() => NullableBoolFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  userId: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  sharedPublicly: z.union([ z.boolean(),z.lazy(() => BoolFieldUpdateOperationsInputSchema) ]).optional(),
  unlisted: z.union([ z.boolean(),z.lazy(() => BoolFieldUpdateOperationsInputSchema) ]).optional(),
  exclusiveAnswers: z.union([ z.boolean(),z.lazy(() => NullableBoolFieldUpdateOperationsInputSchema) ]).optional().nullable(),
}).strict();

export const ForecastCreateManyUserInputSchema: z.ZodType<Prisma.ForecastCreateManyUserInput> = z.object({
  id: z.number().int().optional(),
  createdAt: z.coerce.date().optional(),
  comment: z.string().optional().nullable(),
  forecast: z.union([z.number(),z.string(),z.instanceof(Decimal),z.instanceof(Prisma.Decimal),DecimalJsLikeSchema,]).refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' }),
  profileId: z.number().int().optional().nullable(),
  questionId: z.string(),
  optionId: z.string().optional().nullable()
}).strict();

export const ProfileCreateManyUserInputSchema: z.ZodType<Prisma.ProfileCreateManyUserInput> = z.object({
  id: z.number().int().optional(),
  createdAt: z.coerce.date().optional(),
  slackId: z.string().optional().nullable(),
  slackTeamId: z.string().optional().nullable()
}).strict();

export const QuestionCreateManyUserInputSchema: z.ZodType<Prisma.QuestionCreateManyUserInput> = z.object({
  id: z.string().cuid().optional(),
  createdAt: z.coerce.date().optional(),
  comment: z.string().optional().nullable(),
  profileId: z.number().int().optional().nullable(),
  title: z.string(),
  type: z.lazy(() => QuestionTypeSchema).optional(),
  resolveBy: z.coerce.date(),
  resolved: z.boolean().optional(),
  pingedForResolution: z.boolean().optional(),
  resolution: z.lazy(() => ResolutionSchema).optional().nullable(),
  resolvedAt: z.coerce.date().optional().nullable(),
  notes: z.string().optional().nullable(),
  hideForecastsUntil: z.coerce.date().optional().nullable(),
  hideForecastsUntilPrediction: z.boolean().optional().nullable(),
  sharedPublicly: z.boolean().optional(),
  unlisted: z.boolean().optional(),
  exclusiveAnswers: z.boolean().optional().nullable()
}).strict();

export const QuestionScoreCreateManyUserInputSchema: z.ZodType<Prisma.QuestionScoreCreateManyUserInput> = z.object({
  id: z.number().int().optional(),
  createdAt: z.coerce.date().optional(),
  relativeScore: z.union([z.number(),z.string(),z.instanceof(Decimal),z.instanceof(Prisma.Decimal),DecimalJsLikeSchema,]).refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' }).optional().nullable(),
  questionId: z.string(),
  userQuestionComboId: z.string(),
  absoluteScore: z.union([z.number(),z.string(),z.instanceof(Decimal),z.instanceof(Prisma.Decimal),DecimalJsLikeSchema,]).refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' }),
  rank: z.number().int(),
  questionOptionId: z.string().optional().nullable()
}).strict();

export const CommentCreateManyUserInputSchema: z.ZodType<Prisma.CommentCreateManyUserInput> = z.object({
  id: z.number().int().optional(),
  createdAt: z.coerce.date().optional(),
  comment: z.string(),
  questionId: z.string()
}).strict();

export const UserListCreateManyAuthorInputSchema: z.ZodType<Prisma.UserListCreateManyAuthorInput> = z.object({
  id: z.string().cuid().optional(),
  createdAt: z.coerce.date().optional(),
  inviteId: z.string().cuid().optional().nullable(),
  name: z.string(),
  emailDomains: z.union([ z.lazy(() => UserListCreateemailDomainsInputSchema),z.string().array() ]).optional(),
  syncToSlackTeamId: z.string().optional().nullable(),
  syncToSlackChannelId: z.string().optional().nullable()
}).strict();

export const TagCreateManyUserInputSchema: z.ZodType<Prisma.TagCreateManyUserInput> = z.object({
  id: z.string().cuid().optional(),
  createdAt: z.coerce.date().optional(),
  name: z.string()
}).strict();

export const TournamentCreateManyAuthorInputSchema: z.ZodType<Prisma.TournamentCreateManyAuthorInput> = z.object({
  id: z.string().cuid().optional(),
  createdAt: z.coerce.date().optional(),
  name: z.string(),
  description: z.string().optional().nullable(),
  sharedPublicly: z.boolean().optional(),
  unlisted: z.boolean().optional(),
  userListId: z.string().optional().nullable(),
  anyoneInListCanEdit: z.boolean().optional(),
  showLeaderboard: z.boolean().optional(),
  predictYourYear: z.number().int().optional().nullable(),
  syncToSlackTeamId: z.string().optional().nullable(),
  syncToSlackChannelId: z.string().optional().nullable()
}).strict();

export const NotificationCreateManyUserInputSchema: z.ZodType<Prisma.NotificationCreateManyUserInput> = z.object({
  id: z.string().cuid().optional(),
  createdAt: z.coerce.date().optional(),
  emailSentAt: z.coerce.date().optional().nullable(),
  title: z.string(),
  content: z.string(),
  url: z.string().optional().nullable(),
  tags: z.union([ z.lazy(() => NotificationCreatetagsInputSchema),z.string().array() ]).optional(),
  read: z.boolean().optional(),
  questionId: z.string().optional().nullable()
}).strict();

export const QuestionOptionCreateManyUserInputSchema: z.ZodType<Prisma.QuestionOptionCreateManyUserInput> = z.object({
  id: z.string().cuid().optional(),
  questionId: z.string(),
  text: z.string(),
  resolution: z.lazy(() => ResolutionSchema).optional().nullable(),
  createdAt: z.coerce.date().optional(),
  resolvedAt: z.coerce.date().optional().nullable()
}).strict();

export const AccountCreateManyUserInputSchema: z.ZodType<Prisma.AccountCreateManyUserInput> = z.object({
  id: z.string().cuid().optional(),
  type: z.string(),
  provider: z.string(),
  providerAccountId: z.string(),
  refresh_token: z.string().optional().nullable(),
  access_token: z.string().optional().nullable(),
  expires_at: z.number().int().optional().nullable(),
  token_type: z.string().optional().nullable(),
  scope: z.string().optional().nullable(),
  id_token: z.string().optional().nullable(),
  session_state: z.string().optional().nullable()
}).strict();

export const ForecastUpdateWithoutUserInputSchema: z.ZodType<Prisma.ForecastUpdateWithoutUserInput> = z.object({
  createdAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  comment: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  forecast: z.union([ z.union([z.number(),z.string(),z.instanceof(Decimal),z.instanceof(Prisma.Decimal),DecimalJsLikeSchema,]).refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' }),z.lazy(() => DecimalFieldUpdateOperationsInputSchema) ]).optional(),
  option: z.lazy(() => QuestionOptionUpdateOneWithoutForecastsNestedInputSchema).optional(),
  profile: z.lazy(() => ProfileUpdateOneWithoutForecastsNestedInputSchema).optional(),
  question: z.lazy(() => QuestionUpdateOneRequiredWithoutForecastsNestedInputSchema).optional()
}).strict();

export const ForecastUncheckedUpdateWithoutUserInputSchema: z.ZodType<Prisma.ForecastUncheckedUpdateWithoutUserInput> = z.object({
  id: z.union([ z.number().int(),z.lazy(() => IntFieldUpdateOperationsInputSchema) ]).optional(),
  createdAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  comment: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  forecast: z.union([ z.union([z.number(),z.string(),z.instanceof(Decimal),z.instanceof(Prisma.Decimal),DecimalJsLikeSchema,]).refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' }),z.lazy(() => DecimalFieldUpdateOperationsInputSchema) ]).optional(),
  profileId: z.union([ z.number().int(),z.lazy(() => NullableIntFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  questionId: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  optionId: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
}).strict();

export const ForecastUncheckedUpdateManyWithoutUserInputSchema: z.ZodType<Prisma.ForecastUncheckedUpdateManyWithoutUserInput> = z.object({
  id: z.union([ z.number().int(),z.lazy(() => IntFieldUpdateOperationsInputSchema) ]).optional(),
  createdAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  comment: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  forecast: z.union([ z.union([z.number(),z.string(),z.instanceof(Decimal),z.instanceof(Prisma.Decimal),DecimalJsLikeSchema,]).refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' }),z.lazy(() => DecimalFieldUpdateOperationsInputSchema) ]).optional(),
  profileId: z.union([ z.number().int(),z.lazy(() => NullableIntFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  questionId: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  optionId: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
}).strict();

export const ProfileUpdateWithoutUserInputSchema: z.ZodType<Prisma.ProfileUpdateWithoutUserInput> = z.object({
  createdAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  slackId: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  slackTeamId: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  forecasts: z.lazy(() => ForecastUpdateManyWithoutProfileNestedInputSchema).optional(),
  questions: z.lazy(() => QuestionUpdateManyWithoutProfileNestedInputSchema).optional(),
  resolutionMessages: z.lazy(() => ResolutionSlackMessageUpdateManyWithoutProfileNestedInputSchema).optional(),
  target: z.lazy(() => TargetUpdateOneWithoutProfileNestedInputSchema).optional()
}).strict();

export const ProfileUncheckedUpdateWithoutUserInputSchema: z.ZodType<Prisma.ProfileUncheckedUpdateWithoutUserInput> = z.object({
  id: z.union([ z.number().int(),z.lazy(() => IntFieldUpdateOperationsInputSchema) ]).optional(),
  createdAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  slackId: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  slackTeamId: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  forecasts: z.lazy(() => ForecastUncheckedUpdateManyWithoutProfileNestedInputSchema).optional(),
  questions: z.lazy(() => QuestionUncheckedUpdateManyWithoutProfileNestedInputSchema).optional(),
  resolutionMessages: z.lazy(() => ResolutionSlackMessageUncheckedUpdateManyWithoutProfileNestedInputSchema).optional(),
  target: z.lazy(() => TargetUncheckedUpdateOneWithoutProfileNestedInputSchema).optional()
}).strict();

export const ProfileUncheckedUpdateManyWithoutUserInputSchema: z.ZodType<Prisma.ProfileUncheckedUpdateManyWithoutUserInput> = z.object({
  id: z.union([ z.number().int(),z.lazy(() => IntFieldUpdateOperationsInputSchema) ]).optional(),
  createdAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  slackId: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  slackTeamId: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
}).strict();

export const QuestionUpdateWithoutUserInputSchema: z.ZodType<Prisma.QuestionUpdateWithoutUserInput> = z.object({
  id: z.union([ z.string().cuid(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  createdAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  comment: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  title: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  type: z.union([ z.lazy(() => QuestionTypeSchema),z.lazy(() => EnumQuestionTypeFieldUpdateOperationsInputSchema) ]).optional(),
  resolveBy: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  resolved: z.union([ z.boolean(),z.lazy(() => BoolFieldUpdateOperationsInputSchema) ]).optional(),
  pingedForResolution: z.union([ z.boolean(),z.lazy(() => BoolFieldUpdateOperationsInputSchema) ]).optional(),
  resolution: z.union([ z.lazy(() => ResolutionSchema),z.lazy(() => NullableEnumResolutionFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  resolvedAt: z.union([ z.coerce.date(),z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  notes: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  hideForecastsUntil: z.union([ z.coerce.date(),z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  hideForecastsUntilPrediction: z.union([ z.boolean(),z.lazy(() => NullableBoolFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  sharedPublicly: z.union([ z.boolean(),z.lazy(() => BoolFieldUpdateOperationsInputSchema) ]).optional(),
  unlisted: z.union([ z.boolean(),z.lazy(() => BoolFieldUpdateOperationsInputSchema) ]).optional(),
  exclusiveAnswers: z.union([ z.boolean(),z.lazy(() => NullableBoolFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  options: z.lazy(() => QuestionOptionUpdateManyWithoutQuestionNestedInputSchema).optional(),
  forecasts: z.lazy(() => ForecastUpdateManyWithoutQuestionNestedInputSchema).optional(),
  pingResolveMessages: z.lazy(() => PingSlackMessageUpdateManyWithoutQuestionNestedInputSchema).optional(),
  profile: z.lazy(() => ProfileUpdateOneWithoutQuestionsNestedInputSchema).optional(),
  sharedWith: z.lazy(() => UserUpdateManyWithoutQuestionsSharedWithNestedInputSchema).optional(),
  sharedWithLists: z.lazy(() => UserListUpdateManyWithoutQuestionsNestedInputSchema).optional(),
  questionScores: z.lazy(() => QuestionScoreUpdateManyWithoutQuestionNestedInputSchema).optional(),
  questionMessages: z.lazy(() => QuestionSlackMessageUpdateManyWithoutQuestionNestedInputSchema).optional(),
  resolutionMessages: z.lazy(() => ResolutionSlackMessageUpdateManyWithoutQuestionNestedInputSchema).optional(),
  comments: z.lazy(() => CommentUpdateManyWithoutQuestionNestedInputSchema).optional(),
  tags: z.lazy(() => TagUpdateManyWithoutQuestionsNestedInputSchema).optional(),
  tournaments: z.lazy(() => TournamentUpdateManyWithoutQuestionsNestedInputSchema).optional(),
  notifications: z.lazy(() => NotificationUpdateManyWithoutQuestionNestedInputSchema).optional()
}).strict();

export const QuestionUncheckedUpdateWithoutUserInputSchema: z.ZodType<Prisma.QuestionUncheckedUpdateWithoutUserInput> = z.object({
  id: z.union([ z.string().cuid(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  createdAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  comment: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  profileId: z.union([ z.number().int(),z.lazy(() => NullableIntFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  title: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  type: z.union([ z.lazy(() => QuestionTypeSchema),z.lazy(() => EnumQuestionTypeFieldUpdateOperationsInputSchema) ]).optional(),
  resolveBy: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  resolved: z.union([ z.boolean(),z.lazy(() => BoolFieldUpdateOperationsInputSchema) ]).optional(),
  pingedForResolution: z.union([ z.boolean(),z.lazy(() => BoolFieldUpdateOperationsInputSchema) ]).optional(),
  resolution: z.union([ z.lazy(() => ResolutionSchema),z.lazy(() => NullableEnumResolutionFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  resolvedAt: z.union([ z.coerce.date(),z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  notes: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  hideForecastsUntil: z.union([ z.coerce.date(),z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  hideForecastsUntilPrediction: z.union([ z.boolean(),z.lazy(() => NullableBoolFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  sharedPublicly: z.union([ z.boolean(),z.lazy(() => BoolFieldUpdateOperationsInputSchema) ]).optional(),
  unlisted: z.union([ z.boolean(),z.lazy(() => BoolFieldUpdateOperationsInputSchema) ]).optional(),
  exclusiveAnswers: z.union([ z.boolean(),z.lazy(() => NullableBoolFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  options: z.lazy(() => QuestionOptionUncheckedUpdateManyWithoutQuestionNestedInputSchema).optional(),
  forecasts: z.lazy(() => ForecastUncheckedUpdateManyWithoutQuestionNestedInputSchema).optional(),
  pingResolveMessages: z.lazy(() => PingSlackMessageUncheckedUpdateManyWithoutQuestionNestedInputSchema).optional(),
  sharedWith: z.lazy(() => UserUncheckedUpdateManyWithoutQuestionsSharedWithNestedInputSchema).optional(),
  sharedWithLists: z.lazy(() => UserListUncheckedUpdateManyWithoutQuestionsNestedInputSchema).optional(),
  questionScores: z.lazy(() => QuestionScoreUncheckedUpdateManyWithoutQuestionNestedInputSchema).optional(),
  questionMessages: z.lazy(() => QuestionSlackMessageUncheckedUpdateManyWithoutQuestionNestedInputSchema).optional(),
  resolutionMessages: z.lazy(() => ResolutionSlackMessageUncheckedUpdateManyWithoutQuestionNestedInputSchema).optional(),
  comments: z.lazy(() => CommentUncheckedUpdateManyWithoutQuestionNestedInputSchema).optional(),
  tags: z.lazy(() => TagUncheckedUpdateManyWithoutQuestionsNestedInputSchema).optional(),
  tournaments: z.lazy(() => TournamentUncheckedUpdateManyWithoutQuestionsNestedInputSchema).optional(),
  notifications: z.lazy(() => NotificationUncheckedUpdateManyWithoutQuestionNestedInputSchema).optional()
}).strict();

export const QuestionUncheckedUpdateManyWithoutUserInputSchema: z.ZodType<Prisma.QuestionUncheckedUpdateManyWithoutUserInput> = z.object({
  id: z.union([ z.string().cuid(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  createdAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  comment: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  profileId: z.union([ z.number().int(),z.lazy(() => NullableIntFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  title: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  type: z.union([ z.lazy(() => QuestionTypeSchema),z.lazy(() => EnumQuestionTypeFieldUpdateOperationsInputSchema) ]).optional(),
  resolveBy: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  resolved: z.union([ z.boolean(),z.lazy(() => BoolFieldUpdateOperationsInputSchema) ]).optional(),
  pingedForResolution: z.union([ z.boolean(),z.lazy(() => BoolFieldUpdateOperationsInputSchema) ]).optional(),
  resolution: z.union([ z.lazy(() => ResolutionSchema),z.lazy(() => NullableEnumResolutionFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  resolvedAt: z.union([ z.coerce.date(),z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  notes: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  hideForecastsUntil: z.union([ z.coerce.date(),z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  hideForecastsUntilPrediction: z.union([ z.boolean(),z.lazy(() => NullableBoolFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  sharedPublicly: z.union([ z.boolean(),z.lazy(() => BoolFieldUpdateOperationsInputSchema) ]).optional(),
  unlisted: z.union([ z.boolean(),z.lazy(() => BoolFieldUpdateOperationsInputSchema) ]).optional(),
  exclusiveAnswers: z.union([ z.boolean(),z.lazy(() => NullableBoolFieldUpdateOperationsInputSchema) ]).optional().nullable(),
}).strict();

export const QuestionScoreUpdateWithoutUserInputSchema: z.ZodType<Prisma.QuestionScoreUpdateWithoutUserInput> = z.object({
  createdAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  relativeScore: z.union([ z.union([z.number(),z.string(),z.instanceof(Decimal),z.instanceof(Prisma.Decimal),DecimalJsLikeSchema,]).refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' }),z.lazy(() => NullableDecimalFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  userQuestionComboId: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  absoluteScore: z.union([ z.union([z.number(),z.string(),z.instanceof(Decimal),z.instanceof(Prisma.Decimal),DecimalJsLikeSchema,]).refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' }),z.lazy(() => DecimalFieldUpdateOperationsInputSchema) ]).optional(),
  rank: z.union([ z.number().int(),z.lazy(() => IntFieldUpdateOperationsInputSchema) ]).optional(),
  question: z.lazy(() => QuestionUpdateOneRequiredWithoutQuestionScoresNestedInputSchema).optional(),
  QuestionOption: z.lazy(() => QuestionOptionUpdateOneWithoutQuestionScoresNestedInputSchema).optional()
}).strict();

export const QuestionScoreUncheckedUpdateWithoutUserInputSchema: z.ZodType<Prisma.QuestionScoreUncheckedUpdateWithoutUserInput> = z.object({
  id: z.union([ z.number().int(),z.lazy(() => IntFieldUpdateOperationsInputSchema) ]).optional(),
  createdAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  relativeScore: z.union([ z.union([z.number(),z.string(),z.instanceof(Decimal),z.instanceof(Prisma.Decimal),DecimalJsLikeSchema,]).refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' }),z.lazy(() => NullableDecimalFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  questionId: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  userQuestionComboId: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  absoluteScore: z.union([ z.union([z.number(),z.string(),z.instanceof(Decimal),z.instanceof(Prisma.Decimal),DecimalJsLikeSchema,]).refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' }),z.lazy(() => DecimalFieldUpdateOperationsInputSchema) ]).optional(),
  rank: z.union([ z.number().int(),z.lazy(() => IntFieldUpdateOperationsInputSchema) ]).optional(),
  questionOptionId: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
}).strict();

export const QuestionScoreUncheckedUpdateManyWithoutUserInputSchema: z.ZodType<Prisma.QuestionScoreUncheckedUpdateManyWithoutUserInput> = z.object({
  id: z.union([ z.number().int(),z.lazy(() => IntFieldUpdateOperationsInputSchema) ]).optional(),
  createdAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  relativeScore: z.union([ z.union([z.number(),z.string(),z.instanceof(Decimal),z.instanceof(Prisma.Decimal),DecimalJsLikeSchema,]).refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' }),z.lazy(() => NullableDecimalFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  questionId: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  userQuestionComboId: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  absoluteScore: z.union([ z.union([z.number(),z.string(),z.instanceof(Decimal),z.instanceof(Prisma.Decimal),DecimalJsLikeSchema,]).refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' }),z.lazy(() => DecimalFieldUpdateOperationsInputSchema) ]).optional(),
  rank: z.union([ z.number().int(),z.lazy(() => IntFieldUpdateOperationsInputSchema) ]).optional(),
  questionOptionId: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
}).strict();

export const QuestionUpdateWithoutSharedWithInputSchema: z.ZodType<Prisma.QuestionUpdateWithoutSharedWithInput> = z.object({
  id: z.union([ z.string().cuid(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  createdAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  comment: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  title: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  type: z.union([ z.lazy(() => QuestionTypeSchema),z.lazy(() => EnumQuestionTypeFieldUpdateOperationsInputSchema) ]).optional(),
  resolveBy: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  resolved: z.union([ z.boolean(),z.lazy(() => BoolFieldUpdateOperationsInputSchema) ]).optional(),
  pingedForResolution: z.union([ z.boolean(),z.lazy(() => BoolFieldUpdateOperationsInputSchema) ]).optional(),
  resolution: z.union([ z.lazy(() => ResolutionSchema),z.lazy(() => NullableEnumResolutionFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  resolvedAt: z.union([ z.coerce.date(),z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  notes: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  hideForecastsUntil: z.union([ z.coerce.date(),z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  hideForecastsUntilPrediction: z.union([ z.boolean(),z.lazy(() => NullableBoolFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  sharedPublicly: z.union([ z.boolean(),z.lazy(() => BoolFieldUpdateOperationsInputSchema) ]).optional(),
  unlisted: z.union([ z.boolean(),z.lazy(() => BoolFieldUpdateOperationsInputSchema) ]).optional(),
  exclusiveAnswers: z.union([ z.boolean(),z.lazy(() => NullableBoolFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  options: z.lazy(() => QuestionOptionUpdateManyWithoutQuestionNestedInputSchema).optional(),
  forecasts: z.lazy(() => ForecastUpdateManyWithoutQuestionNestedInputSchema).optional(),
  pingResolveMessages: z.lazy(() => PingSlackMessageUpdateManyWithoutQuestionNestedInputSchema).optional(),
  profile: z.lazy(() => ProfileUpdateOneWithoutQuestionsNestedInputSchema).optional(),
  user: z.lazy(() => UserUpdateOneRequiredWithoutQuestionsNestedInputSchema).optional(),
  sharedWithLists: z.lazy(() => UserListUpdateManyWithoutQuestionsNestedInputSchema).optional(),
  questionScores: z.lazy(() => QuestionScoreUpdateManyWithoutQuestionNestedInputSchema).optional(),
  questionMessages: z.lazy(() => QuestionSlackMessageUpdateManyWithoutQuestionNestedInputSchema).optional(),
  resolutionMessages: z.lazy(() => ResolutionSlackMessageUpdateManyWithoutQuestionNestedInputSchema).optional(),
  comments: z.lazy(() => CommentUpdateManyWithoutQuestionNestedInputSchema).optional(),
  tags: z.lazy(() => TagUpdateManyWithoutQuestionsNestedInputSchema).optional(),
  tournaments: z.lazy(() => TournamentUpdateManyWithoutQuestionsNestedInputSchema).optional(),
  notifications: z.lazy(() => NotificationUpdateManyWithoutQuestionNestedInputSchema).optional()
}).strict();

export const QuestionUncheckedUpdateWithoutSharedWithInputSchema: z.ZodType<Prisma.QuestionUncheckedUpdateWithoutSharedWithInput> = z.object({
  id: z.union([ z.string().cuid(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  createdAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  comment: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  profileId: z.union([ z.number().int(),z.lazy(() => NullableIntFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  title: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  type: z.union([ z.lazy(() => QuestionTypeSchema),z.lazy(() => EnumQuestionTypeFieldUpdateOperationsInputSchema) ]).optional(),
  resolveBy: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  resolved: z.union([ z.boolean(),z.lazy(() => BoolFieldUpdateOperationsInputSchema) ]).optional(),
  pingedForResolution: z.union([ z.boolean(),z.lazy(() => BoolFieldUpdateOperationsInputSchema) ]).optional(),
  resolution: z.union([ z.lazy(() => ResolutionSchema),z.lazy(() => NullableEnumResolutionFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  resolvedAt: z.union([ z.coerce.date(),z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  notes: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  hideForecastsUntil: z.union([ z.coerce.date(),z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  hideForecastsUntilPrediction: z.union([ z.boolean(),z.lazy(() => NullableBoolFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  userId: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  sharedPublicly: z.union([ z.boolean(),z.lazy(() => BoolFieldUpdateOperationsInputSchema) ]).optional(),
  unlisted: z.union([ z.boolean(),z.lazy(() => BoolFieldUpdateOperationsInputSchema) ]).optional(),
  exclusiveAnswers: z.union([ z.boolean(),z.lazy(() => NullableBoolFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  options: z.lazy(() => QuestionOptionUncheckedUpdateManyWithoutQuestionNestedInputSchema).optional(),
  forecasts: z.lazy(() => ForecastUncheckedUpdateManyWithoutQuestionNestedInputSchema).optional(),
  pingResolveMessages: z.lazy(() => PingSlackMessageUncheckedUpdateManyWithoutQuestionNestedInputSchema).optional(),
  sharedWithLists: z.lazy(() => UserListUncheckedUpdateManyWithoutQuestionsNestedInputSchema).optional(),
  questionScores: z.lazy(() => QuestionScoreUncheckedUpdateManyWithoutQuestionNestedInputSchema).optional(),
  questionMessages: z.lazy(() => QuestionSlackMessageUncheckedUpdateManyWithoutQuestionNestedInputSchema).optional(),
  resolutionMessages: z.lazy(() => ResolutionSlackMessageUncheckedUpdateManyWithoutQuestionNestedInputSchema).optional(),
  comments: z.lazy(() => CommentUncheckedUpdateManyWithoutQuestionNestedInputSchema).optional(),
  tags: z.lazy(() => TagUncheckedUpdateManyWithoutQuestionsNestedInputSchema).optional(),
  tournaments: z.lazy(() => TournamentUncheckedUpdateManyWithoutQuestionsNestedInputSchema).optional(),
  notifications: z.lazy(() => NotificationUncheckedUpdateManyWithoutQuestionNestedInputSchema).optional()
}).strict();

export const QuestionUncheckedUpdateManyWithoutSharedWithInputSchema: z.ZodType<Prisma.QuestionUncheckedUpdateManyWithoutSharedWithInput> = z.object({
  id: z.union([ z.string().cuid(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  createdAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  comment: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  profileId: z.union([ z.number().int(),z.lazy(() => NullableIntFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  title: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  type: z.union([ z.lazy(() => QuestionTypeSchema),z.lazy(() => EnumQuestionTypeFieldUpdateOperationsInputSchema) ]).optional(),
  resolveBy: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  resolved: z.union([ z.boolean(),z.lazy(() => BoolFieldUpdateOperationsInputSchema) ]).optional(),
  pingedForResolution: z.union([ z.boolean(),z.lazy(() => BoolFieldUpdateOperationsInputSchema) ]).optional(),
  resolution: z.union([ z.lazy(() => ResolutionSchema),z.lazy(() => NullableEnumResolutionFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  resolvedAt: z.union([ z.coerce.date(),z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  notes: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  hideForecastsUntil: z.union([ z.coerce.date(),z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  hideForecastsUntilPrediction: z.union([ z.boolean(),z.lazy(() => NullableBoolFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  userId: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  sharedPublicly: z.union([ z.boolean(),z.lazy(() => BoolFieldUpdateOperationsInputSchema) ]).optional(),
  unlisted: z.union([ z.boolean(),z.lazy(() => BoolFieldUpdateOperationsInputSchema) ]).optional(),
  exclusiveAnswers: z.union([ z.boolean(),z.lazy(() => NullableBoolFieldUpdateOperationsInputSchema) ]).optional().nullable(),
}).strict();

export const CommentUpdateWithoutUserInputSchema: z.ZodType<Prisma.CommentUpdateWithoutUserInput> = z.object({
  createdAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  comment: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  question: z.lazy(() => QuestionUpdateOneRequiredWithoutCommentsNestedInputSchema).optional()
}).strict();

export const CommentUncheckedUpdateWithoutUserInputSchema: z.ZodType<Prisma.CommentUncheckedUpdateWithoutUserInput> = z.object({
  id: z.union([ z.number().int(),z.lazy(() => IntFieldUpdateOperationsInputSchema) ]).optional(),
  createdAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  comment: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  questionId: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
}).strict();

export const CommentUncheckedUpdateManyWithoutUserInputSchema: z.ZodType<Prisma.CommentUncheckedUpdateManyWithoutUserInput> = z.object({
  id: z.union([ z.number().int(),z.lazy(() => IntFieldUpdateOperationsInputSchema) ]).optional(),
  createdAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  comment: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  questionId: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
}).strict();

export const UserListUpdateWithoutAuthorInputSchema: z.ZodType<Prisma.UserListUpdateWithoutAuthorInput> = z.object({
  id: z.union([ z.string().cuid(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  createdAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  inviteId: z.union([ z.string().cuid(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  name: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  emailDomains: z.union([ z.lazy(() => UserListUpdateemailDomainsInputSchema),z.string().array() ]).optional(),
  syncToSlackTeamId: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  syncToSlackChannelId: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  users: z.lazy(() => UserUpdateManyWithoutMemberOfListsNestedInputSchema).optional(),
  questions: z.lazy(() => QuestionUpdateManyWithoutSharedWithListsNestedInputSchema).optional(),
  tournaments: z.lazy(() => TournamentUpdateManyWithoutUserListNestedInputSchema).optional()
}).strict();

export const UserListUncheckedUpdateWithoutAuthorInputSchema: z.ZodType<Prisma.UserListUncheckedUpdateWithoutAuthorInput> = z.object({
  id: z.union([ z.string().cuid(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  createdAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  inviteId: z.union([ z.string().cuid(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  name: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  emailDomains: z.union([ z.lazy(() => UserListUpdateemailDomainsInputSchema),z.string().array() ]).optional(),
  syncToSlackTeamId: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  syncToSlackChannelId: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  users: z.lazy(() => UserUncheckedUpdateManyWithoutMemberOfListsNestedInputSchema).optional(),
  questions: z.lazy(() => QuestionUncheckedUpdateManyWithoutSharedWithListsNestedInputSchema).optional(),
  tournaments: z.lazy(() => TournamentUncheckedUpdateManyWithoutUserListNestedInputSchema).optional()
}).strict();

export const UserListUncheckedUpdateManyWithoutAuthorInputSchema: z.ZodType<Prisma.UserListUncheckedUpdateManyWithoutAuthorInput> = z.object({
  id: z.union([ z.string().cuid(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  createdAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  inviteId: z.union([ z.string().cuid(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  name: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  emailDomains: z.union([ z.lazy(() => UserListUpdateemailDomainsInputSchema),z.string().array() ]).optional(),
  syncToSlackTeamId: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  syncToSlackChannelId: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
}).strict();

export const UserListUpdateWithoutUsersInputSchema: z.ZodType<Prisma.UserListUpdateWithoutUsersInput> = z.object({
  id: z.union([ z.string().cuid(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  createdAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  inviteId: z.union([ z.string().cuid(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  name: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  emailDomains: z.union([ z.lazy(() => UserListUpdateemailDomainsInputSchema),z.string().array() ]).optional(),
  syncToSlackTeamId: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  syncToSlackChannelId: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  author: z.lazy(() => UserUpdateOneRequiredWithoutAuthorOfListsNestedInputSchema).optional(),
  questions: z.lazy(() => QuestionUpdateManyWithoutSharedWithListsNestedInputSchema).optional(),
  tournaments: z.lazy(() => TournamentUpdateManyWithoutUserListNestedInputSchema).optional()
}).strict();

export const UserListUncheckedUpdateWithoutUsersInputSchema: z.ZodType<Prisma.UserListUncheckedUpdateWithoutUsersInput> = z.object({
  id: z.union([ z.string().cuid(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  createdAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  inviteId: z.union([ z.string().cuid(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  name: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  emailDomains: z.union([ z.lazy(() => UserListUpdateemailDomainsInputSchema),z.string().array() ]).optional(),
  syncToSlackTeamId: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  syncToSlackChannelId: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  authorId: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  questions: z.lazy(() => QuestionUncheckedUpdateManyWithoutSharedWithListsNestedInputSchema).optional(),
  tournaments: z.lazy(() => TournamentUncheckedUpdateManyWithoutUserListNestedInputSchema).optional()
}).strict();

export const UserListUncheckedUpdateManyWithoutUsersInputSchema: z.ZodType<Prisma.UserListUncheckedUpdateManyWithoutUsersInput> = z.object({
  id: z.union([ z.string().cuid(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  createdAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  inviteId: z.union([ z.string().cuid(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  name: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  emailDomains: z.union([ z.lazy(() => UserListUpdateemailDomainsInputSchema),z.string().array() ]).optional(),
  syncToSlackTeamId: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  syncToSlackChannelId: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  authorId: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
}).strict();

export const TagUpdateWithoutUserInputSchema: z.ZodType<Prisma.TagUpdateWithoutUserInput> = z.object({
  id: z.union([ z.string().cuid(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  createdAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  name: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  questions: z.lazy(() => QuestionUpdateManyWithoutTagsNestedInputSchema).optional()
}).strict();

export const TagUncheckedUpdateWithoutUserInputSchema: z.ZodType<Prisma.TagUncheckedUpdateWithoutUserInput> = z.object({
  id: z.union([ z.string().cuid(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  createdAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  name: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  questions: z.lazy(() => QuestionUncheckedUpdateManyWithoutTagsNestedInputSchema).optional()
}).strict();

export const TagUncheckedUpdateManyWithoutUserInputSchema: z.ZodType<Prisma.TagUncheckedUpdateManyWithoutUserInput> = z.object({
  id: z.union([ z.string().cuid(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  createdAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  name: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
}).strict();

export const TournamentUpdateWithoutAuthorInputSchema: z.ZodType<Prisma.TournamentUpdateWithoutAuthorInput> = z.object({
  id: z.union([ z.string().cuid(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  createdAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  name: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  description: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  sharedPublicly: z.union([ z.boolean(),z.lazy(() => BoolFieldUpdateOperationsInputSchema) ]).optional(),
  unlisted: z.union([ z.boolean(),z.lazy(() => BoolFieldUpdateOperationsInputSchema) ]).optional(),
  anyoneInListCanEdit: z.union([ z.boolean(),z.lazy(() => BoolFieldUpdateOperationsInputSchema) ]).optional(),
  showLeaderboard: z.union([ z.boolean(),z.lazy(() => BoolFieldUpdateOperationsInputSchema) ]).optional(),
  predictYourYear: z.union([ z.number().int(),z.lazy(() => NullableIntFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  syncToSlackTeamId: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  syncToSlackChannelId: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  questions: z.lazy(() => QuestionUpdateManyWithoutTournamentsNestedInputSchema).optional(),
  userList: z.lazy(() => UserListUpdateOneWithoutTournamentsNestedInputSchema).optional()
}).strict();

export const TournamentUncheckedUpdateWithoutAuthorInputSchema: z.ZodType<Prisma.TournamentUncheckedUpdateWithoutAuthorInput> = z.object({
  id: z.union([ z.string().cuid(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  createdAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  name: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  description: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  sharedPublicly: z.union([ z.boolean(),z.lazy(() => BoolFieldUpdateOperationsInputSchema) ]).optional(),
  unlisted: z.union([ z.boolean(),z.lazy(() => BoolFieldUpdateOperationsInputSchema) ]).optional(),
  userListId: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  anyoneInListCanEdit: z.union([ z.boolean(),z.lazy(() => BoolFieldUpdateOperationsInputSchema) ]).optional(),
  showLeaderboard: z.union([ z.boolean(),z.lazy(() => BoolFieldUpdateOperationsInputSchema) ]).optional(),
  predictYourYear: z.union([ z.number().int(),z.lazy(() => NullableIntFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  syncToSlackTeamId: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  syncToSlackChannelId: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  questions: z.lazy(() => QuestionUncheckedUpdateManyWithoutTournamentsNestedInputSchema).optional()
}).strict();

export const TournamentUncheckedUpdateManyWithoutAuthorInputSchema: z.ZodType<Prisma.TournamentUncheckedUpdateManyWithoutAuthorInput> = z.object({
  id: z.union([ z.string().cuid(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  createdAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  name: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  description: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  sharedPublicly: z.union([ z.boolean(),z.lazy(() => BoolFieldUpdateOperationsInputSchema) ]).optional(),
  unlisted: z.union([ z.boolean(),z.lazy(() => BoolFieldUpdateOperationsInputSchema) ]).optional(),
  userListId: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  anyoneInListCanEdit: z.union([ z.boolean(),z.lazy(() => BoolFieldUpdateOperationsInputSchema) ]).optional(),
  showLeaderboard: z.union([ z.boolean(),z.lazy(() => BoolFieldUpdateOperationsInputSchema) ]).optional(),
  predictYourYear: z.union([ z.number().int(),z.lazy(() => NullableIntFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  syncToSlackTeamId: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  syncToSlackChannelId: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
}).strict();

export const NotificationUpdateWithoutUserInputSchema: z.ZodType<Prisma.NotificationUpdateWithoutUserInput> = z.object({
  id: z.union([ z.string().cuid(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  createdAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  emailSentAt: z.union([ z.coerce.date(),z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  title: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  content: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  url: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  tags: z.union([ z.lazy(() => NotificationUpdatetagsInputSchema),z.string().array() ]).optional(),
  read: z.union([ z.boolean(),z.lazy(() => BoolFieldUpdateOperationsInputSchema) ]).optional(),
  question: z.lazy(() => QuestionUpdateOneWithoutNotificationsNestedInputSchema).optional()
}).strict();

export const NotificationUncheckedUpdateWithoutUserInputSchema: z.ZodType<Prisma.NotificationUncheckedUpdateWithoutUserInput> = z.object({
  id: z.union([ z.string().cuid(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  createdAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  emailSentAt: z.union([ z.coerce.date(),z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  title: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  content: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  url: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  tags: z.union([ z.lazy(() => NotificationUpdatetagsInputSchema),z.string().array() ]).optional(),
  read: z.union([ z.boolean(),z.lazy(() => BoolFieldUpdateOperationsInputSchema) ]).optional(),
  questionId: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
}).strict();

export const NotificationUncheckedUpdateManyWithoutUserInputSchema: z.ZodType<Prisma.NotificationUncheckedUpdateManyWithoutUserInput> = z.object({
  id: z.union([ z.string().cuid(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  createdAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  emailSentAt: z.union([ z.coerce.date(),z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  title: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  content: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  url: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  tags: z.union([ z.lazy(() => NotificationUpdatetagsInputSchema),z.string().array() ]).optional(),
  read: z.union([ z.boolean(),z.lazy(() => BoolFieldUpdateOperationsInputSchema) ]).optional(),
  questionId: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
}).strict();

export const QuestionOptionUpdateWithoutUserInputSchema: z.ZodType<Prisma.QuestionOptionUpdateWithoutUserInput> = z.object({
  id: z.union([ z.string().cuid(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  text: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  resolution: z.union([ z.lazy(() => ResolutionSchema),z.lazy(() => NullableEnumResolutionFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  createdAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  resolvedAt: z.union([ z.coerce.date(),z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  question: z.lazy(() => QuestionUpdateOneRequiredWithoutOptionsNestedInputSchema).optional(),
  forecasts: z.lazy(() => ForecastUpdateManyWithoutOptionNestedInputSchema).optional(),
  questionScores: z.lazy(() => QuestionScoreUpdateManyWithoutQuestionOptionNestedInputSchema).optional()
}).strict();

export const QuestionOptionUncheckedUpdateWithoutUserInputSchema: z.ZodType<Prisma.QuestionOptionUncheckedUpdateWithoutUserInput> = z.object({
  id: z.union([ z.string().cuid(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  questionId: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  text: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  resolution: z.union([ z.lazy(() => ResolutionSchema),z.lazy(() => NullableEnumResolutionFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  createdAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  resolvedAt: z.union([ z.coerce.date(),z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  forecasts: z.lazy(() => ForecastUncheckedUpdateManyWithoutOptionNestedInputSchema).optional(),
  questionScores: z.lazy(() => QuestionScoreUncheckedUpdateManyWithoutQuestionOptionNestedInputSchema).optional()
}).strict();

export const QuestionOptionUncheckedUpdateManyWithoutUserInputSchema: z.ZodType<Prisma.QuestionOptionUncheckedUpdateManyWithoutUserInput> = z.object({
  id: z.union([ z.string().cuid(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  questionId: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  text: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  resolution: z.union([ z.lazy(() => ResolutionSchema),z.lazy(() => NullableEnumResolutionFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  createdAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  resolvedAt: z.union([ z.coerce.date(),z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema) ]).optional().nullable(),
}).strict();

export const AccountUpdateWithoutUserInputSchema: z.ZodType<Prisma.AccountUpdateWithoutUserInput> = z.object({
  id: z.union([ z.string().cuid(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  type: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  provider: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  providerAccountId: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  refresh_token: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  access_token: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  expires_at: z.union([ z.number().int(),z.lazy(() => NullableIntFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  token_type: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  scope: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  id_token: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  session_state: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
}).strict();

export const AccountUncheckedUpdateWithoutUserInputSchema: z.ZodType<Prisma.AccountUncheckedUpdateWithoutUserInput> = z.object({
  id: z.union([ z.string().cuid(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  type: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  provider: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  providerAccountId: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  refresh_token: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  access_token: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  expires_at: z.union([ z.number().int(),z.lazy(() => NullableIntFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  token_type: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  scope: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  id_token: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  session_state: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
}).strict();

export const AccountUncheckedUpdateManyWithoutUserInputSchema: z.ZodType<Prisma.AccountUncheckedUpdateManyWithoutUserInput> = z.object({
  id: z.union([ z.string().cuid(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  type: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  provider: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  providerAccountId: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  refresh_token: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  access_token: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  expires_at: z.union([ z.number().int(),z.lazy(() => NullableIntFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  token_type: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  scope: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  id_token: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  session_state: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
}).strict();

export const ForecastCreateManyProfileInputSchema: z.ZodType<Prisma.ForecastCreateManyProfileInput> = z.object({
  id: z.number().int().optional(),
  createdAt: z.coerce.date().optional(),
  comment: z.string().optional().nullable(),
  forecast: z.union([z.number(),z.string(),z.instanceof(Decimal),z.instanceof(Prisma.Decimal),DecimalJsLikeSchema,]).refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' }),
  questionId: z.string(),
  optionId: z.string().optional().nullable(),
  userId: z.string()
}).strict();

export const QuestionCreateManyProfileInputSchema: z.ZodType<Prisma.QuestionCreateManyProfileInput> = z.object({
  id: z.string().cuid().optional(),
  createdAt: z.coerce.date().optional(),
  comment: z.string().optional().nullable(),
  title: z.string(),
  type: z.lazy(() => QuestionTypeSchema).optional(),
  resolveBy: z.coerce.date(),
  resolved: z.boolean().optional(),
  pingedForResolution: z.boolean().optional(),
  resolution: z.lazy(() => ResolutionSchema).optional().nullable(),
  resolvedAt: z.coerce.date().optional().nullable(),
  notes: z.string().optional().nullable(),
  hideForecastsUntil: z.coerce.date().optional().nullable(),
  hideForecastsUntilPrediction: z.boolean().optional().nullable(),
  userId: z.string(),
  sharedPublicly: z.boolean().optional(),
  unlisted: z.boolean().optional(),
  exclusiveAnswers: z.boolean().optional().nullable()
}).strict();

export const ResolutionSlackMessageCreateManyProfileInputSchema: z.ZodType<Prisma.ResolutionSlackMessageCreateManyProfileInput> = z.object({
  id: z.number().int().optional(),
  questionId: z.string(),
  detailsId: z.number().int()
}).strict();

export const ForecastUpdateWithoutProfileInputSchema: z.ZodType<Prisma.ForecastUpdateWithoutProfileInput> = z.object({
  createdAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  comment: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  forecast: z.union([ z.union([z.number(),z.string(),z.instanceof(Decimal),z.instanceof(Prisma.Decimal),DecimalJsLikeSchema,]).refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' }),z.lazy(() => DecimalFieldUpdateOperationsInputSchema) ]).optional(),
  option: z.lazy(() => QuestionOptionUpdateOneWithoutForecastsNestedInputSchema).optional(),
  question: z.lazy(() => QuestionUpdateOneRequiredWithoutForecastsNestedInputSchema).optional(),
  user: z.lazy(() => UserUpdateOneRequiredWithoutForecastsNestedInputSchema).optional()
}).strict();

export const ForecastUncheckedUpdateWithoutProfileInputSchema: z.ZodType<Prisma.ForecastUncheckedUpdateWithoutProfileInput> = z.object({
  id: z.union([ z.number().int(),z.lazy(() => IntFieldUpdateOperationsInputSchema) ]).optional(),
  createdAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  comment: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  forecast: z.union([ z.union([z.number(),z.string(),z.instanceof(Decimal),z.instanceof(Prisma.Decimal),DecimalJsLikeSchema,]).refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' }),z.lazy(() => DecimalFieldUpdateOperationsInputSchema) ]).optional(),
  questionId: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  optionId: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  userId: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
}).strict();

export const ForecastUncheckedUpdateManyWithoutProfileInputSchema: z.ZodType<Prisma.ForecastUncheckedUpdateManyWithoutProfileInput> = z.object({
  id: z.union([ z.number().int(),z.lazy(() => IntFieldUpdateOperationsInputSchema) ]).optional(),
  createdAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  comment: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  forecast: z.union([ z.union([z.number(),z.string(),z.instanceof(Decimal),z.instanceof(Prisma.Decimal),DecimalJsLikeSchema,]).refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' }),z.lazy(() => DecimalFieldUpdateOperationsInputSchema) ]).optional(),
  questionId: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  optionId: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  userId: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
}).strict();

export const QuestionUpdateWithoutProfileInputSchema: z.ZodType<Prisma.QuestionUpdateWithoutProfileInput> = z.object({
  id: z.union([ z.string().cuid(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  createdAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  comment: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  title: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  type: z.union([ z.lazy(() => QuestionTypeSchema),z.lazy(() => EnumQuestionTypeFieldUpdateOperationsInputSchema) ]).optional(),
  resolveBy: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  resolved: z.union([ z.boolean(),z.lazy(() => BoolFieldUpdateOperationsInputSchema) ]).optional(),
  pingedForResolution: z.union([ z.boolean(),z.lazy(() => BoolFieldUpdateOperationsInputSchema) ]).optional(),
  resolution: z.union([ z.lazy(() => ResolutionSchema),z.lazy(() => NullableEnumResolutionFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  resolvedAt: z.union([ z.coerce.date(),z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  notes: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  hideForecastsUntil: z.union([ z.coerce.date(),z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  hideForecastsUntilPrediction: z.union([ z.boolean(),z.lazy(() => NullableBoolFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  sharedPublicly: z.union([ z.boolean(),z.lazy(() => BoolFieldUpdateOperationsInputSchema) ]).optional(),
  unlisted: z.union([ z.boolean(),z.lazy(() => BoolFieldUpdateOperationsInputSchema) ]).optional(),
  exclusiveAnswers: z.union([ z.boolean(),z.lazy(() => NullableBoolFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  options: z.lazy(() => QuestionOptionUpdateManyWithoutQuestionNestedInputSchema).optional(),
  forecasts: z.lazy(() => ForecastUpdateManyWithoutQuestionNestedInputSchema).optional(),
  pingResolveMessages: z.lazy(() => PingSlackMessageUpdateManyWithoutQuestionNestedInputSchema).optional(),
  user: z.lazy(() => UserUpdateOneRequiredWithoutQuestionsNestedInputSchema).optional(),
  sharedWith: z.lazy(() => UserUpdateManyWithoutQuestionsSharedWithNestedInputSchema).optional(),
  sharedWithLists: z.lazy(() => UserListUpdateManyWithoutQuestionsNestedInputSchema).optional(),
  questionScores: z.lazy(() => QuestionScoreUpdateManyWithoutQuestionNestedInputSchema).optional(),
  questionMessages: z.lazy(() => QuestionSlackMessageUpdateManyWithoutQuestionNestedInputSchema).optional(),
  resolutionMessages: z.lazy(() => ResolutionSlackMessageUpdateManyWithoutQuestionNestedInputSchema).optional(),
  comments: z.lazy(() => CommentUpdateManyWithoutQuestionNestedInputSchema).optional(),
  tags: z.lazy(() => TagUpdateManyWithoutQuestionsNestedInputSchema).optional(),
  tournaments: z.lazy(() => TournamentUpdateManyWithoutQuestionsNestedInputSchema).optional(),
  notifications: z.lazy(() => NotificationUpdateManyWithoutQuestionNestedInputSchema).optional()
}).strict();

export const QuestionUncheckedUpdateWithoutProfileInputSchema: z.ZodType<Prisma.QuestionUncheckedUpdateWithoutProfileInput> = z.object({
  id: z.union([ z.string().cuid(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  createdAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  comment: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  title: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  type: z.union([ z.lazy(() => QuestionTypeSchema),z.lazy(() => EnumQuestionTypeFieldUpdateOperationsInputSchema) ]).optional(),
  resolveBy: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  resolved: z.union([ z.boolean(),z.lazy(() => BoolFieldUpdateOperationsInputSchema) ]).optional(),
  pingedForResolution: z.union([ z.boolean(),z.lazy(() => BoolFieldUpdateOperationsInputSchema) ]).optional(),
  resolution: z.union([ z.lazy(() => ResolutionSchema),z.lazy(() => NullableEnumResolutionFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  resolvedAt: z.union([ z.coerce.date(),z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  notes: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  hideForecastsUntil: z.union([ z.coerce.date(),z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  hideForecastsUntilPrediction: z.union([ z.boolean(),z.lazy(() => NullableBoolFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  userId: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  sharedPublicly: z.union([ z.boolean(),z.lazy(() => BoolFieldUpdateOperationsInputSchema) ]).optional(),
  unlisted: z.union([ z.boolean(),z.lazy(() => BoolFieldUpdateOperationsInputSchema) ]).optional(),
  exclusiveAnswers: z.union([ z.boolean(),z.lazy(() => NullableBoolFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  options: z.lazy(() => QuestionOptionUncheckedUpdateManyWithoutQuestionNestedInputSchema).optional(),
  forecasts: z.lazy(() => ForecastUncheckedUpdateManyWithoutQuestionNestedInputSchema).optional(),
  pingResolveMessages: z.lazy(() => PingSlackMessageUncheckedUpdateManyWithoutQuestionNestedInputSchema).optional(),
  sharedWith: z.lazy(() => UserUncheckedUpdateManyWithoutQuestionsSharedWithNestedInputSchema).optional(),
  sharedWithLists: z.lazy(() => UserListUncheckedUpdateManyWithoutQuestionsNestedInputSchema).optional(),
  questionScores: z.lazy(() => QuestionScoreUncheckedUpdateManyWithoutQuestionNestedInputSchema).optional(),
  questionMessages: z.lazy(() => QuestionSlackMessageUncheckedUpdateManyWithoutQuestionNestedInputSchema).optional(),
  resolutionMessages: z.lazy(() => ResolutionSlackMessageUncheckedUpdateManyWithoutQuestionNestedInputSchema).optional(),
  comments: z.lazy(() => CommentUncheckedUpdateManyWithoutQuestionNestedInputSchema).optional(),
  tags: z.lazy(() => TagUncheckedUpdateManyWithoutQuestionsNestedInputSchema).optional(),
  tournaments: z.lazy(() => TournamentUncheckedUpdateManyWithoutQuestionsNestedInputSchema).optional(),
  notifications: z.lazy(() => NotificationUncheckedUpdateManyWithoutQuestionNestedInputSchema).optional()
}).strict();

export const QuestionUncheckedUpdateManyWithoutProfileInputSchema: z.ZodType<Prisma.QuestionUncheckedUpdateManyWithoutProfileInput> = z.object({
  id: z.union([ z.string().cuid(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  createdAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  comment: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  title: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  type: z.union([ z.lazy(() => QuestionTypeSchema),z.lazy(() => EnumQuestionTypeFieldUpdateOperationsInputSchema) ]).optional(),
  resolveBy: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  resolved: z.union([ z.boolean(),z.lazy(() => BoolFieldUpdateOperationsInputSchema) ]).optional(),
  pingedForResolution: z.union([ z.boolean(),z.lazy(() => BoolFieldUpdateOperationsInputSchema) ]).optional(),
  resolution: z.union([ z.lazy(() => ResolutionSchema),z.lazy(() => NullableEnumResolutionFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  resolvedAt: z.union([ z.coerce.date(),z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  notes: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  hideForecastsUntil: z.union([ z.coerce.date(),z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  hideForecastsUntilPrediction: z.union([ z.boolean(),z.lazy(() => NullableBoolFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  userId: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  sharedPublicly: z.union([ z.boolean(),z.lazy(() => BoolFieldUpdateOperationsInputSchema) ]).optional(),
  unlisted: z.union([ z.boolean(),z.lazy(() => BoolFieldUpdateOperationsInputSchema) ]).optional(),
  exclusiveAnswers: z.union([ z.boolean(),z.lazy(() => NullableBoolFieldUpdateOperationsInputSchema) ]).optional().nullable(),
}).strict();

export const ResolutionSlackMessageUpdateWithoutProfileInputSchema: z.ZodType<Prisma.ResolutionSlackMessageUpdateWithoutProfileInput> = z.object({
  message: z.lazy(() => SlackMessageUpdateOneRequiredWithoutResolutionSlackMessageNestedInputSchema).optional(),
  question: z.lazy(() => QuestionUpdateOneRequiredWithoutResolutionMessagesNestedInputSchema).optional()
}).strict();

export const ResolutionSlackMessageUncheckedUpdateWithoutProfileInputSchema: z.ZodType<Prisma.ResolutionSlackMessageUncheckedUpdateWithoutProfileInput> = z.object({
  id: z.union([ z.number().int(),z.lazy(() => IntFieldUpdateOperationsInputSchema) ]).optional(),
  questionId: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  detailsId: z.union([ z.number().int(),z.lazy(() => IntFieldUpdateOperationsInputSchema) ]).optional(),
}).strict();

export const ResolutionSlackMessageUncheckedUpdateManyWithoutProfileInputSchema: z.ZodType<Prisma.ResolutionSlackMessageUncheckedUpdateManyWithoutProfileInput> = z.object({
  id: z.union([ z.number().int(),z.lazy(() => IntFieldUpdateOperationsInputSchema) ]).optional(),
  questionId: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  detailsId: z.union([ z.number().int(),z.lazy(() => IntFieldUpdateOperationsInputSchema) ]).optional(),
}).strict();

export const TournamentCreateManyUserListInputSchema: z.ZodType<Prisma.TournamentCreateManyUserListInput> = z.object({
  id: z.string().cuid().optional(),
  createdAt: z.coerce.date().optional(),
  name: z.string(),
  description: z.string().optional().nullable(),
  authorId: z.string(),
  sharedPublicly: z.boolean().optional(),
  unlisted: z.boolean().optional(),
  anyoneInListCanEdit: z.boolean().optional(),
  showLeaderboard: z.boolean().optional(),
  predictYourYear: z.number().int().optional().nullable(),
  syncToSlackTeamId: z.string().optional().nullable(),
  syncToSlackChannelId: z.string().optional().nullable()
}).strict();

export const UserUpdateWithoutMemberOfListsInputSchema: z.ZodType<Prisma.UserUpdateWithoutMemberOfListsInput> = z.object({
  id: z.union([ z.string().cuid(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  name: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  createdAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  email: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  image: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  staleReminder: z.union([ z.boolean(),z.lazy(() => BoolFieldUpdateOperationsInputSchema) ]).optional(),
  unsubscribedFromEmailsAt: z.union([ z.coerce.date(),z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  apiKey: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  discordUserId: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  emailVerified: z.union([ z.coerce.date(),z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  forecasts: z.lazy(() => ForecastUpdateManyWithoutUserNestedInputSchema).optional(),
  profiles: z.lazy(() => ProfileUpdateManyWithoutUserNestedInputSchema).optional(),
  questions: z.lazy(() => QuestionUpdateManyWithoutUserNestedInputSchema).optional(),
  questionScores: z.lazy(() => QuestionScoreUpdateManyWithoutUserNestedInputSchema).optional(),
  questionsSharedWith: z.lazy(() => QuestionUpdateManyWithoutSharedWithNestedInputSchema).optional(),
  comments: z.lazy(() => CommentUpdateManyWithoutUserNestedInputSchema).optional(),
  target: z.lazy(() => TargetUpdateOneWithoutUserNestedInputSchema).optional(),
  authorOfLists: z.lazy(() => UserListUpdateManyWithoutAuthorNestedInputSchema).optional(),
  tags: z.lazy(() => TagUpdateManyWithoutUserNestedInputSchema).optional(),
  tournaments: z.lazy(() => TournamentUpdateManyWithoutAuthorNestedInputSchema).optional(),
  notifications: z.lazy(() => NotificationUpdateManyWithoutUserNestedInputSchema).optional(),
  questionOptions: z.lazy(() => QuestionOptionUpdateManyWithoutUserNestedInputSchema).optional(),
  accounts: z.lazy(() => AccountUpdateManyWithoutUserNestedInputSchema).optional()
}).strict();

export const UserUncheckedUpdateWithoutMemberOfListsInputSchema: z.ZodType<Prisma.UserUncheckedUpdateWithoutMemberOfListsInput> = z.object({
  id: z.union([ z.string().cuid(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  name: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  createdAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  email: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  image: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  staleReminder: z.union([ z.boolean(),z.lazy(() => BoolFieldUpdateOperationsInputSchema) ]).optional(),
  unsubscribedFromEmailsAt: z.union([ z.coerce.date(),z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  apiKey: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  discordUserId: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  emailVerified: z.union([ z.coerce.date(),z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  forecasts: z.lazy(() => ForecastUncheckedUpdateManyWithoutUserNestedInputSchema).optional(),
  profiles: z.lazy(() => ProfileUncheckedUpdateManyWithoutUserNestedInputSchema).optional(),
  questions: z.lazy(() => QuestionUncheckedUpdateManyWithoutUserNestedInputSchema).optional(),
  questionScores: z.lazy(() => QuestionScoreUncheckedUpdateManyWithoutUserNestedInputSchema).optional(),
  questionsSharedWith: z.lazy(() => QuestionUncheckedUpdateManyWithoutSharedWithNestedInputSchema).optional(),
  comments: z.lazy(() => CommentUncheckedUpdateManyWithoutUserNestedInputSchema).optional(),
  target: z.lazy(() => TargetUncheckedUpdateOneWithoutUserNestedInputSchema).optional(),
  authorOfLists: z.lazy(() => UserListUncheckedUpdateManyWithoutAuthorNestedInputSchema).optional(),
  tags: z.lazy(() => TagUncheckedUpdateManyWithoutUserNestedInputSchema).optional(),
  tournaments: z.lazy(() => TournamentUncheckedUpdateManyWithoutAuthorNestedInputSchema).optional(),
  notifications: z.lazy(() => NotificationUncheckedUpdateManyWithoutUserNestedInputSchema).optional(),
  questionOptions: z.lazy(() => QuestionOptionUncheckedUpdateManyWithoutUserNestedInputSchema).optional(),
  accounts: z.lazy(() => AccountUncheckedUpdateManyWithoutUserNestedInputSchema).optional()
}).strict();

export const UserUncheckedUpdateManyWithoutMemberOfListsInputSchema: z.ZodType<Prisma.UserUncheckedUpdateManyWithoutMemberOfListsInput> = z.object({
  id: z.union([ z.string().cuid(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  name: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  createdAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  email: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  image: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  staleReminder: z.union([ z.boolean(),z.lazy(() => BoolFieldUpdateOperationsInputSchema) ]).optional(),
  unsubscribedFromEmailsAt: z.union([ z.coerce.date(),z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  apiKey: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  discordUserId: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  emailVerified: z.union([ z.coerce.date(),z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema) ]).optional().nullable(),
}).strict();

export const QuestionUpdateWithoutSharedWithListsInputSchema: z.ZodType<Prisma.QuestionUpdateWithoutSharedWithListsInput> = z.object({
  id: z.union([ z.string().cuid(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  createdAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  comment: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  title: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  type: z.union([ z.lazy(() => QuestionTypeSchema),z.lazy(() => EnumQuestionTypeFieldUpdateOperationsInputSchema) ]).optional(),
  resolveBy: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  resolved: z.union([ z.boolean(),z.lazy(() => BoolFieldUpdateOperationsInputSchema) ]).optional(),
  pingedForResolution: z.union([ z.boolean(),z.lazy(() => BoolFieldUpdateOperationsInputSchema) ]).optional(),
  resolution: z.union([ z.lazy(() => ResolutionSchema),z.lazy(() => NullableEnumResolutionFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  resolvedAt: z.union([ z.coerce.date(),z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  notes: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  hideForecastsUntil: z.union([ z.coerce.date(),z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  hideForecastsUntilPrediction: z.union([ z.boolean(),z.lazy(() => NullableBoolFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  sharedPublicly: z.union([ z.boolean(),z.lazy(() => BoolFieldUpdateOperationsInputSchema) ]).optional(),
  unlisted: z.union([ z.boolean(),z.lazy(() => BoolFieldUpdateOperationsInputSchema) ]).optional(),
  exclusiveAnswers: z.union([ z.boolean(),z.lazy(() => NullableBoolFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  options: z.lazy(() => QuestionOptionUpdateManyWithoutQuestionNestedInputSchema).optional(),
  forecasts: z.lazy(() => ForecastUpdateManyWithoutQuestionNestedInputSchema).optional(),
  pingResolveMessages: z.lazy(() => PingSlackMessageUpdateManyWithoutQuestionNestedInputSchema).optional(),
  profile: z.lazy(() => ProfileUpdateOneWithoutQuestionsNestedInputSchema).optional(),
  user: z.lazy(() => UserUpdateOneRequiredWithoutQuestionsNestedInputSchema).optional(),
  sharedWith: z.lazy(() => UserUpdateManyWithoutQuestionsSharedWithNestedInputSchema).optional(),
  questionScores: z.lazy(() => QuestionScoreUpdateManyWithoutQuestionNestedInputSchema).optional(),
  questionMessages: z.lazy(() => QuestionSlackMessageUpdateManyWithoutQuestionNestedInputSchema).optional(),
  resolutionMessages: z.lazy(() => ResolutionSlackMessageUpdateManyWithoutQuestionNestedInputSchema).optional(),
  comments: z.lazy(() => CommentUpdateManyWithoutQuestionNestedInputSchema).optional(),
  tags: z.lazy(() => TagUpdateManyWithoutQuestionsNestedInputSchema).optional(),
  tournaments: z.lazy(() => TournamentUpdateManyWithoutQuestionsNestedInputSchema).optional(),
  notifications: z.lazy(() => NotificationUpdateManyWithoutQuestionNestedInputSchema).optional()
}).strict();

export const QuestionUncheckedUpdateWithoutSharedWithListsInputSchema: z.ZodType<Prisma.QuestionUncheckedUpdateWithoutSharedWithListsInput> = z.object({
  id: z.union([ z.string().cuid(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  createdAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  comment: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  profileId: z.union([ z.number().int(),z.lazy(() => NullableIntFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  title: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  type: z.union([ z.lazy(() => QuestionTypeSchema),z.lazy(() => EnumQuestionTypeFieldUpdateOperationsInputSchema) ]).optional(),
  resolveBy: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  resolved: z.union([ z.boolean(),z.lazy(() => BoolFieldUpdateOperationsInputSchema) ]).optional(),
  pingedForResolution: z.union([ z.boolean(),z.lazy(() => BoolFieldUpdateOperationsInputSchema) ]).optional(),
  resolution: z.union([ z.lazy(() => ResolutionSchema),z.lazy(() => NullableEnumResolutionFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  resolvedAt: z.union([ z.coerce.date(),z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  notes: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  hideForecastsUntil: z.union([ z.coerce.date(),z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  hideForecastsUntilPrediction: z.union([ z.boolean(),z.lazy(() => NullableBoolFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  userId: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  sharedPublicly: z.union([ z.boolean(),z.lazy(() => BoolFieldUpdateOperationsInputSchema) ]).optional(),
  unlisted: z.union([ z.boolean(),z.lazy(() => BoolFieldUpdateOperationsInputSchema) ]).optional(),
  exclusiveAnswers: z.union([ z.boolean(),z.lazy(() => NullableBoolFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  options: z.lazy(() => QuestionOptionUncheckedUpdateManyWithoutQuestionNestedInputSchema).optional(),
  forecasts: z.lazy(() => ForecastUncheckedUpdateManyWithoutQuestionNestedInputSchema).optional(),
  pingResolveMessages: z.lazy(() => PingSlackMessageUncheckedUpdateManyWithoutQuestionNestedInputSchema).optional(),
  sharedWith: z.lazy(() => UserUncheckedUpdateManyWithoutQuestionsSharedWithNestedInputSchema).optional(),
  questionScores: z.lazy(() => QuestionScoreUncheckedUpdateManyWithoutQuestionNestedInputSchema).optional(),
  questionMessages: z.lazy(() => QuestionSlackMessageUncheckedUpdateManyWithoutQuestionNestedInputSchema).optional(),
  resolutionMessages: z.lazy(() => ResolutionSlackMessageUncheckedUpdateManyWithoutQuestionNestedInputSchema).optional(),
  comments: z.lazy(() => CommentUncheckedUpdateManyWithoutQuestionNestedInputSchema).optional(),
  tags: z.lazy(() => TagUncheckedUpdateManyWithoutQuestionsNestedInputSchema).optional(),
  tournaments: z.lazy(() => TournamentUncheckedUpdateManyWithoutQuestionsNestedInputSchema).optional(),
  notifications: z.lazy(() => NotificationUncheckedUpdateManyWithoutQuestionNestedInputSchema).optional()
}).strict();

export const QuestionUncheckedUpdateManyWithoutSharedWithListsInputSchema: z.ZodType<Prisma.QuestionUncheckedUpdateManyWithoutSharedWithListsInput> = z.object({
  id: z.union([ z.string().cuid(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  createdAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  comment: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  profileId: z.union([ z.number().int(),z.lazy(() => NullableIntFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  title: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  type: z.union([ z.lazy(() => QuestionTypeSchema),z.lazy(() => EnumQuestionTypeFieldUpdateOperationsInputSchema) ]).optional(),
  resolveBy: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  resolved: z.union([ z.boolean(),z.lazy(() => BoolFieldUpdateOperationsInputSchema) ]).optional(),
  pingedForResolution: z.union([ z.boolean(),z.lazy(() => BoolFieldUpdateOperationsInputSchema) ]).optional(),
  resolution: z.union([ z.lazy(() => ResolutionSchema),z.lazy(() => NullableEnumResolutionFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  resolvedAt: z.union([ z.coerce.date(),z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  notes: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  hideForecastsUntil: z.union([ z.coerce.date(),z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  hideForecastsUntilPrediction: z.union([ z.boolean(),z.lazy(() => NullableBoolFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  userId: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  sharedPublicly: z.union([ z.boolean(),z.lazy(() => BoolFieldUpdateOperationsInputSchema) ]).optional(),
  unlisted: z.union([ z.boolean(),z.lazy(() => BoolFieldUpdateOperationsInputSchema) ]).optional(),
  exclusiveAnswers: z.union([ z.boolean(),z.lazy(() => NullableBoolFieldUpdateOperationsInputSchema) ]).optional().nullable(),
}).strict();

export const TournamentUpdateWithoutUserListInputSchema: z.ZodType<Prisma.TournamentUpdateWithoutUserListInput> = z.object({
  id: z.union([ z.string().cuid(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  createdAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  name: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  description: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  sharedPublicly: z.union([ z.boolean(),z.lazy(() => BoolFieldUpdateOperationsInputSchema) ]).optional(),
  unlisted: z.union([ z.boolean(),z.lazy(() => BoolFieldUpdateOperationsInputSchema) ]).optional(),
  anyoneInListCanEdit: z.union([ z.boolean(),z.lazy(() => BoolFieldUpdateOperationsInputSchema) ]).optional(),
  showLeaderboard: z.union([ z.boolean(),z.lazy(() => BoolFieldUpdateOperationsInputSchema) ]).optional(),
  predictYourYear: z.union([ z.number().int(),z.lazy(() => NullableIntFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  syncToSlackTeamId: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  syncToSlackChannelId: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  questions: z.lazy(() => QuestionUpdateManyWithoutTournamentsNestedInputSchema).optional(),
  author: z.lazy(() => UserUpdateOneRequiredWithoutTournamentsNestedInputSchema).optional()
}).strict();

export const TournamentUncheckedUpdateWithoutUserListInputSchema: z.ZodType<Prisma.TournamentUncheckedUpdateWithoutUserListInput> = z.object({
  id: z.union([ z.string().cuid(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  createdAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  name: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  description: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  authorId: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  sharedPublicly: z.union([ z.boolean(),z.lazy(() => BoolFieldUpdateOperationsInputSchema) ]).optional(),
  unlisted: z.union([ z.boolean(),z.lazy(() => BoolFieldUpdateOperationsInputSchema) ]).optional(),
  anyoneInListCanEdit: z.union([ z.boolean(),z.lazy(() => BoolFieldUpdateOperationsInputSchema) ]).optional(),
  showLeaderboard: z.union([ z.boolean(),z.lazy(() => BoolFieldUpdateOperationsInputSchema) ]).optional(),
  predictYourYear: z.union([ z.number().int(),z.lazy(() => NullableIntFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  syncToSlackTeamId: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  syncToSlackChannelId: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  questions: z.lazy(() => QuestionUncheckedUpdateManyWithoutTournamentsNestedInputSchema).optional()
}).strict();

export const TournamentUncheckedUpdateManyWithoutUserListInputSchema: z.ZodType<Prisma.TournamentUncheckedUpdateManyWithoutUserListInput> = z.object({
  id: z.union([ z.string().cuid(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  createdAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  name: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  description: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  authorId: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  sharedPublicly: z.union([ z.boolean(),z.lazy(() => BoolFieldUpdateOperationsInputSchema) ]).optional(),
  unlisted: z.union([ z.boolean(),z.lazy(() => BoolFieldUpdateOperationsInputSchema) ]).optional(),
  anyoneInListCanEdit: z.union([ z.boolean(),z.lazy(() => BoolFieldUpdateOperationsInputSchema) ]).optional(),
  showLeaderboard: z.union([ z.boolean(),z.lazy(() => BoolFieldUpdateOperationsInputSchema) ]).optional(),
  predictYourYear: z.union([ z.number().int(),z.lazy(() => NullableIntFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  syncToSlackTeamId: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  syncToSlackChannelId: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
}).strict();

export const QuestionUpdateWithoutTournamentsInputSchema: z.ZodType<Prisma.QuestionUpdateWithoutTournamentsInput> = z.object({
  id: z.union([ z.string().cuid(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  createdAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  comment: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  title: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  type: z.union([ z.lazy(() => QuestionTypeSchema),z.lazy(() => EnumQuestionTypeFieldUpdateOperationsInputSchema) ]).optional(),
  resolveBy: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  resolved: z.union([ z.boolean(),z.lazy(() => BoolFieldUpdateOperationsInputSchema) ]).optional(),
  pingedForResolution: z.union([ z.boolean(),z.lazy(() => BoolFieldUpdateOperationsInputSchema) ]).optional(),
  resolution: z.union([ z.lazy(() => ResolutionSchema),z.lazy(() => NullableEnumResolutionFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  resolvedAt: z.union([ z.coerce.date(),z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  notes: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  hideForecastsUntil: z.union([ z.coerce.date(),z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  hideForecastsUntilPrediction: z.union([ z.boolean(),z.lazy(() => NullableBoolFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  sharedPublicly: z.union([ z.boolean(),z.lazy(() => BoolFieldUpdateOperationsInputSchema) ]).optional(),
  unlisted: z.union([ z.boolean(),z.lazy(() => BoolFieldUpdateOperationsInputSchema) ]).optional(),
  exclusiveAnswers: z.union([ z.boolean(),z.lazy(() => NullableBoolFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  options: z.lazy(() => QuestionOptionUpdateManyWithoutQuestionNestedInputSchema).optional(),
  forecasts: z.lazy(() => ForecastUpdateManyWithoutQuestionNestedInputSchema).optional(),
  pingResolveMessages: z.lazy(() => PingSlackMessageUpdateManyWithoutQuestionNestedInputSchema).optional(),
  profile: z.lazy(() => ProfileUpdateOneWithoutQuestionsNestedInputSchema).optional(),
  user: z.lazy(() => UserUpdateOneRequiredWithoutQuestionsNestedInputSchema).optional(),
  sharedWith: z.lazy(() => UserUpdateManyWithoutQuestionsSharedWithNestedInputSchema).optional(),
  sharedWithLists: z.lazy(() => UserListUpdateManyWithoutQuestionsNestedInputSchema).optional(),
  questionScores: z.lazy(() => QuestionScoreUpdateManyWithoutQuestionNestedInputSchema).optional(),
  questionMessages: z.lazy(() => QuestionSlackMessageUpdateManyWithoutQuestionNestedInputSchema).optional(),
  resolutionMessages: z.lazy(() => ResolutionSlackMessageUpdateManyWithoutQuestionNestedInputSchema).optional(),
  comments: z.lazy(() => CommentUpdateManyWithoutQuestionNestedInputSchema).optional(),
  tags: z.lazy(() => TagUpdateManyWithoutQuestionsNestedInputSchema).optional(),
  notifications: z.lazy(() => NotificationUpdateManyWithoutQuestionNestedInputSchema).optional()
}).strict();

export const QuestionUncheckedUpdateWithoutTournamentsInputSchema: z.ZodType<Prisma.QuestionUncheckedUpdateWithoutTournamentsInput> = z.object({
  id: z.union([ z.string().cuid(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  createdAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  comment: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  profileId: z.union([ z.number().int(),z.lazy(() => NullableIntFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  title: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  type: z.union([ z.lazy(() => QuestionTypeSchema),z.lazy(() => EnumQuestionTypeFieldUpdateOperationsInputSchema) ]).optional(),
  resolveBy: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  resolved: z.union([ z.boolean(),z.lazy(() => BoolFieldUpdateOperationsInputSchema) ]).optional(),
  pingedForResolution: z.union([ z.boolean(),z.lazy(() => BoolFieldUpdateOperationsInputSchema) ]).optional(),
  resolution: z.union([ z.lazy(() => ResolutionSchema),z.lazy(() => NullableEnumResolutionFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  resolvedAt: z.union([ z.coerce.date(),z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  notes: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  hideForecastsUntil: z.union([ z.coerce.date(),z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  hideForecastsUntilPrediction: z.union([ z.boolean(),z.lazy(() => NullableBoolFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  userId: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  sharedPublicly: z.union([ z.boolean(),z.lazy(() => BoolFieldUpdateOperationsInputSchema) ]).optional(),
  unlisted: z.union([ z.boolean(),z.lazy(() => BoolFieldUpdateOperationsInputSchema) ]).optional(),
  exclusiveAnswers: z.union([ z.boolean(),z.lazy(() => NullableBoolFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  options: z.lazy(() => QuestionOptionUncheckedUpdateManyWithoutQuestionNestedInputSchema).optional(),
  forecasts: z.lazy(() => ForecastUncheckedUpdateManyWithoutQuestionNestedInputSchema).optional(),
  pingResolveMessages: z.lazy(() => PingSlackMessageUncheckedUpdateManyWithoutQuestionNestedInputSchema).optional(),
  sharedWith: z.lazy(() => UserUncheckedUpdateManyWithoutQuestionsSharedWithNestedInputSchema).optional(),
  sharedWithLists: z.lazy(() => UserListUncheckedUpdateManyWithoutQuestionsNestedInputSchema).optional(),
  questionScores: z.lazy(() => QuestionScoreUncheckedUpdateManyWithoutQuestionNestedInputSchema).optional(),
  questionMessages: z.lazy(() => QuestionSlackMessageUncheckedUpdateManyWithoutQuestionNestedInputSchema).optional(),
  resolutionMessages: z.lazy(() => ResolutionSlackMessageUncheckedUpdateManyWithoutQuestionNestedInputSchema).optional(),
  comments: z.lazy(() => CommentUncheckedUpdateManyWithoutQuestionNestedInputSchema).optional(),
  tags: z.lazy(() => TagUncheckedUpdateManyWithoutQuestionsNestedInputSchema).optional(),
  notifications: z.lazy(() => NotificationUncheckedUpdateManyWithoutQuestionNestedInputSchema).optional()
}).strict();

export const QuestionUncheckedUpdateManyWithoutTournamentsInputSchema: z.ZodType<Prisma.QuestionUncheckedUpdateManyWithoutTournamentsInput> = z.object({
  id: z.union([ z.string().cuid(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  createdAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  comment: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  profileId: z.union([ z.number().int(),z.lazy(() => NullableIntFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  title: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  type: z.union([ z.lazy(() => QuestionTypeSchema),z.lazy(() => EnumQuestionTypeFieldUpdateOperationsInputSchema) ]).optional(),
  resolveBy: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  resolved: z.union([ z.boolean(),z.lazy(() => BoolFieldUpdateOperationsInputSchema) ]).optional(),
  pingedForResolution: z.union([ z.boolean(),z.lazy(() => BoolFieldUpdateOperationsInputSchema) ]).optional(),
  resolution: z.union([ z.lazy(() => ResolutionSchema),z.lazy(() => NullableEnumResolutionFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  resolvedAt: z.union([ z.coerce.date(),z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  notes: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  hideForecastsUntil: z.union([ z.coerce.date(),z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  hideForecastsUntilPrediction: z.union([ z.boolean(),z.lazy(() => NullableBoolFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  userId: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  sharedPublicly: z.union([ z.boolean(),z.lazy(() => BoolFieldUpdateOperationsInputSchema) ]).optional(),
  unlisted: z.union([ z.boolean(),z.lazy(() => BoolFieldUpdateOperationsInputSchema) ]).optional(),
  exclusiveAnswers: z.union([ z.boolean(),z.lazy(() => NullableBoolFieldUpdateOperationsInputSchema) ]).optional().nullable(),
}).strict();

/////////////////////////////////////////
// ARGS
/////////////////////////////////////////

export const WorkspaceFindFirstArgsSchema: z.ZodType<Prisma.WorkspaceFindFirstArgs> = z.object({
  select: WorkspaceSelectSchema.optional(),
  where: WorkspaceWhereInputSchema.optional(),
  orderBy: z.union([ WorkspaceOrderByWithRelationInputSchema.array(),WorkspaceOrderByWithRelationInputSchema ]).optional(),
  cursor: WorkspaceWhereUniqueInputSchema.optional(),
  take: z.number().optional(),
  skip: z.number().optional(),
  distinct: z.union([ WorkspaceScalarFieldEnumSchema,WorkspaceScalarFieldEnumSchema.array() ]).optional(),
}).strict() ;

export const WorkspaceFindFirstOrThrowArgsSchema: z.ZodType<Prisma.WorkspaceFindFirstOrThrowArgs> = z.object({
  select: WorkspaceSelectSchema.optional(),
  where: WorkspaceWhereInputSchema.optional(),
  orderBy: z.union([ WorkspaceOrderByWithRelationInputSchema.array(),WorkspaceOrderByWithRelationInputSchema ]).optional(),
  cursor: WorkspaceWhereUniqueInputSchema.optional(),
  take: z.number().optional(),
  skip: z.number().optional(),
  distinct: z.union([ WorkspaceScalarFieldEnumSchema,WorkspaceScalarFieldEnumSchema.array() ]).optional(),
}).strict() ;

export const WorkspaceFindManyArgsSchema: z.ZodType<Prisma.WorkspaceFindManyArgs> = z.object({
  select: WorkspaceSelectSchema.optional(),
  where: WorkspaceWhereInputSchema.optional(),
  orderBy: z.union([ WorkspaceOrderByWithRelationInputSchema.array(),WorkspaceOrderByWithRelationInputSchema ]).optional(),
  cursor: WorkspaceWhereUniqueInputSchema.optional(),
  take: z.number().optional(),
  skip: z.number().optional(),
  distinct: z.union([ WorkspaceScalarFieldEnumSchema,WorkspaceScalarFieldEnumSchema.array() ]).optional(),
}).strict() ;

export const WorkspaceAggregateArgsSchema: z.ZodType<Prisma.WorkspaceAggregateArgs> = z.object({
  where: WorkspaceWhereInputSchema.optional(),
  orderBy: z.union([ WorkspaceOrderByWithRelationInputSchema.array(),WorkspaceOrderByWithRelationInputSchema ]).optional(),
  cursor: WorkspaceWhereUniqueInputSchema.optional(),
  take: z.number().optional(),
  skip: z.number().optional(),
}).strict() ;

export const WorkspaceGroupByArgsSchema: z.ZodType<Prisma.WorkspaceGroupByArgs> = z.object({
  where: WorkspaceWhereInputSchema.optional(),
  orderBy: z.union([ WorkspaceOrderByWithAggregationInputSchema.array(),WorkspaceOrderByWithAggregationInputSchema ]).optional(),
  by: WorkspaceScalarFieldEnumSchema.array(),
  having: WorkspaceScalarWhereWithAggregatesInputSchema.optional(),
  take: z.number().optional(),
  skip: z.number().optional(),
}).strict() ;

export const WorkspaceFindUniqueArgsSchema: z.ZodType<Prisma.WorkspaceFindUniqueArgs> = z.object({
  select: WorkspaceSelectSchema.optional(),
  where: WorkspaceWhereUniqueInputSchema,
}).strict() ;

export const WorkspaceFindUniqueOrThrowArgsSchema: z.ZodType<Prisma.WorkspaceFindUniqueOrThrowArgs> = z.object({
  select: WorkspaceSelectSchema.optional(),
  where: WorkspaceWhereUniqueInputSchema,
}).strict() ;

export const ForecastFindFirstArgsSchema: z.ZodType<Prisma.ForecastFindFirstArgs> = z.object({
  select: ForecastSelectSchema.optional(),
  include: ForecastIncludeSchema.optional(),
  where: ForecastWhereInputSchema.optional(),
  orderBy: z.union([ ForecastOrderByWithRelationInputSchema.array(),ForecastOrderByWithRelationInputSchema ]).optional(),
  cursor: ForecastWhereUniqueInputSchema.optional(),
  take: z.number().optional(),
  skip: z.number().optional(),
  distinct: z.union([ ForecastScalarFieldEnumSchema,ForecastScalarFieldEnumSchema.array() ]).optional(),
}).strict() ;

export const ForecastFindFirstOrThrowArgsSchema: z.ZodType<Prisma.ForecastFindFirstOrThrowArgs> = z.object({
  select: ForecastSelectSchema.optional(),
  include: ForecastIncludeSchema.optional(),
  where: ForecastWhereInputSchema.optional(),
  orderBy: z.union([ ForecastOrderByWithRelationInputSchema.array(),ForecastOrderByWithRelationInputSchema ]).optional(),
  cursor: ForecastWhereUniqueInputSchema.optional(),
  take: z.number().optional(),
  skip: z.number().optional(),
  distinct: z.union([ ForecastScalarFieldEnumSchema,ForecastScalarFieldEnumSchema.array() ]).optional(),
}).strict() ;

export const ForecastFindManyArgsSchema: z.ZodType<Prisma.ForecastFindManyArgs> = z.object({
  select: ForecastSelectSchema.optional(),
  include: ForecastIncludeSchema.optional(),
  where: ForecastWhereInputSchema.optional(),
  orderBy: z.union([ ForecastOrderByWithRelationInputSchema.array(),ForecastOrderByWithRelationInputSchema ]).optional(),
  cursor: ForecastWhereUniqueInputSchema.optional(),
  take: z.number().optional(),
  skip: z.number().optional(),
  distinct: z.union([ ForecastScalarFieldEnumSchema,ForecastScalarFieldEnumSchema.array() ]).optional(),
}).strict() ;

export const ForecastAggregateArgsSchema: z.ZodType<Prisma.ForecastAggregateArgs> = z.object({
  where: ForecastWhereInputSchema.optional(),
  orderBy: z.union([ ForecastOrderByWithRelationInputSchema.array(),ForecastOrderByWithRelationInputSchema ]).optional(),
  cursor: ForecastWhereUniqueInputSchema.optional(),
  take: z.number().optional(),
  skip: z.number().optional(),
}).strict() ;

export const ForecastGroupByArgsSchema: z.ZodType<Prisma.ForecastGroupByArgs> = z.object({
  where: ForecastWhereInputSchema.optional(),
  orderBy: z.union([ ForecastOrderByWithAggregationInputSchema.array(),ForecastOrderByWithAggregationInputSchema ]).optional(),
  by: ForecastScalarFieldEnumSchema.array(),
  having: ForecastScalarWhereWithAggregatesInputSchema.optional(),
  take: z.number().optional(),
  skip: z.number().optional(),
}).strict() ;

export const ForecastFindUniqueArgsSchema: z.ZodType<Prisma.ForecastFindUniqueArgs> = z.object({
  select: ForecastSelectSchema.optional(),
  include: ForecastIncludeSchema.optional(),
  where: ForecastWhereUniqueInputSchema,
}).strict() ;

export const ForecastFindUniqueOrThrowArgsSchema: z.ZodType<Prisma.ForecastFindUniqueOrThrowArgs> = z.object({
  select: ForecastSelectSchema.optional(),
  include: ForecastIncludeSchema.optional(),
  where: ForecastWhereUniqueInputSchema,
}).strict() ;

export const QuestionScoreFindFirstArgsSchema: z.ZodType<Prisma.QuestionScoreFindFirstArgs> = z.object({
  select: QuestionScoreSelectSchema.optional(),
  include: QuestionScoreIncludeSchema.optional(),
  where: QuestionScoreWhereInputSchema.optional(),
  orderBy: z.union([ QuestionScoreOrderByWithRelationInputSchema.array(),QuestionScoreOrderByWithRelationInputSchema ]).optional(),
  cursor: QuestionScoreWhereUniqueInputSchema.optional(),
  take: z.number().optional(),
  skip: z.number().optional(),
  distinct: z.union([ QuestionScoreScalarFieldEnumSchema,QuestionScoreScalarFieldEnumSchema.array() ]).optional(),
}).strict() ;

export const QuestionScoreFindFirstOrThrowArgsSchema: z.ZodType<Prisma.QuestionScoreFindFirstOrThrowArgs> = z.object({
  select: QuestionScoreSelectSchema.optional(),
  include: QuestionScoreIncludeSchema.optional(),
  where: QuestionScoreWhereInputSchema.optional(),
  orderBy: z.union([ QuestionScoreOrderByWithRelationInputSchema.array(),QuestionScoreOrderByWithRelationInputSchema ]).optional(),
  cursor: QuestionScoreWhereUniqueInputSchema.optional(),
  take: z.number().optional(),
  skip: z.number().optional(),
  distinct: z.union([ QuestionScoreScalarFieldEnumSchema,QuestionScoreScalarFieldEnumSchema.array() ]).optional(),
}).strict() ;

export const QuestionScoreFindManyArgsSchema: z.ZodType<Prisma.QuestionScoreFindManyArgs> = z.object({
  select: QuestionScoreSelectSchema.optional(),
  include: QuestionScoreIncludeSchema.optional(),
  where: QuestionScoreWhereInputSchema.optional(),
  orderBy: z.union([ QuestionScoreOrderByWithRelationInputSchema.array(),QuestionScoreOrderByWithRelationInputSchema ]).optional(),
  cursor: QuestionScoreWhereUniqueInputSchema.optional(),
  take: z.number().optional(),
  skip: z.number().optional(),
  distinct: z.union([ QuestionScoreScalarFieldEnumSchema,QuestionScoreScalarFieldEnumSchema.array() ]).optional(),
}).strict() ;

export const QuestionScoreAggregateArgsSchema: z.ZodType<Prisma.QuestionScoreAggregateArgs> = z.object({
  where: QuestionScoreWhereInputSchema.optional(),
  orderBy: z.union([ QuestionScoreOrderByWithRelationInputSchema.array(),QuestionScoreOrderByWithRelationInputSchema ]).optional(),
  cursor: QuestionScoreWhereUniqueInputSchema.optional(),
  take: z.number().optional(),
  skip: z.number().optional(),
}).strict() ;

export const QuestionScoreGroupByArgsSchema: z.ZodType<Prisma.QuestionScoreGroupByArgs> = z.object({
  where: QuestionScoreWhereInputSchema.optional(),
  orderBy: z.union([ QuestionScoreOrderByWithAggregationInputSchema.array(),QuestionScoreOrderByWithAggregationInputSchema ]).optional(),
  by: QuestionScoreScalarFieldEnumSchema.array(),
  having: QuestionScoreScalarWhereWithAggregatesInputSchema.optional(),
  take: z.number().optional(),
  skip: z.number().optional(),
}).strict() ;

export const QuestionScoreFindUniqueArgsSchema: z.ZodType<Prisma.QuestionScoreFindUniqueArgs> = z.object({
  select: QuestionScoreSelectSchema.optional(),
  include: QuestionScoreIncludeSchema.optional(),
  where: QuestionScoreWhereUniqueInputSchema,
}).strict() ;

export const QuestionScoreFindUniqueOrThrowArgsSchema: z.ZodType<Prisma.QuestionScoreFindUniqueOrThrowArgs> = z.object({
  select: QuestionScoreSelectSchema.optional(),
  include: QuestionScoreIncludeSchema.optional(),
  where: QuestionScoreWhereUniqueInputSchema,
}).strict() ;

export const QuestionOptionFindFirstArgsSchema: z.ZodType<Prisma.QuestionOptionFindFirstArgs> = z.object({
  select: QuestionOptionSelectSchema.optional(),
  include: QuestionOptionIncludeSchema.optional(),
  where: QuestionOptionWhereInputSchema.optional(),
  orderBy: z.union([ QuestionOptionOrderByWithRelationInputSchema.array(),QuestionOptionOrderByWithRelationInputSchema ]).optional(),
  cursor: QuestionOptionWhereUniqueInputSchema.optional(),
  take: z.number().optional(),
  skip: z.number().optional(),
  distinct: z.union([ QuestionOptionScalarFieldEnumSchema,QuestionOptionScalarFieldEnumSchema.array() ]).optional(),
}).strict() ;

export const QuestionOptionFindFirstOrThrowArgsSchema: z.ZodType<Prisma.QuestionOptionFindFirstOrThrowArgs> = z.object({
  select: QuestionOptionSelectSchema.optional(),
  include: QuestionOptionIncludeSchema.optional(),
  where: QuestionOptionWhereInputSchema.optional(),
  orderBy: z.union([ QuestionOptionOrderByWithRelationInputSchema.array(),QuestionOptionOrderByWithRelationInputSchema ]).optional(),
  cursor: QuestionOptionWhereUniqueInputSchema.optional(),
  take: z.number().optional(),
  skip: z.number().optional(),
  distinct: z.union([ QuestionOptionScalarFieldEnumSchema,QuestionOptionScalarFieldEnumSchema.array() ]).optional(),
}).strict() ;

export const QuestionOptionFindManyArgsSchema: z.ZodType<Prisma.QuestionOptionFindManyArgs> = z.object({
  select: QuestionOptionSelectSchema.optional(),
  include: QuestionOptionIncludeSchema.optional(),
  where: QuestionOptionWhereInputSchema.optional(),
  orderBy: z.union([ QuestionOptionOrderByWithRelationInputSchema.array(),QuestionOptionOrderByWithRelationInputSchema ]).optional(),
  cursor: QuestionOptionWhereUniqueInputSchema.optional(),
  take: z.number().optional(),
  skip: z.number().optional(),
  distinct: z.union([ QuestionOptionScalarFieldEnumSchema,QuestionOptionScalarFieldEnumSchema.array() ]).optional(),
}).strict() ;

export const QuestionOptionAggregateArgsSchema: z.ZodType<Prisma.QuestionOptionAggregateArgs> = z.object({
  where: QuestionOptionWhereInputSchema.optional(),
  orderBy: z.union([ QuestionOptionOrderByWithRelationInputSchema.array(),QuestionOptionOrderByWithRelationInputSchema ]).optional(),
  cursor: QuestionOptionWhereUniqueInputSchema.optional(),
  take: z.number().optional(),
  skip: z.number().optional(),
}).strict() ;

export const QuestionOptionGroupByArgsSchema: z.ZodType<Prisma.QuestionOptionGroupByArgs> = z.object({
  where: QuestionOptionWhereInputSchema.optional(),
  orderBy: z.union([ QuestionOptionOrderByWithAggregationInputSchema.array(),QuestionOptionOrderByWithAggregationInputSchema ]).optional(),
  by: QuestionOptionScalarFieldEnumSchema.array(),
  having: QuestionOptionScalarWhereWithAggregatesInputSchema.optional(),
  take: z.number().optional(),
  skip: z.number().optional(),
}).strict() ;

export const QuestionOptionFindUniqueArgsSchema: z.ZodType<Prisma.QuestionOptionFindUniqueArgs> = z.object({
  select: QuestionOptionSelectSchema.optional(),
  include: QuestionOptionIncludeSchema.optional(),
  where: QuestionOptionWhereUniqueInputSchema,
}).strict() ;

export const QuestionOptionFindUniqueOrThrowArgsSchema: z.ZodType<Prisma.QuestionOptionFindUniqueOrThrowArgs> = z.object({
  select: QuestionOptionSelectSchema.optional(),
  include: QuestionOptionIncludeSchema.optional(),
  where: QuestionOptionWhereUniqueInputSchema,
}).strict() ;

export const QuestionFindFirstArgsSchema: z.ZodType<Prisma.QuestionFindFirstArgs> = z.object({
  select: QuestionSelectSchema.optional(),
  include: QuestionIncludeSchema.optional(),
  where: QuestionWhereInputSchema.optional(),
  orderBy: z.union([ QuestionOrderByWithRelationInputSchema.array(),QuestionOrderByWithRelationInputSchema ]).optional(),
  cursor: QuestionWhereUniqueInputSchema.optional(),
  take: z.number().optional(),
  skip: z.number().optional(),
  distinct: z.union([ QuestionScalarFieldEnumSchema,QuestionScalarFieldEnumSchema.array() ]).optional(),
}).strict() ;

export const QuestionFindFirstOrThrowArgsSchema: z.ZodType<Prisma.QuestionFindFirstOrThrowArgs> = z.object({
  select: QuestionSelectSchema.optional(),
  include: QuestionIncludeSchema.optional(),
  where: QuestionWhereInputSchema.optional(),
  orderBy: z.union([ QuestionOrderByWithRelationInputSchema.array(),QuestionOrderByWithRelationInputSchema ]).optional(),
  cursor: QuestionWhereUniqueInputSchema.optional(),
  take: z.number().optional(),
  skip: z.number().optional(),
  distinct: z.union([ QuestionScalarFieldEnumSchema,QuestionScalarFieldEnumSchema.array() ]).optional(),
}).strict() ;

export const QuestionFindManyArgsSchema: z.ZodType<Prisma.QuestionFindManyArgs> = z.object({
  select: QuestionSelectSchema.optional(),
  include: QuestionIncludeSchema.optional(),
  where: QuestionWhereInputSchema.optional(),
  orderBy: z.union([ QuestionOrderByWithRelationInputSchema.array(),QuestionOrderByWithRelationInputSchema ]).optional(),
  cursor: QuestionWhereUniqueInputSchema.optional(),
  take: z.number().optional(),
  skip: z.number().optional(),
  distinct: z.union([ QuestionScalarFieldEnumSchema,QuestionScalarFieldEnumSchema.array() ]).optional(),
}).strict() ;

export const QuestionAggregateArgsSchema: z.ZodType<Prisma.QuestionAggregateArgs> = z.object({
  where: QuestionWhereInputSchema.optional(),
  orderBy: z.union([ QuestionOrderByWithRelationInputSchema.array(),QuestionOrderByWithRelationInputSchema ]).optional(),
  cursor: QuestionWhereUniqueInputSchema.optional(),
  take: z.number().optional(),
  skip: z.number().optional(),
}).strict() ;

export const QuestionGroupByArgsSchema: z.ZodType<Prisma.QuestionGroupByArgs> = z.object({
  where: QuestionWhereInputSchema.optional(),
  orderBy: z.union([ QuestionOrderByWithAggregationInputSchema.array(),QuestionOrderByWithAggregationInputSchema ]).optional(),
  by: QuestionScalarFieldEnumSchema.array(),
  having: QuestionScalarWhereWithAggregatesInputSchema.optional(),
  take: z.number().optional(),
  skip: z.number().optional(),
}).strict() ;

export const QuestionFindUniqueArgsSchema: z.ZodType<Prisma.QuestionFindUniqueArgs> = z.object({
  select: QuestionSelectSchema.optional(),
  include: QuestionIncludeSchema.optional(),
  where: QuestionWhereUniqueInputSchema,
}).strict() ;

export const QuestionFindUniqueOrThrowArgsSchema: z.ZodType<Prisma.QuestionFindUniqueOrThrowArgs> = z.object({
  select: QuestionSelectSchema.optional(),
  include: QuestionIncludeSchema.optional(),
  where: QuestionWhereUniqueInputSchema,
}).strict() ;

export const TagFindFirstArgsSchema: z.ZodType<Prisma.TagFindFirstArgs> = z.object({
  select: TagSelectSchema.optional(),
  include: TagIncludeSchema.optional(),
  where: TagWhereInputSchema.optional(),
  orderBy: z.union([ TagOrderByWithRelationInputSchema.array(),TagOrderByWithRelationInputSchema ]).optional(),
  cursor: TagWhereUniqueInputSchema.optional(),
  take: z.number().optional(),
  skip: z.number().optional(),
  distinct: z.union([ TagScalarFieldEnumSchema,TagScalarFieldEnumSchema.array() ]).optional(),
}).strict() ;

export const TagFindFirstOrThrowArgsSchema: z.ZodType<Prisma.TagFindFirstOrThrowArgs> = z.object({
  select: TagSelectSchema.optional(),
  include: TagIncludeSchema.optional(),
  where: TagWhereInputSchema.optional(),
  orderBy: z.union([ TagOrderByWithRelationInputSchema.array(),TagOrderByWithRelationInputSchema ]).optional(),
  cursor: TagWhereUniqueInputSchema.optional(),
  take: z.number().optional(),
  skip: z.number().optional(),
  distinct: z.union([ TagScalarFieldEnumSchema,TagScalarFieldEnumSchema.array() ]).optional(),
}).strict() ;

export const TagFindManyArgsSchema: z.ZodType<Prisma.TagFindManyArgs> = z.object({
  select: TagSelectSchema.optional(),
  include: TagIncludeSchema.optional(),
  where: TagWhereInputSchema.optional(),
  orderBy: z.union([ TagOrderByWithRelationInputSchema.array(),TagOrderByWithRelationInputSchema ]).optional(),
  cursor: TagWhereUniqueInputSchema.optional(),
  take: z.number().optional(),
  skip: z.number().optional(),
  distinct: z.union([ TagScalarFieldEnumSchema,TagScalarFieldEnumSchema.array() ]).optional(),
}).strict() ;

export const TagAggregateArgsSchema: z.ZodType<Prisma.TagAggregateArgs> = z.object({
  where: TagWhereInputSchema.optional(),
  orderBy: z.union([ TagOrderByWithRelationInputSchema.array(),TagOrderByWithRelationInputSchema ]).optional(),
  cursor: TagWhereUniqueInputSchema.optional(),
  take: z.number().optional(),
  skip: z.number().optional(),
}).strict() ;

export const TagGroupByArgsSchema: z.ZodType<Prisma.TagGroupByArgs> = z.object({
  where: TagWhereInputSchema.optional(),
  orderBy: z.union([ TagOrderByWithAggregationInputSchema.array(),TagOrderByWithAggregationInputSchema ]).optional(),
  by: TagScalarFieldEnumSchema.array(),
  having: TagScalarWhereWithAggregatesInputSchema.optional(),
  take: z.number().optional(),
  skip: z.number().optional(),
}).strict() ;

export const TagFindUniqueArgsSchema: z.ZodType<Prisma.TagFindUniqueArgs> = z.object({
  select: TagSelectSchema.optional(),
  include: TagIncludeSchema.optional(),
  where: TagWhereUniqueInputSchema,
}).strict() ;

export const TagFindUniqueOrThrowArgsSchema: z.ZodType<Prisma.TagFindUniqueOrThrowArgs> = z.object({
  select: TagSelectSchema.optional(),
  include: TagIncludeSchema.optional(),
  where: TagWhereUniqueInputSchema,
}).strict() ;

export const ResolutionSlackMessageFindFirstArgsSchema: z.ZodType<Prisma.ResolutionSlackMessageFindFirstArgs> = z.object({
  select: ResolutionSlackMessageSelectSchema.optional(),
  include: ResolutionSlackMessageIncludeSchema.optional(),
  where: ResolutionSlackMessageWhereInputSchema.optional(),
  orderBy: z.union([ ResolutionSlackMessageOrderByWithRelationInputSchema.array(),ResolutionSlackMessageOrderByWithRelationInputSchema ]).optional(),
  cursor: ResolutionSlackMessageWhereUniqueInputSchema.optional(),
  take: z.number().optional(),
  skip: z.number().optional(),
  distinct: z.union([ ResolutionSlackMessageScalarFieldEnumSchema,ResolutionSlackMessageScalarFieldEnumSchema.array() ]).optional(),
}).strict() ;

export const ResolutionSlackMessageFindFirstOrThrowArgsSchema: z.ZodType<Prisma.ResolutionSlackMessageFindFirstOrThrowArgs> = z.object({
  select: ResolutionSlackMessageSelectSchema.optional(),
  include: ResolutionSlackMessageIncludeSchema.optional(),
  where: ResolutionSlackMessageWhereInputSchema.optional(),
  orderBy: z.union([ ResolutionSlackMessageOrderByWithRelationInputSchema.array(),ResolutionSlackMessageOrderByWithRelationInputSchema ]).optional(),
  cursor: ResolutionSlackMessageWhereUniqueInputSchema.optional(),
  take: z.number().optional(),
  skip: z.number().optional(),
  distinct: z.union([ ResolutionSlackMessageScalarFieldEnumSchema,ResolutionSlackMessageScalarFieldEnumSchema.array() ]).optional(),
}).strict() ;

export const ResolutionSlackMessageFindManyArgsSchema: z.ZodType<Prisma.ResolutionSlackMessageFindManyArgs> = z.object({
  select: ResolutionSlackMessageSelectSchema.optional(),
  include: ResolutionSlackMessageIncludeSchema.optional(),
  where: ResolutionSlackMessageWhereInputSchema.optional(),
  orderBy: z.union([ ResolutionSlackMessageOrderByWithRelationInputSchema.array(),ResolutionSlackMessageOrderByWithRelationInputSchema ]).optional(),
  cursor: ResolutionSlackMessageWhereUniqueInputSchema.optional(),
  take: z.number().optional(),
  skip: z.number().optional(),
  distinct: z.union([ ResolutionSlackMessageScalarFieldEnumSchema,ResolutionSlackMessageScalarFieldEnumSchema.array() ]).optional(),
}).strict() ;

export const ResolutionSlackMessageAggregateArgsSchema: z.ZodType<Prisma.ResolutionSlackMessageAggregateArgs> = z.object({
  where: ResolutionSlackMessageWhereInputSchema.optional(),
  orderBy: z.union([ ResolutionSlackMessageOrderByWithRelationInputSchema.array(),ResolutionSlackMessageOrderByWithRelationInputSchema ]).optional(),
  cursor: ResolutionSlackMessageWhereUniqueInputSchema.optional(),
  take: z.number().optional(),
  skip: z.number().optional(),
}).strict() ;

export const ResolutionSlackMessageGroupByArgsSchema: z.ZodType<Prisma.ResolutionSlackMessageGroupByArgs> = z.object({
  where: ResolutionSlackMessageWhereInputSchema.optional(),
  orderBy: z.union([ ResolutionSlackMessageOrderByWithAggregationInputSchema.array(),ResolutionSlackMessageOrderByWithAggregationInputSchema ]).optional(),
  by: ResolutionSlackMessageScalarFieldEnumSchema.array(),
  having: ResolutionSlackMessageScalarWhereWithAggregatesInputSchema.optional(),
  take: z.number().optional(),
  skip: z.number().optional(),
}).strict() ;

export const ResolutionSlackMessageFindUniqueArgsSchema: z.ZodType<Prisma.ResolutionSlackMessageFindUniqueArgs> = z.object({
  select: ResolutionSlackMessageSelectSchema.optional(),
  include: ResolutionSlackMessageIncludeSchema.optional(),
  where: ResolutionSlackMessageWhereUniqueInputSchema,
}).strict() ;

export const ResolutionSlackMessageFindUniqueOrThrowArgsSchema: z.ZodType<Prisma.ResolutionSlackMessageFindUniqueOrThrowArgs> = z.object({
  select: ResolutionSlackMessageSelectSchema.optional(),
  include: ResolutionSlackMessageIncludeSchema.optional(),
  where: ResolutionSlackMessageWhereUniqueInputSchema,
}).strict() ;

export const PingSlackMessageFindFirstArgsSchema: z.ZodType<Prisma.PingSlackMessageFindFirstArgs> = z.object({
  select: PingSlackMessageSelectSchema.optional(),
  include: PingSlackMessageIncludeSchema.optional(),
  where: PingSlackMessageWhereInputSchema.optional(),
  orderBy: z.union([ PingSlackMessageOrderByWithRelationInputSchema.array(),PingSlackMessageOrderByWithRelationInputSchema ]).optional(),
  cursor: PingSlackMessageWhereUniqueInputSchema.optional(),
  take: z.number().optional(),
  skip: z.number().optional(),
  distinct: z.union([ PingSlackMessageScalarFieldEnumSchema,PingSlackMessageScalarFieldEnumSchema.array() ]).optional(),
}).strict() ;

export const PingSlackMessageFindFirstOrThrowArgsSchema: z.ZodType<Prisma.PingSlackMessageFindFirstOrThrowArgs> = z.object({
  select: PingSlackMessageSelectSchema.optional(),
  include: PingSlackMessageIncludeSchema.optional(),
  where: PingSlackMessageWhereInputSchema.optional(),
  orderBy: z.union([ PingSlackMessageOrderByWithRelationInputSchema.array(),PingSlackMessageOrderByWithRelationInputSchema ]).optional(),
  cursor: PingSlackMessageWhereUniqueInputSchema.optional(),
  take: z.number().optional(),
  skip: z.number().optional(),
  distinct: z.union([ PingSlackMessageScalarFieldEnumSchema,PingSlackMessageScalarFieldEnumSchema.array() ]).optional(),
}).strict() ;

export const PingSlackMessageFindManyArgsSchema: z.ZodType<Prisma.PingSlackMessageFindManyArgs> = z.object({
  select: PingSlackMessageSelectSchema.optional(),
  include: PingSlackMessageIncludeSchema.optional(),
  where: PingSlackMessageWhereInputSchema.optional(),
  orderBy: z.union([ PingSlackMessageOrderByWithRelationInputSchema.array(),PingSlackMessageOrderByWithRelationInputSchema ]).optional(),
  cursor: PingSlackMessageWhereUniqueInputSchema.optional(),
  take: z.number().optional(),
  skip: z.number().optional(),
  distinct: z.union([ PingSlackMessageScalarFieldEnumSchema,PingSlackMessageScalarFieldEnumSchema.array() ]).optional(),
}).strict() ;

export const PingSlackMessageAggregateArgsSchema: z.ZodType<Prisma.PingSlackMessageAggregateArgs> = z.object({
  where: PingSlackMessageWhereInputSchema.optional(),
  orderBy: z.union([ PingSlackMessageOrderByWithRelationInputSchema.array(),PingSlackMessageOrderByWithRelationInputSchema ]).optional(),
  cursor: PingSlackMessageWhereUniqueInputSchema.optional(),
  take: z.number().optional(),
  skip: z.number().optional(),
}).strict() ;

export const PingSlackMessageGroupByArgsSchema: z.ZodType<Prisma.PingSlackMessageGroupByArgs> = z.object({
  where: PingSlackMessageWhereInputSchema.optional(),
  orderBy: z.union([ PingSlackMessageOrderByWithAggregationInputSchema.array(),PingSlackMessageOrderByWithAggregationInputSchema ]).optional(),
  by: PingSlackMessageScalarFieldEnumSchema.array(),
  having: PingSlackMessageScalarWhereWithAggregatesInputSchema.optional(),
  take: z.number().optional(),
  skip: z.number().optional(),
}).strict() ;

export const PingSlackMessageFindUniqueArgsSchema: z.ZodType<Prisma.PingSlackMessageFindUniqueArgs> = z.object({
  select: PingSlackMessageSelectSchema.optional(),
  include: PingSlackMessageIncludeSchema.optional(),
  where: PingSlackMessageWhereUniqueInputSchema,
}).strict() ;

export const PingSlackMessageFindUniqueOrThrowArgsSchema: z.ZodType<Prisma.PingSlackMessageFindUniqueOrThrowArgs> = z.object({
  select: PingSlackMessageSelectSchema.optional(),
  include: PingSlackMessageIncludeSchema.optional(),
  where: PingSlackMessageWhereUniqueInputSchema,
}).strict() ;

export const QuestionSlackMessageFindFirstArgsSchema: z.ZodType<Prisma.QuestionSlackMessageFindFirstArgs> = z.object({
  select: QuestionSlackMessageSelectSchema.optional(),
  include: QuestionSlackMessageIncludeSchema.optional(),
  where: QuestionSlackMessageWhereInputSchema.optional(),
  orderBy: z.union([ QuestionSlackMessageOrderByWithRelationInputSchema.array(),QuestionSlackMessageOrderByWithRelationInputSchema ]).optional(),
  cursor: QuestionSlackMessageWhereUniqueInputSchema.optional(),
  take: z.number().optional(),
  skip: z.number().optional(),
  distinct: z.union([ QuestionSlackMessageScalarFieldEnumSchema,QuestionSlackMessageScalarFieldEnumSchema.array() ]).optional(),
}).strict() ;

export const QuestionSlackMessageFindFirstOrThrowArgsSchema: z.ZodType<Prisma.QuestionSlackMessageFindFirstOrThrowArgs> = z.object({
  select: QuestionSlackMessageSelectSchema.optional(),
  include: QuestionSlackMessageIncludeSchema.optional(),
  where: QuestionSlackMessageWhereInputSchema.optional(),
  orderBy: z.union([ QuestionSlackMessageOrderByWithRelationInputSchema.array(),QuestionSlackMessageOrderByWithRelationInputSchema ]).optional(),
  cursor: QuestionSlackMessageWhereUniqueInputSchema.optional(),
  take: z.number().optional(),
  skip: z.number().optional(),
  distinct: z.union([ QuestionSlackMessageScalarFieldEnumSchema,QuestionSlackMessageScalarFieldEnumSchema.array() ]).optional(),
}).strict() ;

export const QuestionSlackMessageFindManyArgsSchema: z.ZodType<Prisma.QuestionSlackMessageFindManyArgs> = z.object({
  select: QuestionSlackMessageSelectSchema.optional(),
  include: QuestionSlackMessageIncludeSchema.optional(),
  where: QuestionSlackMessageWhereInputSchema.optional(),
  orderBy: z.union([ QuestionSlackMessageOrderByWithRelationInputSchema.array(),QuestionSlackMessageOrderByWithRelationInputSchema ]).optional(),
  cursor: QuestionSlackMessageWhereUniqueInputSchema.optional(),
  take: z.number().optional(),
  skip: z.number().optional(),
  distinct: z.union([ QuestionSlackMessageScalarFieldEnumSchema,QuestionSlackMessageScalarFieldEnumSchema.array() ]).optional(),
}).strict() ;

export const QuestionSlackMessageAggregateArgsSchema: z.ZodType<Prisma.QuestionSlackMessageAggregateArgs> = z.object({
  where: QuestionSlackMessageWhereInputSchema.optional(),
  orderBy: z.union([ QuestionSlackMessageOrderByWithRelationInputSchema.array(),QuestionSlackMessageOrderByWithRelationInputSchema ]).optional(),
  cursor: QuestionSlackMessageWhereUniqueInputSchema.optional(),
  take: z.number().optional(),
  skip: z.number().optional(),
}).strict() ;

export const QuestionSlackMessageGroupByArgsSchema: z.ZodType<Prisma.QuestionSlackMessageGroupByArgs> = z.object({
  where: QuestionSlackMessageWhereInputSchema.optional(),
  orderBy: z.union([ QuestionSlackMessageOrderByWithAggregationInputSchema.array(),QuestionSlackMessageOrderByWithAggregationInputSchema ]).optional(),
  by: QuestionSlackMessageScalarFieldEnumSchema.array(),
  having: QuestionSlackMessageScalarWhereWithAggregatesInputSchema.optional(),
  take: z.number().optional(),
  skip: z.number().optional(),
}).strict() ;

export const QuestionSlackMessageFindUniqueArgsSchema: z.ZodType<Prisma.QuestionSlackMessageFindUniqueArgs> = z.object({
  select: QuestionSlackMessageSelectSchema.optional(),
  include: QuestionSlackMessageIncludeSchema.optional(),
  where: QuestionSlackMessageWhereUniqueInputSchema,
}).strict() ;

export const QuestionSlackMessageFindUniqueOrThrowArgsSchema: z.ZodType<Prisma.QuestionSlackMessageFindUniqueOrThrowArgs> = z.object({
  select: QuestionSlackMessageSelectSchema.optional(),
  include: QuestionSlackMessageIncludeSchema.optional(),
  where: QuestionSlackMessageWhereUniqueInputSchema,
}).strict() ;

export const SlackMessageFindFirstArgsSchema: z.ZodType<Prisma.SlackMessageFindFirstArgs> = z.object({
  select: SlackMessageSelectSchema.optional(),
  include: SlackMessageIncludeSchema.optional(),
  where: SlackMessageWhereInputSchema.optional(),
  orderBy: z.union([ SlackMessageOrderByWithRelationInputSchema.array(),SlackMessageOrderByWithRelationInputSchema ]).optional(),
  cursor: SlackMessageWhereUniqueInputSchema.optional(),
  take: z.number().optional(),
  skip: z.number().optional(),
  distinct: z.union([ SlackMessageScalarFieldEnumSchema,SlackMessageScalarFieldEnumSchema.array() ]).optional(),
}).strict() ;

export const SlackMessageFindFirstOrThrowArgsSchema: z.ZodType<Prisma.SlackMessageFindFirstOrThrowArgs> = z.object({
  select: SlackMessageSelectSchema.optional(),
  include: SlackMessageIncludeSchema.optional(),
  where: SlackMessageWhereInputSchema.optional(),
  orderBy: z.union([ SlackMessageOrderByWithRelationInputSchema.array(),SlackMessageOrderByWithRelationInputSchema ]).optional(),
  cursor: SlackMessageWhereUniqueInputSchema.optional(),
  take: z.number().optional(),
  skip: z.number().optional(),
  distinct: z.union([ SlackMessageScalarFieldEnumSchema,SlackMessageScalarFieldEnumSchema.array() ]).optional(),
}).strict() ;

export const SlackMessageFindManyArgsSchema: z.ZodType<Prisma.SlackMessageFindManyArgs> = z.object({
  select: SlackMessageSelectSchema.optional(),
  include: SlackMessageIncludeSchema.optional(),
  where: SlackMessageWhereInputSchema.optional(),
  orderBy: z.union([ SlackMessageOrderByWithRelationInputSchema.array(),SlackMessageOrderByWithRelationInputSchema ]).optional(),
  cursor: SlackMessageWhereUniqueInputSchema.optional(),
  take: z.number().optional(),
  skip: z.number().optional(),
  distinct: z.union([ SlackMessageScalarFieldEnumSchema,SlackMessageScalarFieldEnumSchema.array() ]).optional(),
}).strict() ;

export const SlackMessageAggregateArgsSchema: z.ZodType<Prisma.SlackMessageAggregateArgs> = z.object({
  where: SlackMessageWhereInputSchema.optional(),
  orderBy: z.union([ SlackMessageOrderByWithRelationInputSchema.array(),SlackMessageOrderByWithRelationInputSchema ]).optional(),
  cursor: SlackMessageWhereUniqueInputSchema.optional(),
  take: z.number().optional(),
  skip: z.number().optional(),
}).strict() ;

export const SlackMessageGroupByArgsSchema: z.ZodType<Prisma.SlackMessageGroupByArgs> = z.object({
  where: SlackMessageWhereInputSchema.optional(),
  orderBy: z.union([ SlackMessageOrderByWithAggregationInputSchema.array(),SlackMessageOrderByWithAggregationInputSchema ]).optional(),
  by: SlackMessageScalarFieldEnumSchema.array(),
  having: SlackMessageScalarWhereWithAggregatesInputSchema.optional(),
  take: z.number().optional(),
  skip: z.number().optional(),
}).strict() ;

export const SlackMessageFindUniqueArgsSchema: z.ZodType<Prisma.SlackMessageFindUniqueArgs> = z.object({
  select: SlackMessageSelectSchema.optional(),
  include: SlackMessageIncludeSchema.optional(),
  where: SlackMessageWhereUniqueInputSchema,
}).strict() ;

export const SlackMessageFindUniqueOrThrowArgsSchema: z.ZodType<Prisma.SlackMessageFindUniqueOrThrowArgs> = z.object({
  select: SlackMessageSelectSchema.optional(),
  include: SlackMessageIncludeSchema.optional(),
  where: SlackMessageWhereUniqueInputSchema,
}).strict() ;

export const UserFindFirstArgsSchema: z.ZodType<Prisma.UserFindFirstArgs> = z.object({
  select: UserSelectSchema.optional(),
  include: UserIncludeSchema.optional(),
  where: UserWhereInputSchema.optional(),
  orderBy: z.union([ UserOrderByWithRelationInputSchema.array(),UserOrderByWithRelationInputSchema ]).optional(),
  cursor: UserWhereUniqueInputSchema.optional(),
  take: z.number().optional(),
  skip: z.number().optional(),
  distinct: z.union([ UserScalarFieldEnumSchema,UserScalarFieldEnumSchema.array() ]).optional(),
}).strict() ;

export const UserFindFirstOrThrowArgsSchema: z.ZodType<Prisma.UserFindFirstOrThrowArgs> = z.object({
  select: UserSelectSchema.optional(),
  include: UserIncludeSchema.optional(),
  where: UserWhereInputSchema.optional(),
  orderBy: z.union([ UserOrderByWithRelationInputSchema.array(),UserOrderByWithRelationInputSchema ]).optional(),
  cursor: UserWhereUniqueInputSchema.optional(),
  take: z.number().optional(),
  skip: z.number().optional(),
  distinct: z.union([ UserScalarFieldEnumSchema,UserScalarFieldEnumSchema.array() ]).optional(),
}).strict() ;

export const UserFindManyArgsSchema: z.ZodType<Prisma.UserFindManyArgs> = z.object({
  select: UserSelectSchema.optional(),
  include: UserIncludeSchema.optional(),
  where: UserWhereInputSchema.optional(),
  orderBy: z.union([ UserOrderByWithRelationInputSchema.array(),UserOrderByWithRelationInputSchema ]).optional(),
  cursor: UserWhereUniqueInputSchema.optional(),
  take: z.number().optional(),
  skip: z.number().optional(),
  distinct: z.union([ UserScalarFieldEnumSchema,UserScalarFieldEnumSchema.array() ]).optional(),
}).strict() ;

export const UserAggregateArgsSchema: z.ZodType<Prisma.UserAggregateArgs> = z.object({
  where: UserWhereInputSchema.optional(),
  orderBy: z.union([ UserOrderByWithRelationInputSchema.array(),UserOrderByWithRelationInputSchema ]).optional(),
  cursor: UserWhereUniqueInputSchema.optional(),
  take: z.number().optional(),
  skip: z.number().optional(),
}).strict() ;

export const UserGroupByArgsSchema: z.ZodType<Prisma.UserGroupByArgs> = z.object({
  where: UserWhereInputSchema.optional(),
  orderBy: z.union([ UserOrderByWithAggregationInputSchema.array(),UserOrderByWithAggregationInputSchema ]).optional(),
  by: UserScalarFieldEnumSchema.array(),
  having: UserScalarWhereWithAggregatesInputSchema.optional(),
  take: z.number().optional(),
  skip: z.number().optional(),
}).strict() ;

export const UserFindUniqueArgsSchema: z.ZodType<Prisma.UserFindUniqueArgs> = z.object({
  select: UserSelectSchema.optional(),
  include: UserIncludeSchema.optional(),
  where: UserWhereUniqueInputSchema,
}).strict() ;

export const UserFindUniqueOrThrowArgsSchema: z.ZodType<Prisma.UserFindUniqueOrThrowArgs> = z.object({
  select: UserSelectSchema.optional(),
  include: UserIncludeSchema.optional(),
  where: UserWhereUniqueInputSchema,
}).strict() ;

export const ProfileFindFirstArgsSchema: z.ZodType<Prisma.ProfileFindFirstArgs> = z.object({
  select: ProfileSelectSchema.optional(),
  include: ProfileIncludeSchema.optional(),
  where: ProfileWhereInputSchema.optional(),
  orderBy: z.union([ ProfileOrderByWithRelationInputSchema.array(),ProfileOrderByWithRelationInputSchema ]).optional(),
  cursor: ProfileWhereUniqueInputSchema.optional(),
  take: z.number().optional(),
  skip: z.number().optional(),
  distinct: z.union([ ProfileScalarFieldEnumSchema,ProfileScalarFieldEnumSchema.array() ]).optional(),
}).strict() ;

export const ProfileFindFirstOrThrowArgsSchema: z.ZodType<Prisma.ProfileFindFirstOrThrowArgs> = z.object({
  select: ProfileSelectSchema.optional(),
  include: ProfileIncludeSchema.optional(),
  where: ProfileWhereInputSchema.optional(),
  orderBy: z.union([ ProfileOrderByWithRelationInputSchema.array(),ProfileOrderByWithRelationInputSchema ]).optional(),
  cursor: ProfileWhereUniqueInputSchema.optional(),
  take: z.number().optional(),
  skip: z.number().optional(),
  distinct: z.union([ ProfileScalarFieldEnumSchema,ProfileScalarFieldEnumSchema.array() ]).optional(),
}).strict() ;

export const ProfileFindManyArgsSchema: z.ZodType<Prisma.ProfileFindManyArgs> = z.object({
  select: ProfileSelectSchema.optional(),
  include: ProfileIncludeSchema.optional(),
  where: ProfileWhereInputSchema.optional(),
  orderBy: z.union([ ProfileOrderByWithRelationInputSchema.array(),ProfileOrderByWithRelationInputSchema ]).optional(),
  cursor: ProfileWhereUniqueInputSchema.optional(),
  take: z.number().optional(),
  skip: z.number().optional(),
  distinct: z.union([ ProfileScalarFieldEnumSchema,ProfileScalarFieldEnumSchema.array() ]).optional(),
}).strict() ;

export const ProfileAggregateArgsSchema: z.ZodType<Prisma.ProfileAggregateArgs> = z.object({
  where: ProfileWhereInputSchema.optional(),
  orderBy: z.union([ ProfileOrderByWithRelationInputSchema.array(),ProfileOrderByWithRelationInputSchema ]).optional(),
  cursor: ProfileWhereUniqueInputSchema.optional(),
  take: z.number().optional(),
  skip: z.number().optional(),
}).strict() ;

export const ProfileGroupByArgsSchema: z.ZodType<Prisma.ProfileGroupByArgs> = z.object({
  where: ProfileWhereInputSchema.optional(),
  orderBy: z.union([ ProfileOrderByWithAggregationInputSchema.array(),ProfileOrderByWithAggregationInputSchema ]).optional(),
  by: ProfileScalarFieldEnumSchema.array(),
  having: ProfileScalarWhereWithAggregatesInputSchema.optional(),
  take: z.number().optional(),
  skip: z.number().optional(),
}).strict() ;

export const ProfileFindUniqueArgsSchema: z.ZodType<Prisma.ProfileFindUniqueArgs> = z.object({
  select: ProfileSelectSchema.optional(),
  include: ProfileIncludeSchema.optional(),
  where: ProfileWhereUniqueInputSchema,
}).strict() ;

export const ProfileFindUniqueOrThrowArgsSchema: z.ZodType<Prisma.ProfileFindUniqueOrThrowArgs> = z.object({
  select: ProfileSelectSchema.optional(),
  include: ProfileIncludeSchema.optional(),
  where: ProfileWhereUniqueInputSchema,
}).strict() ;

export const GroupFindFirstArgsSchema: z.ZodType<Prisma.GroupFindFirstArgs> = z.object({
  select: GroupSelectSchema.optional(),
  where: GroupWhereInputSchema.optional(),
  orderBy: z.union([ GroupOrderByWithRelationInputSchema.array(),GroupOrderByWithRelationInputSchema ]).optional(),
  cursor: GroupWhereUniqueInputSchema.optional(),
  take: z.number().optional(),
  skip: z.number().optional(),
  distinct: z.union([ GroupScalarFieldEnumSchema,GroupScalarFieldEnumSchema.array() ]).optional(),
}).strict() ;

export const GroupFindFirstOrThrowArgsSchema: z.ZodType<Prisma.GroupFindFirstOrThrowArgs> = z.object({
  select: GroupSelectSchema.optional(),
  where: GroupWhereInputSchema.optional(),
  orderBy: z.union([ GroupOrderByWithRelationInputSchema.array(),GroupOrderByWithRelationInputSchema ]).optional(),
  cursor: GroupWhereUniqueInputSchema.optional(),
  take: z.number().optional(),
  skip: z.number().optional(),
  distinct: z.union([ GroupScalarFieldEnumSchema,GroupScalarFieldEnumSchema.array() ]).optional(),
}).strict() ;

export const GroupFindManyArgsSchema: z.ZodType<Prisma.GroupFindManyArgs> = z.object({
  select: GroupSelectSchema.optional(),
  where: GroupWhereInputSchema.optional(),
  orderBy: z.union([ GroupOrderByWithRelationInputSchema.array(),GroupOrderByWithRelationInputSchema ]).optional(),
  cursor: GroupWhereUniqueInputSchema.optional(),
  take: z.number().optional(),
  skip: z.number().optional(),
  distinct: z.union([ GroupScalarFieldEnumSchema,GroupScalarFieldEnumSchema.array() ]).optional(),
}).strict() ;

export const GroupAggregateArgsSchema: z.ZodType<Prisma.GroupAggregateArgs> = z.object({
  where: GroupWhereInputSchema.optional(),
  orderBy: z.union([ GroupOrderByWithRelationInputSchema.array(),GroupOrderByWithRelationInputSchema ]).optional(),
  cursor: GroupWhereUniqueInputSchema.optional(),
  take: z.number().optional(),
  skip: z.number().optional(),
}).strict() ;

export const GroupGroupByArgsSchema: z.ZodType<Prisma.GroupGroupByArgs> = z.object({
  where: GroupWhereInputSchema.optional(),
  orderBy: z.union([ GroupOrderByWithAggregationInputSchema.array(),GroupOrderByWithAggregationInputSchema ]).optional(),
  by: GroupScalarFieldEnumSchema.array(),
  having: GroupScalarWhereWithAggregatesInputSchema.optional(),
  take: z.number().optional(),
  skip: z.number().optional(),
}).strict() ;

export const GroupFindUniqueArgsSchema: z.ZodType<Prisma.GroupFindUniqueArgs> = z.object({
  select: GroupSelectSchema.optional(),
  where: GroupWhereUniqueInputSchema,
}).strict() ;

export const GroupFindUniqueOrThrowArgsSchema: z.ZodType<Prisma.GroupFindUniqueOrThrowArgs> = z.object({
  select: GroupSelectSchema.optional(),
  where: GroupWhereUniqueInputSchema,
}).strict() ;

export const TargetFindFirstArgsSchema: z.ZodType<Prisma.TargetFindFirstArgs> = z.object({
  select: TargetSelectSchema.optional(),
  include: TargetIncludeSchema.optional(),
  where: TargetWhereInputSchema.optional(),
  orderBy: z.union([ TargetOrderByWithRelationInputSchema.array(),TargetOrderByWithRelationInputSchema ]).optional(),
  cursor: TargetWhereUniqueInputSchema.optional(),
  take: z.number().optional(),
  skip: z.number().optional(),
  distinct: z.union([ TargetScalarFieldEnumSchema,TargetScalarFieldEnumSchema.array() ]).optional(),
}).strict() ;

export const TargetFindFirstOrThrowArgsSchema: z.ZodType<Prisma.TargetFindFirstOrThrowArgs> = z.object({
  select: TargetSelectSchema.optional(),
  include: TargetIncludeSchema.optional(),
  where: TargetWhereInputSchema.optional(),
  orderBy: z.union([ TargetOrderByWithRelationInputSchema.array(),TargetOrderByWithRelationInputSchema ]).optional(),
  cursor: TargetWhereUniqueInputSchema.optional(),
  take: z.number().optional(),
  skip: z.number().optional(),
  distinct: z.union([ TargetScalarFieldEnumSchema,TargetScalarFieldEnumSchema.array() ]).optional(),
}).strict() ;

export const TargetFindManyArgsSchema: z.ZodType<Prisma.TargetFindManyArgs> = z.object({
  select: TargetSelectSchema.optional(),
  include: TargetIncludeSchema.optional(),
  where: TargetWhereInputSchema.optional(),
  orderBy: z.union([ TargetOrderByWithRelationInputSchema.array(),TargetOrderByWithRelationInputSchema ]).optional(),
  cursor: TargetWhereUniqueInputSchema.optional(),
  take: z.number().optional(),
  skip: z.number().optional(),
  distinct: z.union([ TargetScalarFieldEnumSchema,TargetScalarFieldEnumSchema.array() ]).optional(),
}).strict() ;

export const TargetAggregateArgsSchema: z.ZodType<Prisma.TargetAggregateArgs> = z.object({
  where: TargetWhereInputSchema.optional(),
  orderBy: z.union([ TargetOrderByWithRelationInputSchema.array(),TargetOrderByWithRelationInputSchema ]).optional(),
  cursor: TargetWhereUniqueInputSchema.optional(),
  take: z.number().optional(),
  skip: z.number().optional(),
}).strict() ;

export const TargetGroupByArgsSchema: z.ZodType<Prisma.TargetGroupByArgs> = z.object({
  where: TargetWhereInputSchema.optional(),
  orderBy: z.union([ TargetOrderByWithAggregationInputSchema.array(),TargetOrderByWithAggregationInputSchema ]).optional(),
  by: TargetScalarFieldEnumSchema.array(),
  having: TargetScalarWhereWithAggregatesInputSchema.optional(),
  take: z.number().optional(),
  skip: z.number().optional(),
}).strict() ;

export const TargetFindUniqueArgsSchema: z.ZodType<Prisma.TargetFindUniqueArgs> = z.object({
  select: TargetSelectSchema.optional(),
  include: TargetIncludeSchema.optional(),
  where: TargetWhereUniqueInputSchema,
}).strict() ;

export const TargetFindUniqueOrThrowArgsSchema: z.ZodType<Prisma.TargetFindUniqueOrThrowArgs> = z.object({
  select: TargetSelectSchema.optional(),
  include: TargetIncludeSchema.optional(),
  where: TargetWhereUniqueInputSchema,
}).strict() ;

export const AccountFindFirstArgsSchema: z.ZodType<Prisma.AccountFindFirstArgs> = z.object({
  select: AccountSelectSchema.optional(),
  include: AccountIncludeSchema.optional(),
  where: AccountWhereInputSchema.optional(),
  orderBy: z.union([ AccountOrderByWithRelationInputSchema.array(),AccountOrderByWithRelationInputSchema ]).optional(),
  cursor: AccountWhereUniqueInputSchema.optional(),
  take: z.number().optional(),
  skip: z.number().optional(),
  distinct: z.union([ AccountScalarFieldEnumSchema,AccountScalarFieldEnumSchema.array() ]).optional(),
}).strict() ;

export const AccountFindFirstOrThrowArgsSchema: z.ZodType<Prisma.AccountFindFirstOrThrowArgs> = z.object({
  select: AccountSelectSchema.optional(),
  include: AccountIncludeSchema.optional(),
  where: AccountWhereInputSchema.optional(),
  orderBy: z.union([ AccountOrderByWithRelationInputSchema.array(),AccountOrderByWithRelationInputSchema ]).optional(),
  cursor: AccountWhereUniqueInputSchema.optional(),
  take: z.number().optional(),
  skip: z.number().optional(),
  distinct: z.union([ AccountScalarFieldEnumSchema,AccountScalarFieldEnumSchema.array() ]).optional(),
}).strict() ;

export const AccountFindManyArgsSchema: z.ZodType<Prisma.AccountFindManyArgs> = z.object({
  select: AccountSelectSchema.optional(),
  include: AccountIncludeSchema.optional(),
  where: AccountWhereInputSchema.optional(),
  orderBy: z.union([ AccountOrderByWithRelationInputSchema.array(),AccountOrderByWithRelationInputSchema ]).optional(),
  cursor: AccountWhereUniqueInputSchema.optional(),
  take: z.number().optional(),
  skip: z.number().optional(),
  distinct: z.union([ AccountScalarFieldEnumSchema,AccountScalarFieldEnumSchema.array() ]).optional(),
}).strict() ;

export const AccountAggregateArgsSchema: z.ZodType<Prisma.AccountAggregateArgs> = z.object({
  where: AccountWhereInputSchema.optional(),
  orderBy: z.union([ AccountOrderByWithRelationInputSchema.array(),AccountOrderByWithRelationInputSchema ]).optional(),
  cursor: AccountWhereUniqueInputSchema.optional(),
  take: z.number().optional(),
  skip: z.number().optional(),
}).strict() ;

export const AccountGroupByArgsSchema: z.ZodType<Prisma.AccountGroupByArgs> = z.object({
  where: AccountWhereInputSchema.optional(),
  orderBy: z.union([ AccountOrderByWithAggregationInputSchema.array(),AccountOrderByWithAggregationInputSchema ]).optional(),
  by: AccountScalarFieldEnumSchema.array(),
  having: AccountScalarWhereWithAggregatesInputSchema.optional(),
  take: z.number().optional(),
  skip: z.number().optional(),
}).strict() ;

export const AccountFindUniqueArgsSchema: z.ZodType<Prisma.AccountFindUniqueArgs> = z.object({
  select: AccountSelectSchema.optional(),
  include: AccountIncludeSchema.optional(),
  where: AccountWhereUniqueInputSchema,
}).strict() ;

export const AccountFindUniqueOrThrowArgsSchema: z.ZodType<Prisma.AccountFindUniqueOrThrowArgs> = z.object({
  select: AccountSelectSchema.optional(),
  include: AccountIncludeSchema.optional(),
  where: AccountWhereUniqueInputSchema,
}).strict() ;

export const CommentFindFirstArgsSchema: z.ZodType<Prisma.CommentFindFirstArgs> = z.object({
  select: CommentSelectSchema.optional(),
  include: CommentIncludeSchema.optional(),
  where: CommentWhereInputSchema.optional(),
  orderBy: z.union([ CommentOrderByWithRelationInputSchema.array(),CommentOrderByWithRelationInputSchema ]).optional(),
  cursor: CommentWhereUniqueInputSchema.optional(),
  take: z.number().optional(),
  skip: z.number().optional(),
  distinct: z.union([ CommentScalarFieldEnumSchema,CommentScalarFieldEnumSchema.array() ]).optional(),
}).strict() ;

export const CommentFindFirstOrThrowArgsSchema: z.ZodType<Prisma.CommentFindFirstOrThrowArgs> = z.object({
  select: CommentSelectSchema.optional(),
  include: CommentIncludeSchema.optional(),
  where: CommentWhereInputSchema.optional(),
  orderBy: z.union([ CommentOrderByWithRelationInputSchema.array(),CommentOrderByWithRelationInputSchema ]).optional(),
  cursor: CommentWhereUniqueInputSchema.optional(),
  take: z.number().optional(),
  skip: z.number().optional(),
  distinct: z.union([ CommentScalarFieldEnumSchema,CommentScalarFieldEnumSchema.array() ]).optional(),
}).strict() ;

export const CommentFindManyArgsSchema: z.ZodType<Prisma.CommentFindManyArgs> = z.object({
  select: CommentSelectSchema.optional(),
  include: CommentIncludeSchema.optional(),
  where: CommentWhereInputSchema.optional(),
  orderBy: z.union([ CommentOrderByWithRelationInputSchema.array(),CommentOrderByWithRelationInputSchema ]).optional(),
  cursor: CommentWhereUniqueInputSchema.optional(),
  take: z.number().optional(),
  skip: z.number().optional(),
  distinct: z.union([ CommentScalarFieldEnumSchema,CommentScalarFieldEnumSchema.array() ]).optional(),
}).strict() ;

export const CommentAggregateArgsSchema: z.ZodType<Prisma.CommentAggregateArgs> = z.object({
  where: CommentWhereInputSchema.optional(),
  orderBy: z.union([ CommentOrderByWithRelationInputSchema.array(),CommentOrderByWithRelationInputSchema ]).optional(),
  cursor: CommentWhereUniqueInputSchema.optional(),
  take: z.number().optional(),
  skip: z.number().optional(),
}).strict() ;

export const CommentGroupByArgsSchema: z.ZodType<Prisma.CommentGroupByArgs> = z.object({
  where: CommentWhereInputSchema.optional(),
  orderBy: z.union([ CommentOrderByWithAggregationInputSchema.array(),CommentOrderByWithAggregationInputSchema ]).optional(),
  by: CommentScalarFieldEnumSchema.array(),
  having: CommentScalarWhereWithAggregatesInputSchema.optional(),
  take: z.number().optional(),
  skip: z.number().optional(),
}).strict() ;

export const CommentFindUniqueArgsSchema: z.ZodType<Prisma.CommentFindUniqueArgs> = z.object({
  select: CommentSelectSchema.optional(),
  include: CommentIncludeSchema.optional(),
  where: CommentWhereUniqueInputSchema,
}).strict() ;

export const CommentFindUniqueOrThrowArgsSchema: z.ZodType<Prisma.CommentFindUniqueOrThrowArgs> = z.object({
  select: CommentSelectSchema.optional(),
  include: CommentIncludeSchema.optional(),
  where: CommentWhereUniqueInputSchema,
}).strict() ;

export const UserListFindFirstArgsSchema: z.ZodType<Prisma.UserListFindFirstArgs> = z.object({
  select: UserListSelectSchema.optional(),
  include: UserListIncludeSchema.optional(),
  where: UserListWhereInputSchema.optional(),
  orderBy: z.union([ UserListOrderByWithRelationInputSchema.array(),UserListOrderByWithRelationInputSchema ]).optional(),
  cursor: UserListWhereUniqueInputSchema.optional(),
  take: z.number().optional(),
  skip: z.number().optional(),
  distinct: z.union([ UserListScalarFieldEnumSchema,UserListScalarFieldEnumSchema.array() ]).optional(),
}).strict() ;

export const UserListFindFirstOrThrowArgsSchema: z.ZodType<Prisma.UserListFindFirstOrThrowArgs> = z.object({
  select: UserListSelectSchema.optional(),
  include: UserListIncludeSchema.optional(),
  where: UserListWhereInputSchema.optional(),
  orderBy: z.union([ UserListOrderByWithRelationInputSchema.array(),UserListOrderByWithRelationInputSchema ]).optional(),
  cursor: UserListWhereUniqueInputSchema.optional(),
  take: z.number().optional(),
  skip: z.number().optional(),
  distinct: z.union([ UserListScalarFieldEnumSchema,UserListScalarFieldEnumSchema.array() ]).optional(),
}).strict() ;

export const UserListFindManyArgsSchema: z.ZodType<Prisma.UserListFindManyArgs> = z.object({
  select: UserListSelectSchema.optional(),
  include: UserListIncludeSchema.optional(),
  where: UserListWhereInputSchema.optional(),
  orderBy: z.union([ UserListOrderByWithRelationInputSchema.array(),UserListOrderByWithRelationInputSchema ]).optional(),
  cursor: UserListWhereUniqueInputSchema.optional(),
  take: z.number().optional(),
  skip: z.number().optional(),
  distinct: z.union([ UserListScalarFieldEnumSchema,UserListScalarFieldEnumSchema.array() ]).optional(),
}).strict() ;

export const UserListAggregateArgsSchema: z.ZodType<Prisma.UserListAggregateArgs> = z.object({
  where: UserListWhereInputSchema.optional(),
  orderBy: z.union([ UserListOrderByWithRelationInputSchema.array(),UserListOrderByWithRelationInputSchema ]).optional(),
  cursor: UserListWhereUniqueInputSchema.optional(),
  take: z.number().optional(),
  skip: z.number().optional(),
}).strict() ;

export const UserListGroupByArgsSchema: z.ZodType<Prisma.UserListGroupByArgs> = z.object({
  where: UserListWhereInputSchema.optional(),
  orderBy: z.union([ UserListOrderByWithAggregationInputSchema.array(),UserListOrderByWithAggregationInputSchema ]).optional(),
  by: UserListScalarFieldEnumSchema.array(),
  having: UserListScalarWhereWithAggregatesInputSchema.optional(),
  take: z.number().optional(),
  skip: z.number().optional(),
}).strict() ;

export const UserListFindUniqueArgsSchema: z.ZodType<Prisma.UserListFindUniqueArgs> = z.object({
  select: UserListSelectSchema.optional(),
  include: UserListIncludeSchema.optional(),
  where: UserListWhereUniqueInputSchema,
}).strict() ;

export const UserListFindUniqueOrThrowArgsSchema: z.ZodType<Prisma.UserListFindUniqueOrThrowArgs> = z.object({
  select: UserListSelectSchema.optional(),
  include: UserListIncludeSchema.optional(),
  where: UserListWhereUniqueInputSchema,
}).strict() ;

export const TournamentFindFirstArgsSchema: z.ZodType<Prisma.TournamentFindFirstArgs> = z.object({
  select: TournamentSelectSchema.optional(),
  include: TournamentIncludeSchema.optional(),
  where: TournamentWhereInputSchema.optional(),
  orderBy: z.union([ TournamentOrderByWithRelationInputSchema.array(),TournamentOrderByWithRelationInputSchema ]).optional(),
  cursor: TournamentWhereUniqueInputSchema.optional(),
  take: z.number().optional(),
  skip: z.number().optional(),
  distinct: z.union([ TournamentScalarFieldEnumSchema,TournamentScalarFieldEnumSchema.array() ]).optional(),
}).strict() ;

export const TournamentFindFirstOrThrowArgsSchema: z.ZodType<Prisma.TournamentFindFirstOrThrowArgs> = z.object({
  select: TournamentSelectSchema.optional(),
  include: TournamentIncludeSchema.optional(),
  where: TournamentWhereInputSchema.optional(),
  orderBy: z.union([ TournamentOrderByWithRelationInputSchema.array(),TournamentOrderByWithRelationInputSchema ]).optional(),
  cursor: TournamentWhereUniqueInputSchema.optional(),
  take: z.number().optional(),
  skip: z.number().optional(),
  distinct: z.union([ TournamentScalarFieldEnumSchema,TournamentScalarFieldEnumSchema.array() ]).optional(),
}).strict() ;

export const TournamentFindManyArgsSchema: z.ZodType<Prisma.TournamentFindManyArgs> = z.object({
  select: TournamentSelectSchema.optional(),
  include: TournamentIncludeSchema.optional(),
  where: TournamentWhereInputSchema.optional(),
  orderBy: z.union([ TournamentOrderByWithRelationInputSchema.array(),TournamentOrderByWithRelationInputSchema ]).optional(),
  cursor: TournamentWhereUniqueInputSchema.optional(),
  take: z.number().optional(),
  skip: z.number().optional(),
  distinct: z.union([ TournamentScalarFieldEnumSchema,TournamentScalarFieldEnumSchema.array() ]).optional(),
}).strict() ;

export const TournamentAggregateArgsSchema: z.ZodType<Prisma.TournamentAggregateArgs> = z.object({
  where: TournamentWhereInputSchema.optional(),
  orderBy: z.union([ TournamentOrderByWithRelationInputSchema.array(),TournamentOrderByWithRelationInputSchema ]).optional(),
  cursor: TournamentWhereUniqueInputSchema.optional(),
  take: z.number().optional(),
  skip: z.number().optional(),
}).strict() ;

export const TournamentGroupByArgsSchema: z.ZodType<Prisma.TournamentGroupByArgs> = z.object({
  where: TournamentWhereInputSchema.optional(),
  orderBy: z.union([ TournamentOrderByWithAggregationInputSchema.array(),TournamentOrderByWithAggregationInputSchema ]).optional(),
  by: TournamentScalarFieldEnumSchema.array(),
  having: TournamentScalarWhereWithAggregatesInputSchema.optional(),
  take: z.number().optional(),
  skip: z.number().optional(),
}).strict() ;

export const TournamentFindUniqueArgsSchema: z.ZodType<Prisma.TournamentFindUniqueArgs> = z.object({
  select: TournamentSelectSchema.optional(),
  include: TournamentIncludeSchema.optional(),
  where: TournamentWhereUniqueInputSchema,
}).strict() ;

export const TournamentFindUniqueOrThrowArgsSchema: z.ZodType<Prisma.TournamentFindUniqueOrThrowArgs> = z.object({
  select: TournamentSelectSchema.optional(),
  include: TournamentIncludeSchema.optional(),
  where: TournamentWhereUniqueInputSchema,
}).strict() ;

export const NotificationFindFirstArgsSchema: z.ZodType<Prisma.NotificationFindFirstArgs> = z.object({
  select: NotificationSelectSchema.optional(),
  include: NotificationIncludeSchema.optional(),
  where: NotificationWhereInputSchema.optional(),
  orderBy: z.union([ NotificationOrderByWithRelationInputSchema.array(),NotificationOrderByWithRelationInputSchema ]).optional(),
  cursor: NotificationWhereUniqueInputSchema.optional(),
  take: z.number().optional(),
  skip: z.number().optional(),
  distinct: z.union([ NotificationScalarFieldEnumSchema,NotificationScalarFieldEnumSchema.array() ]).optional(),
}).strict() ;

export const NotificationFindFirstOrThrowArgsSchema: z.ZodType<Prisma.NotificationFindFirstOrThrowArgs> = z.object({
  select: NotificationSelectSchema.optional(),
  include: NotificationIncludeSchema.optional(),
  where: NotificationWhereInputSchema.optional(),
  orderBy: z.union([ NotificationOrderByWithRelationInputSchema.array(),NotificationOrderByWithRelationInputSchema ]).optional(),
  cursor: NotificationWhereUniqueInputSchema.optional(),
  take: z.number().optional(),
  skip: z.number().optional(),
  distinct: z.union([ NotificationScalarFieldEnumSchema,NotificationScalarFieldEnumSchema.array() ]).optional(),
}).strict() ;

export const NotificationFindManyArgsSchema: z.ZodType<Prisma.NotificationFindManyArgs> = z.object({
  select: NotificationSelectSchema.optional(),
  include: NotificationIncludeSchema.optional(),
  where: NotificationWhereInputSchema.optional(),
  orderBy: z.union([ NotificationOrderByWithRelationInputSchema.array(),NotificationOrderByWithRelationInputSchema ]).optional(),
  cursor: NotificationWhereUniqueInputSchema.optional(),
  take: z.number().optional(),
  skip: z.number().optional(),
  distinct: z.union([ NotificationScalarFieldEnumSchema,NotificationScalarFieldEnumSchema.array() ]).optional(),
}).strict() ;

export const NotificationAggregateArgsSchema: z.ZodType<Prisma.NotificationAggregateArgs> = z.object({
  where: NotificationWhereInputSchema.optional(),
  orderBy: z.union([ NotificationOrderByWithRelationInputSchema.array(),NotificationOrderByWithRelationInputSchema ]).optional(),
  cursor: NotificationWhereUniqueInputSchema.optional(),
  take: z.number().optional(),
  skip: z.number().optional(),
}).strict() ;

export const NotificationGroupByArgsSchema: z.ZodType<Prisma.NotificationGroupByArgs> = z.object({
  where: NotificationWhereInputSchema.optional(),
  orderBy: z.union([ NotificationOrderByWithAggregationInputSchema.array(),NotificationOrderByWithAggregationInputSchema ]).optional(),
  by: NotificationScalarFieldEnumSchema.array(),
  having: NotificationScalarWhereWithAggregatesInputSchema.optional(),
  take: z.number().optional(),
  skip: z.number().optional(),
}).strict() ;

export const NotificationFindUniqueArgsSchema: z.ZodType<Prisma.NotificationFindUniqueArgs> = z.object({
  select: NotificationSelectSchema.optional(),
  include: NotificationIncludeSchema.optional(),
  where: NotificationWhereUniqueInputSchema,
}).strict() ;

export const NotificationFindUniqueOrThrowArgsSchema: z.ZodType<Prisma.NotificationFindUniqueOrThrowArgs> = z.object({
  select: NotificationSelectSchema.optional(),
  include: NotificationIncludeSchema.optional(),
  where: NotificationWhereUniqueInputSchema,
}).strict() ;

export const FeedbackFindFirstArgsSchema: z.ZodType<Prisma.FeedbackFindFirstArgs> = z.object({
  select: FeedbackSelectSchema.optional(),
  where: FeedbackWhereInputSchema.optional(),
  orderBy: z.union([ FeedbackOrderByWithRelationInputSchema.array(),FeedbackOrderByWithRelationInputSchema ]).optional(),
  cursor: FeedbackWhereUniqueInputSchema.optional(),
  take: z.number().optional(),
  skip: z.number().optional(),
  distinct: z.union([ FeedbackScalarFieldEnumSchema,FeedbackScalarFieldEnumSchema.array() ]).optional(),
}).strict() ;

export const FeedbackFindFirstOrThrowArgsSchema: z.ZodType<Prisma.FeedbackFindFirstOrThrowArgs> = z.object({
  select: FeedbackSelectSchema.optional(),
  where: FeedbackWhereInputSchema.optional(),
  orderBy: z.union([ FeedbackOrderByWithRelationInputSchema.array(),FeedbackOrderByWithRelationInputSchema ]).optional(),
  cursor: FeedbackWhereUniqueInputSchema.optional(),
  take: z.number().optional(),
  skip: z.number().optional(),
  distinct: z.union([ FeedbackScalarFieldEnumSchema,FeedbackScalarFieldEnumSchema.array() ]).optional(),
}).strict() ;

export const FeedbackFindManyArgsSchema: z.ZodType<Prisma.FeedbackFindManyArgs> = z.object({
  select: FeedbackSelectSchema.optional(),
  where: FeedbackWhereInputSchema.optional(),
  orderBy: z.union([ FeedbackOrderByWithRelationInputSchema.array(),FeedbackOrderByWithRelationInputSchema ]).optional(),
  cursor: FeedbackWhereUniqueInputSchema.optional(),
  take: z.number().optional(),
  skip: z.number().optional(),
  distinct: z.union([ FeedbackScalarFieldEnumSchema,FeedbackScalarFieldEnumSchema.array() ]).optional(),
}).strict() ;

export const FeedbackAggregateArgsSchema: z.ZodType<Prisma.FeedbackAggregateArgs> = z.object({
  where: FeedbackWhereInputSchema.optional(),
  orderBy: z.union([ FeedbackOrderByWithRelationInputSchema.array(),FeedbackOrderByWithRelationInputSchema ]).optional(),
  cursor: FeedbackWhereUniqueInputSchema.optional(),
  take: z.number().optional(),
  skip: z.number().optional(),
}).strict() ;

export const FeedbackGroupByArgsSchema: z.ZodType<Prisma.FeedbackGroupByArgs> = z.object({
  where: FeedbackWhereInputSchema.optional(),
  orderBy: z.union([ FeedbackOrderByWithAggregationInputSchema.array(),FeedbackOrderByWithAggregationInputSchema ]).optional(),
  by: FeedbackScalarFieldEnumSchema.array(),
  having: FeedbackScalarWhereWithAggregatesInputSchema.optional(),
  take: z.number().optional(),
  skip: z.number().optional(),
}).strict() ;

export const FeedbackFindUniqueArgsSchema: z.ZodType<Prisma.FeedbackFindUniqueArgs> = z.object({
  select: FeedbackSelectSchema.optional(),
  where: FeedbackWhereUniqueInputSchema,
}).strict() ;

export const FeedbackFindUniqueOrThrowArgsSchema: z.ZodType<Prisma.FeedbackFindUniqueOrThrowArgs> = z.object({
  select: FeedbackSelectSchema.optional(),
  where: FeedbackWhereUniqueInputSchema,
}).strict() ;

export const WorkspaceCreateArgsSchema: z.ZodType<Prisma.WorkspaceCreateArgs> = z.object({
  select: WorkspaceSelectSchema.optional(),
  data: z.union([ WorkspaceCreateInputSchema,WorkspaceUncheckedCreateInputSchema ]),
}).strict() ;

export const WorkspaceUpsertArgsSchema: z.ZodType<Prisma.WorkspaceUpsertArgs> = z.object({
  select: WorkspaceSelectSchema.optional(),
  where: WorkspaceWhereUniqueInputSchema,
  create: z.union([ WorkspaceCreateInputSchema,WorkspaceUncheckedCreateInputSchema ]),
  update: z.union([ WorkspaceUpdateInputSchema,WorkspaceUncheckedUpdateInputSchema ]),
}).strict() ;

export const WorkspaceCreateManyArgsSchema: z.ZodType<Prisma.WorkspaceCreateManyArgs> = z.object({
  data: z.union([ WorkspaceCreateManyInputSchema,WorkspaceCreateManyInputSchema.array() ]),
  skipDuplicates: z.boolean().optional(),
}).strict() ;

export const WorkspaceCreateManyAndReturnArgsSchema: z.ZodType<Prisma.WorkspaceCreateManyAndReturnArgs> = z.object({
  data: z.union([ WorkspaceCreateManyInputSchema,WorkspaceCreateManyInputSchema.array() ]),
  skipDuplicates: z.boolean().optional(),
}).strict() ;

export const WorkspaceDeleteArgsSchema: z.ZodType<Prisma.WorkspaceDeleteArgs> = z.object({
  select: WorkspaceSelectSchema.optional(),
  where: WorkspaceWhereUniqueInputSchema,
}).strict() ;

export const WorkspaceUpdateArgsSchema: z.ZodType<Prisma.WorkspaceUpdateArgs> = z.object({
  select: WorkspaceSelectSchema.optional(),
  data: z.union([ WorkspaceUpdateInputSchema,WorkspaceUncheckedUpdateInputSchema ]),
  where: WorkspaceWhereUniqueInputSchema,
}).strict() ;

export const WorkspaceUpdateManyArgsSchema: z.ZodType<Prisma.WorkspaceUpdateManyArgs> = z.object({
  data: z.union([ WorkspaceUpdateManyMutationInputSchema,WorkspaceUncheckedUpdateManyInputSchema ]),
  where: WorkspaceWhereInputSchema.optional(),
}).strict() ;

export const WorkspaceDeleteManyArgsSchema: z.ZodType<Prisma.WorkspaceDeleteManyArgs> = z.object({
  where: WorkspaceWhereInputSchema.optional(),
}).strict() ;

export const ForecastCreateArgsSchema: z.ZodType<Prisma.ForecastCreateArgs> = z.object({
  select: ForecastSelectSchema.optional(),
  include: ForecastIncludeSchema.optional(),
  data: z.union([ ForecastCreateInputSchema,ForecastUncheckedCreateInputSchema ]),
}).strict() ;

export const ForecastUpsertArgsSchema: z.ZodType<Prisma.ForecastUpsertArgs> = z.object({
  select: ForecastSelectSchema.optional(),
  include: ForecastIncludeSchema.optional(),
  where: ForecastWhereUniqueInputSchema,
  create: z.union([ ForecastCreateInputSchema,ForecastUncheckedCreateInputSchema ]),
  update: z.union([ ForecastUpdateInputSchema,ForecastUncheckedUpdateInputSchema ]),
}).strict() ;

export const ForecastCreateManyArgsSchema: z.ZodType<Prisma.ForecastCreateManyArgs> = z.object({
  data: z.union([ ForecastCreateManyInputSchema,ForecastCreateManyInputSchema.array() ]),
  skipDuplicates: z.boolean().optional(),
}).strict() ;

export const ForecastCreateManyAndReturnArgsSchema: z.ZodType<Prisma.ForecastCreateManyAndReturnArgs> = z.object({
  data: z.union([ ForecastCreateManyInputSchema,ForecastCreateManyInputSchema.array() ]),
  skipDuplicates: z.boolean().optional(),
}).strict() ;

export const ForecastDeleteArgsSchema: z.ZodType<Prisma.ForecastDeleteArgs> = z.object({
  select: ForecastSelectSchema.optional(),
  include: ForecastIncludeSchema.optional(),
  where: ForecastWhereUniqueInputSchema,
}).strict() ;

export const ForecastUpdateArgsSchema: z.ZodType<Prisma.ForecastUpdateArgs> = z.object({
  select: ForecastSelectSchema.optional(),
  include: ForecastIncludeSchema.optional(),
  data: z.union([ ForecastUpdateInputSchema,ForecastUncheckedUpdateInputSchema ]),
  where: ForecastWhereUniqueInputSchema,
}).strict() ;

export const ForecastUpdateManyArgsSchema: z.ZodType<Prisma.ForecastUpdateManyArgs> = z.object({
  data: z.union([ ForecastUpdateManyMutationInputSchema,ForecastUncheckedUpdateManyInputSchema ]),
  where: ForecastWhereInputSchema.optional(),
}).strict() ;

export const ForecastDeleteManyArgsSchema: z.ZodType<Prisma.ForecastDeleteManyArgs> = z.object({
  where: ForecastWhereInputSchema.optional(),
}).strict() ;

export const QuestionScoreCreateArgsSchema: z.ZodType<Prisma.QuestionScoreCreateArgs> = z.object({
  select: QuestionScoreSelectSchema.optional(),
  include: QuestionScoreIncludeSchema.optional(),
  data: z.union([ QuestionScoreCreateInputSchema,QuestionScoreUncheckedCreateInputSchema ]),
}).strict() ;

export const QuestionScoreUpsertArgsSchema: z.ZodType<Prisma.QuestionScoreUpsertArgs> = z.object({
  select: QuestionScoreSelectSchema.optional(),
  include: QuestionScoreIncludeSchema.optional(),
  where: QuestionScoreWhereUniqueInputSchema,
  create: z.union([ QuestionScoreCreateInputSchema,QuestionScoreUncheckedCreateInputSchema ]),
  update: z.union([ QuestionScoreUpdateInputSchema,QuestionScoreUncheckedUpdateInputSchema ]),
}).strict() ;

export const QuestionScoreCreateManyArgsSchema: z.ZodType<Prisma.QuestionScoreCreateManyArgs> = z.object({
  data: z.union([ QuestionScoreCreateManyInputSchema,QuestionScoreCreateManyInputSchema.array() ]),
  skipDuplicates: z.boolean().optional(),
}).strict() ;

export const QuestionScoreCreateManyAndReturnArgsSchema: z.ZodType<Prisma.QuestionScoreCreateManyAndReturnArgs> = z.object({
  data: z.union([ QuestionScoreCreateManyInputSchema,QuestionScoreCreateManyInputSchema.array() ]),
  skipDuplicates: z.boolean().optional(),
}).strict() ;

export const QuestionScoreDeleteArgsSchema: z.ZodType<Prisma.QuestionScoreDeleteArgs> = z.object({
  select: QuestionScoreSelectSchema.optional(),
  include: QuestionScoreIncludeSchema.optional(),
  where: QuestionScoreWhereUniqueInputSchema,
}).strict() ;

export const QuestionScoreUpdateArgsSchema: z.ZodType<Prisma.QuestionScoreUpdateArgs> = z.object({
  select: QuestionScoreSelectSchema.optional(),
  include: QuestionScoreIncludeSchema.optional(),
  data: z.union([ QuestionScoreUpdateInputSchema,QuestionScoreUncheckedUpdateInputSchema ]),
  where: QuestionScoreWhereUniqueInputSchema,
}).strict() ;

export const QuestionScoreUpdateManyArgsSchema: z.ZodType<Prisma.QuestionScoreUpdateManyArgs> = z.object({
  data: z.union([ QuestionScoreUpdateManyMutationInputSchema,QuestionScoreUncheckedUpdateManyInputSchema ]),
  where: QuestionScoreWhereInputSchema.optional(),
}).strict() ;

export const QuestionScoreDeleteManyArgsSchema: z.ZodType<Prisma.QuestionScoreDeleteManyArgs> = z.object({
  where: QuestionScoreWhereInputSchema.optional(),
}).strict() ;

export const QuestionOptionCreateArgsSchema: z.ZodType<Prisma.QuestionOptionCreateArgs> = z.object({
  select: QuestionOptionSelectSchema.optional(),
  include: QuestionOptionIncludeSchema.optional(),
  data: z.union([ QuestionOptionCreateInputSchema,QuestionOptionUncheckedCreateInputSchema ]),
}).strict() ;

export const QuestionOptionUpsertArgsSchema: z.ZodType<Prisma.QuestionOptionUpsertArgs> = z.object({
  select: QuestionOptionSelectSchema.optional(),
  include: QuestionOptionIncludeSchema.optional(),
  where: QuestionOptionWhereUniqueInputSchema,
  create: z.union([ QuestionOptionCreateInputSchema,QuestionOptionUncheckedCreateInputSchema ]),
  update: z.union([ QuestionOptionUpdateInputSchema,QuestionOptionUncheckedUpdateInputSchema ]),
}).strict() ;

export const QuestionOptionCreateManyArgsSchema: z.ZodType<Prisma.QuestionOptionCreateManyArgs> = z.object({
  data: z.union([ QuestionOptionCreateManyInputSchema,QuestionOptionCreateManyInputSchema.array() ]),
  skipDuplicates: z.boolean().optional(),
}).strict() ;

export const QuestionOptionCreateManyAndReturnArgsSchema: z.ZodType<Prisma.QuestionOptionCreateManyAndReturnArgs> = z.object({
  data: z.union([ QuestionOptionCreateManyInputSchema,QuestionOptionCreateManyInputSchema.array() ]),
  skipDuplicates: z.boolean().optional(),
}).strict() ;

export const QuestionOptionDeleteArgsSchema: z.ZodType<Prisma.QuestionOptionDeleteArgs> = z.object({
  select: QuestionOptionSelectSchema.optional(),
  include: QuestionOptionIncludeSchema.optional(),
  where: QuestionOptionWhereUniqueInputSchema,
}).strict() ;

export const QuestionOptionUpdateArgsSchema: z.ZodType<Prisma.QuestionOptionUpdateArgs> = z.object({
  select: QuestionOptionSelectSchema.optional(),
  include: QuestionOptionIncludeSchema.optional(),
  data: z.union([ QuestionOptionUpdateInputSchema,QuestionOptionUncheckedUpdateInputSchema ]),
  where: QuestionOptionWhereUniqueInputSchema,
}).strict() ;

export const QuestionOptionUpdateManyArgsSchema: z.ZodType<Prisma.QuestionOptionUpdateManyArgs> = z.object({
  data: z.union([ QuestionOptionUpdateManyMutationInputSchema,QuestionOptionUncheckedUpdateManyInputSchema ]),
  where: QuestionOptionWhereInputSchema.optional(),
}).strict() ;

export const QuestionOptionDeleteManyArgsSchema: z.ZodType<Prisma.QuestionOptionDeleteManyArgs> = z.object({
  where: QuestionOptionWhereInputSchema.optional(),
}).strict() ;

export const QuestionCreateArgsSchema: z.ZodType<Prisma.QuestionCreateArgs> = z.object({
  select: QuestionSelectSchema.optional(),
  include: QuestionIncludeSchema.optional(),
  data: z.union([ QuestionCreateInputSchema,QuestionUncheckedCreateInputSchema ]),
}).strict() ;

export const QuestionUpsertArgsSchema: z.ZodType<Prisma.QuestionUpsertArgs> = z.object({
  select: QuestionSelectSchema.optional(),
  include: QuestionIncludeSchema.optional(),
  where: QuestionWhereUniqueInputSchema,
  create: z.union([ QuestionCreateInputSchema,QuestionUncheckedCreateInputSchema ]),
  update: z.union([ QuestionUpdateInputSchema,QuestionUncheckedUpdateInputSchema ]),
}).strict() ;

export const QuestionCreateManyArgsSchema: z.ZodType<Prisma.QuestionCreateManyArgs> = z.object({
  data: z.union([ QuestionCreateManyInputSchema,QuestionCreateManyInputSchema.array() ]),
  skipDuplicates: z.boolean().optional(),
}).strict() ;

export const QuestionCreateManyAndReturnArgsSchema: z.ZodType<Prisma.QuestionCreateManyAndReturnArgs> = z.object({
  data: z.union([ QuestionCreateManyInputSchema,QuestionCreateManyInputSchema.array() ]),
  skipDuplicates: z.boolean().optional(),
}).strict() ;

export const QuestionDeleteArgsSchema: z.ZodType<Prisma.QuestionDeleteArgs> = z.object({
  select: QuestionSelectSchema.optional(),
  include: QuestionIncludeSchema.optional(),
  where: QuestionWhereUniqueInputSchema,
}).strict() ;

export const QuestionUpdateArgsSchema: z.ZodType<Prisma.QuestionUpdateArgs> = z.object({
  select: QuestionSelectSchema.optional(),
  include: QuestionIncludeSchema.optional(),
  data: z.union([ QuestionUpdateInputSchema,QuestionUncheckedUpdateInputSchema ]),
  where: QuestionWhereUniqueInputSchema,
}).strict() ;

export const QuestionUpdateManyArgsSchema: z.ZodType<Prisma.QuestionUpdateManyArgs> = z.object({
  data: z.union([ QuestionUpdateManyMutationInputSchema,QuestionUncheckedUpdateManyInputSchema ]),
  where: QuestionWhereInputSchema.optional(),
}).strict() ;

export const QuestionDeleteManyArgsSchema: z.ZodType<Prisma.QuestionDeleteManyArgs> = z.object({
  where: QuestionWhereInputSchema.optional(),
}).strict() ;

export const TagCreateArgsSchema: z.ZodType<Prisma.TagCreateArgs> = z.object({
  select: TagSelectSchema.optional(),
  include: TagIncludeSchema.optional(),
  data: z.union([ TagCreateInputSchema,TagUncheckedCreateInputSchema ]),
}).strict() ;

export const TagUpsertArgsSchema: z.ZodType<Prisma.TagUpsertArgs> = z.object({
  select: TagSelectSchema.optional(),
  include: TagIncludeSchema.optional(),
  where: TagWhereUniqueInputSchema,
  create: z.union([ TagCreateInputSchema,TagUncheckedCreateInputSchema ]),
  update: z.union([ TagUpdateInputSchema,TagUncheckedUpdateInputSchema ]),
}).strict() ;

export const TagCreateManyArgsSchema: z.ZodType<Prisma.TagCreateManyArgs> = z.object({
  data: z.union([ TagCreateManyInputSchema,TagCreateManyInputSchema.array() ]),
  skipDuplicates: z.boolean().optional(),
}).strict() ;

export const TagCreateManyAndReturnArgsSchema: z.ZodType<Prisma.TagCreateManyAndReturnArgs> = z.object({
  data: z.union([ TagCreateManyInputSchema,TagCreateManyInputSchema.array() ]),
  skipDuplicates: z.boolean().optional(),
}).strict() ;

export const TagDeleteArgsSchema: z.ZodType<Prisma.TagDeleteArgs> = z.object({
  select: TagSelectSchema.optional(),
  include: TagIncludeSchema.optional(),
  where: TagWhereUniqueInputSchema,
}).strict() ;

export const TagUpdateArgsSchema: z.ZodType<Prisma.TagUpdateArgs> = z.object({
  select: TagSelectSchema.optional(),
  include: TagIncludeSchema.optional(),
  data: z.union([ TagUpdateInputSchema,TagUncheckedUpdateInputSchema ]),
  where: TagWhereUniqueInputSchema,
}).strict() ;

export const TagUpdateManyArgsSchema: z.ZodType<Prisma.TagUpdateManyArgs> = z.object({
  data: z.union([ TagUpdateManyMutationInputSchema,TagUncheckedUpdateManyInputSchema ]),
  where: TagWhereInputSchema.optional(),
}).strict() ;

export const TagDeleteManyArgsSchema: z.ZodType<Prisma.TagDeleteManyArgs> = z.object({
  where: TagWhereInputSchema.optional(),
}).strict() ;

export const ResolutionSlackMessageCreateArgsSchema: z.ZodType<Prisma.ResolutionSlackMessageCreateArgs> = z.object({
  select: ResolutionSlackMessageSelectSchema.optional(),
  include: ResolutionSlackMessageIncludeSchema.optional(),
  data: z.union([ ResolutionSlackMessageCreateInputSchema,ResolutionSlackMessageUncheckedCreateInputSchema ]),
}).strict() ;

export const ResolutionSlackMessageUpsertArgsSchema: z.ZodType<Prisma.ResolutionSlackMessageUpsertArgs> = z.object({
  select: ResolutionSlackMessageSelectSchema.optional(),
  include: ResolutionSlackMessageIncludeSchema.optional(),
  where: ResolutionSlackMessageWhereUniqueInputSchema,
  create: z.union([ ResolutionSlackMessageCreateInputSchema,ResolutionSlackMessageUncheckedCreateInputSchema ]),
  update: z.union([ ResolutionSlackMessageUpdateInputSchema,ResolutionSlackMessageUncheckedUpdateInputSchema ]),
}).strict() ;

export const ResolutionSlackMessageCreateManyArgsSchema: z.ZodType<Prisma.ResolutionSlackMessageCreateManyArgs> = z.object({
  data: z.union([ ResolutionSlackMessageCreateManyInputSchema,ResolutionSlackMessageCreateManyInputSchema.array() ]),
  skipDuplicates: z.boolean().optional(),
}).strict() ;

export const ResolutionSlackMessageCreateManyAndReturnArgsSchema: z.ZodType<Prisma.ResolutionSlackMessageCreateManyAndReturnArgs> = z.object({
  data: z.union([ ResolutionSlackMessageCreateManyInputSchema,ResolutionSlackMessageCreateManyInputSchema.array() ]),
  skipDuplicates: z.boolean().optional(),
}).strict() ;

export const ResolutionSlackMessageDeleteArgsSchema: z.ZodType<Prisma.ResolutionSlackMessageDeleteArgs> = z.object({
  select: ResolutionSlackMessageSelectSchema.optional(),
  include: ResolutionSlackMessageIncludeSchema.optional(),
  where: ResolutionSlackMessageWhereUniqueInputSchema,
}).strict() ;

export const ResolutionSlackMessageUpdateArgsSchema: z.ZodType<Prisma.ResolutionSlackMessageUpdateArgs> = z.object({
  select: ResolutionSlackMessageSelectSchema.optional(),
  include: ResolutionSlackMessageIncludeSchema.optional(),
  data: z.union([ ResolutionSlackMessageUpdateInputSchema,ResolutionSlackMessageUncheckedUpdateInputSchema ]),
  where: ResolutionSlackMessageWhereUniqueInputSchema,
}).strict() ;

export const ResolutionSlackMessageUpdateManyArgsSchema: z.ZodType<Prisma.ResolutionSlackMessageUpdateManyArgs> = z.object({
  data: z.union([ ResolutionSlackMessageUpdateManyMutationInputSchema,ResolutionSlackMessageUncheckedUpdateManyInputSchema ]),
  where: ResolutionSlackMessageWhereInputSchema.optional(),
}).strict() ;

export const ResolutionSlackMessageDeleteManyArgsSchema: z.ZodType<Prisma.ResolutionSlackMessageDeleteManyArgs> = z.object({
  where: ResolutionSlackMessageWhereInputSchema.optional(),
}).strict() ;

export const PingSlackMessageCreateArgsSchema: z.ZodType<Prisma.PingSlackMessageCreateArgs> = z.object({
  select: PingSlackMessageSelectSchema.optional(),
  include: PingSlackMessageIncludeSchema.optional(),
  data: z.union([ PingSlackMessageCreateInputSchema,PingSlackMessageUncheckedCreateInputSchema ]),
}).strict() ;

export const PingSlackMessageUpsertArgsSchema: z.ZodType<Prisma.PingSlackMessageUpsertArgs> = z.object({
  select: PingSlackMessageSelectSchema.optional(),
  include: PingSlackMessageIncludeSchema.optional(),
  where: PingSlackMessageWhereUniqueInputSchema,
  create: z.union([ PingSlackMessageCreateInputSchema,PingSlackMessageUncheckedCreateInputSchema ]),
  update: z.union([ PingSlackMessageUpdateInputSchema,PingSlackMessageUncheckedUpdateInputSchema ]),
}).strict() ;

export const PingSlackMessageCreateManyArgsSchema: z.ZodType<Prisma.PingSlackMessageCreateManyArgs> = z.object({
  data: z.union([ PingSlackMessageCreateManyInputSchema,PingSlackMessageCreateManyInputSchema.array() ]),
  skipDuplicates: z.boolean().optional(),
}).strict() ;

export const PingSlackMessageCreateManyAndReturnArgsSchema: z.ZodType<Prisma.PingSlackMessageCreateManyAndReturnArgs> = z.object({
  data: z.union([ PingSlackMessageCreateManyInputSchema,PingSlackMessageCreateManyInputSchema.array() ]),
  skipDuplicates: z.boolean().optional(),
}).strict() ;

export const PingSlackMessageDeleteArgsSchema: z.ZodType<Prisma.PingSlackMessageDeleteArgs> = z.object({
  select: PingSlackMessageSelectSchema.optional(),
  include: PingSlackMessageIncludeSchema.optional(),
  where: PingSlackMessageWhereUniqueInputSchema,
}).strict() ;

export const PingSlackMessageUpdateArgsSchema: z.ZodType<Prisma.PingSlackMessageUpdateArgs> = z.object({
  select: PingSlackMessageSelectSchema.optional(),
  include: PingSlackMessageIncludeSchema.optional(),
  data: z.union([ PingSlackMessageUpdateInputSchema,PingSlackMessageUncheckedUpdateInputSchema ]),
  where: PingSlackMessageWhereUniqueInputSchema,
}).strict() ;

export const PingSlackMessageUpdateManyArgsSchema: z.ZodType<Prisma.PingSlackMessageUpdateManyArgs> = z.object({
  data: z.union([ PingSlackMessageUpdateManyMutationInputSchema,PingSlackMessageUncheckedUpdateManyInputSchema ]),
  where: PingSlackMessageWhereInputSchema.optional(),
}).strict() ;

export const PingSlackMessageDeleteManyArgsSchema: z.ZodType<Prisma.PingSlackMessageDeleteManyArgs> = z.object({
  where: PingSlackMessageWhereInputSchema.optional(),
}).strict() ;

export const QuestionSlackMessageCreateArgsSchema: z.ZodType<Prisma.QuestionSlackMessageCreateArgs> = z.object({
  select: QuestionSlackMessageSelectSchema.optional(),
  include: QuestionSlackMessageIncludeSchema.optional(),
  data: z.union([ QuestionSlackMessageCreateInputSchema,QuestionSlackMessageUncheckedCreateInputSchema ]),
}).strict() ;

export const QuestionSlackMessageUpsertArgsSchema: z.ZodType<Prisma.QuestionSlackMessageUpsertArgs> = z.object({
  select: QuestionSlackMessageSelectSchema.optional(),
  include: QuestionSlackMessageIncludeSchema.optional(),
  where: QuestionSlackMessageWhereUniqueInputSchema,
  create: z.union([ QuestionSlackMessageCreateInputSchema,QuestionSlackMessageUncheckedCreateInputSchema ]),
  update: z.union([ QuestionSlackMessageUpdateInputSchema,QuestionSlackMessageUncheckedUpdateInputSchema ]),
}).strict() ;

export const QuestionSlackMessageCreateManyArgsSchema: z.ZodType<Prisma.QuestionSlackMessageCreateManyArgs> = z.object({
  data: z.union([ QuestionSlackMessageCreateManyInputSchema,QuestionSlackMessageCreateManyInputSchema.array() ]),
  skipDuplicates: z.boolean().optional(),
}).strict() ;

export const QuestionSlackMessageCreateManyAndReturnArgsSchema: z.ZodType<Prisma.QuestionSlackMessageCreateManyAndReturnArgs> = z.object({
  data: z.union([ QuestionSlackMessageCreateManyInputSchema,QuestionSlackMessageCreateManyInputSchema.array() ]),
  skipDuplicates: z.boolean().optional(),
}).strict() ;

export const QuestionSlackMessageDeleteArgsSchema: z.ZodType<Prisma.QuestionSlackMessageDeleteArgs> = z.object({
  select: QuestionSlackMessageSelectSchema.optional(),
  include: QuestionSlackMessageIncludeSchema.optional(),
  where: QuestionSlackMessageWhereUniqueInputSchema,
}).strict() ;

export const QuestionSlackMessageUpdateArgsSchema: z.ZodType<Prisma.QuestionSlackMessageUpdateArgs> = z.object({
  select: QuestionSlackMessageSelectSchema.optional(),
  include: QuestionSlackMessageIncludeSchema.optional(),
  data: z.union([ QuestionSlackMessageUpdateInputSchema,QuestionSlackMessageUncheckedUpdateInputSchema ]),
  where: QuestionSlackMessageWhereUniqueInputSchema,
}).strict() ;

export const QuestionSlackMessageUpdateManyArgsSchema: z.ZodType<Prisma.QuestionSlackMessageUpdateManyArgs> = z.object({
  data: z.union([ QuestionSlackMessageUpdateManyMutationInputSchema,QuestionSlackMessageUncheckedUpdateManyInputSchema ]),
  where: QuestionSlackMessageWhereInputSchema.optional(),
}).strict() ;

export const QuestionSlackMessageDeleteManyArgsSchema: z.ZodType<Prisma.QuestionSlackMessageDeleteManyArgs> = z.object({
  where: QuestionSlackMessageWhereInputSchema.optional(),
}).strict() ;

export const SlackMessageCreateArgsSchema: z.ZodType<Prisma.SlackMessageCreateArgs> = z.object({
  select: SlackMessageSelectSchema.optional(),
  include: SlackMessageIncludeSchema.optional(),
  data: z.union([ SlackMessageCreateInputSchema,SlackMessageUncheckedCreateInputSchema ]),
}).strict() ;

export const SlackMessageUpsertArgsSchema: z.ZodType<Prisma.SlackMessageUpsertArgs> = z.object({
  select: SlackMessageSelectSchema.optional(),
  include: SlackMessageIncludeSchema.optional(),
  where: SlackMessageWhereUniqueInputSchema,
  create: z.union([ SlackMessageCreateInputSchema,SlackMessageUncheckedCreateInputSchema ]),
  update: z.union([ SlackMessageUpdateInputSchema,SlackMessageUncheckedUpdateInputSchema ]),
}).strict() ;

export const SlackMessageCreateManyArgsSchema: z.ZodType<Prisma.SlackMessageCreateManyArgs> = z.object({
  data: z.union([ SlackMessageCreateManyInputSchema,SlackMessageCreateManyInputSchema.array() ]),
  skipDuplicates: z.boolean().optional(),
}).strict() ;

export const SlackMessageCreateManyAndReturnArgsSchema: z.ZodType<Prisma.SlackMessageCreateManyAndReturnArgs> = z.object({
  data: z.union([ SlackMessageCreateManyInputSchema,SlackMessageCreateManyInputSchema.array() ]),
  skipDuplicates: z.boolean().optional(),
}).strict() ;

export const SlackMessageDeleteArgsSchema: z.ZodType<Prisma.SlackMessageDeleteArgs> = z.object({
  select: SlackMessageSelectSchema.optional(),
  include: SlackMessageIncludeSchema.optional(),
  where: SlackMessageWhereUniqueInputSchema,
}).strict() ;

export const SlackMessageUpdateArgsSchema: z.ZodType<Prisma.SlackMessageUpdateArgs> = z.object({
  select: SlackMessageSelectSchema.optional(),
  include: SlackMessageIncludeSchema.optional(),
  data: z.union([ SlackMessageUpdateInputSchema,SlackMessageUncheckedUpdateInputSchema ]),
  where: SlackMessageWhereUniqueInputSchema,
}).strict() ;

export const SlackMessageUpdateManyArgsSchema: z.ZodType<Prisma.SlackMessageUpdateManyArgs> = z.object({
  data: z.union([ SlackMessageUpdateManyMutationInputSchema,SlackMessageUncheckedUpdateManyInputSchema ]),
  where: SlackMessageWhereInputSchema.optional(),
}).strict() ;

export const SlackMessageDeleteManyArgsSchema: z.ZodType<Prisma.SlackMessageDeleteManyArgs> = z.object({
  where: SlackMessageWhereInputSchema.optional(),
}).strict() ;

export const UserCreateArgsSchema: z.ZodType<Prisma.UserCreateArgs> = z.object({
  select: UserSelectSchema.optional(),
  include: UserIncludeSchema.optional(),
  data: z.union([ UserCreateInputSchema,UserUncheckedCreateInputSchema ]),
}).strict() ;

export const UserUpsertArgsSchema: z.ZodType<Prisma.UserUpsertArgs> = z.object({
  select: UserSelectSchema.optional(),
  include: UserIncludeSchema.optional(),
  where: UserWhereUniqueInputSchema,
  create: z.union([ UserCreateInputSchema,UserUncheckedCreateInputSchema ]),
  update: z.union([ UserUpdateInputSchema,UserUncheckedUpdateInputSchema ]),
}).strict() ;

export const UserCreateManyArgsSchema: z.ZodType<Prisma.UserCreateManyArgs> = z.object({
  data: z.union([ UserCreateManyInputSchema,UserCreateManyInputSchema.array() ]),
  skipDuplicates: z.boolean().optional(),
}).strict() ;

export const UserCreateManyAndReturnArgsSchema: z.ZodType<Prisma.UserCreateManyAndReturnArgs> = z.object({
  data: z.union([ UserCreateManyInputSchema,UserCreateManyInputSchema.array() ]),
  skipDuplicates: z.boolean().optional(),
}).strict() ;

export const UserDeleteArgsSchema: z.ZodType<Prisma.UserDeleteArgs> = z.object({
  select: UserSelectSchema.optional(),
  include: UserIncludeSchema.optional(),
  where: UserWhereUniqueInputSchema,
}).strict() ;

export const UserUpdateArgsSchema: z.ZodType<Prisma.UserUpdateArgs> = z.object({
  select: UserSelectSchema.optional(),
  include: UserIncludeSchema.optional(),
  data: z.union([ UserUpdateInputSchema,UserUncheckedUpdateInputSchema ]),
  where: UserWhereUniqueInputSchema,
}).strict() ;

export const UserUpdateManyArgsSchema: z.ZodType<Prisma.UserUpdateManyArgs> = z.object({
  data: z.union([ UserUpdateManyMutationInputSchema,UserUncheckedUpdateManyInputSchema ]),
  where: UserWhereInputSchema.optional(),
}).strict() ;

export const UserDeleteManyArgsSchema: z.ZodType<Prisma.UserDeleteManyArgs> = z.object({
  where: UserWhereInputSchema.optional(),
}).strict() ;

export const ProfileCreateArgsSchema: z.ZodType<Prisma.ProfileCreateArgs> = z.object({
  select: ProfileSelectSchema.optional(),
  include: ProfileIncludeSchema.optional(),
  data: z.union([ ProfileCreateInputSchema,ProfileUncheckedCreateInputSchema ]),
}).strict() ;

export const ProfileUpsertArgsSchema: z.ZodType<Prisma.ProfileUpsertArgs> = z.object({
  select: ProfileSelectSchema.optional(),
  include: ProfileIncludeSchema.optional(),
  where: ProfileWhereUniqueInputSchema,
  create: z.union([ ProfileCreateInputSchema,ProfileUncheckedCreateInputSchema ]),
  update: z.union([ ProfileUpdateInputSchema,ProfileUncheckedUpdateInputSchema ]),
}).strict() ;

export const ProfileCreateManyArgsSchema: z.ZodType<Prisma.ProfileCreateManyArgs> = z.object({
  data: z.union([ ProfileCreateManyInputSchema,ProfileCreateManyInputSchema.array() ]),
  skipDuplicates: z.boolean().optional(),
}).strict() ;

export const ProfileCreateManyAndReturnArgsSchema: z.ZodType<Prisma.ProfileCreateManyAndReturnArgs> = z.object({
  data: z.union([ ProfileCreateManyInputSchema,ProfileCreateManyInputSchema.array() ]),
  skipDuplicates: z.boolean().optional(),
}).strict() ;

export const ProfileDeleteArgsSchema: z.ZodType<Prisma.ProfileDeleteArgs> = z.object({
  select: ProfileSelectSchema.optional(),
  include: ProfileIncludeSchema.optional(),
  where: ProfileWhereUniqueInputSchema,
}).strict() ;

export const ProfileUpdateArgsSchema: z.ZodType<Prisma.ProfileUpdateArgs> = z.object({
  select: ProfileSelectSchema.optional(),
  include: ProfileIncludeSchema.optional(),
  data: z.union([ ProfileUpdateInputSchema,ProfileUncheckedUpdateInputSchema ]),
  where: ProfileWhereUniqueInputSchema,
}).strict() ;

export const ProfileUpdateManyArgsSchema: z.ZodType<Prisma.ProfileUpdateManyArgs> = z.object({
  data: z.union([ ProfileUpdateManyMutationInputSchema,ProfileUncheckedUpdateManyInputSchema ]),
  where: ProfileWhereInputSchema.optional(),
}).strict() ;

export const ProfileDeleteManyArgsSchema: z.ZodType<Prisma.ProfileDeleteManyArgs> = z.object({
  where: ProfileWhereInputSchema.optional(),
}).strict() ;

export const GroupCreateArgsSchema: z.ZodType<Prisma.GroupCreateArgs> = z.object({
  select: GroupSelectSchema.optional(),
  data: z.union([ GroupCreateInputSchema,GroupUncheckedCreateInputSchema ]),
}).strict() ;

export const GroupUpsertArgsSchema: z.ZodType<Prisma.GroupUpsertArgs> = z.object({
  select: GroupSelectSchema.optional(),
  where: GroupWhereUniqueInputSchema,
  create: z.union([ GroupCreateInputSchema,GroupUncheckedCreateInputSchema ]),
  update: z.union([ GroupUpdateInputSchema,GroupUncheckedUpdateInputSchema ]),
}).strict() ;

export const GroupCreateManyArgsSchema: z.ZodType<Prisma.GroupCreateManyArgs> = z.object({
  data: z.union([ GroupCreateManyInputSchema,GroupCreateManyInputSchema.array() ]),
  skipDuplicates: z.boolean().optional(),
}).strict() ;

export const GroupCreateManyAndReturnArgsSchema: z.ZodType<Prisma.GroupCreateManyAndReturnArgs> = z.object({
  data: z.union([ GroupCreateManyInputSchema,GroupCreateManyInputSchema.array() ]),
  skipDuplicates: z.boolean().optional(),
}).strict() ;

export const GroupDeleteArgsSchema: z.ZodType<Prisma.GroupDeleteArgs> = z.object({
  select: GroupSelectSchema.optional(),
  where: GroupWhereUniqueInputSchema,
}).strict() ;

export const GroupUpdateArgsSchema: z.ZodType<Prisma.GroupUpdateArgs> = z.object({
  select: GroupSelectSchema.optional(),
  data: z.union([ GroupUpdateInputSchema,GroupUncheckedUpdateInputSchema ]),
  where: GroupWhereUniqueInputSchema,
}).strict() ;

export const GroupUpdateManyArgsSchema: z.ZodType<Prisma.GroupUpdateManyArgs> = z.object({
  data: z.union([ GroupUpdateManyMutationInputSchema,GroupUncheckedUpdateManyInputSchema ]),
  where: GroupWhereInputSchema.optional(),
}).strict() ;

export const GroupDeleteManyArgsSchema: z.ZodType<Prisma.GroupDeleteManyArgs> = z.object({
  where: GroupWhereInputSchema.optional(),
}).strict() ;

export const TargetCreateArgsSchema: z.ZodType<Prisma.TargetCreateArgs> = z.object({
  select: TargetSelectSchema.optional(),
  include: TargetIncludeSchema.optional(),
  data: z.union([ TargetCreateInputSchema,TargetUncheckedCreateInputSchema ]),
}).strict() ;

export const TargetUpsertArgsSchema: z.ZodType<Prisma.TargetUpsertArgs> = z.object({
  select: TargetSelectSchema.optional(),
  include: TargetIncludeSchema.optional(),
  where: TargetWhereUniqueInputSchema,
  create: z.union([ TargetCreateInputSchema,TargetUncheckedCreateInputSchema ]),
  update: z.union([ TargetUpdateInputSchema,TargetUncheckedUpdateInputSchema ]),
}).strict() ;

export const TargetCreateManyArgsSchema: z.ZodType<Prisma.TargetCreateManyArgs> = z.object({
  data: z.union([ TargetCreateManyInputSchema,TargetCreateManyInputSchema.array() ]),
  skipDuplicates: z.boolean().optional(),
}).strict() ;

export const TargetCreateManyAndReturnArgsSchema: z.ZodType<Prisma.TargetCreateManyAndReturnArgs> = z.object({
  data: z.union([ TargetCreateManyInputSchema,TargetCreateManyInputSchema.array() ]),
  skipDuplicates: z.boolean().optional(),
}).strict() ;

export const TargetDeleteArgsSchema: z.ZodType<Prisma.TargetDeleteArgs> = z.object({
  select: TargetSelectSchema.optional(),
  include: TargetIncludeSchema.optional(),
  where: TargetWhereUniqueInputSchema,
}).strict() ;

export const TargetUpdateArgsSchema: z.ZodType<Prisma.TargetUpdateArgs> = z.object({
  select: TargetSelectSchema.optional(),
  include: TargetIncludeSchema.optional(),
  data: z.union([ TargetUpdateInputSchema,TargetUncheckedUpdateInputSchema ]),
  where: TargetWhereUniqueInputSchema,
}).strict() ;

export const TargetUpdateManyArgsSchema: z.ZodType<Prisma.TargetUpdateManyArgs> = z.object({
  data: z.union([ TargetUpdateManyMutationInputSchema,TargetUncheckedUpdateManyInputSchema ]),
  where: TargetWhereInputSchema.optional(),
}).strict() ;

export const TargetDeleteManyArgsSchema: z.ZodType<Prisma.TargetDeleteManyArgs> = z.object({
  where: TargetWhereInputSchema.optional(),
}).strict() ;

export const AccountCreateArgsSchema: z.ZodType<Prisma.AccountCreateArgs> = z.object({
  select: AccountSelectSchema.optional(),
  include: AccountIncludeSchema.optional(),
  data: z.union([ AccountCreateInputSchema,AccountUncheckedCreateInputSchema ]),
}).strict() ;

export const AccountUpsertArgsSchema: z.ZodType<Prisma.AccountUpsertArgs> = z.object({
  select: AccountSelectSchema.optional(),
  include: AccountIncludeSchema.optional(),
  where: AccountWhereUniqueInputSchema,
  create: z.union([ AccountCreateInputSchema,AccountUncheckedCreateInputSchema ]),
  update: z.union([ AccountUpdateInputSchema,AccountUncheckedUpdateInputSchema ]),
}).strict() ;

export const AccountCreateManyArgsSchema: z.ZodType<Prisma.AccountCreateManyArgs> = z.object({
  data: z.union([ AccountCreateManyInputSchema,AccountCreateManyInputSchema.array() ]),
  skipDuplicates: z.boolean().optional(),
}).strict() ;

export const AccountCreateManyAndReturnArgsSchema: z.ZodType<Prisma.AccountCreateManyAndReturnArgs> = z.object({
  data: z.union([ AccountCreateManyInputSchema,AccountCreateManyInputSchema.array() ]),
  skipDuplicates: z.boolean().optional(),
}).strict() ;

export const AccountDeleteArgsSchema: z.ZodType<Prisma.AccountDeleteArgs> = z.object({
  select: AccountSelectSchema.optional(),
  include: AccountIncludeSchema.optional(),
  where: AccountWhereUniqueInputSchema,
}).strict() ;

export const AccountUpdateArgsSchema: z.ZodType<Prisma.AccountUpdateArgs> = z.object({
  select: AccountSelectSchema.optional(),
  include: AccountIncludeSchema.optional(),
  data: z.union([ AccountUpdateInputSchema,AccountUncheckedUpdateInputSchema ]),
  where: AccountWhereUniqueInputSchema,
}).strict() ;

export const AccountUpdateManyArgsSchema: z.ZodType<Prisma.AccountUpdateManyArgs> = z.object({
  data: z.union([ AccountUpdateManyMutationInputSchema,AccountUncheckedUpdateManyInputSchema ]),
  where: AccountWhereInputSchema.optional(),
}).strict() ;

export const AccountDeleteManyArgsSchema: z.ZodType<Prisma.AccountDeleteManyArgs> = z.object({
  where: AccountWhereInputSchema.optional(),
}).strict() ;

export const CommentCreateArgsSchema: z.ZodType<Prisma.CommentCreateArgs> = z.object({
  select: CommentSelectSchema.optional(),
  include: CommentIncludeSchema.optional(),
  data: z.union([ CommentCreateInputSchema,CommentUncheckedCreateInputSchema ]),
}).strict() ;

export const CommentUpsertArgsSchema: z.ZodType<Prisma.CommentUpsertArgs> = z.object({
  select: CommentSelectSchema.optional(),
  include: CommentIncludeSchema.optional(),
  where: CommentWhereUniqueInputSchema,
  create: z.union([ CommentCreateInputSchema,CommentUncheckedCreateInputSchema ]),
  update: z.union([ CommentUpdateInputSchema,CommentUncheckedUpdateInputSchema ]),
}).strict() ;

export const CommentCreateManyArgsSchema: z.ZodType<Prisma.CommentCreateManyArgs> = z.object({
  data: z.union([ CommentCreateManyInputSchema,CommentCreateManyInputSchema.array() ]),
  skipDuplicates: z.boolean().optional(),
}).strict() ;

export const CommentCreateManyAndReturnArgsSchema: z.ZodType<Prisma.CommentCreateManyAndReturnArgs> = z.object({
  data: z.union([ CommentCreateManyInputSchema,CommentCreateManyInputSchema.array() ]),
  skipDuplicates: z.boolean().optional(),
}).strict() ;

export const CommentDeleteArgsSchema: z.ZodType<Prisma.CommentDeleteArgs> = z.object({
  select: CommentSelectSchema.optional(),
  include: CommentIncludeSchema.optional(),
  where: CommentWhereUniqueInputSchema,
}).strict() ;

export const CommentUpdateArgsSchema: z.ZodType<Prisma.CommentUpdateArgs> = z.object({
  select: CommentSelectSchema.optional(),
  include: CommentIncludeSchema.optional(),
  data: z.union([ CommentUpdateInputSchema,CommentUncheckedUpdateInputSchema ]),
  where: CommentWhereUniqueInputSchema,
}).strict() ;

export const CommentUpdateManyArgsSchema: z.ZodType<Prisma.CommentUpdateManyArgs> = z.object({
  data: z.union([ CommentUpdateManyMutationInputSchema,CommentUncheckedUpdateManyInputSchema ]),
  where: CommentWhereInputSchema.optional(),
}).strict() ;

export const CommentDeleteManyArgsSchema: z.ZodType<Prisma.CommentDeleteManyArgs> = z.object({
  where: CommentWhereInputSchema.optional(),
}).strict() ;

export const UserListCreateArgsSchema: z.ZodType<Prisma.UserListCreateArgs> = z.object({
  select: UserListSelectSchema.optional(),
  include: UserListIncludeSchema.optional(),
  data: z.union([ UserListCreateInputSchema,UserListUncheckedCreateInputSchema ]),
}).strict() ;

export const UserListUpsertArgsSchema: z.ZodType<Prisma.UserListUpsertArgs> = z.object({
  select: UserListSelectSchema.optional(),
  include: UserListIncludeSchema.optional(),
  where: UserListWhereUniqueInputSchema,
  create: z.union([ UserListCreateInputSchema,UserListUncheckedCreateInputSchema ]),
  update: z.union([ UserListUpdateInputSchema,UserListUncheckedUpdateInputSchema ]),
}).strict() ;

export const UserListCreateManyArgsSchema: z.ZodType<Prisma.UserListCreateManyArgs> = z.object({
  data: z.union([ UserListCreateManyInputSchema,UserListCreateManyInputSchema.array() ]),
  skipDuplicates: z.boolean().optional(),
}).strict() ;

export const UserListCreateManyAndReturnArgsSchema: z.ZodType<Prisma.UserListCreateManyAndReturnArgs> = z.object({
  data: z.union([ UserListCreateManyInputSchema,UserListCreateManyInputSchema.array() ]),
  skipDuplicates: z.boolean().optional(),
}).strict() ;

export const UserListDeleteArgsSchema: z.ZodType<Prisma.UserListDeleteArgs> = z.object({
  select: UserListSelectSchema.optional(),
  include: UserListIncludeSchema.optional(),
  where: UserListWhereUniqueInputSchema,
}).strict() ;

export const UserListUpdateArgsSchema: z.ZodType<Prisma.UserListUpdateArgs> = z.object({
  select: UserListSelectSchema.optional(),
  include: UserListIncludeSchema.optional(),
  data: z.union([ UserListUpdateInputSchema,UserListUncheckedUpdateInputSchema ]),
  where: UserListWhereUniqueInputSchema,
}).strict() ;

export const UserListUpdateManyArgsSchema: z.ZodType<Prisma.UserListUpdateManyArgs> = z.object({
  data: z.union([ UserListUpdateManyMutationInputSchema,UserListUncheckedUpdateManyInputSchema ]),
  where: UserListWhereInputSchema.optional(),
}).strict() ;

export const UserListDeleteManyArgsSchema: z.ZodType<Prisma.UserListDeleteManyArgs> = z.object({
  where: UserListWhereInputSchema.optional(),
}).strict() ;

export const TournamentCreateArgsSchema: z.ZodType<Prisma.TournamentCreateArgs> = z.object({
  select: TournamentSelectSchema.optional(),
  include: TournamentIncludeSchema.optional(),
  data: z.union([ TournamentCreateInputSchema,TournamentUncheckedCreateInputSchema ]),
}).strict() ;

export const TournamentUpsertArgsSchema: z.ZodType<Prisma.TournamentUpsertArgs> = z.object({
  select: TournamentSelectSchema.optional(),
  include: TournamentIncludeSchema.optional(),
  where: TournamentWhereUniqueInputSchema,
  create: z.union([ TournamentCreateInputSchema,TournamentUncheckedCreateInputSchema ]),
  update: z.union([ TournamentUpdateInputSchema,TournamentUncheckedUpdateInputSchema ]),
}).strict() ;

export const TournamentCreateManyArgsSchema: z.ZodType<Prisma.TournamentCreateManyArgs> = z.object({
  data: z.union([ TournamentCreateManyInputSchema,TournamentCreateManyInputSchema.array() ]),
  skipDuplicates: z.boolean().optional(),
}).strict() ;

export const TournamentCreateManyAndReturnArgsSchema: z.ZodType<Prisma.TournamentCreateManyAndReturnArgs> = z.object({
  data: z.union([ TournamentCreateManyInputSchema,TournamentCreateManyInputSchema.array() ]),
  skipDuplicates: z.boolean().optional(),
}).strict() ;

export const TournamentDeleteArgsSchema: z.ZodType<Prisma.TournamentDeleteArgs> = z.object({
  select: TournamentSelectSchema.optional(),
  include: TournamentIncludeSchema.optional(),
  where: TournamentWhereUniqueInputSchema,
}).strict() ;

export const TournamentUpdateArgsSchema: z.ZodType<Prisma.TournamentUpdateArgs> = z.object({
  select: TournamentSelectSchema.optional(),
  include: TournamentIncludeSchema.optional(),
  data: z.union([ TournamentUpdateInputSchema,TournamentUncheckedUpdateInputSchema ]),
  where: TournamentWhereUniqueInputSchema,
}).strict() ;

export const TournamentUpdateManyArgsSchema: z.ZodType<Prisma.TournamentUpdateManyArgs> = z.object({
  data: z.union([ TournamentUpdateManyMutationInputSchema,TournamentUncheckedUpdateManyInputSchema ]),
  where: TournamentWhereInputSchema.optional(),
}).strict() ;

export const TournamentDeleteManyArgsSchema: z.ZodType<Prisma.TournamentDeleteManyArgs> = z.object({
  where: TournamentWhereInputSchema.optional(),
}).strict() ;

export const NotificationCreateArgsSchema: z.ZodType<Prisma.NotificationCreateArgs> = z.object({
  select: NotificationSelectSchema.optional(),
  include: NotificationIncludeSchema.optional(),
  data: z.union([ NotificationCreateInputSchema,NotificationUncheckedCreateInputSchema ]),
}).strict() ;

export const NotificationUpsertArgsSchema: z.ZodType<Prisma.NotificationUpsertArgs> = z.object({
  select: NotificationSelectSchema.optional(),
  include: NotificationIncludeSchema.optional(),
  where: NotificationWhereUniqueInputSchema,
  create: z.union([ NotificationCreateInputSchema,NotificationUncheckedCreateInputSchema ]),
  update: z.union([ NotificationUpdateInputSchema,NotificationUncheckedUpdateInputSchema ]),
}).strict() ;

export const NotificationCreateManyArgsSchema: z.ZodType<Prisma.NotificationCreateManyArgs> = z.object({
  data: z.union([ NotificationCreateManyInputSchema,NotificationCreateManyInputSchema.array() ]),
  skipDuplicates: z.boolean().optional(),
}).strict() ;

export const NotificationCreateManyAndReturnArgsSchema: z.ZodType<Prisma.NotificationCreateManyAndReturnArgs> = z.object({
  data: z.union([ NotificationCreateManyInputSchema,NotificationCreateManyInputSchema.array() ]),
  skipDuplicates: z.boolean().optional(),
}).strict() ;

export const NotificationDeleteArgsSchema: z.ZodType<Prisma.NotificationDeleteArgs> = z.object({
  select: NotificationSelectSchema.optional(),
  include: NotificationIncludeSchema.optional(),
  where: NotificationWhereUniqueInputSchema,
}).strict() ;

export const NotificationUpdateArgsSchema: z.ZodType<Prisma.NotificationUpdateArgs> = z.object({
  select: NotificationSelectSchema.optional(),
  include: NotificationIncludeSchema.optional(),
  data: z.union([ NotificationUpdateInputSchema,NotificationUncheckedUpdateInputSchema ]),
  where: NotificationWhereUniqueInputSchema,
}).strict() ;

export const NotificationUpdateManyArgsSchema: z.ZodType<Prisma.NotificationUpdateManyArgs> = z.object({
  data: z.union([ NotificationUpdateManyMutationInputSchema,NotificationUncheckedUpdateManyInputSchema ]),
  where: NotificationWhereInputSchema.optional(),
}).strict() ;

export const NotificationDeleteManyArgsSchema: z.ZodType<Prisma.NotificationDeleteManyArgs> = z.object({
  where: NotificationWhereInputSchema.optional(),
}).strict() ;

export const FeedbackCreateArgsSchema: z.ZodType<Prisma.FeedbackCreateArgs> = z.object({
  select: FeedbackSelectSchema.optional(),
  data: z.union([ FeedbackCreateInputSchema,FeedbackUncheckedCreateInputSchema ]),
}).strict() ;

export const FeedbackUpsertArgsSchema: z.ZodType<Prisma.FeedbackUpsertArgs> = z.object({
  select: FeedbackSelectSchema.optional(),
  where: FeedbackWhereUniqueInputSchema,
  create: z.union([ FeedbackCreateInputSchema,FeedbackUncheckedCreateInputSchema ]),
  update: z.union([ FeedbackUpdateInputSchema,FeedbackUncheckedUpdateInputSchema ]),
}).strict() ;

export const FeedbackCreateManyArgsSchema: z.ZodType<Prisma.FeedbackCreateManyArgs> = z.object({
  data: z.union([ FeedbackCreateManyInputSchema,FeedbackCreateManyInputSchema.array() ]),
  skipDuplicates: z.boolean().optional(),
}).strict() ;

export const FeedbackCreateManyAndReturnArgsSchema: z.ZodType<Prisma.FeedbackCreateManyAndReturnArgs> = z.object({
  data: z.union([ FeedbackCreateManyInputSchema,FeedbackCreateManyInputSchema.array() ]),
  skipDuplicates: z.boolean().optional(),
}).strict() ;

export const FeedbackDeleteArgsSchema: z.ZodType<Prisma.FeedbackDeleteArgs> = z.object({
  select: FeedbackSelectSchema.optional(),
  where: FeedbackWhereUniqueInputSchema,
}).strict() ;

export const FeedbackUpdateArgsSchema: z.ZodType<Prisma.FeedbackUpdateArgs> = z.object({
  select: FeedbackSelectSchema.optional(),
  data: z.union([ FeedbackUpdateInputSchema,FeedbackUncheckedUpdateInputSchema ]),
  where: FeedbackWhereUniqueInputSchema,
}).strict() ;

export const FeedbackUpdateManyArgsSchema: z.ZodType<Prisma.FeedbackUpdateManyArgs> = z.object({
  data: z.union([ FeedbackUpdateManyMutationInputSchema,FeedbackUncheckedUpdateManyInputSchema ]),
  where: FeedbackWhereInputSchema.optional(),
}).strict() ;

export const FeedbackDeleteManyArgsSchema: z.ZodType<Prisma.FeedbackDeleteManyArgs> = z.object({
  where: FeedbackWhereInputSchema.optional(),
}).strict() ;