generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model Forecast {
  id         Int      @id @default(autoincrement())
  createdAt  DateTime @default(now())
  comment    String?
  forecast   Decimal
  authorId   Int
  questionId Int
  profile    Profile  @relation(fields: [authorId], references: [id], onDelete: Cascade)
  question   Question @relation(fields: [questionId], references: [id], onDelete: Cascade)
}

model QuestionScore {
  id         Int      @id @default(autoincrement())
  createdAt  DateTime @default(now())
  score      Decimal
  profileId  Int
  questionId Int
  profile    Profile  @relation(fields: [profileId], references: [id], onDelete: Cascade)
  question   Question @relation(fields: [questionId], references: [id], onDelete: Cascade)
  profileQuestionComboId Int @unique
}

model Question {
  id                  Int             @id @default(autoincrement())
  createdAt           DateTime        @default(now())
  comment             String?
  authorId            Int
  title               String          @db.VarChar(255)
  forecasts           Forecast[]
  resolveBy           DateTime
  resolvedAt          DateTime?
  resolved            Boolean         @default(false)
  profile             Profile         @relation(fields: [authorId], references: [id], onDelete: Cascade)
  groups              Group[]
  resolution          Resolution?
  pingedForResolution Boolean         @default(false)
  questionScores      QuestionScore[]
  slackMessages      QuestionSlackMessage[]
}

model QuestionSlackMessage {
  id          Int @id @default(autoincrement())
  questionId  Int
  question    Question @relation(fields: [questionId], references: [id], onDelete: Cascade)
  ts          String // Slack timestamp identifier for messages
  channel     String
  // could store threadts here
}

model User {
  id        Int       @id @default(autoincrement())
  createdAt DateTime  @default(now())
  email     String    @unique
  name      String?
  imageUrl  String?
  profiles  Profile[]
}

model Profile {
  id             Int             @id @default(autoincrement())
  createdAt      DateTime        @default(now())
  groups         Group[]
  slackId        String?
  userId         Int             @unique
  user           User            @relation(fields: [userId], references: [id], onDelete: Cascade)
  forecasts      Forecast[]
  questions      Question[]
  questionScores QuestionScore[]
}

model Group {
  id          Int        @id @default(autoincrement())
  type        GroupType
  createdAt   DateTime   @default(now())
  name        String     @db.VarChar(255)
  slackTeamId String?
  questions   Question[]
  profiles    Profile[]
}

enum GroupType {
  WEB
  SLACK
}

enum Resolution {
  YES
  NO
  AMBIGUOUS
}
